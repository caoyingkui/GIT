{
    "id": "LUCENE-3312",
    "title": "Break out StorableField from IndexableField",
    "details": {
        "labels": "",
        "priority": "Major",
        "components": [
            "core/index"
        ],
        "type": "Improvement",
        "fix_versions": [
            "6.0"
        ],
        "affect_versions": "None",
        "resolution": "Fixed",
        "status": "Resolved"
    },
    "description": "In the field type branch we have strongly decoupled\nDocument/Field/FieldType impl from the indexer, by having only a\nnarrow API (IndexableField) passed to IndexWriter.  This frees apps up\nuse their own \"documents\" instead of the \"user-space\" impls we provide\nin oal.document.\n\nSimilarly, with LUCENE-3309, we've done the same thing on the\ndoc/field retrieval side (from IndexReader), with the\nStoredFieldsVisitor.\n\nBut, maybe we should break out StorableField from IndexableField,\nsuch that when you index a doc you provide two Iterables \u2013 one for the\nIndexableFields and one for the StorableFields.  Either can be null.\n\nOne downside is possible perf hit for fields that are both indexed &\nstored (ie, we visit them twice, lookup their name in a hash twice,\netc.).  But the upside is a cleaner separation of concerns in API....",
    "attachments": {
        "lucene-3312-patch-14.patch": "https://issues.apache.org/jira/secure/attachment/12541596/lucene-3312-patch-14.patch",
        "lucene-3312-patch-04.patch": "https://issues.apache.org/jira/secure/attachment/12530416/lucene-3312-patch-04.patch",
        "lucene-3312-patch-13.patch": "https://issues.apache.org/jira/secure/attachment/12541246/lucene-3312-patch-13.patch",
        "lucene-3312-patch-09.patch": "https://issues.apache.org/jira/secure/attachment/12539916/lucene-3312-patch-09.patch",
        "lucene-3312-patch-03.patch": "https://issues.apache.org/jira/secure/attachment/12529869/lucene-3312-patch-03.patch",
        "LUCENE-3312-reintegration.patch": "https://issues.apache.org/jira/secure/attachment/12542405/LUCENE-3312-reintegration.patch",
        "lucene-3312-patch-06.patch": "https://issues.apache.org/jira/secure/attachment/12534096/lucene-3312-patch-06.patch",
        "lucene-3312-patch-08.patch": "https://issues.apache.org/jira/secure/attachment/12538239/lucene-3312-patch-08.patch",
        "lucene-3312-patch-12.patch": "https://issues.apache.org/jira/secure/attachment/12540470/lucene-3312-patch-12.patch",
        "lucene-3312-patch-05.patch": "https://issues.apache.org/jira/secure/attachment/12532850/lucene-3312-patch-05.patch",
        "lucene-3312-patch-01.patch": "https://issues.apache.org/jira/secure/attachment/12529863/lucene-3312-patch-01.patch",
        "LUCENE-3312-DocumentIterators-uwe.patch": "https://issues.apache.org/jira/secure/attachment/12542407/LUCENE-3312-DocumentIterators-uwe.patch",
        "lucene-3312-patch-07.patch": "https://issues.apache.org/jira/secure/attachment/12535660/lucene-3312-patch-07.patch",
        "lucene-3312-patch-12a.patch": "https://issues.apache.org/jira/secure/attachment/12540649/lucene-3312-patch-12a.patch",
        "lucene-3312-patch-10.patch": "https://issues.apache.org/jira/secure/attachment/12540080/lucene-3312-patch-10.patch",
        "lucene-3312-patch-11.patch": "https://issues.apache.org/jira/secure/attachment/12540132/lucene-3312-patch-11.patch",
        "lucene-3312-patch-02.patch": "https://issues.apache.org/jira/secure/attachment/12529864/lucene-3312-patch-02.patch"
    },
    "issue_links": {},
    "comments": [
        {
            "date": "2011-07-14T11:04:38+0000",
            "content": "once we are on this here we should think about breaking out storing fields from the indexing chain. I think this could easily be a separated process such that stored fields are not written by the indexing chain but once all fields are indexed. This would make the indexing chain somewhat cleaner I think. ",
            "author": "Simon Willnauer",
            "id": "comment-13065180"
        },
        {
            "date": "2011-08-29T04:19:48+0000",
            "content": "With LUCENE-2308 out of the way, I've started looking into this more deeply.  Changing the indexer code has not been especially difficult since there is already a clear separation in the handling of indexed and stored fields.  The challenges are in the consumer / user code. So I have a couple of questions I'm hoping for some opinions on:\n\n\n\tDue to the fact that FieldInfo is maintained per field name, if an IndexableField and StorableField are added to a Document separately but with the same name, a single FieldInfo will be created noting the field is both indexed and stored.  This isn't a problem, however a lot of code used to leverage this fact to get metadata about indexed Fields using searcher.document(docId).  They would retrieve all the stored fields and then see which were also indexed (and associated metadata).  This seems like a bit of a hack, piggybacking stored fields to find out about their indexing attributes.  So I guess it cannot continue to go forward? When you pull the StorableFields, you should only be able to access the stored value metadata?\n\n\n\n\n\tBy creating this separation, we will need some notion of a Document in index.* which provides Iterable access to both the IndexableFields and StorableFields.  As such, Document itself is becoming more userland.  However by letting it store Indexable and StorableFields separately, the functionality it provides (getBinaryValue for example) becomes quite verbose because it must provide an implementations of both kinds of fields.  Given that Field is a userland implementation of both Indexable and StorableField, should Document work solely with Fields? or should we allow people to register both kinds of fields separately and just have a verbose set of functionality?\n\n ",
            "author": "Chris Male",
            "id": "comment-13092625"
        },
        {
            "date": "2011-08-29T16:14:31+0000",
            "content": "Due to the fact that FieldInfo is maintained per field name, if an IndexableField and StorableField are added to a Document separately but with the same name, a single FieldInfo will be created noting the field is both indexed and stored. This isn't a problem, however a lot of code used to leverage this fact to get metadata about indexed Fields using searcher.document(docId). They would retrieve all the stored fields and then see which were also indexed (and associated metadata). This seems like a bit of a hack, piggybacking stored fields to find out about their indexing attributes. So I guess it cannot continue to go forward? When you pull the StorableFields, you should only be able to access the stored value metadata?\n\nRight, this has been a long standing problem w/ the Document class you\nload at search time, ie the fields \"pretend\" to carry over the\ndetails from indexing.  But it's buggy now, eg boost is not carried\nover, and the indexed bit is \"global\" (comes from field info) while\nthe \"tokenized\" bit used to be per-doc, before LUCENE-2308.\n\nSo I consider this (these indexing details are no longer available\nwhen you pull the document) a big benefit of cutting over to\nStorableField.  Ie, its trappy today since it's buggy, so we'd be\nremoving that trap.\n\nBy creating this separation, we will need some notion of a Document in index.* which provides Iterable access to both the IndexableFields and StorableFields. As such, Document itself is becoming more userland. However by letting it store Indexable and StorableFields separately, the functionality it provides (getBinaryValue for example) becomes quite verbose because it must provide an implementations of both kinds of fields. Given that Field is a userland implementation of both Indexable and StorableField, should Document work solely with Fields? or should we allow people to register both kinds of fields separately and just have a verbose set of functionality?\n\nGood question... I think the userland \"Field\" (oal.document) should\nimplement both IndexableField and StorableField?  And then\noal.document.Document holds Field instances?\n\nMaybe we can name the new class oal.index.Indexable?  It's a trivial\nclass, just exposing .indexableFieldsIterator and\n.storableFieldsIterator? ",
            "author": "Michael McCandless",
            "id": "comment-13092948"
        },
        {
            "date": "2011-08-30T03:15:44+0000",
            "content": "\nGood question... I think the userland \"Field\" (oal.document) should\nimplement both IndexableField and StorableField? And then\noal.document.Document holds Field instances?\n\nYeah I have made Field implement both types.  I have also left stored() and indexed() on Field while removing them from the respective interfaces.\n\n\nMaybe we can name the new class oal.index.Indexable? It's a trivial\nclass, just exposing .indexableFieldsIterator and\n.storableFieldsIterator?\n\nAbsolutely.\n\nThanks for your help Mike! ",
            "author": "Chris Male",
            "id": "comment-13093406"
        },
        {
            "date": "2011-08-30T06:54:29+0000",
            "content": "I'm almost done getting an initial patch for this, just one issue remaining - IndexDocValues.  IndexDocValues can be both not indexed and not stored.  Therefore when you retrieve the indexed fields and then the stored fields, you can miss some IndexDocValues.  It seems to be that we might need a 3rd interface to cover these fields?  ",
            "author": "Chris Male",
            "id": "comment-13093483"
        },
        {
            "date": "2011-08-30T07:21:08+0000",
            "content": "I'm almost done getting an initial patch for this, just one issue remaining - IndexDocValues. IndexDocValues can be both not indexed and not stored. Therefore when you retrieve the indexed fields and then the stored fields, you can miss some IndexDocValues. It seems to be that we might need a 3rd interface to cover these fields?\n\nTo me it appears that we need some clarification what DocValues are. Actually, when you think about it Stored Fields and DocValues have a lot in common. A Stored Field is basically a DocValues DerefVarBytes type and maybe down the road we should think about merge those two types together. It would be nice to have only one typesafe API that can store whatever you want and based on the codec lucene would decide how to store it on disk ie. if it is a multi field container like Stored Fields are done today or if the values are split appart like DocValues does it today.\nFor now we should try to differentiate between and InvertedField and a StoredField ie. everything which is not an InvertedField is a StoredField. The API could basically already reflect that DocValues and StoredFields are the same and simply specify a type like Store.Packed vs. Store.ColumnStride or something like that. If we do that we could also expose loading \"Packed\" Fields via PerDocValues and have one API for our users. ",
            "author": "Simon Willnauer",
            "id": "comment-13093499"
        },
        {
            "date": "2011-08-30T07:34:21+0000",
            "content": "Just for clarification, Packed refers to the notion of a stored field? or am I lost? ",
            "author": "Chris Male",
            "id": "comment-13093513"
        },
        {
            "date": "2011-08-30T07:41:20+0000",
            "content": "Just for clarification, Packed refers to the notion of a stored field? or am I lost?\nyes, since we pack all fields together into one location and store only the offset to the first field per document. I just used that term here to differentiate, sorry for the confusion ",
            "author": "Simon Willnauer",
            "id": "comment-13093520"
        },
        {
            "date": "2011-08-30T07:46:01+0000",
            "content": "Given what you say about the similarities between stored fields and DocValues and the direction we seem to be heading, I think its a good term to start using. ",
            "author": "Chris Male",
            "id": "comment-13093525"
        },
        {
            "date": "2011-08-30T12:49:03+0000",
            "content": "\nGood question... I think the userland \"Field\" (oal.document) should\nimplement both IndexableField and StorableField? And then\noal.document.Document holds Field instances?\n\nHm I'm going round in circles on this.  For building and indexing a Document, having the class hold Field instances is easiest and the most clean option.  However this then means we are once again providing Field instances in the Document returned by reader.document(), meaning we lose:\n\n\nSo I consider this (these indexing details are no longer available\nwhen you pull the document) a big benefit of cutting over to\nStorableField. Ie, its trappy today since it's buggy, so we'd be\nremoving that trap.\n\nThoughts? :/ ",
            "author": "Chris Male",
            "id": "comment-13093698"
        },
        {
            "date": "2011-08-30T15:14:22+0000",
            "content": "So one thought would be to have a different class being returned by reader.document(), we could call it StoredDocument and it would only make access to StorableFields.  I like this idea since it gets people over the hump of piggybacking Field, but it is a bw compat break.  Any objections? ",
            "author": "Chris Male",
            "id": "comment-13093802"
        },
        {
            "date": "2011-08-30T15:27:27+0000",
            "content": "I agree DocValues seem both indexed and stored, but they are closer to\nstored field so let's put them under StorableField.\n\nAnd indeed we could impl stored fields as a DerefVarBytes doc values\nfield, but I think we should hold off on unifying this in the APIs we\nare creating here?\n\nIe, StorableField should just have a .docValues() method and if that\nreturns non-null value the indexer will index those doc values\n(likewise for .stringValue(), binaryValue(), etc.)? ",
            "author": "Michael McCandless",
            "id": "comment-13093818"
        },
        {
            "date": "2011-08-30T15:32:51+0000",
            "content": "So one thought would be to have a different class being returned by reader.document(), we could call it StoredDocument and it would only make access to StorableFields.\n\n+1 ",
            "author": "Michael McCandless",
            "id": "comment-13093825"
        },
        {
            "date": "2011-09-24T14:23:34+0000",
            "content": "Back on this wagon for a bit.\n\nJust wondering about whether we need a StorableFieldType to accompany StorableField.\n\nAt this stage I've struggling to identify candidate properties for a StorableFieldType.  Options include moving the Numeric.DataType and DocValues' ValueType to the FieldType.  While I sort of like this idea, it seems to have a couple of disadvantages:\n\n\n\tAny FieldTypes passed into NumericField and IndexDocValuesField would have to have these properties set from the beginning.  For both of these, this would mean it wouldn't be possible to simple initialize a field and then use one of the setters to define the Data/ValueType - they would need to be known at construction.\n\tIt separates the 'data type' away from the actual value.\n\n\n\nIf these properties were to stay on StorableField, I can't really see the need for a StorableFieldType. ",
            "author": "Chris Male",
            "id": "comment-13113984"
        },
        {
            "date": "2012-03-29T14:54:34+0000",
            "content": "Hi folks, \n\nI think this one could be a nice addition to my last year GSOC and I would like to take on it for this year GSOC. \nMike also suggested using different class for reader.document() so this means I would also do https://issues.apache.org/jira/browse/LUCENE-3891 \n\nWhat do you guys think? ",
            "author": "Nikola Tankovic",
            "id": "comment-13241286"
        },
        {
            "date": "2012-03-29T16:14:47+0000",
            "content": "Hi Nikola,\n\nI think this plus LUCENE-3891 sounds great!  The challenge is... we need a mentor for this project... volunteers? ",
            "author": "Michael McCandless",
            "id": "comment-13241354"
        },
        {
            "date": "2012-04-04T16:21:04+0000",
            "content": "Hi guys,\n\nI submited first draft of proposal @ http://www.google-melange.com/gsoc/proposal/review/google/gsoc2012/ntankovic/30002#\n\nI'm welcome for corrections and further proposals.\n\nTy! ",
            "author": "Nikola Tankovic",
            "id": "comment-13246424"
        },
        {
            "date": "2012-04-13T20:29:40+0000",
            "content": "Hi Michael,\nI would take the mentorship. We will have an IRC meeting for a short interview tomorrow (Sat, 14) on #lucene-dev at 13:00 UTC. ",
            "author": "Uwe Schindler",
            "id": "comment-13253716"
        },
        {
            "date": "2012-04-14T17:56:08+0000",
            "content": "We had the GSoC interview today: http://colabti.org/irclogger/irclogger_log/lucene-dev?date=2012-04-14#l27 ",
            "author": "Uwe Schindler",
            "id": "comment-13254162"
        },
        {
            "date": "2012-04-23T20:49:39+0000",
            "content": "I want to thank you guys for the opportunity to be part of GSOC 2012. Let the coding begin! You rock! ",
            "author": "Nikola Tankovic",
            "id": "comment-13259939"
        },
        {
            "date": "2012-04-23T21:16:43+0000",
            "content": "Hi Nikola,\nI am glad to work with you this year! I did not get the official confirmation from Google until now, but I will check out later! Once back at home (I am on business trip), we should meet this week maybe in IRC to make a plan for the following weeks!\n\nUwe ",
            "author": "Uwe Schindler",
            "id": "comment-13259960"
        },
        {
            "date": "2012-04-27T17:40:03+0000",
            "content": "Hi Nikola,\nwhat's the plan to start with? ",
            "author": "Uwe Schindler",
            "id": "comment-13263826"
        },
        {
            "date": "2012-05-20T09:05:43+0000",
            "content": "While at the Lucene Revolution Conference, Mike and me discussed about \"hiding\" the internal Lucene document IDs from the public search/TopDocs API. As this is very related to this issue, we may thing about implementing this.\n\nMy idea was to let TopDocs directly return the SearchDocument classes, only addressed by its slot in the TopDocs. This way, we prevent the ongoing problems with users \"thinking\" that Lucene internal document IDs should be stable (which they aren't).\n\nOf course in the expert APIs (Scorer, DocIDSet, FoildCache...) we still have the internal DocIDs, but the public facing APIs (executing a query and getting TopDocs) should not use internal DocIds. Robert already opened a new issue to \"resurrect the crazy Hits\" class (LUCENE-4052, but with it's problems fixed). ",
            "author": "Uwe Schindler",
            "id": "comment-13279704"
        },
        {
            "date": "2012-05-20T14:55:48+0000",
            "content": "I'd argue that TopDocs is also expert level and core (e.g. see TopFieldCollector.create()) hence we shouldn't hide the IDs as that would seriously be diminishing functionality.\n ",
            "author": "Yonik Seeley",
            "id": "comment-13279786"
        },
        {
            "date": "2012-05-20T15:24:10+0000",
            "content": "The TopDocs class is what IndexSearcher.search() returns, so why is it expert? ",
            "author": "Uwe Schindler",
            "id": "comment-13279793"
        },
        {
            "date": "2012-05-20T15:55:40+0000",
            "content": "The TopDocs class is what IndexSearcher.search() returns, so why is it expert?\n\nBecause it's not just a friendly wrapper around other expert level classes.  Remove access to the internal ID there, and it gets extremely difficult to do some types of searches where you want the IDs.\nFor example: the TopDocsCollector (expert level) classes return TopDocs. ",
            "author": "Yonik Seeley",
            "id": "comment-13279799"
        },
        {
            "date": "2012-05-20T16:26:07+0000",
            "content": "My intention wa snot to remove it completely, the idea was to make TopDocs internally hold the IndexSearcher, too, so it can return the Document instance (or what we have here after the refactoring). Returning the docId would then be \"expert\", but user-facing code could call \"Document TopDocs.getDocument(slot)\". ",
            "author": "Uwe Schindler",
            "id": "comment-13279810"
        },
        {
            "date": "2012-05-20T16:34:50+0000",
            "content": "But its wrong now to put an IndexSearcher in TopDocs, as it can contain results\nfrom multiple searchers (TopDocs.merge) ",
            "author": "Robert Muir",
            "id": "comment-13279811"
        },
        {
            "date": "2012-05-21T06:00:14+0000",
            "content": "Robert, I agree about that! I am just discussing ideas, maybe create separate issue about that. ",
            "author": "Uwe Schindler",
            "id": "comment-13279979"
        },
        {
            "date": "2012-05-26T14:02:36+0000",
            "content": "Patch 01: Introduces StoredDocument,\nPatch 02: Continues along path in patch 01, introduces StorableField ",
            "author": "Nikola Tankovic",
            "id": "comment-13283980"
        },
        {
            "date": "2012-05-26T15:35:45+0000",
            "content": "Patch 03: Core compiles, and almost all test pass.\n\nThe problem remains: should StoredDocument with StorableFields have typeInfos? So we can make new Document for another round of indexing from StoredDocuments? ",
            "author": "Nikola Tankovic",
            "id": "comment-13283997"
        },
        {
            "date": "2012-05-29T10:44:33+0000",
            "content": "Patch looks great!\n\nI'm not sure IndexableField should extend StorableField?  Shouldn't they be separate classes?  I\nthink we should also split out a StorableFieldType from IndexableFieldType?  Then, the Document\nclass would expose two iterators (one for indexed fields, one for stored fields) and IW uses those\niterators to know what fields to index/store?\n\nshould StoredDocument with StorableFields have typeInfos? So we can make new Document for another round of indexing from StoredDocuments?\n\nI think ideally we would have only a StorableFieldType accessible in the loaded document?  Ie, such\nthat, it would in fact be safe to turn around and re-use that StoredFields instance for adding stored fields to\nanother document your are about to index? ",
            "author": "Michael McCandless",
            "id": "comment-13284717"
        },
        {
            "date": "2012-05-29T10:48:25+0000",
            "content": "\nI'm not sure IndexableField should extend StorableField? Shouldn't they be separate classes? I\nthink we should also split out a StorableFieldType from IndexableFieldType? Then, the Document\nclass would expose two iterators (one for indexed fields, one for stored fields) and IW uses those\niterators to know what fields to index/store?\n\nI agree fully with this.  We really want to decouple Storable and Indexable concepts as much as possible. ",
            "author": "Chris Male",
            "id": "comment-13284719"
        },
        {
            "date": "2012-05-29T10:57:50+0000",
            "content": "OK, I agree with decoupling. Can I make GeneralField interface with methods like \"getName\" and \"getXXXValue\"? Then, both Indexable and Storable fields can extend that? ",
            "author": "Nikola Tankovic",
            "id": "comment-13284721"
        },
        {
            "date": "2012-05-29T11:01:20+0000",
            "content": "I'm not sure that's needed.  In the end IndexableField shouldn't have any getXXXValue() methods, it should only return a TokenStream.  Only StorableField would need those methods. ",
            "author": "Chris Male",
            "id": "comment-13284724"
        },
        {
            "date": "2012-05-29T11:04:53+0000",
            "content": "OK, thank you! I was not sure about that. ",
            "author": "Nikola Tankovic",
            "id": "comment-13284726"
        },
        {
            "date": "2012-05-31T17:50:21+0000",
            "content": "Patch 04: Status > core compiles.\n\nThis is an attempt to separate IndexableFields and StorebleFields in indexing. \n\nI introduced oal.index.Document which holds both type of fields.\n\nI also introduced StorableFieldType interface, StoredFieldType class.\n\nLet me know what you think! ",
            "author": "Nikola Tankovic",
            "id": "comment-13286777"
        },
        {
            "date": "2012-05-31T20:38:21+0000",
            "content": "Comments to patch 04:\n\n\n\tindex.Document is an interface, I think for better extensibility in the future it could be an abstract class - who knows what we will want to put there in addition to the iterators...\n\tas noted on IRC, this strong decoupling of stored and indexed content poses some interesting questions:\n\t\n\t\tsince you can add multiple fields with the same name, you can now add an arbitrary sequence of Stored and Indexed fields (all with the same name). This means that you can now store parts of a field that are not indexed, and parts of a field that are indexed but not stored.\n\t\tpreviously, if a field was flagged as indexed but didn't have a tokenStream, its String or Reader value would be used to create a token stream. Now if you want a value to be stored and indexed you have to add two fields with the same name - one StoredField and the other an IndexedField for which you create a token stream from the value. My assumption is that StoredField-s will never be used anymore as potential sources of token streams?\n\t\n\t\n\tmaybe this is a good moment to change all getters that return arrays of fields or values to return List-s, since all the code is doing underneath is collecting them into lists and then converting to arrays?\n\tpreviously we allowed one to remove fields from document by name, are we going to allow this now separately for indexed and stored fields?\n\n\n\n\n\tminor nit: there's a grammar mistake in Field.setTokenStream(..): \"TokenStream fields tokenized\".\n\n ",
            "author": "Andrzej Bialecki",
            "id": "comment-13286909"
        },
        {
            "date": "2012-06-01T04:03:34+0000",
            "content": "index.Document is an interface, I think for better extensibility in the future it could be an abstract class - who knows what we will want to put there in addition to the iterators...\n\nI'm not sure that is such a big deal.  But I do think  should think about the name here.  We already have Document and it's going to become confusing with two different Document classes kind of doing the same thing and with document.Document implementing index.Document as well.\n\npreviously we allowed one to remove fields from document by name, are we going to allow this now separately for indexed and stored fields?\n\nI think we need to simplify the document.Document API.  I don't think it should hold Indexable/StorableField instances but instead should just hold Field instances.  It is a userland kind of class and so is Field.  We should make it easy for people to add the Fields that they want.  If they want to have a Field which is both indexed and stored, then they can create it once and add it to Document.  If they want to do it separately, then they can do that too.  Since Field implements both IndexableField and StorableField, it can serve the dual purpose.\n\nThat way the API in document.Document is pretty simple and you can add and remove things as done in the past. ",
            "author": "Chris Male",
            "id": "comment-13287136"
        },
        {
            "date": "2012-06-01T07:02:04+0000",
            "content": "My assumption is that StoredField-s will never be used anymore as potential sources of token streams?\n\nOne case where it might make sense are scenarios where a user wants to store analyzed field (not original) and later to to read it as TokenStream. Kind of TermVector without tf. I think I remember seing great patch with indexable-storable field (with serialization and deserialization).\n\nA user can do it in two passes, but sumetimes it is a not chep to analyze two times\n ",
            "author": "Eks Dev",
            "id": "comment-13287213"
        },
        {
            "date": "2012-06-01T08:44:01+0000",
            "content": "We already have Document and it's going to become confusing with two different Document classes\n\n+1 to use a better name (LuceneDocument? AbstractDocument?).\n\nI don't think it should hold Indexable/StorableField instances but instead should just hold Field instances.\n\nWith the Field class implementing IndexableField and StorableField, and on retrieval returning a different class that implements only StorableField? Well, at least it would allow for expressing the association between consecutive stored/indexed values that we can express now when creating a Document for indexing. But the strong decoupling of stored/indexed parts of a field has its benefits too (arbitrary sequences of stored/indexed parts of fields)... and if you require a specific implementation at the level of (input) Document then you prevent users from using their own impls. of strongly decoupled sequences of StoredField/IndexedField.\n\nI think I remember seing great patch with indexable-storable field (with serialization and deserialization).\nSOLR-1535 . ",
            "author": "Andrzej Bialecki",
            "id": "comment-13287267"
        },
        {
            "date": "2012-06-01T09:35:19+0000",
            "content": "With the Field class implementing IndexableField and StorableField, and on retrieval returning a different class that implements only StorableField?\n\nYes, Nikola has included a StoredDocument class for that.  This would prevent users from thinking they can just take a search result and pass it into being indexed.  It creates a clear separation between indexing and search results.\n\nBut the strong decoupling of stored/indexed parts of a field has its benefits too (arbitrary sequences of stored/indexed parts of fields)... and if you require a specific implementation at the level of (input) Document then you prevent users from using their own impls. of strongly decoupled sequences of StoredField/IndexedField.\n\nI agree that there are benefits to the decoupling.  It's just that one of the important factors in this issue and other work in and around Document & Field is creating a cleaner API for users.  I'm not sure bogging the document.Document API down with having to manage both Storable and IndexableField instances is worth it.  Field is already basically a parent class with the extensive list of specializations we now have.\n\nI'm wondering whether expert users who are using their own Storable/IndexableField impls will also want their own 'Document' impls as well, maybe to support direct streaming of fields or something.  If we enforce this, then we're have a consistent policy that to use these expert interfaces, you're going to have to provide your own implementations for everything.\n\nWith all that said, I'm open to a clean API in Document that can do everything  ",
            "author": "Chris Male",
            "id": "comment-13287294"
        },
        {
            "date": "2012-06-01T12:46:16+0000",
            "content": "I think I like this decoupling ... for normal users I don't think this\nmakes the API harder?  They still work with TextField, FloatField,\nStoredField, etc.?  It's just that, under the hood, these sugar classes\nextend from the right base class (indexed or stored).\n\nDocument.add is just type overloaded, but Document.get* will get\nmessier: we'll need getStored and getIndexed?  I guess that would be\nsimpler if Document could just store Field instances... hmm.\n\nIt would also be less invasive change for migrating from 4.0 -> 5.0\n(assuming this issue is done only for 5.0...) if we didn't do the hard\nsplit.... else we need a back-compat story...\n\n\nWe already have Document and it's going to become confusing with two different Document classes\n\n+1 to use a better name (LuceneDocument? AbstractDocument?).\n\nMaybe IndexDocument?  I think it's OK as an interface if we mark it\n@lucene.internal?  This is the raw, super expert low-level that indexer\nuses to consume documents... it has only 2 methods, and I think for\nexpert users it could be a hassle if we force the impl to inherit from\nour base class...\n\nShould StoredDocument (returned from IR.document) be \"read only\"?  Like\nyou can iterate its fields, look them up, etc., but not eg remove them?\n\nWe should probably rename document.Field -> document.IndexedField and\ndocument.Field -> document.IndexedFieldType?\n\nAlso I think we should rename XXXField.TYPE_UNSTORED -> .TYPE, since in\neach case there's only 1 TYPE instance for that sugar field?\n\nSeparately, I think even for 4.0 we should remove XXXField.TYPE_STORED\nfrom all the sugar fields (TextField, StringField, etc.); expert users\ncan always make a custom Indexable/Storable/Field/FieldType that both\nstores & indexes... ",
            "author": "Michael McCandless",
            "id": "comment-13287364"
        },
        {
            "date": "2012-06-01T13:10:58+0000",
            "content": "I am all for the decoupling too, just want to thoroughly kick the tyres on this one   I dont want another FieldType like discussion.\n\n\nDocument.add is just type overloaded, but Document.get* will get\nmessier: we'll need getStored and getIndexed? I guess that would be\nsimpler if Document could just store Field instances... hmm.\n\nPerhaps if we just limit the API in Document we can handle this okay.  We can provide the overloaded add methods, two get methods and 1 remove method.\n\n\nMaybe IndexDocument? I think it's OK as an interface if we mark it\n@lucene.internal? This is the raw, super expert low-level that indexer\nuses to consume documents... it has only 2 methods, and I think for\nexpert users it could be a hassle if we force the impl to inherit from\nour base class...\n\n+1 to both the name and the handling of the interface.\n\n\nShould StoredDocument (returned from IR.document) be \"read only\"? Like\nyou can iterate its fields, look them up, etc., but not eg remove them?\n\n+1 You shouldn't really need to remove fields, you can achieve that by not retrieving them in the first place ",
            "author": "Chris Male",
            "id": "comment-13287380"
        },
        {
            "date": "2012-06-02T18:08:28+0000",
            "content": "\nSeparately, I think even for 4.0 we should remove XXXField.TYPE_STORED\n from all the sugar fields (TextField, StringField, etc.); expert users\n can always make a custom Indexable/Storable/Field/FieldType that both\n stores & indexes...\n\nI opened a new issue for this: LUCENE-4101.\n\nNikola, before you modify any of the tests for this issue you might want to wait for me to commit & forward port to 5.0 else there will be a lot of conflicts! ",
            "author": "Michael McCandless",
            "id": "comment-13287987"
        },
        {
            "date": "2012-06-02T18:45:02+0000",
            "content": "Nikola, before you modify any of the tests for this issue you might want to wait for me to commit & forward port to 5.0 else there will be a lot of conflicts!\n\nOK, let me know when you finish! ",
            "author": "Nikola Tankovic",
            "id": "comment-13287999"
        },
        {
            "date": "2012-06-02T18:52:22+0000",
            "content": "I am back @ office, trying to catch up. ",
            "author": "Uwe Schindler",
            "id": "comment-13288003"
        },
        {
            "date": "2012-06-09T17:42:46+0000",
            "content": "I think, given the discussions in LUCENE-4101, that the document.FieldType class should implement both index.IndexableFieldType and index.StorableFieldType, so that users can add a single Field instance that's both stored and indexed ... ",
            "author": "Michael McCandless",
            "id": "comment-13292389"
        },
        {
            "date": "2012-06-10T03:13:22+0000",
            "content": "Following on from that, I don't think we should expose the IndexableField / StorableField decoupling in document.Document.  It should remain an easy to use class for the most common use cases.  In which case I think it should only use Field instances.  We can then do some work for it to meet the needs of index.IndexDocument.  Having it this way means users can choose whether they want to add a single instance for both stored and indexed, or two instances. ",
            "author": "Chris Male",
            "id": "comment-13292467"
        },
        {
            "date": "2012-06-10T07:24:31+0000",
            "content": "I think as we have 2 interfaces, we should only allow the interface StorableField added to StoredDocument and vice versa. The user still can add combined fields, as both interfaces are implemented? Do I miss something? ",
            "author": "Uwe Schindler",
            "id": "comment-13292486"
        },
        {
            "date": "2012-06-10T08:04:13+0000",
            "content": "Yeah StoredDocument should only consist of StorableFields. ",
            "author": "Chris Male",
            "id": "comment-13292488"
        },
        {
            "date": "2012-06-20T13:20:58+0000",
            "content": "Hi Nikola,\ndo you have any news or progress? I did not hear anything from you the last two weeks and I am a little bit nervous (because of GSoC). ",
            "author": "Uwe Schindler",
            "id": "comment-13397487"
        },
        {
            "date": "2012-06-21T08:54:56+0000",
            "content": "Patch 05:\n\n\n\tRenamed index.Document to index.IndexDocument\n\tMade oal.Document consisting only of Field's\n\tMade Field implement both Storable and IndexableField\n\tMade iterators to extract indexed and stored fields from document separately\n\n ",
            "author": "Nikola Tankovic",
            "id": "comment-13398300"
        },
        {
            "date": "2012-06-21T10:15:55+0000",
            "content": "Hey Nikola,\n\nJust did a quick pass over the patch.\n\nI have an alternative way to do the Indexable/StorableFieldsIterator in Document (it'll need the policeman's tick though):\n\n\npublic abstract class SelectiveIterator<T> implements Iterator<T> {\n\n  private T next;\n  private final List<T> list;\n  private int pos;\n\n  public SelectiveIterator(List<T> list) {\n    this.list = list;\n  }\n\n  @Override\n  public void remove() {\n    throw new UnsupportedOperationException();\n  }\n\n  @Override\n  public boolean hasNext() {\n    for (; pos < list.size(); pos++) {\n      T t = list.get(pos);\n      if (isNext(t)) {\n        next = t;\n        return true;\n      }\n    }\n    return false;\n  }\n\n  @Override\n  public T next() {\n    return next;\n  }\n\n  abstract boolean isNext(T t);\n}\n\n\n\nI think that'll work.  Then you can just create two instances which implement isNext differently.\n\nI also noticed that you've included import org.apache.commons.lang.NotImplementedException; in Document which will also need to be removed. ",
            "author": "Chris Male",
            "id": "comment-13398324"
        },
        {
            "date": "2012-06-21T10:19:33+0000",
            "content": "I like the solution, but we will wait for Mr. Policeman \n\nSorry about the NotImplementedException, I needed it temporarily, and will remove it! ",
            "author": "Nikola Tankovic",
            "id": "comment-13398325"
        },
        {
            "date": "2012-06-21T10:20:26+0000",
            "content": "Chris: The iterator looks generics-wise correct, the big problem is that it only works correct with Lists implementing RandomAccess. To work performant and correct on all Lists, it should use the ListIterator/Iterator of the wrapped List.\n\nThe second problem is that it violates the Iterator pattern: You should be able to call next() without calling hasNext() before and you must also be able to call hasNext() multiple times. So the \"iteration\" logic must be in next(). Ideally you can do that by coping some code from commons-collections or google-collect. The general pattern how to implement filtering decorators for other Iterators is to use a doNext() method which moves the wrapped iterator forward and is called inside next() after the current value was returned (means the wrapped iterator is already one step further than the outer iterator).\n\nUwe ",
            "author": "Uwe Schindler",
            "id": "comment-13398327"
        },
        {
            "date": "2012-06-21T10:30:30+0000",
            "content": "Yes you're right on all accounts.\n\nTaking a look at Google Guava I see AbstractIterator might be an example of what we want? ",
            "author": "Chris Male",
            "id": "comment-13398330"
        },
        {
            "date": "2012-06-21T10:30:34+0000",
            "content": "This is an example how to do it correct (just add Generics, please): http://javasourcecode.org/html/open-source/commons-collections/commons-collections-3.2.1/org/apache/commons/collections/iterators/FilterIterator.java.html ",
            "author": "Uwe Schindler",
            "id": "comment-13398331"
        },
        {
            "date": "2012-06-21T11:16:46+0000",
            "content": "Can I use something like this?\n\n\n  private FilterIterator storedFieldsIterator = new FilterIterator(fields.iterator(), new Predicate() {\n    @Override\n    public boolean evaluate(Object field) {\n      if (field instanceof Field) {\n        Field f = (Field) field;\n        return f.type.stored();\n      }\n      else return false;\n    }\n  });\n\n\n ",
            "author": "Nikola Tankovic",
            "id": "comment-13398348"
        },
        {
            "date": "2012-06-21T11:25:24+0000",
            "content": "I think we should make it so you can use appropriate generics and not need that instanceof ",
            "author": "Chris Male",
            "id": "comment-13398353"
        },
        {
            "date": "2012-06-21T11:35:24+0000",
            "content": "The code I sent was just an example. We have to duplicate the code, as Lucene-core allows no external dependencies. I would also nuke the Predicate class. My proposal was just to fix Chris' code to look like the one from commons-collections (including the generics like Chris proposed). And replace the Predicate class by the abstract method (this saves the stupid object creation). ",
            "author": "Uwe Schindler",
            "id": "comment-13398356"
        },
        {
            "date": "2012-06-21T11:51:02+0000",
            "content": "Maybe something like this?\n\n\n  public static Iterator<StorableField> storedFieldsIterator(final Iterator<Field> in) {\n    return new AbstractIterator<StorableField>() {\n      protected StorableField computeNext() {\n        while (in.hasNext()) {\n          Field f = in.next();\n          if (f.type.stored()) {\n            return f;\n          }\n        }\n        return endOfData();\n      }\n    };\n  }\n\n ",
            "author": "Nikola Tankovic",
            "id": "comment-13398361"
        },
        {
            "date": "2012-06-21T12:04:05+0000",
            "content": "OK, so no AbstractIterator then. I will make new generic iterator with abstract method. ",
            "author": "Nikola Tankovic",
            "id": "comment-13398368"
        },
        {
            "date": "2012-06-21T13:41:42+0000",
            "content": "Let me know if I can further improve this:\n\n\n  public Iterator<StorableField> storedFieldsIterator() {\n    return new FieldFilterIterator<StorableField>() {\n      @Override\n      protected boolean predicateFunction(Field field) {\n        return field.type.stored();\n      }\n    };\n  }\n  \n  public Iterator<IndexableField> indexedFieldsIterator() {\n    return new FieldFilterIterator<IndexableField>() {\n      @Override\n      protected boolean predicateFunction(Field field) {\n        return field.type.indexed();\n      }\n    };\n  }\n  \n  private abstract class FieldFilterIterator<T> implements Iterator<T> {\n\n    private Iterator<Field> iterator = fields.iterator();\n    private T nextField = null;\n    private boolean nextIsSet = false;\n    \n    protected abstract boolean predicateFunction(Field field);\n\n    public boolean hasNext() {\n        if (nextIsSet) {\n            return true;\n        } else {\n            return setNext();\n        }\n    }\n    \n    public T next() {\n        if (!nextIsSet) {\n            if (!setNext()) {\n                throw new NoSuchElementException();\n            }\n        }\n        nextIsSet = false;\n        return nextField;\n    }\n\n    public void remove() {\n        if (nextIsSet) {\n            throw new IllegalStateException(\"remove() cannot be called\");\n        }\n        iterator.remove();\n    }\n\n    private boolean setNext() {\n        while (iterator.hasNext()) {\n            Field field = iterator.next();\n            if (predicateFunction(field)) {\n                nextField = (T) field;\n                nextIsSet = true;\n                return true;\n            }\n        }\n        return false;\n    }\n  }\n\n ",
            "author": "Nikola Tankovic",
            "id": "comment-13398429"
        },
        {
            "date": "2012-06-21T13:45:06+0000",
            "content": "Looks fine, I would disallow remove() completely like in Chris' iterator.\n\nOne addition, the declaration of the abstract iterator base class should include <T extends Field>, otherweise its not generics correct. ",
            "author": "Uwe Schindler",
            "id": "comment-13398432"
        },
        {
            "date": "2012-06-21T13:53:25+0000",
            "content": "Why not make this a public class in util.* and keep the generic <T> but make the whole thing generic as well (remove Field and just use T).  It seems like a useful class. ",
            "author": "Chris Male",
            "id": "comment-13398435"
        },
        {
            "date": "2012-06-21T13:59:48+0000",
            "content": "+1 ",
            "author": "Uwe Schindler",
            "id": "comment-13398438"
        },
        {
            "date": "2012-06-21T14:17:36+0000",
            "content": "I think this is now OK, I'll put in util.*\n\n\n  public Iterator<StorableField> storedFieldsIterator() {\n    return new FilterIterator<StorableField, Field>(fields.iterator()) {\n      @Override\n      protected boolean predicateFunction(Field field) {\n        return field.type.stored();\n      }\n    };\n  }\n  \n  public Iterator<IndexableField> indexedFieldsIterator() {\n    return new FilterIterator<IndexableField, Field>(fields.iterator()) {\n      @Override\n      protected boolean predicateFunction(Field field) {\n        return field.type.indexed();\n      }\n    };\n  }\n  \n  private abstract class FilterIterator<T, U extends T> implements Iterator<T> {\n\n    private Iterator<U> iterator;\n    private T next = null;\n    private boolean nextIsSet = false;\n    \n    protected abstract boolean predicateFunction(U field);\n\n    public FilterIterator(Iterator<U> baseIterator) {\n      this.iterator = baseIterator;\n    }\n    \n    public boolean hasNext() {\n      if (nextIsSet) {\n        return true;\n      } else {\n        return setNext();\n      }\n    }\n    \n    public T next() {\n      if (!nextIsSet) {\n        if (!setNext()) { \n          throw new NoSuchElementException();\n        }\n      }\n      nextIsSet = false;\n      return next;\n    }\n\n    public void remove() {\n      throw new UnsupportedOperationException();\n    }\n\n    private boolean setNext() {\n      while (iterator.hasNext()) {\n        U object = iterator.next();\n        if (predicateFunction(object)) {\n          next = object;\n          nextIsSet = true;\n          return true;\n        }\n      }\n      return false;\n    }\n  }\n\n ",
            "author": "Nikola Tankovic",
            "id": "comment-13398446"
        },
        {
            "date": "2012-06-30T09:40:12+0000",
            "content": "Patch 06: summary of discussions. If we can somewhat agree on this core API then I would like move along to fixing tests, as that is quite a lot of work  ",
            "author": "Nikola Tankovic",
            "id": "comment-13404433"
        },
        {
            "date": "2012-06-30T11:05:35+0000",
            "content": "Hi Nikola,\nI will think about the core API and give my comments later.\nAs changing tests and solr is really the biggest change, we should create a branch and do it step for step. I would commit the current patch to a branched trunk (5.0) and then you can work with a new checkout from there and I will commit the later steps. This also allows heavy\u2122 commiting\u2122 by other committers. Unfortunately I cannot give you commit access to Apache's SVN. ",
            "author": "Uwe Schindler",
            "id": "comment-13404449"
        },
        {
            "date": "2012-06-30T11:08:08+0000",
            "content": "Agreed! No problem about commit access, I'll send patches  ",
            "author": "Nikola Tankovic",
            "id": "comment-13404450"
        },
        {
            "date": "2012-07-05T21:42:00+0000",
            "content": "Hi Nikola,\n\nI merged your patch to current tunk (removed lots of throws CorruptIndexException) and undid some formatti ng Changes in IndexReader.\n\nCan you configure your IDE to not change unrelated code? This makes merging extremely hard.\n\nI committed this in r1357938 to a new branch https://svn.apache.org/repos/asf/lucene/dev/branches/lucene3312 (from trunk r1357904, Lucene 5.0). Please use this branch for further work! I will merge it regularily when bigger changes are in main dev, so please keep it updated. Please provide new patches against this branch. ",
            "author": "Uwe Schindler",
            "id": "comment-13407509"
        },
        {
            "date": "2012-07-05T21:52:28+0000",
            "content": "And as noted before: In Lucene core we dont use extrenal dependencies, so we have a compile failure because of AbstractIterator from Google Collect, we have to put this one into Lucene utils. ",
            "author": "Uwe Schindler",
            "id": "comment-13407524"
        },
        {
            "date": "2012-07-06T11:14:31+0000",
            "content": "Uwe,\n\nI apologize for inconveniences. I don't use AbstractIterator from Google any more, and I did put custom implementation in util, but I forgot to remove \"import\" declaration. I certainly will configure my IDE to not change unrelated code (apologies once again). I switched to your new branch, and will work on it from now. \n\nThe big question is: can I go to fixing solr and tests or do you think there is some major API change left to do? ",
            "author": "Nikola Tankovic",
            "id": "comment-13407894"
        },
        {
            "date": "2012-07-06T11:18:41+0000",
            "content": "My feeling at least is that we should definitely get going on Solr and tests since they are good ways to see if the API can be consumed.  A failing test might reveal something we haven't considered. ",
            "author": "Chris Male",
            "id": "comment-13407897"
        },
        {
            "date": "2012-07-06T11:23:22+0000",
            "content": "Fine, thanks. I had no time to do API wise checks, maybe Chris had a closer look. Great work in all cases! \n\nUwe. ",
            "author": "Uwe Schindler",
            "id": "comment-13407898"
        },
        {
            "date": "2012-07-07T09:53:08+0000",
            "content": "Hi, I'm going over tests and so far so good.\n\nI am seeing a lot of \"id\" fields in document that aren't stored, e.g.:\n\n\n\n      doc.add(new IntField(\"id\", docCount, Field.Store.NO));\n\n\n\n... and having errors because my returned StoredDocument only shows stored fields. Can I convert these \"id\" fields into stored in tests? Or did we do something wrong with StoredDocument?\n\nNikola ",
            "author": "Nikola Tankovic",
            "id": "comment-13408611"
        },
        {
            "date": "2012-07-07T11:28:40+0000",
            "content": "If the test is wanting to retrieve the ID field for a StoredDocument then yes the field will need to be stored. ",
            "author": "Chris Male",
            "id": "comment-13408626"
        },
        {
            "date": "2012-07-08T17:05:31+0000",
            "content": "Hmm ... if the test is running fine today, not storing the id field, then why would it need to start storing it on switching to returning StoredDocument from IR.document...?  In theory this should be a rote change? ",
            "author": "Michael McCandless",
            "id": "comment-13408973"
        },
        {
            "date": "2012-07-08T17:53:18+0000",
            "content": "Branch looks good!\n\nBut we still seem to have StoredDocument.removeField/s methods?  Shouldn't that class be read-only? ",
            "author": "Michael McCandless",
            "id": "comment-13408997"
        },
        {
            "date": "2012-07-09T12:14:56+0000",
            "content": "Hmm ... if the test is running fine today, not storing the id field, then why would it need to start storing it on switching to returning StoredDocument from IR.document...? In theory this should be a rote change?\n\nGood point\n\nBut we still seem to have StoredDocument.removeField/s methods? Shouldn't that class be read-only?\n\n+1 ",
            "author": "Chris Male",
            "id": "comment-13409375"
        },
        {
            "date": "2012-07-09T12:40:23+0000",
            "content": "Patch 07: Core compiles and core tests looks good (except for one).\n\nI have only a problem in org.apache.lucene.index.TestIndexableField test. I cannot get it working, any help is appreciated, because I spent days with no success. I'm just missing something \n\nRegarding 'deleteField' in 'StoredDocument', I cannot remove it 'cause of PersistentSnapshotDeletionPolicy::readSnapshotsInfo function, I guess it needs refactoring. ",
            "author": "Nikola Tankovic",
            "id": "comment-13409394"
        },
        {
            "date": "2012-07-09T12:51:49+0000",
            "content": "Regarding 'deleteField' in 'StoredDocument', I cannot remove it 'cause of PersistentSnapshotDeletionPolicy::readSnapshotsInfo function, I guess it needs refactoring.\n\nAll that code seems to be doing is removing a specific field from the Document and then iterating over the remaining values in the Document.  It seems an easy change to just skip the field during the for loop. ",
            "author": "Chris Male",
            "id": "comment-13409402"
        },
        {
            "date": "2012-07-09T13:07:11+0000",
            "content": "I applied the patch to the branch: At revision: 1359139\n\nI will now do svn merge to keep branch up-to-date! ",
            "author": "Uwe Schindler",
            "id": "comment-13409419"
        },
        {
            "date": "2012-07-09T13:14:01+0000",
            "content": "Done, no new compile failures! At revision: 1359151\n\nI get 2 unneeded cast warnings in lucene-core, that's all. Lucene Core Tests pass, did you disable the failing tests? (1 test failing as expected) ",
            "author": "Uwe Schindler",
            "id": "comment-13409432"
        },
        {
            "date": "2012-07-09T13:48:51+0000",
            "content": "Hi Uwe, \n\nhow can I see those warnings?\n\nThank you! ",
            "author": "Nikola Tankovic",
            "id": "comment-13409461"
        },
        {
            "date": "2012-07-09T13:52:53+0000",
            "content": "\"ant compile\" on command line. Before sending the patch, you should always build & test on command line with ant! ",
            "author": "Uwe Schindler",
            "id": "comment-13409464"
        },
        {
            "date": "2012-07-09T13:56:35+0000",
            "content": "Yes, of course  Mike taught me that. The problem is I don't see those warning with \"ant compile\". ",
            "author": "Nikola Tankovic",
            "id": "comment-13409476"
        },
        {
            "date": "2012-07-09T13:59:40+0000",
            "content": "Maybe you missed to clean before? ANT's javac only compiles files not yet compiled, so warnings only show on first time?\n\n\nC:\\Users\\Uwe Schindler\\Projects\\lucene\\lucene3312\\lucene\\core>ant clean compile\nBuildfile: C:\\Users\\Uwe Schindler\\Projects\\lucene\\lucene3312\\lucene\\core\\build.xml\n\nclean:\n\njflex-uptodate-check:\n\njflex-notice:\n\njavacc-uptodate-check:\n\njavacc-notice:\n\nivy-availability-check:\n\nivy-fail:\n\nivy-configure:\n[ivy:configure] :: Ivy 2.2.0 - 20100923230623 :: http://ant.apache.org/ivy/ ::\n[ivy:configure] :: loading settings :: file = C:\\Users\\Uwe Schindler\\Projects\\lucene\\lucene3312\\lucene\\ivy-settings.xml\n\nresolve:\n\ninit:\n\nclover.setup:\n\nclover.info:\n     [echo]\n     [echo]       Clover not found. Code coverage reports disabled.\n     [echo]\n\nclover:\n\ncommon.compile-core:\n    [mkdir] Created dir: C:\\Users\\Uwe Schindler\\Projects\\lucene\\lucene3312\\lucene\\build\\core\\classes\\java\n    [javac] Compiling 634 source files to C:\\Users\\Uwe Schindler\\Projects\\lucene\\lucene3312\\lucene\\build\\core\\classes\\java\n    [javac] C:\\Users\\Uwe Schindler\\Projects\\lucene\\lucene3312\\lucene\\core\\src\\java\\org\\apache\\lucene\\index\\DocFieldProcessor.java:24\n3: warning: [cast] redundant cast to org.apache.lucene.index.StorableField\n    [javac]           consumer.add(docState.docID, (StorableField) field);\n    [javac]                                        ^\n    [javac] C:\\Users\\Uwe Schindler\\Projects\\lucene\\lucene3312\\lucene\\core\\src\\java\\org\\apache\\lucene\\index\\NormsConsumerPerField.jav\na:57: warning: [cast] redundant cast to org.apache.lucene.index.StorableField\n    [javac]         consumer.add(docState.docID, (StorableField) field);\n    [javac]                                      ^\n    [javac] 2 warnings\n     [copy] Copying 2 files to C:\\Users\\Uwe Schindler\\Projects\\lucene\\lucene3312\\lucene\\build\\core\\classes\\java\n\ncompile-core:\n\ncompile:\n\nBUILD SUCCESSFUL\nTotal time: 13 seconds\n\n ",
            "author": "Uwe Schindler",
            "id": "comment-13409481"
        },
        {
            "date": "2012-07-09T14:03:12+0000",
            "content": "Sorry for my n00b-iness. Thank you! ",
            "author": "Nikola Tankovic",
            "id": "comment-13409484"
        },
        {
            "date": "2012-07-09T17:05:37+0000",
            "content": "I merged trunk again (because of LUCENE-4199): revision: 1359283 ",
            "author": "Uwe Schindler",
            "id": "comment-13409641"
        },
        {
            "date": "2012-07-11T09:47:08+0000",
            "content": "Nikola: Did you get the test running now? Otherwise I see no problems with the code at the moment, but I will wait for other comment contributions!\n\nI still have a question to the iterator again:\n\n\npublic abstract class FilterIterator<T, U extends T> implements Iterator<T> {\n\n\n\nThis seems strange U extends T, so the iterator returns a wider type than it was in the original. I would expect it to be the other way round. In general for this FilteredIterator I would make no generics magic and let it return the same as the delegate. If the predicate changes type, then this should be done by the caller (who provides the predicate). Do I miss something? ",
            "author": "Uwe Schindler",
            "id": "comment-13411355"
        },
        {
            "date": "2012-07-11T20:10:52+0000",
            "content": "Hi Uwe, \n\nI have the test fixed, and both Lucene and Solr are successfully compiling now  \n\nYou are right about the FilterIterator,  \n\npublic abstract class FilterIterator<T> implements Iterator<T> {\n\n\nis enough..\n\nI am now fixing test on rest of Lucene and Solr. ",
            "author": "Nikola Tankovic",
            "id": "comment-13411920"
        },
        {
            "date": "2012-07-13T22:00:52+0000",
            "content": "Hi Nikola,\nthe second half of the GSoC started now. What are the plans for the second part? I expected that the Solr+Test changes proceed now, so we have enough time check the new API in general use and fix issues! ",
            "author": "Uwe Schindler",
            "id": "comment-13414097"
        },
        {
            "date": "2012-07-13T22:05:45+0000",
            "content": "Hi Uwe, \n\nin a few days I will hopefully finish with Solr+Test part. Then we can do another round of discussion, API checking and modifying. ",
            "author": "Nikola Tankovic",
            "id": "comment-13414100"
        },
        {
            "date": "2012-07-13T22:09:27+0000",
            "content": "Is there anything at the moment you need help with? ",
            "author": "Uwe Schindler",
            "id": "comment-13414102"
        },
        {
            "date": "2012-07-13T22:20:44+0000",
            "content": "Not at the moment, just little more time  A lot of code here  ",
            "author": "Nikola Tankovic",
            "id": "comment-13414107"
        },
        {
            "date": "2012-07-21T13:17:45+0000",
            "content": "I keep getting this error:\n\n[junit4:junit4] Suite: org.apache.lucene.benchmark.quality.TestQualityRun\n[junit4:junit4] FAILURE 27.4s | TestQualityRun.testTrecQuality\n[junit4:junit4]    > Throwable #1: java.lang.AssertionError: avg-p should be perfect: 0.9856606205097583 expected:<1.0> but was:<0.9856606205097583>\n\n\n\nShould I worry? ",
            "author": "Nikola Tankovic",
            "id": "comment-13419831"
        },
        {
            "date": "2012-07-21T13:23:32+0000",
            "content": "Yes. There aren't many tests that test that Lucene's default ranking is correct, but this is one of them.\n\nThis means something is wrong... ",
            "author": "Robert Muir",
            "id": "comment-13419832"
        },
        {
            "date": "2012-07-27T13:07:21+0000",
            "content": "Hi Nikola, should I merge up the branch to trunk? Do you have anything to commit? ",
            "author": "Uwe Schindler",
            "id": "comment-13423853"
        },
        {
            "date": "2012-07-28T10:17:42+0000",
            "content": "Patch 08: Everything compiles, Lucene tests pass except for 'TestQualityRun' (I'm struggling with this one). Solr tests are yet to be fixed. Uwe, you can merge in the trunk, so I can continue. ",
            "author": "Nikola Tankovic",
            "id": "comment-13424314"
        },
        {
            "date": "2012-07-28T10:59:42+0000",
            "content": "Thanks Nikola, I applied your patch in revision: 1366638\n\nThe merging is now running.\n\nLucene tests pass except for 'TestQualityRun' (I'm struggling with this one)\n\nI think Robert Muir may be able to help you, he already had some comments about this. I will ping him! ",
            "author": "Uwe Schindler",
            "id": "comment-13424319"
        },
        {
            "date": "2012-07-28T11:29:00+0000",
            "content": "Merged up to trunk in revision: 1366643 ",
            "author": "Uwe Schindler",
            "id": "comment-13424320"
        },
        {
            "date": "2012-08-08T17:41:16+0000",
            "content": "Hi Nikola,\nnext week is \"pencils down\", so we should start to finish this task and do final things like \"scrub code, write tests, improve documentation\" (official google description). Did you find out whats causing your test failures? I may try to look into it this evening, so I will try to find out.\nShould I merge up to trunk?\nThe final week until Fri, 24th should be used to prepare the final branch reintegrate and provide the final patch (that could also be sent to Google). ",
            "author": "Uwe Schindler",
            "id": "comment-13431240"
        },
        {
            "date": "2012-08-08T20:13:31+0000",
            "content": "Patch 09: small fix that fixes many Solr test, Solr now compiles and tests all OK! Lucene compiles, every test OK, except for mentioned TestQualityRun.testTrecQuality. I am really struggling with this one, any help is appreciated!\n\nSome tests throw OutOfMemory errors (but that was also last year), so I think this is one final test to fix. ",
            "author": "Nikola Tankovic",
            "id": "comment-13431346"
        },
        {
            "date": "2012-08-08T21:54:39+0000",
            "content": "Some tests throw OutOfMemory errors (but that was also last year), so I think this is one final test to fix.\n\nThey should not do this when ran with \"ant test\". If they do in eclipse or other GUIs it can happen because the default test -Xmx is 512M for Lucene's build.xml, which is not respected by Eclipse.\n\nI will apply the patch later! ",
            "author": "Uwe Schindler",
            "id": "comment-13431433"
        },
        {
            "date": "2012-08-09T10:02:39+0000",
            "content": "Patch applied revision: 1371131 ",
            "author": "Uwe Schindler",
            "id": "comment-13431712"
        },
        {
            "date": "2012-08-09T10:22:27+0000",
            "content": "I merged the branch up to current trunk (revision: 1371142)\n\nBy this merge, new compile failures in tests occur, mainly caused by new tests added in some commits, using the old API. It would be good to fix those. ",
            "author": "Uwe Schindler",
            "id": "comment-13431717"
        },
        {
            "date": "2012-08-09T10:25:59+0000",
            "content": "Hey Nikola,\n\nexcept for mentioned TestQualityRun.testTrecQuality.\n\nI'm happy to help work out what is going wrong here, have you done any debugging of the test yourself? What have you worked out so far? ",
            "author": "Chris Male",
            "id": "comment-13431719"
        },
        {
            "date": "2012-08-09T10:43:40+0000",
            "content": "Well some stats in this test are hurt:\n\nStat nr.3 => Avp: 1.0, Recall: 1.0\nStat nr.4 => Avp: 0.9919381323163302, Recall: 1.0\nStat nr.5 => Avp: 0.9978136200716846, Recall: 1.0\nStat nr.6 => Avp: 1.0, Recall: 1.0\nStat nr.7 => Avp: 1.0, Recall: 1.0\nStat nr.11 => Avp: 0.9978136200716846, Recall: 1.0\nStat nr.12 => Avp: 0.9989247311827957, Recall: 1.0\nStat nr.13 => Avp: 0.9856606205097583, Recall: 1.0\nStat nr.14 => Avp: 1.0, Recall: 1.0\nStat nr.15 => Avp: 0.9934262275544256, Recall: 1.0\nStat nr.19 => Avp: 0.9862623857947443, Recall: 1.0\n\n\n\nAvp below 0.99 is not allowed, what could be the possible reasons of bad Avg-p? ",
            "author": "Nikola Tankovic",
            "id": "comment-13431728"
        },
        {
            "date": "2012-08-09T13:52:00+0000",
            "content": "Something is going wrong with the indexing of the reuters content. \n\nI ran the test with SimpleText on both branches (adding forceMerge(1) for simplicity) and looked at the resulting index:\n\nTrunk:\n\n-rw-rw-r-- 1 rmuir rmuir   13798 Aug  9 09:42 _0_6.len\n-rw-rw-r-- 1 rmuir rmuir 1022509 Aug  9 09:42 _0.fld\n-rw-rw-r-- 1 rmuir rmuir    1310 Aug  9 09:42 _0.inf\n-rw-rw-r-- 1 rmuir rmuir 3345582 Aug  9 09:42 _0.pst\n-rw-rw-r-- 1 rmuir rmuir     513 Aug  9 09:42 _0.si\n-rw-rw-r-- 1 rmuir rmuir      71 Aug  9 09:42 segments_1\n-rw-rw-r-- 1 rmuir rmuir      20 Aug  9 09:42 segments.gen\n\n\n\nBranch:\n\n-rw-rw-r-- 1 rmuir rmuir     13262 Aug  9 09:46 _4_6.len\n-rw-rw-r-- 1 rmuir rmuir 290247032 Aug  9 09:45 _4.fld\n-rw-rw-r-- 1 rmuir rmuir      1310 Aug  9 09:46 _4.inf\n-rw-rw-r-- 1 rmuir rmuir 459164224 Aug  9 09:46 _4.pst\n-rw-rw-r-- 1 rmuir rmuir       593 Aug  9 09:46 _4.si\n-rw-rw-r-- 1 rmuir rmuir        71 Aug  9 09:46 segments_1\n-rw-rw-r-- 1 rmuir rmuir        20 Aug  9 09:46 segments.gen\n\n\n\nLooking into the .fld file, I think the problem is obvious:\non trunk:\n\ndoc 0\n  numfields 5\ndoc 1\n  numfields 5\ndoc 2\n  numfields 5\n\n\n\non branch:\n\ndoc 0\n  numfields 5\ndoc 1\n  numfields 10\ndoc 2\n  numfields 15\n\n\n\nSo there is some bug, where a field is 'accumulating' across documents. The last document has 2890.\n\nI'm really horrified this is the only test that fails! ",
            "author": "Robert Muir",
            "id": "comment-13431807"
        },
        {
            "date": "2012-08-09T14:17:18+0000",
            "content": "Wow, I have replicated the same behaviour.  On the branch the number of fields per doc is... wow. ",
            "author": "Chris Male",
            "id": "comment-13431828"
        },
        {
            "date": "2012-08-09T14:25:43+0000",
            "content": "Ah I think I found the problem, it's in Document, I'll verify in a few seconds. ",
            "author": "Chris Male",
            "id": "comment-13431833"
        },
        {
            "date": "2012-08-09T14:28:52+0000",
            "content": "nice: the bug wasn't obvious to me (i glanced thru the diff of the branches),\nbut at least SimpleText came to the rescue \n\nI'm still really really shocked more tests aren't failing for this: I guess\nmaybe it only happens in certain circumstances? ",
            "author": "Robert Muir",
            "id": "comment-13431836"
        },
        {
            "date": "2012-08-09T14:29:55+0000",
            "content": "I found the problem, will report in a minute with solution! ",
            "author": "Nikola Tankovic",
            "id": "comment-13431838"
        },
        {
            "date": "2012-08-09T14:31:22+0000",
            "content": "Yup found it.  \n\nThe problem is in the branch Document#getFields() is creating a new List and inside DocMaker in the benchmark module, it is pulling the Fields and clearing them (using clear()).  Since a new List is being created each time, it is the new List that is getting cleared rather than the actual fields.  Hence each iteration just adds more fields without having the previous ones cleared. ",
            "author": "Chris Male",
            "id": "comment-13431839"
        },
        {
            "date": "2012-08-09T14:33:21+0000",
            "content": "Nikola, we should probably move all of Document's methods over to just working with Field (and not IndexableField).  I don't mind if we want to make getFields() return an immutable list but we then need to provide a clear() method so people can reuse Document instances. ",
            "author": "Chris Male",
            "id": "comment-13431841"
        },
        {
            "date": "2012-08-09T14:34:04+0000",
            "content": "Can we not return a new list? I don't think we should just work around the problem in DocMaker.\n\nThis would be a serious sneaky bug to introduce to apps that do this. ",
            "author": "Robert Muir",
            "id": "comment-13431843"
        },
        {
            "date": "2012-08-09T14:35:59+0000",
            "content": "\nI don't mind if we want to make getFields() return an immutable list\n\nThats an ok solution too, so someone would get exception if they do this?\n\nThen they would use Document.clear() or whatever else instead? (we should make sure\nthey can still remove things or whatever, just safely). ",
            "author": "Robert Muir",
            "id": "comment-13431845"
        },
        {
            "date": "2012-08-09T14:38:16+0000",
            "content": "Yes, that is the problem. clear() meathod was clearing not the fields of Document but a copy. Should I go with immutable list, and Document.clear()?\nDocument.getFields().clear() doesn't sound right... ",
            "author": "Nikola Tankovic",
            "id": "comment-13431848"
        },
        {
            "date": "2012-08-09T14:38:50+0000",
            "content": "Yeah we definitely shouldn't return a new list.  I think the immutable list and Document.clear() combo will suffice. ",
            "author": "Chris Male",
            "id": "comment-13431849"
        },
        {
            "date": "2012-08-09T14:40:11+0000",
            "content": "Oh we should also include a unit test that verifies this behaviour. ",
            "author": "Chris Male",
            "id": "comment-13431851"
        },
        {
            "date": "2012-08-09T14:41:17+0000",
            "content": "+1, nobody should have to debug TestQualityRun  ",
            "author": "Robert Muir",
            "id": "comment-13431852"
        },
        {
            "date": "2012-08-09T14:45:05+0000",
            "content": "OK, will do that, and also a Document.clear() test. ",
            "author": "Nikola Tankovic",
            "id": "comment-13431858"
        },
        {
            "date": "2012-08-09T14:50:56+0000",
            "content": "Nikola,\n\nOn a note totally unrelated to the bug, I noticed that StorableField still returns an IndexableFieldType for type().  This lead me to GeneralField.  I don't think we need this.  IndexableField should only need name(), tokenStream() and type().  StorableField needs name(), type() and the various xyzValue() accessors.  Its type() should be a StorableFieldType and some of the functionality from IndexableFieldType should go there.   ",
            "author": "Chris Male",
            "id": "comment-13431867"
        },
        {
            "date": "2012-08-09T14:54:28+0000",
            "content": "I'm sure someone knows a better way to create immutable List than this:\n\n\n \n  public final List<IndexableField> getFields() {\n    IndexableField[] immArray = new IndexableField[fields.size()];\n    int i=0;\n    for (IndexableField field : fields) {\n      immArray[i++] = field;\n    }\n\n    return Arrays.asList(immArray);\n  }\n\n\n\n\nAny pointers? ",
            "author": "Nikola Tankovic",
            "id": "comment-13431874"
        },
        {
            "date": "2012-08-09T14:57:52+0000",
            "content": "\npublic final List<Field> getFields() {\n  return Collections.unmodifiableList(fields);\n}\n\n ",
            "author": "Chris Male",
            "id": "comment-13431880"
        },
        {
            "date": "2012-08-09T15:06:28+0000",
            "content": "Chris,\n\nI tried to go with StorableFieldType but I ended with a whole lot of mess, after this fix I'll try that again and report if I find problems! ",
            "author": "Nikola Tankovic",
            "id": "comment-13431884"
        },
        {
            "date": "2012-08-09T17:44:10+0000",
            "content": "Patch 10: Added Document.clear() method with Unit tests. Fixed all JUnit tests. Everything compiles and all tests pass. ",
            "author": "Nikola Tankovic",
            "id": "comment-13432019"
        },
        {
            "date": "2012-08-09T18:24:22+0000",
            "content": "Branch + current patch looks great!  I just found some minor things:\n\nIndexDocument, Document methods (eg the new clear()), GeneralField\nneed javadocs.\n\nImport statements should be under the copyright header (eg\nStoredDocument.java, StorableField.java, GeneralField.java,\nStoredFieldsWriter.java)?  Silly IDEs... Emacs does this correctly \n\nDocument's add(IndexableField) and add(StorableField) seem dangerous\nbecause they secretly cast to oal.document.Field?  Ie, I cannot use\nDocument to hold my private Storable/IndexableField implementations.\nI think we should remove them, leaving only add(Field)?\n\nI think StoredDocument should be in oal.index not oal.document?  Ie,\nbecause it's something you've retrieved from the IndexReader.  Also,\nit will cause confusion with oal.document.Document which is the\nobvious class you should use to hold all your indexed/stored fields.\n\nWhy does StoredDocument still have removeField/s?  Shouldn't it be\nread-only?  (I feel like a broken record....). ",
            "author": "Michael McCandless",
            "id": "comment-13432041"
        },
        {
            "date": "2012-08-09T18:36:11+0000",
            "content": "I was confused about one thing, Norm.java has a StoredField in the branch.\n\nThis didn't seem intuitive to me, because Norms are an indexing thing.\n\nBut then i looked at it more, it seems Norm just uses this as a \"container\" (implementation detail)\nto hold its \"docvalue\".\n\nCan we add some notes or javadocs about this to this class? I think it would\nprevent future confusion.\n ",
            "author": "Robert Muir",
            "id": "comment-13432049"
        },
        {
            "date": "2012-08-09T21:31:04+0000",
            "content": "Patch 11: Mike's and Robert's comments applied. ",
            "author": "Nikola Tankovic",
            "id": "comment-13432177"
        },
        {
            "date": "2012-08-09T21:37:03+0000",
            "content": "I applied patch to current branch, but it does not compile anymore. ",
            "author": "Uwe Schindler",
            "id": "comment-13432182"
        },
        {
            "date": "2012-08-10T06:02:01+0000",
            "content": "Uwe, \nit seems that my SVN client doesn't mark oal.document.StoredDocument for removal. Wierd... Can you please manually remove this class because it moved to oal.index.StoredDocument? Then everything should be OK. ",
            "author": "Nikola Tankovic",
            "id": "comment-13432599"
        },
        {
            "date": "2012-08-10T10:57:42+0000",
            "content": "Patch 12: Fix of compiler warning. You still need to manually remove oal.document.StoredDocument ",
            "author": "Nikola Tankovic",
            "id": "comment-13432697"
        },
        {
            "date": "2012-08-13T12:11:45+0000",
            "content": "Your patch is also missing the replacement file addition. I tried to do it manually, but i have no patch.\n\nCan you use SVN 1.7.x and use --show-copies-as-adds (this does not work with SVN 1.6)? This simplifies patches a lot! ",
            "author": "Uwe Schindler",
            "id": "comment-13433093"
        },
        {
            "date": "2012-08-13T13:07:24+0000",
            "content": "Patch 12a: Added missing oal.index.StoredDocument. I'm really sorry about that! ",
            "author": "Nikola Tankovic",
            "id": "comment-13433118"
        },
        {
            "date": "2012-08-13T14:06:49+0000",
            "content": "Applied patch to branch in revision 1372427.\n\nNow merging trunk in... ",
            "author": "Uwe Schindler",
            "id": "comment-13433150"
        },
        {
            "date": "2012-08-13T14:19:34+0000",
            "content": "Merged up to trunk revision: 1372438\n\nThere was one conflict in some TermVectors test, but they now pass. ",
            "author": "Uwe Schindler",
            "id": "comment-13433161"
        },
        {
            "date": "2012-08-15T11:13:21+0000",
            "content": "Hi Nikola,\n\nwe should now use the remaining time to do some cleanup and prepare the branch for merging with Lucene trunk. There will be no backport, so this would be the first Lucene 5.x only change, do we all agree with this? I think the change would be too heavy to go into 4.0.\n\nThe final \"pencils down\" date would be monday next week, the evaluations of GSoC until Thursday, noon UTC next week, so we should hurry up. ",
            "author": "Uwe Schindler",
            "id": "comment-13434968"
        },
        {
            "date": "2012-08-15T11:17:03+0000",
            "content": "Is it going to be possible to address IndexableFieldType vs StorableFieldType situation resolved before this lands? I can assist if that would help. ",
            "author": "Chris Male",
            "id": "comment-13434970"
        },
        {
            "date": "2012-08-15T11:24:58+0000",
            "content": "Hi, I merged up to trunk (to get jenkins config changes in): revision 1373337\n\nI also created a Jenkins Job on the Policeman build server: http://jenkins.sd-datasolutions.de/job/lucene3312-branch/\nIt will send mails to Nikola and myself on failures. It would be good to adress them asap. ",
            "author": "Uwe Schindler",
            "id": "comment-13434972"
        },
        {
            "date": "2012-08-15T11:54:16+0000",
            "content": "First build succeeded: http://jenkins.sd-datasolutions.de/job/lucene3312-branch/1/consoleFull ",
            "author": "Uwe Schindler",
            "id": "comment-13434996"
        },
        {
            "date": "2012-08-15T17:27:23+0000",
            "content": "Hi Nikola, the first build was not done using Oracle JDK 6, so Javadocs were not built. The recent one failed, because of invalid Javadocs. Could you send a patch with those corrected? I would recommend to run \"ant javadocs\" or \"ant javadocs-lint) (more thorough) from top-level.\n\nHere the error message (we fail on javadocs warnings): http://jenkins.sd-datasolutions.de/job/lucene3312-branch/3/console ",
            "author": "Uwe Schindler",
            "id": "comment-13435324"
        },
        {
            "date": "2012-08-16T17:30:16+0000",
            "content": "Patch 13: fixed Javadoc warnings. 'ant javadocs' builds successfully. ",
            "author": "Nikola Tankovic",
            "id": "comment-13436134"
        },
        {
            "date": "2012-08-16T17:39:50+0000",
            "content": "OK, applied and committed the patch, rev 1373940. ",
            "author": "Uwe Schindler",
            "id": "comment-13436142"
        },
        {
            "date": "2012-08-17T13:13:22+0000",
            "content": "How should we proceed with this? I think the IndexableFieldType vs StorableFieldType  situation is not yet decided. How should we proceed? We have to stop working next monday and prepare the final GSoC evaluation. ",
            "author": "Uwe Schindler",
            "id": "comment-13436713"
        },
        {
            "date": "2012-08-17T14:26:38+0000",
            "content": "We definitely need to clean up StorableFieldType situation, but I think we can tackle that afterwards.  I think it's best to ensure what we have now works and we're comfortable with the API. ",
            "author": "Chris Male",
            "id": "comment-13436755"
        },
        {
            "date": "2012-08-19T09:36:16+0000",
            "content": "Merged up to trunk revision: 1374718 ",
            "author": "Uwe Schindler",
            "id": "comment-13437489"
        },
        {
            "date": "2012-08-19T20:41:46+0000",
            "content": "Hi Nikola,\nafetr the branch merge, the more picky javadocs checker in Lucene Core found few classes without Javadoc at all. It would be good to add Javadocs for the new StorableField, StorableFieldType, GeneralField,... classes.\n\nAlso please make sure that the ASF License header does not start with /** (which is javadoc), but starts with /* (simple comment). I fixed the ones I found. ",
            "author": "Uwe Schindler",
            "id": "comment-13437575"
        },
        {
            "date": "2012-08-20T14:35:14+0000",
            "content": "Added missing javadoc descriptions, very basic; may need further elaboration. ",
            "author": "Nikola Tankovic",
            "id": "comment-13437900"
        },
        {
            "date": "2012-08-20T14:40:39+0000",
            "content": "Applied patch in revision 1375040. Thanks for fixing. ",
            "author": "Uwe Schindler",
            "id": "comment-13437905"
        },
        {
            "date": "2012-08-25T09:55:40+0000",
            "content": "Hi Nikola,\nthanks for your work on this GSoC project. The Jenkins job seems to pass, we should now work on reintegrating the branch into trunk.\n\nHere my questions to the other committers:\n\n\tApply only to trunk (5.0) - so it has more time to bake? I think this change would be too big for Lucene 4.0 - and too late??\n\tAre there any other things to change? One open point is StorableFieldType.\n\n\n\nI would like to integrate it asap, as it gets out of date quite early. I will do a merge from trunk -> branch to keep up-to-date. ",
            "author": "Uwe Schindler",
            "id": "comment-13441823"
        },
        {
            "date": "2012-08-25T10:07:58+0000",
            "content": "Merged up to trunk rev 1377246. ",
            "author": "Uwe Schindler",
            "id": "comment-13441825"
        },
        {
            "date": "2012-08-25T10:34:49+0000",
            "content": "Apply only to trunk (5.0) - so it has more time to bake? I think this change would be too big for Lucene 4.0 - and too late??\n\n+1 to 5.0 only.  It's another big change to the Document/Field API that we may want to evolve more as it bakes and earlier adopters begin to use it.\n\nAre there any other things to change? One open point is StorableFieldType.\n\nStorableFieldType seems like the only thing at this stage that needs to be addressed. ",
            "author": "Chris Male",
            "id": "comment-13441830"
        },
        {
            "date": "2012-08-25T10:35:51+0000",
            "content": "Attached you will find the \"master patch\" after running \"svn merge --reintegrate\".\n\nNikola: I think you could use this patch to submit the mandatory code submission to Google. It shows what you did the last months on GSoC.\n\nOther committers: Are you fine with this patch (see my comments above)? ",
            "author": "Uwe Schindler",
            "id": "comment-13441831"
        },
        {
            "date": "2012-08-25T10:48:00+0000",
            "content": "I have one comment about the following methods in Document:\n\n\n+  /** Obtains all indexed fields in document */\n+  @Override\n+  public Iterable<? extends IndexableField> indexableFields() {\n+    Iterator<Field> it = indexedFieldsIterator();\n+    \n+    List<IndexableField> result = new ArrayList<IndexableField>();\n+    while(it.hasNext()) {\n+      result.add(it.next());\n+    }\n+    \n+    return result;\n+  }\n+\n+\n+  /** Obtains all stored fields in document. */\n+  @Override\n+  public Iterable<? extends StorableField> storableFields() {\n+    Iterator<Field> it = storedFieldsIterator();\n+    \n+    List<StorableField> result = new ArrayList<StorableField>();\n+    while(it.hasNext()) {\n+      result.add(it.next());\n+    }\n+    \n+    return result;\n+  }\n+\n\n\n\nIn my opinion, this should not copy to an ArrayList, it shoudl simply return a anonymous Iterable<..> wrapping the iterator:\n\n\npublic Iterable<? extends StorableField> storableFields() {\n return new Iterable<? extends StorableField>() {\n  @Override\n  Iterator<? extends StorableField> iterator() {\n    return Document.this.storedFieldsIterator();\n  }\n }\n}\n\n\n\nAlso it may not be needed to have <? extends Foo> a simple <Foo> is enough here (comment from Generics Policman) ",
            "author": "Uwe Schindler",
            "id": "comment-13441834"
        },
        {
            "date": "2012-08-25T10:53:45+0000",
            "content": "+1 ",
            "author": "Chris Male",
            "id": "comment-13441836"
        },
        {
            "date": "2012-08-25T11:06:37+0000",
            "content": "I committed attached patch to branch.\n\nPlease proceed with reviewing the reintegration patch. Once all changes are done, I will reintegrate again and commit! ",
            "author": "Uwe Schindler",
            "id": "comment-13441837"
        },
        {
            "date": "2012-08-30T22:51:39+0000",
            "content": "I merged in the recent changes in trunk (rev. 1379200). Robert Muir added lots of JavaDocs to the document and index package, so we should check that everything is still correct. We should especially review sentences that contain hints to stored documents on IndexableDocument and vice versa. ",
            "author": "Uwe Schindler",
            "id": "comment-13445383"
        },
        {
            "date": "2012-08-30T23:56:53+0000",
            "content": "\n * If you also need to store the value, you should add a\n * separate {@link StoredField} instance.\n ...\n * */\n\npublic class ByteDocValuesField extends StoredField {\n\n\n\nI opened an issue for this already (LUCENE-4331), but here its really confusing since\nall thse DocValuesField themselves extend StoredField. I think we need to figure this out. ",
            "author": "Robert Muir",
            "id": "comment-13445462"
        },
        {
            "date": "2012-08-31T00:09:54+0000",
            "content": "I echo Chris on the confusion of StorableField requires IndexableFieldType (since it extends GeneralField).\n\nTo me storing needs no 'type' information at all: But I guess the problem with that is that we need\nDocValues types since DocValues are \"stored fields\" here.\n\nBut I think this is related to my comment above: I think its confusing that DocValues fields are treated\nas Stored fields at all? \n\nThis basically is the same problem all over again.\n\n\tYou make a Document with N StorableFields\n\tYou call IR.document and get a StorableDocument back, with N-3 StorableFields.\n\tYou wonder: what happened to the other 3 fields?\n\n\n\nThey were DocValues.\n ",
            "author": "Robert Muir",
            "id": "comment-13445481"
        },
        {
            "date": "2012-08-31T00:12:34+0000",
            "content": "and some of my javadocs warnings on DocumentStoredFieldVisitor in trunk, that were removed\nduring merging should be added back here again as long as StorableField still has IndexableFieldType:\n\n\n   * @return Document populated with stored fields. Note that only\n   *         the stored information in the field instances is valid,\n   *         data such as indexing options, term vector options,\n   *         etc is not set.\n\n\n ",
            "author": "Robert Muir",
            "id": "comment-13445484"
        },
        {
            "date": "2012-08-31T00:25:14+0000",
            "content": "By the way, these werent meant to be objections to the issue (just random thoughts while reviewing javadocs). ",
            "author": "Robert Muir",
            "id": "comment-13445503"
        },
        {
            "date": "2012-08-31T05:08:10+0000",
            "content": "and some of my javadocs warnings on DocumentStoredFieldVisitor in trunk,\n\nsorry that was only this one, I did it because at the time of merging the fact that it still implements IndexableField was not in my mind. But this is the same issue like Chris complained about. We should cover that in a second step.\n\nRobert can you commit your javadoc comments back in or should I do it? ",
            "author": "Uwe Schindler",
            "id": "comment-13445669"
        },
        {
            "date": "2012-08-31T11:13:40+0000",
            "content": "I've thought about this a little bit.\n\n\nTo me storing needs no 'type' information at all: But I guess the problem with that is that we need\nDocValues types since DocValues are \"stored fields\" here.\n\nWe've gone back and forwards about this a lot since the Fields cleanup began but it would be nice to actually have the DocValues Types on the StorableField itself rather than on StorableFieldType.  In the end the type is related to the type of the value itself, not disconnected metadata.  Having it this way would also alleviate the need for StorableFieldType and make storing values as simple as possible.\n\n\nThis basically is the same problem all over again.\n\n\tYou make a Document with N StorableFields\n\tYou call IR.document and get a StorableDocument back, with N-3 StorableFields.\n\tYou wonder: what happened to the other 3 fields?\n\n\n\nThey were DocValues.\n\nWhat if they were returned? Because you're absolutely right, it seems odd for DocValues Fields to be StorableFields and then not accessible like all other StorableFields.  So what if we changed how IR.document worked so you could pull DocValues Fields too.  Is that something users might want? ",
            "author": "Chris Male",
            "id": "comment-13445842"
        },
        {
            "date": "2012-08-31T11:38:30+0000",
            "content": "What if they were returned? Because you're absolutely right, it seems odd for DocValues Fields to be StorableFields and then not accessible like all other StorableFields. So what if we changed how IR.document worked so you could pull DocValues Fields too. Is that something users might want?\n\nThis could be a large overhead if e.g. the loading of the whole column would be triggered automatically (depends on configuration). Also, IndexReader.document() is in the basic IndexReader class (because stored fields can always be returned, also for composite readers). DocValues is AtomicReader only... This could of course be managed by BaseCompositeReader to use the subindex function to get the correct document, but it is somehow not the thing docvalues are made for. They are there for using them while scoring, filtering, functions... ",
            "author": "Uwe Schindler",
            "id": "comment-13445852"
        },
        {
            "date": "2012-08-31T11:38:58+0000",
            "content": "This is not really a viable option. its n random seeks to retreive n dv fields for a doc.\n\nThey are not stored fields  ",
            "author": "Robert Muir",
            "id": "comment-13445853"
        },
        {
            "date": "2012-08-31T11:40:29+0000",
            "content": "Yeah right! Every value is a seek. ",
            "author": "Uwe Schindler",
            "id": "comment-13445854"
        },
        {
            "date": "2012-09-02T11:43:48+0000",
            "content": "Hi Nikola,\n\nI am about to reintegrate the branch back o Lucene trunk. We need a new entry for MIGRATE.txt. Can you prepare one, so users of the current Lucene 4.0 API can migrate to the new one? It should give some hints what needs to be changed in the code to make a Lucene 4.0 APP ready for Lucene trunk (5.0)? The migrate.txt is formatted using Markdown syntax, so mostly text-only.\n\nI will in all cases commit the reintragrated branch, but I want to add a short guide about the changes at a later stage. ",
            "author": "Uwe Schindler",
            "id": "comment-13446923"
        },
        {
            "date": "2012-09-02T11:57:18+0000",
            "content": "Attached the reintegration patch. ",
            "author": "Uwe Schindler",
            "id": "comment-13446925"
        },
        {
            "date": "2012-09-02T12:48:06+0000",
            "content": "Hi Uwe, \n\nit would be most helpful if I could see some similar MIGRATE.txt file from previous migrations to see the level of detail, but if it's a hassle I'll probably manage something without it. ",
            "author": "Nikola Tankovic",
            "id": "comment-13446939"
        },
        {
            "date": "2012-09-02T13:32:10+0000",
            "content": "Hi Nikola,\njust download the 4.0-BETA release of Lucene. There is a MIGRATE.txt (and corresponding Markdown-generated HTML in the docs folder): http://lucene.apache.org/core/4_0_0-BETA/index.html -> http://lucene.apache.org/core/4_0_0-BETA/MIGRATE.html, the source code is here: https://svn.apache.org/repos/asf/lucene/dev/branches/branch_4x/lucene/MIGRATE.txt ",
            "author": "Uwe Schindler",
            "id": "comment-13446944"
        },
        {
            "date": "2012-09-02T14:38:30+0000",
            "content": "I merged the branch to trunk, rev 1379982. The branch itsself was deleted after reintegration.\n\nI will now open new issues for the remaining problems. ",
            "author": "Uwe Schindler",
            "id": "comment-13446958"
        },
        {
            "date": "2012-09-02T14:45:53+0000",
            "content": "Thanks Uwe and Nikola! ",
            "author": "Chris Male",
            "id": "comment-13446962"
        },
        {
            "date": "2012-09-02T14:53:56+0000",
            "content": "I opened LUCENE-4347 as container issue for later changes.\n\nNikola, please attach MIGRATE.txt changes to LUCENE-4348, as patches againt Lucene trunk! Thanks.\n\nFinally: My thanks also goes to Nikola and Chris for the work on this issue. I want to also mention Robert and Mike for helpful comments. ",
            "author": "Uwe Schindler",
            "id": "comment-13446966"
        },
        {
            "date": "2012-09-08T03:52:44+0000",
            "content": "Uwe, can you please explain why you changed SpatialStrategy.createIndexableFields to return Field[] instead of IndexableField[]?  As its name suggests and as the javadocs go to some lengths to clarify, createIndexableFields is for indexed data and not storing it.  Field implements StorableField. ",
            "author": "David Smiley",
            "id": "comment-13451238"
        },
        {
            "date": "2012-09-09T11:37:54+0000",
            "content": "s/Uwe/Nikola/; ",
            "author": "Uwe Schindler",
            "id": "comment-13451574"
        },
        {
            "date": "2012-09-09T11:52:26+0000",
            "content": "David, just at a guess I imagine the branch used in this issue was created before we changed createIndexableFields to not handle storing.  To satisfy the conditions at the time (indexing and storing) Nikola changed it to return Field.  Lets just fix it and we'll be fine. ",
            "author": "Chris Male",
            "id": "comment-13451579"
        },
        {
            "date": "2014-12-24T14:00:35+0000",
            "content": "This never landed on branch_5x. Can someone help me understand why? ",
            "author": "Shalin Shekhar Mangar",
            "id": "comment-14258260"
        },
        {
            "date": "2014-12-24T14:43:16+0000",
            "content": "The problem is currently some API problems with DocValues and StoredFields. The current API makes then somehwo the same and Robert and I are not happy with that. Because the features around DocValues should now be stabilized, we can look into this again.\n\nBut to do this, I have to first review what currently in trunk... Maybe a task for post-XMas  ",
            "author": "Uwe Schindler",
            "id": "comment-14258300"
        },
        {
            "date": "2014-12-24T14:48:36+0000",
            "content": "that is the most confusing thing, but there are other confusing things.\n\n\n\twhy does StorableField have a readerValue() method?\n\twhy does StorableField have IndexableFieldType?\n\n\n\nCurrently, i dont understand the benefits of the trunk api. it does not seem to allow any more flexibility than branch_5x, just a ton of abstractions? ",
            "author": "Robert Muir",
            "id": "comment-14258304"
        },
        {
            "date": "2014-12-24T16:03:57+0000",
            "content": "Currently, i dont understand the benefits of the trunk api\n\nThe main advantage is the fact that IndexReader.document() for stored fields does not return something that can be indexed directly using IndexWriter.addDocument(), preventing a common trap of people thinking that they can update a document by first fetching it from index, modifying it and indexing it back.\n\nUnfortunately the current implementation is a bit confusing, but I still want to go that route. ",
            "author": "Uwe Schindler",
            "id": "comment-14258353"
        },
        {
            "date": "2014-12-24T18:38:14+0000",
            "content": "\nThe main advantage is the fact that IndexReader.document() for stored fields does not return something that can be indexed directly using IndexWriter.addDocument(), preventing a common trap of people thinking that they can update a document by first fetching it from index, modifying it and indexing it back.\n\nBut this premise does not work today still, e.g. because docvalues are treated as part of stored fields. so the trap remains.\n\n\nUnfortunately the current implementation is a bit confusing, but I still want to go that route.\n\nAlternatively, we could just do other work to make that workflow work instead? Users want to do it, why not let them? ",
            "author": "Robert Muir",
            "id": "comment-14258432"
        }
    ]
}