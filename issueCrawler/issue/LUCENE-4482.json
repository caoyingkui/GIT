{
    "id": "LUCENE-4482",
    "title": "Likely Zing JVM bug causes failures in TestPayloadNearQuery",
    "details": {
        "components": [],
        "fix_versions": [],
        "affect_versions": "None",
        "priority": "Major",
        "labels": "",
        "type": "Bug",
        "resolution": "Fixed",
        "status": "Resolved"
    },
    "description": "I dug into one of the Lucene test failures when running with Zing JVM\n(available free for open source devs...).  At least one other test\nsometimes fails but I haven't dug into that yet.\n\nI managed to get the failure easily reproduced: with the attached\npatch, on rev 1397735 checkout, if you cd to lucene/core and run:\n\n\n  ant test -Dtests.jvms=1 -Dtests.seed=C3802435F5FB39D0 -Dtests.showSuccess=true\n\n\n\nThen you'll hit several failures in TestPayloadNearQuery, eg:\n\n\nSuite: org.apache.lucene.search.payloads.TestPayloadNearQuery\n  1> FAILED\n  2> NOTE: reproduce with: ant test  -Dtestcase=TestPayloadNearQuery -Dtests.method=test -Dtests.seed=C3802435F5FB39D0 -Dtests.slow=true -Dtests.locale=ga -Dtests.timezone=America/Adak -Dtests.file.encoding=US-ASCII\nERROR   0.01s | TestPayloadNearQuery.test <<<\n   > Throwable #1: java.lang.RuntimeException: overridden idfExplain method in TestPayloadNearQuery.BoostingSimilarity was not called\n   > \tat __randomizedtesting.SeedInfo.seed([C3802435F5FB39D0:4BD41BEF5B075428]:0)\n   > \tat org.apache.lucene.search.similarities.TFIDFSimilarity.computeWeight(TFIDFSimilarity.java:740)\n   > \tat org.apache.lucene.search.spans.SpanWeight.<init>(SpanWeight.java:62)\n   > \tat org.apache.lucene.search.payloads.PayloadNearQuery$PayloadNearSpanWeight.<init>(PayloadNearQuery.java:147)\n   > \tat org.apache.lucene.search.payloads.PayloadNearQuery.createWeight(PayloadNearQuery.java:75)\n   > \tat org.apache.lucene.search.IndexSearcher.createNormalizedWeight(IndexSearcher.java:648)\n   > \tat org.apache.lucene.search.AssertingIndexSearcher.createNormalizedWeight(AssertingIndexSearcher.java:60)\n   > \tat org.apache.lucene.search.IndexSearcher.search(IndexSearcher.java:265)\n   > \tat org.apache.lucene.search.payloads.TestPayloadNearQuery.test(TestPayloadNearQuery.java:146)\n   > \tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n   > \tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)\n   > \tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)\n   > \tat java.lang.reflect.Method.invoke(Method.java:597)\n   > \tat com.carrotsearch.randomizedtesting.RandomizedRunner.invoke(RandomizedRunner.java:1559)\n   > \tat com.carrotsearch.randomizedtesting.RandomizedRunner.access$600(RandomizedRunner.java:79)\n   > \tat com.carrotsearch.randomizedtesting.RandomizedRunner$6.evaluate(RandomizedRunner.java:737)\n   > \tat com.carrotsearch.randomizedtesting.RandomizedRunner$7.evaluate(RandomizedRunner.java:773)\n   > \tat com.carrotsearch.randomizedtesting.RandomizedRunner$8.evaluate(RandomizedRunner.java:787)\n   > \tat org.apache.lucene.util.TestRuleSetupTeardownChained$1.evaluate(TestRuleSetupTeardownChained.java:50)\n   > \tat org.apache.lucene.util.TestRuleFieldCacheSanity$1.evaluate(TestRuleFieldCacheSanity.java:51)\n   > \tat org.apache.lucene.util.AbstractBeforeAfterRule$1.evaluate(AbstractBeforeAfterRule.java:45)\n   > \tat com.carrotsearch.randomizedtesting.rules.SystemPropertiesInvariantRule$1.evaluate(SystemPropertiesInvariantRule.java:55)\n   > \tat org.apache.lucene.util.TestRuleThreadAndTestName$1.evaluate(TestRuleThreadAndTestName.java:48)\n   > \tat org.apache.lucene.util.TestRuleIgnoreAfterMaxFailures$1.evaluate(TestRuleIgnoreAfterMaxFailures.java:70)\n   > \tat org.apache.lucene.util.TestRuleMarkFailure$1.evaluate(TestRuleMarkFailure.java:48)\n   > \tat com.carrotsearch.randomizedtesting.rules.StatementAdapter.evaluate(StatementAdapter.java:36)\n   > \tat com.carrotsearch.randomizedtesting.ThreadLeakControl$StatementRunner.run(ThreadLeakControl.java:358)\n   > \tat com.carrotsearch.randomizedtesting.ThreadLeakControl.forkTimeoutingTask(ThreadLeakControl.java:782)\n   > \tat com.carrotsearch.randomizedtesting.ThreadLeakControl$3.evaluate(ThreadLeakControl.java:442)\n   > \tat com.carrotsearch.randomizedtesting.RandomizedRunner.runSingleTest(RandomizedRunner.java:746)\n   > \tat com.carrotsearch.randomizedtesting.RandomizedRunner$3.evaluate(RandomizedRunner.java:648)\n   > \tat com.carrotsearch.randomizedtesting.RandomizedRunner$4.evaluate(RandomizedRunner.java:682)\n   > \tat com.carrotsearch.randomizedtesting.RandomizedRunner$5.evaluate(RandomizedRunner.java:693)\n   > \tat org.apache.lucene.util.AbstractBeforeAfterRule$1.evaluate(AbstractBeforeAfterRule.java:45)\n   > \tat org.apache.lucene.util.TestRuleStoreClassName$1.evaluate(TestRuleStoreClassName.java:42)\n   > \tat com.carrotsearch.randomizedtesting.rules.SystemPropertiesInvariantRule$1.evaluate(SystemPropertiesInvariantRule.java:55)\n   > \tat com.carrotsearch.randomizedtesting.rules.NoShadowingOrOverridesOnMethodsRule$1.evaluate(NoShadowingOrOverridesOnMethodsRule.java:39)\n   > \tat com.carrotsearch.randomizedtesting.rules.NoShadowingOrOverridesOnMethodsRule$1.evaluate(NoShadowingOrOverridesOnMethodsRule.java:39)\n   > \tat com.carrotsearch.randomizedtesting.rules.StatementAdapter.evaluate(StatementAdapter.java:36)\n   > \tat org.apache.lucene.util.TestRuleAssertionsRequired$1.evaluate(TestRuleAssertionsRequired.java:43)\n   > \tat org.apache.lucene.util.TestRuleMarkFailure$1.evaluate(TestRuleMarkFailure.java:48)\n   > \tat org.apache.lucene.util.TestRuleIgnoreAfterMaxFailures$1.evaluate(TestRuleIgnoreAfterMaxFailures.java:70)\n   > \tat org.apache.lucene.util.TestRuleIgnoreTestSuites$1.evaluate(TestRuleIgnoreTestSuites.java:55)\n   > \tat com.carrotsearch.randomizedtesting.rules.StatementAdapter.evaluate(StatementAdapter.java:36)\n   > \tat com.carrotsearch.randomizedtesting.ThreadLeakControl$StatementRunner.run(ThreadLeakControl.java:358)\n   > \tat java.lang.Thread.run(Thread.java:661)\n\n\n\nThe patch at least isolates the JVM bug even if it's not exactly a\nminimal test   Somehow the idfExplain method, which\nis overridden in this test's BoostingSimilarity, fails to be called\n(the super.idfExplain is called instead), which leads to the test\nfailures.\n\nThe failure does not happen if you run this test in isolation.",
    "attachments": {
        "LUCENE-4482.patch": "https://issues.apache.org/jira/secure/attachment/12548983/LUCENE-4482.patch"
    },
    "issue_links": {},
    "comments": [
        {
            "date": "2012-10-13T09:24:38+0000",
            "content": "\nThe patch at least isolates the JVM bug even if it's not exactly a\nminimal test  Somehow the idfExplain method, which\nis overridden in this test's BoostingSimilarity, fails to be called\n(the super.idfExplain is called instead), which leads to the test\nfailures.\n\nSo it is definitely a JVM and not a Lucene bug! Have you reported it?\n\nI would run Zing tests, too, but before doing that they should:\nNot rely on strange binary kernel modules that are outdated on Ubuntu 12.04.1 LTS. The Jenkins server is running in DMZ so I will never ever run it with outdated kernels. They should (if they really need a kernel module, which is in my opinion a no-go, too) use DKMS and make the kernel module open source, so my kernel is also not tainted. Without that I will not support Zing, sorry. But I doubt if the kernel module is really needed! Without a clear explanation why this is needed on their homepage I don't agree. ",
            "author": "Uwe Schindler",
            "id": "comment-13475566"
        },
        {
            "date": "2012-10-13T15:10:04+0000",
            "content": "\nSo it is definitely a JVM and not a Lucene bug!\n\nI'm pretty sure: the JVM is failing to call the overridden method in a\nsubclass (calling the base class method instead).  No other JVMs fail\nhere, and Zing won't fail if you run the test in isolation ... and it\ndoesn't always fail if you run all tests (ie it seems to depend on the\nseed).\n\nHave you reported it?\n\nWorking on it ... trying to get an account at http://www.azulsystems.com/developers/bugzilla/\n\n\nI would run Zing tests, too, but before doing that they should:\nNot rely on strange binary kernel modules that are outdated on Ubuntu 12.04.1 LTS. The Jenkins server is running in DMZ so I will never ever run it with outdated kernels. They should (if they really need a kernel module, which is in my opinion a no-go, too) use DKMS and make the kernel module open source, so my kernel is also not tainted. Without that I will not support Zing, sorry. But I doubt if the kernel module is really needed! Without a clear explanation why this is needed on their homepage I don't agree.\n\nI agree: it's crazy it only runs as binary module on old kernel\nversions ... they know this is a showstopper (I've complained about\nit several times...) and they're working on it. ",
            "author": "Michael McCandless",
            "id": "comment-13475624"
        },
        {
            "date": "2012-10-13T16:06:13+0000",
            "content": "We're looking into this bug report. Will hopefully report back / resolve it soon. [But Michael, please go ahead and report it on our bugzilla as well per the above].\n\n[Uwe Schindler wrote:]\n> I would run Zing tests, too, but before doing that they should:\n> Not rely on strange binary kernel modules that are outdated on\n> Ubuntu 12.04.1 LTS. The Jenkins server is running in DMZ so I\n> will never ever run it with outdated kernels. They should (if\n> they really need a kernel module, which is in my opinion a no-go,\n> too) use DKMS and make the kernel module open source, so my kernel\n> is also not tainted. Without that I will not support Zing, sorry.\n> But I doubt if the kernel module is really needed! Without a\n> clear explanation why this is needed on their homepage I don't agree.\n\nThis has two parts: One asking/questioning why our loadable module is needed at all, and the other relating to it's availability for various kernels and Linux distros.\n\n1. Why is the ZST (which includes a loadable module) needed for Zing to operate?\n\nOne of Zing JVM's main distinctions is that it's C4 garbage collector (aka GPGC internally) eliminates garbage collection as a response time concern for enterprise applications. Among other things, C4 relies on rapid manipulation of virtual memory and physical memory mappings to maintain continuous operation. While the semantics of the manipulations we do are possible using the vanilla mmap/mremap/munmap/madvise APIs, the rate at which those are supported in Linux (and most other OSs) is extremely low due mostly to the historic, extremely conservative approach to in-process TLB invalidation, and due partly to issues with multiple-page size manipulations. We're not talking small change here. More like 4-6 orders of magnitude for our common operation, which is, right now, the difference between a practical and impractical implementation of C4.\nYou can find a detailed discussion of the difference in metrics for these operations at http://tinyurl.com/34ytcvc, and a detailed discussion of C4 in our ISMM paper (http://tinyurl.com/94c9btb at the ACM site, or at the Azul site http://tinyurl.com/7rydpvo).\n\n2. Loadable Module availability and compatibility\n\nTo be clear our loadable module is open source, under GPLv2, and you can have the sources for it if you wish. The reason for the current choice of packaging is that a wide range of current end-customer's Linux systems do not have (or wish to install) the tooling needed to build or re-build the module, and what they need operationally is an RPM that opens and installs without requiring kernel headers and the like. In addition, we tend to  intensively test and examine the kernel module against specific distros and kernel to verify compatibility and stability, and declare official support for these well tested combinations.\n\nOn other linux distros (RHEL, CentOS, SLES), the kernel revision velocity is fairly slow, and the kernel api signatures tend to remain the same unless semantics are actually modified. As a result, we use a single module RPM of RHEL5 and CentOS 5 versions, and have only needed a single rev of the module packaging during the evolution of RHEL6/CentOS6 and SLES 11 thus far.  \n\nAs we added Zing support for Ubunutu, primarily due to it's popularity with developers, we found that kernel api signatures there change with practically every patch, even with no semantic change. This creates some serious friction with our current loadable module packaging and distribution choice for Ubuntu. We are working to resolve this, either by using DKMS or some other alternative, such that modules can continue to work or be properly updated as kernels rev up in Ubunutu-style distros.\n\nSo we're working on it, and it will get better...\n\n\u2013 Gil. [CTO, Azul Systems] ",
            "author": "Gil Tene",
            "id": "comment-13475643"
        },
        {
            "date": "2012-10-13T16:45:52+0000",
            "content": "Thanks Gil for the explanation,\n\nMaybe it would be a good idea to provide both C4 -> Memory Management layers, so also for plain kernels (as configuration option to the JVM like huge pages in Oracle's). Or is your VM then only as fast as Oracle's?\n\nAs we added Zing support for Ubunutu, primarily due to it's popularity with developers, we found that kernel api signatures there change with practically every patch, even with no semantic change. This creates some serious friction with our current loadable module packaging and distribution choice for Ubuntu. We are working to resolve this, either by using DKMS or some other alternative, such that modules can continue to work or be properly updated as kernels rev up in Ubunutu-style distros.\n\nVirtualBOX has similar requirements and uses DKMS. They ship with a deb package that contains the source code of their kernel module. It is rebuild on every kernel installation automatically. DKMS itsself depends on compiler and suggests kernel headers, so you only need to depend on \"dkms\" package and \"linux-headers\" and almost nothing more. The Jenkins Server als runs Windows in a virtual machine, and therefore uses their kernel module, too. As VirtualBOX's module has similar use-cases like yours for virtualization, I hope yours does not conflict with that one.\n\nBy the way, Ubuntu LTS is also very popular on servers! ",
            "author": "Uwe Schindler",
            "id": "comment-13475658"
        },
        {
            "date": "2012-10-13T17:19:14+0000",
            "content": "\nMaybe it would be a good idea to provide both C4 -> Memory Management layers, so also for plain kernels (as configuration option to the JVM like huge pages in Oracle's). Or is your VM then only as fast as Oracle's?\n\nIt's not so much a matter of speed as it is a matter of pause time. Zing is not faster than Oracle's JVM, it's just as fast but without those pesky pauses. It's those pauses that keep people from using anything more than a tiny amount of memory in Java these days (to me \"tiny\" means \"a small fraction of a commodity, $4K server\"). With the ability to practically (i.e. without completely stopping for many seconds at a time once is a while) use the nice, cheap memory we now have in servers comes another form of speed - the kind that comes from not repeating work, or from not having to leave the process to look something up.\n\nA 4 to 6 order of magnitude difference in pause time and in sustainable allocation rate is so big that a C4 that uses the vanilla memory management api would be unusable at this point. Think of the difference between a 20usec phase shift and a 20 second pause...\n\n\n...As VirtualBOX's module has similar use-cases like yours for virtualization, I hope yours does not conflict with that one.\n\nWe don't test on VirtualBOX, so I don't know for sure. In general, Zing works fine when run on top of hypervisors that fully support things like 2MB page mappings (the same sort of support needed for hugetlb feature to work). Unfortunately, there are some hypervisors out there (e.g.  some versions of Xen for paravirt guests) that don't support that, and will crash a vanilla linux kernel trying to use hugetlb. Zing won't work in such cases either, and for the same reasons... ",
            "author": "Gil Tene",
            "id": "comment-13475666"
        },
        {
            "date": "2012-10-13T17:40:47+0000",
            "content": "We don't test on VirtualBOX, so I don't know for sure. In general, Zing works fine when run on top of hypervisors that fully support things like 2MB page mappings (the same sort of support needed for hugetlb feature to work). Unfortunately, there are some hypervisors out there (e.g. some versions of Xen for paravirt guests) that don't support that, and will crash a vanilla linux kernel trying to use hugetlb. Zing won't work in such cases either, and for the same reasons...\n\nIn our/my case, the VM is not running inside a guest OS, but in parallel to a hypervisor (running windows) using the same linux kernel. The question was if the 2 modules may conflict to each other. But I could also imagine to use Zing inside a virtual machine on one of my servers using Lucene (once the bugs are fixed).\n\nA 4 to 6 order of magnitude difference in pause time and in sustainable allocation rate is so big that a C4 that uses the vanilla memory management api would be unusable at this point. Think of the difference between a 20usec phase shift and a 20 second pause...\n\nHave you thought about making this kernel module available to the kernel developers for other potential use cases (like virtual machines) also needing to re-allocate lots of RAM and influence paging/unmapping/mapping?\n\nI did not find the GPL source code of your kernel module only the binary downloads. Where can I get it. It's easy to hook it's build into DKMS (if its a standard Makefile, see https://help.ubuntu.com/community/DKMS) without any custom debian package. ",
            "author": "Uwe Schindler",
            "id": "comment-13475671"
        },
        {
            "date": "2012-10-14T11:12:10+0000",
            "content": "OK it turns out the issue tracker is at http://www.azulsystems.com/developers/mantis ... I got an account and opened this issue for Zing: http://www.azulsystems.com/developers/mantis/view.php?id=9 ",
            "author": "Michael McCandless",
            "id": "comment-13475821"
        },
        {
            "date": "2012-11-07T21:02:15+0000",
            "content": "The new Zing 5.5 release looks to have fixed this issue!  I can now pass all Lucene/Solr tests with Zing ... at lest two times  ",
            "author": "Michael McCandless",
            "id": "comment-13492692"
        }
    ]
}