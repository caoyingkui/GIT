{
    "id": "SOLR-8907",
    "title": "add features to MiniSolrCloudCluster to make shard/leader/replica placement more reproducible",
    "details": {
        "components": [],
        "type": "Improvement",
        "labels": "",
        "fix_versions": [],
        "affect_versions": "None",
        "status": "Open",
        "resolution": "Unresolved",
        "priority": "Major"
    },
    "description": "I think MiniSolrCloudCluster would be greatly improved if (by default) collections created for test purposes had predictable shard/leader/core assignment across the jetty instances that are spun up.  Even though the port#s used by the jettys will obviously vary every time a test is run, ideally a given seed should ensure that the following are all consistent:\n\n\n\tthe node_name used by each JettySolrRunner\n\twhich nodes host which shards\n\tthe core names use on each jetty instance\n\twhich core is the leader for each shard\n\n\n\nObviously this wouldn't make sense for tests where the entire purpose is to ensure that the automatic assignment of these things works properly when creating a collection, or when explicitly testing things like \"preferedLeader\", but for tests of non-collection API related features (ie: update requests, search requests, sorting, etc...) where the test setup already takes advantage of methods like MiniSolrCloudCluster.createCollection(...) as a short cut to using the API directly, this type of consistency would make potential test failures a lot more reproducible && easier to diagnose.",
    "attachments": {},
    "issue_links": {},
    "comments": [
        {
            "date": "2016-03-25T22:22:26+0000",
            "author": "Hoss Man",
            "content": "\nThe motivation for creating this issue came out of a situation i noticed while working on SOLR-445.\n\nThe goal was to test that updates were working reliably regardless of if what node they were routed to.\n\nThe test, in a nutshell, looked like this...\n\n\n// tests setup...\ncluster.createCollection(...);\nCLOUD_CLIENT = cluster.getSolrClient();\nNODE_CLIENTS = new ArrayList<SolrClient>(numServers);\nfor (JettySolrRunner jetty : cluster.getJettySolrRunners()) {\n  URL jettyURL = jetty.getBaseUrl();\n  NODE_CLIENTS.add(new HttpSolrClient(jettyURL.toString() + \"/\" + COLLECTION_NAME + \"/\"));\n}\n\n\n// in a loop...\nSolrRequest req = makeRandomUpdateRequest(random());\nSolrClient client = random().nextBoolean() ? CLOUD_CLIENT\n   : NODE_CLIENTS.get(TestUtil.nextInt(random(), 0, NODE_CLIENTS.size()-1));\n}\nassertSomeStuffAboutResponse(req.process(client));\n\n\n\nThere was a bug in the code such that in some specific situations (based on the output of makeRandomUpdateRequest(...)) updates meeting certain criteria would fail unless they were sent to the leader of a particular shard (particular because it was the leader for all the Ids generated by makeRandomUpdateRequest(...) in that particular loop iteration)\n\nThis meant that there were particular seeds that most of the time would reliably reproduce, but roughly every 1 / numServer number of attempts, the leader for the particular shard in question would randomly be assigned to the jetty instance whose httpSolrClient was randomly (but consistently for this seed) being selected at this point.\n\nThat made the test far more confusing to try and debug then if the leaders for the shards were being consistently assigned to the same jetty nodes (relative to their ordering in the list returned by cluster.getJettySolrRunners()) ... like how older, pre-cloud, distributed update tests use to work.\n\nIn short: given a fixed seed, the test code was doing everything in it's power to be 100% consistent w/ the requests it generated and the jetty nodes those requests were sent to \u2013 but the test still wasn't very reproducible because of the shard & leader assignments were random.\n\n\n\nI suspect that the best way to try and implement something like this would be to use rule based replica placement feature \u2013 perhaps with a special \"Snitch\" designed for use in MiniSolrCloudCluster tests? ... But i'm not really sure how it would work because i don't really understand how to use / extend that feature.\n\n\nSo assuming for the sake of argument that it's not possible using the rule based placement stuff, here's a description of the approach that initially ocured to me to serve as a straw man for discussion...\n\n\n\tIf it's not already, MiniSolrCloudCluster should ensure every Jetty instance is started up with a consistent node name (sequentially numbered or whatever)\n\tIf it's not already, MiniSolrCloudCluster.getJettySolrRunners() should return the jetty instances in a consistently sorted order (based on something like node name \u2013 not something non-deterministic like the port#, or order that they started up)\n\tMiniSolrCloudCluster.createCollection(...) (or some new method with a similar signature) should be changed to more explicitly do a lot of work currently done implicitly by the CREATE API call...\n\t\n\t\tuse the shards param to provide explicitly generated names for every shard\n\t\tuse the createNodeSet=EMPTY param\n\t\tOnce the collection is created (w/o any replicas)...\n\t\t\n\t\t\tADDREPLICA and ADDREPLICAPROP should be used explicitly to create a preferedLeader for each (named) shard and assign it to a predictably chosen node (by name).\n\t\t\tAdditional ADDREPLICA calls should then be made as needed to add the expected number of replicas for each shard on predictably chosen {{node}}s (by name).\n\t\t\n\t\t\n\t\n\t\n\tMiniSolrCloudCluster could then support some new convenience methods for tests to use:\n\t\n\t\tThings like...\n\t\t\n\t\t\tList<HttpSolrClient> getClientsForAllReplicas(String collectionName)\n\t\t\tList<HttpSolrClient> getClientsForShard(String collectionName, String shardName)\n\t\t\tSortedMap<String,HttpSolrClient> getClientsForLeaders(String collectionName) // keyed by shardName\n\t\t\tHttpSolrClient getClientForLeader(String collectionName, String shardName)\n\t\t\n\t\t\n\t\tThese methods should do a \"live\" lookup of the data current in ZK, so that even if a test shuts down nodes, or adds replicas, or triggers some bit of chaos they can still subsequently lookup a useful SolrClient to test some action with\n\t\tObviously these methods should return all clients in a consistent order (ie: sort by core node name)\n\t\t(See TestTolerantUpdateProcessorCloud.createMiniSolrCloudCluster() for some sample code of building up SolrClients targeting shard leaders)\n\t\n\t\n\n\n\n\n\n...what do folks think?\n\nis this possible/easy using a custom \"snitch\" ? ",
            "id": "comment-15212498"
        }
    ]
}