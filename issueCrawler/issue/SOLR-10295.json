{
    "id": "SOLR-10295",
    "title": "Decide online location for Ref Guide HTML pages",
    "details": {
        "labels": "",
        "priority": "Major",
        "components": [
            "documentation"
        ],
        "type": "Sub-task",
        "fix_versions": [],
        "affect_versions": "None",
        "resolution": "Fixed",
        "status": "Resolved"
    },
    "description": "One of the biggest decisions we need to make is where to put the new Solr Ref Guide. Confluence at least had the whole web-hosting bits figured out; we have to figure that out on our own.\n\nAn obvious (maybe only to me) choice is to integrate the Ref Guide with the Solr Website. However, due to the size of the Solr Ref Guide (nearly 200 pages), I believe trying to publish it solely with existing CMS tools will create problems similar to those described in the Lucene ReleaseTodo when it comes to publishing the Lucene/Solr javadocs (see https://wiki.apache.org/lucene-java/ReleaseTodo#Website_.2B-.3D_javadocs).\n\nA solution exists already, and it's what is done for the javadocs. From the above link:\n\n\nThe solution: skip committing javadocs to the source tree, then staging, then publishing, and instead commit javadocs directly to the production tree. Ordinarily this would be problematic, because the CMS wants to keep the production tree in sync with the staging tree, so anything it finds in the production tree that's not in the staging tree gets nuked. However, the CMS has a built-in mechanism to allow exceptions to the keep-production-in-sync-with-staging rule: extpaths.txt.\n\nThis solution (for those who don't know already) is to provide a static text file (extpaths.txt) that includes the javadoc paths that should be presented in production, but which won't exist in CMS staging environments. This way, we can publish HTML files directly to production and they will be preserved when the staging-production trees are synced.\n\nThe rest of the process would be quite similar to what is documented in the ReleaseTodo in sections following the link above - use SVN to update the CMS production site and update extpaths.txt properly. We'd do this in the solr section of the CMS obviously, and not the lucene section.\n\nA drawback to this approach is that we won't have a staging area to view the Guide before publication. Files would be generated and go to production directly. We may want to put a process in place to give some additional confidence that things look right first (someone's people.apache.org directory? a pre-pub validation script that tests...something...?), and agree on what we'd be voting on when a vote to release comes up. However, the CMS is pretty much the only option that I can think of...other ideas are welcome if they might work.\n\nWe also need to agree on URL paths that make sense, considering we'll have a new \"site\" for each major release - something like http://lucene.apache.org/solr/ref-guide/6_1 might work? Other thoughts are welcome on this point also.",
    "attachments": {},
    "issue_links": {},
    "comments": [
        {
            "date": "2017-03-17T00:36:31+0000",
            "content": "How often would updates be published with these processes? Javadoc we publish once per version. But the guide currently is \"live\". ",
            "author": "Alexandre Rafalovitch",
            "id": "comment-15929240"
        },
        {
            "date": "2017-03-17T15:23:42+0000",
            "content": "How often would updates be published with these processes?\n\nYeah, that's a very good question. \n\nI think we want the flexibility to update the online version as often as we need to - some things are just wrong sometimes and need to be fixed quickly to prevent further confusion. A related question would be how many online versions we re-publish if, for example, something's been wrong for a number of releases. And related to that is the approval process for republishing - do we vote every time? A separate vote for every re-publish of every version? Seems we could be voting every day on something. ",
            "author": "Cassandra Targett",
            "id": "comment-15930127"
        },
        {
            "date": "2017-03-17T15:39:50+0000",
            "content": "If this is all mirrored on GitHub, can we use one of the Continuous Integration pipelines to make the static output visible somewhere? Then, the latest changes are all built automatically.\n\nI don't think we should be voting any more frequently than we do now.  ",
            "author": "Alexandre Rafalovitch",
            "id": "comment-15930153"
        },
        {
            "date": "2017-03-17T15:47:26+0000",
            "content": "If this is all mirrored on GitHub, can we use one of the Continuous Integration pipelines to make the static output visible somewhere?\n\nWhere? Do you mean like Github Pages? \"Somewhere\" sounds nice, but we need to think it all the way through to where it actually lives - the actual server it lives on, how it's served, etc. ",
            "author": "Cassandra Targett",
            "id": "comment-15930185"
        },
        {
            "date": "2017-03-17T15:51:03+0000",
            "content": "https://www.netlify.com/open-source/ ? Just as one of the options, I am sure.\n ",
            "author": "Alexandre Rafalovitch",
            "id": "comment-15930197"
        },
        {
            "date": "2017-03-17T18:09:09+0000",
            "content": "https://www.netlify.com/open-source/ ?\n\nSo, there are about 7 different projects on that page. It's difficult at first glance to tell what you are proposing. \n\nThe thing to keep in mind is that GitHub is a mirror of the ASF Git repository, not the actual repository. How often is it synced? It has in the past gotten out of sync, sometimes really out of sync, and I'm not sure that issue is 100% resolved. I think relying on GitHub could be risky but perhaps you have more details on the current situation. \n\nEven if the GH mirror was synced within an acceptable and reliable period of time, there is a rule about making sure that release artifacts - which this will be - are only built on hardware controlled by the committer. If what you are proposing violates that, it will be a non-starter. But, before I just shoot it down, perhaps you can spend a little time to lay out the details of a workflow you think is preferable. ",
            "author": "Cassandra Targett",
            "id": "comment-15930400"
        },
        {
            "date": "2017-03-17T18:26:48+0000",
            "content": "Sorry it was confusing. I was referring actually to the text right in the black header: \"Netlify is home to many open-source projects and we support them by giving our $49 pro plan to OS projects free of charge\" which is their hosting solution for the static-built websites, including build pipeline, CDN, SSL certificate, etc. https://www.netlify.com/features/\n\nI don't have any additional information about Github sync issues and definitely no visibility into INFRA issues.\n\nThe release artifacts rule I was not aware of. But I thought we were talking about the live version of the document, not necessarily the final verified build. Perhaps the final build is done as usual but if we just want to have a public end-point for ongoing output, then it is not that different from accessing it via GitHub mirror. \n\nActually, rereading the whole thread, In my mind, I was answering the question about how to make the manual built/visible at least as often as it is now. But maybe that is not the important part of this issue. Maybe the \"this is for unreleased version of the Solr\" is actually a bug not a feature and public does not need to see the latest commits live.\n ",
            "author": "Alexandre Rafalovitch",
            "id": "comment-15930432"
        },
        {
            "date": "2017-03-17T19:12:47+0000",
            "content": "We should define \"release\" probably.\n\nToday we have an online version which is always marked as for the next release. This is because we have to be able to edit content somewhere - there is no realistic offline editing in Confluence - and we don't have the ability to version it online either. So we have one live document that needs to serve as the staging area for updates to the Guide for an upcoming version. Because of this, the Official Ref Guide is the PDF version because it's the only thing we can \"bless\" as being accurate for a particular Solr version. The PDF is the release.\n\nThis whole scenario changes now. We have the ability to edit the content without it impacting what users see online. We can do this in branches or on master or wherever. What users see online now has to be specifically built & published because we can edit content all day without it changing what users see anywhere. In my mind, I now consider the online version a release. There will be two \"artifacts\", as it were, instead of just one - an HTML format and a PDF format (and maybe later an EPUB version or whatever other format people would like to see).\n\nI don't think you were misunderstanding the issue, there are multiple questions here:\n\n\tWhere does the online version live?\n\tWhat are the steps between running ant build and having a live site?\n\tWhat is the approval process for releasing?\n\tWhat do we do if there are changes needed between releases?\n\tIf we re-publish, do we also re-publish the PDF (and other formats)?\n\n\n\nI didn't list all these in my original description, but they are all related, so it makes sense to try to resolve them here. ",
            "author": "Cassandra Targett",
            "id": "comment-15930541"
        },
        {
            "date": "2017-03-18T00:29:40+0000",
            "content": "Here's my dream scenario\n\nDefine only the PDF as the official guide release. The versioned online HTML-format guides are convenience versions, not officially signed etc. That gives us great freedom for how and where to place HTML versions, also without need for formal voting.\n\nI would fully automate the build and publishing of the various versions of the HTML ref-guide though a new bot. The bot would watch git commits, build the HTML guide and publish it.\n\nI think http://lucene.apache.org/solr/guide/ would be a great landing page for the guide. It would be a page highlighting the latest official released guide, as well as linking to historic versions and also, less prominently, unreleased versions, such as master, branch_6x, branch_6_4 etc. This landing page could even be an SPA with auto generated links based on info we already have in DOAP and git. So we would have\n\n\nhttp://lucene.apache.org/solr/guide/ (main landing page)\nhttp://lucene.apache.org/solr/guide/6_5/ (built from branch_6_5, this way we can release bugfixes simply by committing to the branch)\nhttp://lucene.apache.org/solr/guide/branch_6x/ (build from branch_6x, next feature version to be released)\nhttp://lucene.apache.org/solr/guide/master/ (build from master, next major version to be released)\nhttp://lucene.apache.org/solr/guide/7_0/ (the permlink for Solr7 once it is released)\n...\n\n\n\nSo the bot (some script we write but Infra hosts) will \n\n\tmonitor every lucene-solr git commit\n\tif branch in not master, or a release branch, or if commit does not modify refguide, then exit\n\tcheckout the branch\n\tbuild ref-guide using ant, jekyll etc\n\tpublish the resulting guide to the website under correct sub folder (see above).\n\t\n\t\tAlternatively, publish to some other place such as www.solr-guide.com or wherever we want really.\n\t\n\t\n\tif JIRA issue mentioned in commit message, also add a comment to the JIRA issue with a link to the newly built version of the guide.\n\t\n\t\tCould even generate a list of deep-links to the individual guide pages changed by the commit, for easier review.\n\t\n\t\n\tif the build of the refguide fails, then post to the JIRA issue a relevant error message\n\n\n\nThe online, semi-live versioned copies of the guide should include a JS which alerts the user if he is looking at an old version of the guide or an unreleased version. In such a warning note, we could provide a link to current version and a dropdown to switch between all existing versions.\n\nPerhaps we could learn some tricks from other Apache projects already using Asciidoc as well? ",
            "author": "Jan H\u00f8ydahl",
            "id": "comment-15930934"
        },
        {
            "date": "2017-03-18T15:33:31+0000",
            "content": "Maybe the \"this is for unreleased version of the Solr\" is actually a bug not a feature and public does not need to see the latest commits live.\n\n+1.  \n\nI think there are two desirable functions here: 1) Committers should be able to preview formatted docs ASAP after commits without having to build them for every doc change; and 2) Release candidate voters should be able to review the ref guide release in all its forms (PDF and HTML currently) as part of the voting process.\n\nFor 1), Jenkins should work, I think, maybe by just adding a build step to the Solr Artifacts Jenkins jobs, which run roughly daily?: https://builds.apache.org/job/Solr-Artifacts-6.x/ and https://builds.apache.org/job/Solr-Artifacts-master/.\n\nCassandra wrote RE 2):\n\n[W]e won't have a staging area to view the Guide before publication. [...] We may want to put a process in place to give some additional confidence that things look right first [...], and agree on what we'd be voting on when a vote to release comes up. However, the CMS is pretty much the only option that I can think of...other ideas are welcome if they might work.\n\nMaybe we could leverage 1)'s output and bless a particular Jenkins Solr Artifacts job's output (against the release branch of course) as the thing to be voted on?  Then the release process would just copy those from Jenkins to wherever the downloadable/viewable release will live. ",
            "author": "Steve Rowe",
            "id": "comment-15931248"
        },
        {
            "date": "2017-03-18T15:37:09+0000",
            "content": "Maybe we could leverage 1)'s output and bless a particular Jenkins Solr Artifacts job's output (against the release branch of course) as the thing to be voted on? Then the release process would just copy those from Jenkins to wherever the downloadable/viewable release will live.\n\nDuh, this would violate the requirement to build release artifacts on local hardware  : http://www.apache.org/legal/release-policy.html#owned-controlled-hardware.  So that won't work. ",
            "author": "Steve Rowe",
            "id": "comment-15931251"
        },
        {
            "date": "2017-03-18T16:05:14+0000",
            "content": "Define only the PDF as the official guide release. The versioned online HTML-format guides are convenience versions, not officially signed etc. That gives us great freedom for how and where to place HTML versions, also without need for formal voting.\n\nI like this plan.  Official releases are in a format that's resistant to change, contained in a single file with an easily verified signature.  If we retroactively discover that there's a big enough problem with a versioned PDF that we need to fix it, we can vote on a replacement release, which I think would be how X.Y.1 releases of the ref guide might become a reality.  For bugfix binary releases, we generally avoid making changes that would require a documentation update.\n\nRef guide releases (especially those beyond X.Y.0) could be completely independent of similarly numbered reference guide releases.  Separate releases is likely to require separate tags that actually contain something like \"refguide\" in the name, but I believe git makes those really cheap.  Of course we would TRY to only release X.Y.0 reference guides, from the exact same tag as the binary.  Always synchronizing point releases with ref guide releases of the same version number would open the door to including more substantial changes in a point release, which I think we probably don't want.\n\nIf online HTML versions of the guide are NOT official release product, I think Jan's right.  We should be able to rebuild them as necessary, by any mechanism, without a vote. ",
            "author": "Shawn Heisey",
            "id": "comment-15931258"
        },
        {
            "date": "2017-04-05T22:21:43+0000",
            "content": "There are some really good ideas here. \n\nLet's start with what seems we have broad agreement on. Please let me know if I have misrepresented anything here:\n\n\n\tPDF version remains the \"official\" released Ref Guide.\n\t\n\t\tThis is a release artifact, and is voted on before release, which will operate mostly the same as it does today. We vote, it is uploaded to mirrors, the release is formally announced, etc.\n\t\tCurrently this still uses Subversion...we can take that up in a separate issue.\n\t\n\t\n\tHTML (online) version is considered a \"convenience\" version, and it will exist in multiple versions online\n\t\n\t\tOnline versions correspond to a release, any pending releases, and master\n\t\tDoesn't require a vote to publish, can be updated with some degree of frequency\n\t\n\t\n\n\n\nThen we have an idea that we need to think through a little bit more:\n\nI would fully automate the build and publishing of the various versions of the HTML ref-guide though a new bot\n\nI like the general outlines of this idea. A few things to mention:\n\n\n\tCurrently the HTML build has a few dependencies that must be installed locally on the build machine (Jekyll is one, which has dependencies on JRuby and some other stuff). I don't know how open INFRA would be to that being on their machines, we'd have to check.\n\tI'm not sure of the efficacy of building for every commit. I believe this is trying to address the issue of committers being able to see their changes? I like the idea of putting a comment in the related JIRA issue to the newly built version of the guide, but wonder how useful it will be in practice (and thus if it's worth building). I also wonder about publishing a new version for every change - I wonder if that will make the docs in a constant state of flux? We know from experience that users will more likely use the online version, so we want some degree of stability there, even if it's not really the \"official\" version. One thing that might mitigate that is publishing only pages which have changed - our build scripts don't handle this at all today, we'd have to rethink that some.\n\tWe can add to the top navigation bar some text that changes depending on the version being reviewed. There are multiple ways we can do this - if/then statements in the Liquid template, Javascript, etc.\n\n\n\nWhile I like this idea and would like to implement it (or some variant of it), I wonder if it might be more effective in order to make progress for us to split this specific idea into a separate issue to tackle it. We can have an easy publication process today - someone builds it on their local machine and puts it somewhere. It's the \"where\" part of that somewhere that we need to get resolved. If we split this off, we can work on it in conjunction with the other issues that remain unresolved, such as the actual work of the conversion, but still be able to cut over to the new approach and add automation shortly thereafter.\n\nAnyone have an alternative to my idea of using the CMS to host the docs the same way the Javadocs are hosted? (Note, we need to use an apache.org server or the comments will not appear...We could check with INFRA about that, but it seems it should be apache.org hosted so it can really be considered something quasi-official.) ",
            "author": "Cassandra Targett",
            "id": "comment-15957908"
        },
        {
            "date": "2017-04-06T14:41:29+0000",
            "content": "\n2. HTML (online) version is considered a \"convenience\" version, and it will exist in multiple versions online\n\n\tOnline versions correspond to a release, any pending releases, and master\n\tDoesn't require a vote to publish, can be updated with some degree of frequency\n\n\n\nAs I mentioned in a previous comment, non-release publishing (currently for master and branch_6x) could be handled by Jenkins, but your summary above doesn't refer to this as a possibility - are you ruling it out?\n\nCurrently the HTML build has a few dependencies that must be installed locally on the build machine (Jekyll is one, which has dependencies on JRuby and some other stuff). I don't know how open INFRA would be to that being on their machines, we'd have to check.\n\nFor non-release publishing, if we go with Jenkins, the lucene build machine already has some custom stuff installed, so we have precedent in our favor there. ",
            "author": "Steve Rowe",
            "id": "comment-15959020"
        },
        {
            "date": "2017-04-06T16:07:19+0000",
            "content": "As I mentioned in a previous comment, non-release publishing (currently for master and branch_6x) could be handled by Jenkins, but your summary above doesn't refer to this as a possibility - are you ruling it out?\n\nNo, not ruling it out necessarily. I wanted to reply to Jan's idea in some depth and building on Jenkins is related to that. But, Jenkins, sure, IMO. If it's not an official release, there's no problem there.\n\nBut, again, the actual server that runs ant build-site is not the critical part of the question in order to make progress. We still need to figure out where the artifacts created by <insert server name> will ultimately be served from. ",
            "author": "Cassandra Targett",
            "id": "comment-15959192"
        },
        {
            "date": "2017-04-06T16:20:11+0000",
            "content": "But, again, the actual server that runs ant build-site is not the critical part of the question in order to make progress. We still need to figure out where the artifacts created by <insert server name> will ultimately be served from.\n\nIMO non-release publication can be handled by Jenkins, and nothing else needs to be done: the output from each Solr-Artifacts-* job has a stable URL, e.g. for master: https://builds.apache.org/job/Solr-Artifacts-master/lastSuccessfulBuild/artifact/.  I think comments could be hosted in this scenario, but I'm not 100% sure.\n\nI agree for release publication, we need a hosting server and a process to get the convenience format(s) from the build server to the hosting server.  +1 for the CMS as hosting server.  The publication process could be to download builds.apache.org/job/Solr-Artifacts-<release>/lastSuccessfulBuild/artifact/*zip*/archive.zip, unpack it in a CMS checkout, then svn add/commit. ",
            "author": "Steve Rowe",
            "id": "comment-15959220"
        },
        {
            "date": "2017-04-06T16:38:49+0000",
            "content": "Thinking more about using Jenkins as the convenience format(s) build location, as well as hosting location for non-release builds: it may make more sense to have dedicated jobs for this purpose rather than piggy-backing on the existing Solr-Artifacts-* jobs.  In particular, Jenkins jobs can poll git on a regular interval and build only if there are changes.  Apparently there is a new Jenkins plugin deployed on ASF Jenkins that minimizes the delay between commit and triggering a Jenkins job - I haven't investigated yet: https://blogs.apache.org/infra/entry/bringing-gitpubsub-to-the-apache ",
            "author": "Steve Rowe",
            "id": "comment-15959247"
        },
        {
            "date": "2017-04-07T12:04:57+0000",
            "content": "The GitPubSub sounds very attractive, if that means we can have a lightweight job in Jenkins that only builds the refGuide on each commit.\n\nI also wonder about publishing a new version for every change - I wonder if that will make the docs in a constant state of flux? We know from experience that users will more likely use the online version, so we want some degree of stability there, even if it's not really the \"official\" version.\n\nMost commits would be master or branch_6x and trigger a refGuide build of unreleased next-ver docs, no problem with flux there.\nAny asciidoc commits on release-branches (e.g. branch_6_5) would be few and minor, so should not create much flux either.\nThe default version of the refGude hosted on http://lucene.apache.org/solr/guide/ should be the one for latest stable, and then users can choose to view for earlier branches as well as the unstable.\n\nI think we should attempt to have all versions of the guide in the same place. Alternatively, I guess it would be fine if the master/branch_6x versions were either linked or redirected from the CMS /solr/guide to the location in Jenkins... ",
            "author": "Jan H\u00f8ydahl",
            "id": "comment-15960664"
        },
        {
            "date": "2017-04-07T13:33:18+0000",
            "content": "The GitPubSub sounds very attractive, if that means we can have a lightweight job in Jenkins that only builds the refGuide on each commit.\n\nIf we want (near-)immediate builds triggered by commits, we'll have to use a different Jenkins machine than the lucene VM, because it has only one executor; if I understand Jenkins' model correctly, currently running jobs (and queued jobs too, I think) will take precedence over newly triggered jobs.\n\nI think we should attempt to have all versions of the guide in the same place. Alternatively, I guess it would be fine if the master/branch_6x versions were either linked or redirected from the CMS /solr/guide to the location in Jenkins...\n\nOnce we have a stable released online ref guide, I don't think we should be referring regular users to dev versions of the online ref guide; for contributors and committers, sure, e.g. from the HowToContribute wiki page. ",
            "author": "Steve Rowe",
            "id": "comment-15960798"
        },
        {
            "date": "2017-04-21T19:17:17+0000",
            "content": "Most commits would be master or branch_6x and trigger a refGuide build of unreleased next-ver docs, no problem with flux there. Any asciidoc commits on release-branches (e.g. branch_6_5) would be few and minor, so should not create much flux either.\n\nYeah, these are good points. I won't worry about flux then.\n\nIf we want (near-)immediate builds triggered by commits, we'll have to use a different Jenkins machine than the lucene VM, because it has only one executor; if I understand Jenkins' model correctly, currently running jobs (and queued jobs too, I think) will take precedence over newly triggered jobs.\n\nThat's my understanding of the model also. Any job running tests shouldn't be stopped for docs anyway. But it seems to me that VM is always doing something. Looking at the load statistics for the lucene VM for the past couple of weeks, the queue length is always between 10-15 jobs...it could be a really long time before the docs are built.\n\nI guess one of us should talk to INFRA about what our options might be here. ",
            "author": "Cassandra Targett",
            "id": "comment-15979241"
        },
        {
            "date": "2017-04-21T19:34:46+0000",
            "content": "I guess one of us should talk to INFRA about what our options might be here.\n\nI see on this INFRA wiki doc page that there are currently two Jenkins nodes (H19 and H20) that are intended to be used for website publishing: https://cwiki.apache.org/confluence/display/INFRA/Jenkins+node+labels\n\nNodes that are reserved for ANY project that wants to build their website docs and publish directly live (requires asf-site and gitpubsub. See Docs here)\n\nThe Docs link is missing though .\n\nI found this INFRA JIRA issue that appears to have some helpful info: https://issues.apache.org/jira/browse/INFRA-10722\n\n ",
            "author": "Steve Rowe",
            "id": "comment-15979267"
        },
        {
            "date": "2017-04-21T21:54:17+0000",
            "content": "So, from these links and other browsing/searching around, I've learned a few things:\n\n\n\tThere are 2 dedicated VMs for building docs, and it seems all that's required is adding the right tag to the job (git-websites)\n\tgitpubsub is described here: https://www.apache.org/dev/project-site.html and here:https://www.apache.org/dev/gitpubsub.html\n\tThere is some kind of Jekyll support already integrated into either these VMs or the gitpubsub process\n\tI have no good citation for this, but several issues I've looked at seem to imply that you use EITHER the CMS OR gitpubsub, not a combo of both\n\tAs stated in the Jenkins node labels page Steve provided, if you use gitpubsub you also have to have all your generated docs in a branch \"asf-site\", which I think is because the generated files are committed back into the project and then pushed via gitpubsub to webservers.\n\n ",
            "author": "Cassandra Targett",
            "id": "comment-15979461"
        },
        {
            "date": "2017-04-25T16:24:18+0000",
            "content": "A question for folks on this thread - does anyone think getting near-real-time Jenkins builds up & running is a barrier to locking Confluence and starting the conversion of the content (SOLR-10296)? ",
            "author": "Cassandra Targett",
            "id": "comment-15983174"
        },
        {
            "date": "2017-04-25T16:28:39+0000",
            "content": "What's the alternative to \"near-real-time\"? Daily? Manual? On release only?\n\nI suspect it is not a barrier as long as docs can be built locally, but it would be good to be clear what the public docs workflow would be in a meanwhile. ",
            "author": "Alexandre Rafalovitch",
            "id": "comment-15983187"
        },
        {
            "date": "2017-04-25T16:54:04+0000",
            "content": "I'm thinking only local builds to start, and then we have a new issue to figure out how to trigger it automatically on the dedicated docs-building machine I mentioned in an earlier comment and pubsub, etc., as appropriate. \n\nBut if others feel we should have some of process center around Jenkins, and in place now, I'm fine with that, just wanted to decide if this is the most important issue for this migration that I should be working on right now. Note that building locally requires some dependencies to be installed first - Ruby, Jekyll, Asciidoctor-Jekyll gem, and possibly a couple others that I'm forgetting right now. ",
            "author": "Cassandra Targett",
            "id": "comment-15983249"
        },
        {
            "date": "2017-04-25T17:24:47+0000",
            "content": "I think that automated building should not hold up the migration.\n\nIf I understand what we discussed correctly, automated building would only apply to branches like master and branch_6x, and maybe the current minor branch, not releases.  Most users won't be looking at the pages built automatically \u2013 it would be a way for a committer to quickly see the results of their changes without needing a way to host the documentation locally. ",
            "author": "Shawn Heisey",
            "id": "comment-15983287"
        },
        {
            "date": "2017-04-25T17:43:43+0000",
            "content": "I think we could set up a Jenkins job that builds the docs on a periodic basis, rather than triggered by commits.  This would allow for (delayed) feedback for those that don't build locally, and would avoid the need to integrate with GitPubSub.  In any case, I don't think this is a blocker for other activities. ",
            "author": "Steve Rowe",
            "id": "comment-15983318"
        },
        {
            "date": "2017-04-25T18:46:51+0000",
            "content": "Created SOLR-10568 as a spin-off for the automation of builds. ",
            "author": "Cassandra Targett",
            "id": "comment-15983429"
        },
        {
            "date": "2017-04-26T07:43:42+0000",
            "content": "+1 to continue the move, and do automation afterwards ",
            "author": "Jan H\u00f8ydahl",
            "id": "comment-15984318"
        },
        {
            "date": "2017-04-26T19:16:37+0000",
            "content": "Based on the idea we'll publish the HTML version to the website with a similar process as is currently used for the Javadocs, I've written up a strawman process, and committed it to the meta-docs in the branch:\n\nhttps://git1-us-west.apache.org/repos/asf?p=lucene-solr.git;a=blob;f=solr/solr-ref-guide/meta-docs/publish.adoc;h=f01978dba39fba074c7cb19fe1d1ca434c6b6c8e;hb=refs/heads/jira/solr-10290\n\nedit: I forgot to mention that I plan to try this process out with the content on the jira/solr-10290 branch. ",
            "author": "Cassandra Targett",
            "id": "comment-15985396"
        },
        {
            "date": "2017-04-26T20:20:31+0000",
            "content": "solr-ref-guide/meta-docs/publish.adoc looks good to me, with one caveat: use of svn import assumes that the entire destination directory does not already exist.  When we re-publish a previously published version, though, a different flow will be required: check out (an appropriate subtree of) the CMS production tree; use svn add/svn rm for file/dir additions/deletions; and svn commit.\n\nOh, I see you have a TODO for this: \"figure out process for updating guide\" ",
            "author": "Steve Rowe",
            "id": "comment-15985489"
        },
        {
            "date": "2017-04-26T20:42:44+0000",
            "content": "I plan to try this process out with the content on the jira/solr-10290 branch\n\nThis went without a hitch: https://lucene.apache.org/solr/guide/test-10290/apache-solr-reference-guide.html. A cool milestone after this much work.\n\n(We'll be able to remove the path at a later time and the content should be automatically deleted on the next staging-production sync. If it is not, I'll remove it manually. Of course, this shouldn't be announced as live in any way to any end users, since it's just a test.)\n\nA couple things I thought of while doing this:\n\nFirst, we maybe want to have a permanent path solr/guide that has an index.html file in it for directing people to the released HTML versions and official PDFs. The update to extpaths.txt would work the same, just there is a file there that is a landing page.\n\nSecond, we have no index.html in the set of files that are generated for the webserver to default to if someone goes to just https://lucene.apache.org/solr/guide/test-10290, for example. You just get a listing of files under that path. We either need to do some redirect magic in .htaccess, or change the \"home\" page of the Guide to be named index.html (which has a bunch of other implications to the build process since the page \"apache-solr-reference-guide.adoc is considered the super-parent of every other page of the Guide). ",
            "author": "Cassandra Targett",
            "id": "comment-15985509"
        },
        {
            "date": "2017-04-26T20:56:50+0000",
            "content": "Oh, I see you have a TODO for this: \"figure out process for updating guide\"\n\nheh, that wasn't what I meant, actually. That was supposed to be something about a process for updating the landing page that I completely munged. Correctly.\n\nI added a new line for what I really meant and pushed a new version of the file to the branch. ",
            "author": "Cassandra Targett",
            "id": "comment-15985544"
        },
        {
            "date": "2017-04-26T21:58:10+0000",
            "content": "Second, we have no index.html in the set of files that are generated for the webserver to default to if someone goes to just https://lucene.apache.org/solr/guide/test-10290, for example. You just get a listing of files under that path. We either need to do some redirect magic in .htaccess, or change the \"home\" page of the Guide to be named index.html (which has a bunch of other implications to the build process since the page \"apache-solr-reference-guide.adoc is considered the super-parent of every other page of the Guide).\n\nI think I brought this up in an github issue in the old POC repo but we never discussed it much...\n\nIt would be fairly simple to change the \"one time cwiki->asciidoc\" code to use index.adoc as the (created) name for the page currently named apache-solr-reference-guide.adoc if that's what we want to \u2013 but that would mean all the pages that refer to it as a parent / link to it would have to refer to it as index not apache-solr-reference-guide (this would happen automatically for the \"one time cwiki->asciidoc\" converted links/references).\n\nAlternatively, a DirectoryIndex entry (or rewrite rule) in an .htaccess file would also be easy to set up (but if we ever expect to ship a ZIPed up copy of the directory that people might open on their desktops, we'll definitely want an index.html file there \u2013 even if it's just a link to apache-solr-reference-guide.adoc) ",
            "author": "Hoss Man",
            "id": "comment-15985637"
        },
        {
            "date": "2017-04-27T08:52:08+0000",
            "content": "People are going to share the refguide links a lot, and I'd much prefer e.g. https://lucene.apache.org/solr/guide/6.5.0/ over https://lucene.apache.org/solr/guide/6.5.0/apache-solr-reference-guide.html. I also think we should avoid index.html in the authoritative online link to a particular guide version. So to achieve that I think we need two things\n\n\tUse index.adoc (html) for the front page\n\tUse .htaccess to rewrite https://lucene.apache.org/solr/guide/X.Y.Z/index.html to remove the index.html part so people copy/paste or bookmark the short one\n\n ",
            "author": "Jan H\u00f8ydahl",
            "id": "comment-15986214"
        },
        {
            "date": "2017-04-27T19:50:57+0000",
            "content": "A few things from today. The process I followed yesterday for my test of the process stalled the 6.5.1 release a little bit, and that caused me a bit of time to figure out what was going wrong there:\n\n\n\tThe process I followed likely left out a key step to publish the extpaths.txt from staging to production.\n\tThe publication of extpaths.txt can't happen until the path you're exempting from sync exists, and I likely missed that window.\n\n\n\nI chatted with INFRA briefly earlier about the problem encountered during the release, and their suggestion was that we should avoid using extpaths.txt if we can, in case we need to migrate off the CMS in the future. So I spent some time today on an experiment to try uploading the Ref Guide via the staging SVN repo (not the web-gui of the CMS). I encountered timeouts while publishing that to production, and subsequent attempts to make the commit smaller were unsuccessful, so that made it not worthwhile to recommend as a process. So, to publish the guide in the CMS, I'm sure will need to use the extpaths.txt method and commit the content files directly to production.\n\nIn the process of playing around with the CMS, I made a permanent directory content/solr/guide and included an index.html file there with a bit of placeholder content and a link to my test: https://lucene.apache.org/solr/guide/.\n\nI have not yet addressed any redirection with index.html or .htaccess so hard-coded the link from the placeholder landing page to the primary page of the Guide for now. ",
            "author": "Cassandra Targett",
            "id": "comment-15987453"
        },
        {
            "date": "2017-05-03T13:35:10+0000",
            "content": "I don't have a ton of experience with RewriteRules (OK, zero), but I think something like this would work in .htaccess:\n\n\nRewriteRule solr/guide/(.*)/index.html$ /solr/guide/$1/                         [R=301,NE]\n\n\n\nI believe that would work for any path under solr/guide/ so it won't need to be updated for each release or branch we choose to publish.\n\nAnyone know for sure? ",
            "author": "Cassandra Targett",
            "id": "comment-15994862"
        },
        {
            "date": "2017-05-03T14:39:37+0000",
            "content": "but that would mean all the pages that refer to it as a parent / link to it would have to refer to it as index not apache-solr-reference-guide\n\nHoss Man: I checked and there are no content pages that refer to apache-solr-reference-guide. There are only 2 references at all - one in the topnav.html include file and another in build.xml.\n\nI had the mental model backwards - I thought each page declared its parent which made this change seem slightly more complicated. I forgot that we did it the other way, where each parent declares its children. That makes changing to use an index.html a really minor change, and that's what we should do. ",
            "author": "Cassandra Targett",
            "id": "comment-15994992"
        },
        {
            "date": "2017-05-03T16:05:08+0000",
            "content": "In the process of playing around with the CMS, I made a permanent directory content/solr/guide and included an index.html file there with a bit of placeholder content and a link to my test: https://lucene.apache.org/solr/guide/.\n\nCassandra Targett, I see your landing page has placeholders for development branches, but once things have settled (i.e. there is a released guide with an HTML format) I don't think we should link from the website to development versions of the ref guide. ",
            "author": "Steve Rowe",
            "id": "comment-15995136"
        },
        {
            "date": "2017-05-03T16:10:35+0000",
            "content": "but once things have settled (i.e. there is a released guide with an HTML format) I don't think we should link from the website to development versions of the ref guide\n\nOK. ",
            "author": "Cassandra Targett",
            "id": "comment-15995146"
        },
        {
            "date": "2017-05-03T17:50:48+0000",
            "content": "I made some changes manually to change \"apache-solr-reference-guide.html\" to \"index.html\", corrected the references I mentioned earlier to Hoss Man, and uploaded those changes to the test Guide that's online on the website. \n\nIf you go to https://lucene.apache.org/solr/guide/test-10290/, you'll notice that the index.html page is served as the default, and it does not append \"index.html\" to the URL. So, if someone lands there and copies/pastes, they will not share URLs with \"index.html\" appended. Thus, I don't believe we need any additional RewriteRule in .htaccess at all at this point.\n\nThis was additionally a nice test of the process I initially came up with for updating an already published Guide. Modifications to that will be coming later today. ",
            "author": "Cassandra Targett",
            "id": "comment-15995322"
        },
        {
            "date": "2017-05-10T15:43:44+0000",
            "content": "I think this issue has been discussed enough, and add-on issues filed where it makes sense.\n\nI'll close this in the next day or so if there aren't any other thoughts on this for now. ",
            "author": "Cassandra Targett",
            "id": "comment-16004878"
        },
        {
            "date": "2017-06-01T20:41:55+0000",
            "content": "One thing I've found is that I prefer reading the documents directly from the github repo. Github does a very nice job with the ascii doc and the links seem to work fine. The docs are also nicely versioned. I suspect most people will eventually gravitate to just reading the docs on github. \n ",
            "author": "Joel Bernstein",
            "id": "comment-16033648"
        }
    ]
}