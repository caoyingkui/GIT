{
    "id": "SOLR-9040",
    "title": "bin/solr SSL support for client->server communcation (as well as default SSL behavior in 'new HttpSolrClient(String)') broken on master",
    "details": {
        "components": [],
        "type": "Bug",
        "labels": "",
        "fix_versions": [
            "7.0"
        ],
        "affect_versions": "None",
        "status": "Resolved",
        "resolution": "Fixed",
        "priority": "Major"
    },
    "description": "Working on SOLR-9028 lead me to realize that bin/solr actions which require communicating with solr over HTTP are broken on master when SSL is enabled.  My testing suggests that this doesn't affect branch 6x or 6.0.\n\n(Long) detailed steps to reproduce to follow in first  comment\n\nFurther investigation indicates this is a general problem with HTTP based SolrClient initialization when standard javax.net.ssl.* sys properties are expected to be used for initializing the underlying HTTP client code.",
    "attachments": {
        "SOLR-9040.patch": "https://issues.apache.org/jira/secure/attachment/12800692/SOLR-9040.patch"
    },
    "issue_links": {},
    "comments": [
        {
            "date": "2016-04-25T23:52:54+0000",
            "author": "Hoss Man",
            "content": "\n\n\tRun the following commands (typing in secret everytime you are asked for a password/pass phrase) to create the certificate files...\n\nmkdir /tmp/keystore \\\n && cd /tmp/keystore \\\n && keytool -genkeypair -alias solr-ssl -keyalg RSA -keysize 2048 -keypass secret -storepass secret -validity 9999 -keystore solr-ssl.keystore.jks -ext SAN=DNS:localhost,IP:192.168.1.3,IP:127.0.0.1 -dname \"CN=localhost, OU=Organizational Unit, O=Organization, L=Location, ST=State, C=Country\" \\\n && keytool -importkeystore -srckeystore solr-ssl.keystore.jks -destkeystore solr-ssl.keystore.p12 -srcstoretype jks -deststoretype pkcs12 \\\n && openssl pkcs12 -in solr-ssl.keystore.p12 -out solr-ssl.pem \\\n && openssl pkcs12 -nokeys -in solr-ssl.keystore.p12 -out solr-ssl.cacert.pem\n\n\n\tAdd the following to solr/bin/solr.in.sh ... \n\nSOLR_SSL_KEY_STORE=/tmp/keystore/solr-ssl.keystore.jks\nSOLR_SSL_KEY_STORE_PASSWORD=secret\nSOLR_SSL_TRUST_STORE=/tmp/keystore/solr-ssl.keystore.jks\nSOLR_SSL_TRUST_STORE_PASSWORD=secret\nSOLR_SSL_NEED_CLIENT_AUTH=false\nSOLR_SSL_WANT_CLIENT_AUTH=false\n\n\n\tRun: ant clean && cd solr && ant server\n\tRun: bin/solr -e techproducts\n\tRun: bin/solr status\n\tRun: curl --cacert /tmp/keystore/solr-ssl.cacert.pem https://localhost:8983/solr/admin/cores\n\t\n\t\tCompare output to: curl https://localhost:8983/solr/admin/cores\n\t\n\t\n\n\n\nOn branch_6x (or in the 6.0 release) this all works fine, and bin/solr not only starts Solr but can also create the techproduct core & the subsequent command to get status info works.  The curl commands demonstrate that Solr is in fact using the specified self-signed cert, and w/o that cert clients like curl won't communicate with it.  (Likewise: if you rm -r /tmp/keystore while solr is already running, re-run the commands to re-create the certificates, and then run bin/solr status you'll see that with the (new) incorrect certificates bin/solr status will return an error)\n\nOn master however, things don't work.  bin/solr -e techproducts can startup solr \u2013 but it can't create the core becuase the HTTP client code it tries to use says it doesn't support https \u2013 curl meanwhile still can communicate with Solr using the specified cacert, indicating that the server itself is running SSL fine, it's the lcient code that's having issues...\n\n\nhossman@tray:~/lucene/dev/solr [master] $ bin/solr -e techproducts\nCreating Solr home directory /home/hossman/lucene/dev/solr/example/techproducts/solr\n\nStarting up Solr on port 8983 using command:\nbin/solr start -p 8983 -s \"example/techproducts/solr\"\n\nWaiting up to 30 seconds to see Solr running on port 8983 [/]  \nStarted Solr server on port 8983 (pid=9925). Happy searching!\n\nINFO  - 2016-04-25 16:43:29.823; org.apache.http.impl.execchain.RetryExec; I/O exception (org.apache.http.conn.UnsupportedSchemeException) caught when processing request to {s}->https://localhost:8983: https protocol is not supported\nINFO  - 2016-04-25 16:43:29.827; org.apache.http.impl.execchain.RetryExec; Retrying request to {s}->https://localhost:8983\nINFO  - 2016-04-25 16:43:29.828; org.apache.http.impl.execchain.RetryExec; I/O exception (org.apache.http.conn.UnsupportedSchemeException) caught when processing request to {s}->https://localhost:8983: https protocol is not supported\n...\nINFO  - 2016-04-25 16:43:57.887; org.apache.http.impl.execchain.RetryExec; I/O exception (org.apache.http.conn.UnsupportedSchemeException) caught when processing request to {s}->https://localhost:8983: https protocol is not supported\nINFO  - 2016-04-25 16:43:57.887; org.apache.http.impl.execchain.RetryExec; Retrying request to {s}->https://localhost:8983\n\nERROR: Did not see Solr at https://localhost:8983/solr come online within 30\n\nhossman@tray:~/lucene/dev/solr [master] $ bin/solr status\n\nFound 1 Solr nodes: \n\nSolr process 9925 running on port 8983\nINFO  - 2016-04-25 16:44:33.437; org.apache.http.impl.execchain.RetryExec; I/O exception (org.apache.http.conn.UnsupportedSchemeException) caught when processing request to {s}->https://localhost:8983: https protocol is not supported\nINFO  - 2016-04-25 16:44:33.440; org.apache.http.impl.execchain.RetryExec; Retrying request to {s}->https://localhost:8983\nINFO  - 2016-04-25 16:44:33.443; org.apache.http.impl.execchain.RetryExec; I/O exception (org.apache.http.conn.UnsupportedSchemeException) caught when processing request to {s}->https://localhost:8983: https protocol is not supported\nINFO  - 2016-04-25 16:44:33.443; org.apache.http.impl.execchain.RetryExec; Retrying request to {s}->https://localhost:8983\nINFO  - 2016-04-25 16:44:33.443; org.apache.http.impl.execchain.RetryExec; I/O exception (org.apache.http.conn.UnsupportedSchemeException) caught when processing request to {s}->https://localhost:8983: https protocol is not supported\nINFO  - 2016-04-25 16:44:33.444; org.apache.http.impl.execchain.RetryExec; Retrying request to {s}->https://localhost:8983\n\nERROR: Failed to get system information from https://localhost:8983/solr due to: org.apache.http.conn.UnsupportedSchemeException: https protocol is not supported\n\nhossman@tray:~/lucene/dev/solr [master] $ curl --cacert /tmp/keystore/solr-ssl.cacert.pem https://localhost:8983/solr/admin/cores\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<response>\n<lst name=\"responseHeader\"><int name=\"status\">0</int><int name=\"QTime\">22</int></lst><lst name=\"initFailures\"/><lst name=\"status\"/>\n</response>\n\n\n\n ",
            "id": "comment-15257275"
        },
        {
            "date": "2016-04-26T00:20:01+0000",
            "author": "Hoss Man",
            "content": "\nWhen comparing the differences in SolrCLI.java between branch_6x and master, GIT commit ce172acb from SOLR-4509 jumpted out at me as beingsuspiciously relevant.\n\nIf you check out the commit prior to ce172acb (via git co ce172acb8fec6c3bbb18837a4d640da6c5aad649~1) then the steps described above (to reproduce the problem) seem to work flawlessly.\n\nIf you instead do git co ce172acb8fec6c3bbb18837a4d640da6c5aad649 then the steps to reproduce fail exactly as described above.\n ",
            "id": "comment-15257320"
        },
        {
            "date": "2016-04-26T01:59:57+0000",
            "author": "Hoss Man",
            "content": "Here's a really hacked together patch that gets things working again.\n\nThe root problem is that the (default) SchemaRegistryProvider in HttpClientUtil is hardcoded to only know about http.  With the older style HttpClientConfigurer code in SolrCLI pre-SOLR-4509, the default behavior of HttpClientUtil came from DefaultHttpClient and automatically included http & https protocols, using the various javax system properties (for things like keystore & truststore)\n\nIn this patch, i eliminate the hardcoded default behavior of only supporting \"http\" in HttpClientUtil and instead changed the Registry returned by the default SchemaRegistryProvider to \"null\", with caller coded updated to know that if/when the result is null, they should use the no-arg new PoolingHttpClientConnectionManager() constructor, instead of new PoolingHttpClientConnectionManager(reg) \u2013 because unfortunately PoolingHttpClientConnectionManager doesn't provide public access to it's default registry.\n\nThis seems to work in my manual testing - still running full test suite, but because of SOLR-9028 I don't have a whole lot of confidence even if the tests do all pass.  i have some ideas of how to write an explicit test for this bug, but it will probably require most of the changes in SOLR-9028 as well, so we may just want to roll these bugs together?\n\nThe big question is what the final API should look like \u2013 whether HttpClientUtil.getSchemaRegisteryProvider().getSchemaRegistry() should return null when this default behavior is desired, or if HttpClientUtil.getSchemaRegisteryProvider() should return null directly ... also: should the conditional instantiation of PoolingHttpClientConnectionManager be rolled into a public method in HttpClientUtil so it isn't duplicated in UpdateShardHandler (and any other client that wantsSchemaRegistryProvider to customize the connection manager) ... and more generally: WTF is up with the SchemaRegistryProvider API anyway? why is it a distinct class with distinct setters in HttpClientUtil, instead of being part of SolrHttpClientBuilder ?\n\n\u2014\n\nMark Miller - i'd really appreciate your thoughts on all of this. ",
            "id": "comment-15257421"
        },
        {
            "date": "2016-04-26T14:28:55+0000",
            "author": "Mark Miller",
            "content": "why is it a distinct class with distinct setters in HttpClientUtil, instead of being part of SolrHttpClientBuilder ?\n\nI probably felt that the builder for the httpclient and setting this for the pooling connection manager where somewhat distinct. I'm sure you could move it to the builder. As it is, you could have some code somewhere that configures the httpclient builder and then some code that turns on SSL somewhere else, and the SSL code would not have to rebuild the same httpclient builder and add the schema registry so that it could change schema registry and not any other httpclient builder settings. ",
            "id": "comment-15258168"
        },
        {
            "date": "2016-04-26T18:29:55+0000",
            "author": "Hoss Man",
            "content": "\nI probably felt that the builder for the httpclient and setting this for the pooling connection manager where somewhat distinct. ..\n\nHmm, ok well \u2013 my point is really just that it seems weird to me that there is this special SchemaRegistryProvider API that people have to write impls of just to implement one method that returns the registry \u2013 and to use their SchemaRegistryProvider they have to call HttpClientUtil.setSchemeRegistryProvider \u2013 but meanwhile in SolrCLI it's setup that a simple system property (\"solr.authentication.httpclient.builder\") can be used to to override the SolrHttpClientBuilder, but nothing can be used to easily override the default SchemaRegistryProvider from the command line like that (and as is, the default SchemaRegistryProvider is ignorant of the standard javax.net.ssl.* sys props that SolrHttpClient use to pay attention to implicitly).\n\nI mean - i suppose your custom SolrHttpClientBuilder that you specify with -Dsolr.authentication.httpclient.builder could, in it's constructor call HttpClientUtil.setSchemeRegistryProvider(...) ... it just seems weird that SchemaRegistryProvider getSchemaRegisteryProvider() isn't a method in the SolrHttpClientBuilder API (or that it isn't just refactored down to putting Registry<ConnectionSocketFactory> getSchemaRegistry() directly in SolrHttpClientBuilder   (especially since HttpClientUtil.resetHttpClientBuilder also automatically resets schemaRegistryProvider as well \u2013 making them very closely bound to each other)\n\nIn any case...  I've updated the patch in SOLR-9028 to demonstrate this bug (it already had most of the plumbing needed) and with the current SOLR-9040.patch 1/2 failures is resolved \u2013 but something is still wrong with clientAuth using the system properties, so i guess maybe the no arg PoolingHttpClientConnectionManager doesn't pick up all the javax.* system properties like i thought? ... i'm going to try to get to the bottom of that before i worry too much about what the final HttpClientUtil API should be for dealing with the scheme registry.\n ",
            "id": "comment-15258650"
        },
        {
            "date": "2016-04-26T19:41:26+0000",
            "author": "Mark Miller",
            "content": "Feel free to make improvements to the APIs. It's only in trunk I mainly spent time just getting it all to work.  ",
            "id": "comment-15258774"
        },
        {
            "date": "2016-04-27T21:15:59+0000",
            "author": "Hoss Man",
            "content": "updating summary to note this isn't just a bin/solr problem, it affects any solrj code that expects standard javax.net.ssl.* properties to be used when SolrClient impls take responsibility for creating HttpClient instances. ",
            "id": "comment-15260959"
        },
        {
            "date": "2016-04-27T21:17:52+0000",
            "author": "Hoss Man",
            "content": "\nOk, so the underlying problem with the old patch was that PoolingHttpClientConnectionManager's default behavior is to use SSLConnectionSocketFactory.getSocketFactory() which uses SSLContexts.createDefault() under the hood.  SSLContexts.createDefault() constructs an explicit SSLCOntext that ignores any system properties.\n\nInstead we want SSLConnectionSocketFactory.getSystemSocketFactory(), which does pay attention to some sys properties directly, and usees the standard SSLSocketFactory.getDefault() under the hood \u2013 ensuring that the javax.net.ssl.* system properties are also respected.\n\nThe only problem is that the way SSLSocketFactory.getDefault() works involves using SSLContext.getDefault(), which loads the deafault SSLContext (and reads the system properties) only once and then treats it as a singleton \u2013 making it a bit tricky to actually unit test diff sys prop options after the JVM has already started.\n\nI'll comment more on this in SOLR-9028 where it makes more sense.\n\nin any case, here's a patch that seems to fix bin/solr (and any new HttpSolrClient(String) usage that expects the various SSL sys props to affect the keystore/truststore).\n\nI've punted on the earlier questions i raised about the SchemaRegistryProvider API \u2013 I'll leave it to mark to decide if he thinks it's worth opening an issue to improve this. ",
            "id": "comment-15260967"
        },
        {
            "date": "2016-04-27T22:41:13+0000",
            "author": "ASF subversion and git services",
            "content": "Commit 9ab76a1e41d7019fd07b16a79a587653cf6d76a4 in lucene-solr's branch refs/heads/master from Chris Hostetter (Unused)\n[ https://git-wip-us.apache.org/repos/asf?p=lucene-solr.git;h=9ab76a1 ]\n\nSOLR-9040 / SOLR-4509: Fix default SchemaRegistryProvider so javax.net.ssl.* system properties are respected by default ",
            "id": "comment-15261100"
        }
    ]
}