{
    "id": "LUCENE-6759",
    "title": "Integrate lat/long BKD and spatial 3d, part 2",
    "details": {
        "resolution": "Fixed",
        "affect_versions": "None",
        "components": [],
        "labels": "",
        "fix_versions": [
            "5.4",
            "6.0"
        ],
        "priority": "Major",
        "status": "Closed",
        "type": "New Feature"
    },
    "description": "This is just a continuation of LUCENE-6699, which became too big.",
    "attachments": {
        "LUCENE-6699.patch": "https://issues.apache.org/jira/secure/attachment/12751898/LUCENE-6699.patch"
    },
    "issue_links": {},
    "comments": [
        {
            "id": "comment-14707945",
            "author": "Michael McCandless",
            "date": "2015-08-22T08:30:10+0000",
            "content": "Maybe, we should take a step back and accept that precision issues mean that points near a shape's boundary may or may not be accepted?\n\nI.e. we can just relax the test so that any point within X of the boundary (can we compute this easily?) is not tested. "
        },
        {
            "id": "comment-14707993",
            "author": "Karl Wright",
            "date": "2015-08-22T11:18:58+0000",
            "content": "I think you'll need to do that, yes.  But there's more to it than that.  See next comment. "
        },
        {
            "id": "comment-14707995",
            "author": "Karl Wright",
            "date": "2015-08-22T11:19:46+0000",
            "content": "Michael McCandless Here's the analysis, so far.\n\nI first enabled evaluation of all four points where the XYZSolid intersected the planet surface.  As you can see, only one of them comes back as being inside the GeoCircle:\n\n\n   [junit4]   2>  Point 1.0010913867774043 0.007079167343247293 -0.0021855011220022575: shape.isWithin? true; minx=9.128715394490783E-6, maxx=-3.191195882434883E-6, miny=0.0, maxy=-4.618394311805439E-4, minz=0.0, maxz=-2.893784038207395E-4\n   [junit4]   2>  Point 1.0010919806760743 0.007079167343247293 -0.001896122718181518: shape.isWithin? false; minx=9.722614064511248E-6, maxx=-2.597297212414418E-6, miny=0.0, maxy=-4.618394311805439E-4, minz=2.893784038207395E-4, maxz=0.0\n   [junit4]   2>  Point 1.001088014365874 0.007541006774427837 -0.0021855011220022575: shape.isWithin? false; minx=5.7563038642349795E-6, maxx=-6.563607412690686E-6, miny=4.618394311805439E-4, maxy=0.0, minz=0.0, maxz=-2.893784038207395E-4\n   [junit4]   2>  Point 1.0010886082665449 0.007541006774427837 -0.001896122718181518: shape.isWithin? false; minx=6.35020453509938E-6, maxx=-5.969706741826286E-6, miny=4.618394311805439E-4, maxy=0.0, minz=2.893784038207395E-4, maxz=0.0\n\n\n\nIf the above is an accurate picture, then there should be intersections between the GeoCircle and two of the edge planes.\n\nminy should intersect:\n\n\n   [junit4]   2>  Point 1.0010913867774043 0.007079167343247293 -0.0021855011220022575: shape.isWithin? true; minx=9.128715394490783E-6, maxx=-3.191195882434883E-6, miny=0.0, maxy=-4.618394311805439E-4, minz=0.0, maxz=-2.893784038207395E-4\n   [junit4]   2>  Point 1.0010919806760743 0.007079167343247293 -0.001896122718181518: shape.isWithin? false; minx=9.722614064511248E-6, maxx=-2.597297212414418E-6, miny=0.0, maxy=-4.618394311805439E-4, minz=2.893784038207395E-4, maxz=0.0\n\n\n\nAnd, minz should intersect:\n\n\n   [junit4]   2>  Point 1.0010913867774043 0.007079167343247293 -0.0021855011220022575: shape.isWithin? true; minx=9.128715394490783E-6, maxx=-3.191195882434883E-6, miny=0.0, maxy=-4.618394311805439E-4, minz=0.0, maxz=-2.893784038207395E-4\n   [junit4]   2>  Point 1.001088014365874 0.007541006774427837 -0.0021855011220022575: shape.isWithin? false; minx=5.7563038642349795E-6, maxx=-6.563607412690686E-6, miny=4.618394311805439E-4, maxy=0.0, minz=0.0, maxz=-2.893784038207395E-4\n\n\n\nThese two intersections are not being detected, and after much careful analysis, I concluded that the reason that they are not being detected is because no intersection actually happens.  Looking at the miny plane:\n\n\n   [junit4]   2> Checking for intersections that should be found...\n   [junit4]   2>  Not identical plane\n   [junit4]   2> Looking for intersection between plane [A=-0.9999680546313309, B=-0.0046605790633783275, C=0.006493744653569968, D=1.0011065916522879, side=-1.0] and plane [A=0.0, B=1.0, C=0.0, D=-0.007079167343247293, side=1.0] within bounds\n   [junit4]   2>  Two points of intersection\n   [junit4]   2>   [X=1.0010359045488204, Y=0.0070791673432472925, Z=-0.010729178478687706] this=(0.0) q=(-8.673617379884035E-19), and [X=1.0010913867758835, Y=0.0070791673432472925, Z=-0.0021855018140558226] this=(0.0) q=(-8.673617379884035E-19)\n\n\n\nTwo points of intersection are detected, but both are outside the X or Z bounds of the XYZSolid, so they do not represent intersection.\n\nSo, how can this be?  Well, the reason for the discrepancy is because the first point of the four mentioned at the top is, in fact, not really inside the GeoCircle.  It is coming up as being inside the GeoCircle only because of the fact that we've increased MINIMUM_RESOLUTION from its original value of 1e-12:\n\n\n   [junit4]   2> circlePlane eval = 2.9731772599461692E-12\n\n\n\nSo the problem is that ONE measure of error (point within GeoCircle) disagrees with another measure of error (intersection points in or out of XYZSolid), leading to an incorrect assessment.\n\nThis is obviously going to be challenging to address.  I may need to introduce two distinct error bounds in order for this logic to be robust.  But I have to think it through carefully. "
        },
        {
            "id": "comment-14708013",
            "author": "Karl Wright",
            "date": "2015-08-22T12:12:02+0000",
            "content": "Thinking through why one error measure just doesn't work in this case:\n\n(1) The point in question is on the wrong side of the GeoCircle plane, and is pretty nearly the closest point on the XYZSolid to the GeoCircle plane.\n(2) The slight tilt of the GeoCircle plane is enough to put the upper intersection point beyond the MINIMUM_RESOLUTION distance (at a distance of roughly 1e-8).  That removes the first candidate intersection point from consideration.\n(3) Because the GeoCircle is almost at the edge of the world, the slope between the GeoCircle plane and the planet surface is quite high, so a small error distance in X translates to a large distance in Y or Z.  That allows the second candidate intersection point to be removed from consideration.\n\nThe obvious conclusion is that we can tolerate no error at all in determining if a point is within a shape or not, for the purposes of evaluating relationships.  It's not clear to me yet whether we need to simply tighten the existing definition of \"isWithin()\", or we need to have multiple variants of \"isWithin()\".  Further analysis is needed to figure that out. "
        },
        {
            "id": "comment-14708063",
            "author": "Karl Wright",
            "date": "2015-08-22T15:38:11+0000",
            "content": "Changing isWithin() to be stricter globally seems like a reasonable way to go.  However, this requires SidedPlane to have two different isWithin() methods anyhow.  So I think I'll just bite the bullet and introduce isWithinStrict() as a new part of the Membership interface.\n\nThis will take some time to propagate and test. "
        },
        {
            "id": "comment-14708228",
            "author": "Karl Wright",
            "date": "2015-08-22T23:51:26+0000",
            "content": "Michael McCandless This patch reverts MINIMUM_RESOLUTION to 1e-12, and fixes the requirement for a high MINIMUM_RESOLUTION value another way.\n\nAll tests pass when this is done.  Since I've been adding tests every time your beasting finds something, that's meaningful.\n\nPlease bear in mind that this is probably not the final patch.  A final patch will have an even lower value for MINIMUM_RESOLUTION and probably more fixes designed to lower error values further.  But it does address the current issues, and the only way to know what breaks next is to pound on it.\n\nI'd also like to know what exactly you do to \"beast\" this patch, so that I may do the same here. "
        },
        {
            "id": "comment-14709274",
            "author": "Michael McCandless",
            "date": "2015-08-24T13:24:08+0000",
            "content": "Karl Wright thank you, I committed that last patch, but noticed GeoCircleTest.testCircleBounds is angry:\n\n\n   [junit4] Suite: org.apache.lucene.geo3d.GeoCircleTest\n   [junit4]   2> NOTE: reproduce with: ant test  -Dtestcase=GeoCircleTest -Dtests.method=testCircleBounds -Dtests.seed=8068B689836F03CE -Dtests.locale=es_PR -Dtests.timezone=Europe/Zagreb -Dtests.asserts=true -Dtests.file.encoding=UTF-8\n   [junit4] FAILURE 0.05s J1 | GeoCircleTest.testCircleBounds <<<\n   [junit4]    > Throwable #1: java.lang.AssertionError\n   [junit4]    > \tat __randomizedtesting.SeedInfo.seed([8068B689836F03CE:75EBD17B83B5147A]:0)\n   [junit4]    > \tat org.apache.lucene.geo3d.GeoCircleTest.testCircleBounds(GeoCircleTest.java:111)\n   [junit4]    > \tat java.lang.Thread.run(Thread.java:745)\n   [junit4]   2> NOTE: test params are: codec=Asserting(Lucene53): {}, docValues:{}, sim=RandomSimilarityProvider(queryNorm=true,coord=crazy): {}, locale=es_PR, timezone=Europe/Zagreb\n   [junit4]   2> NOTE: Linux 3.13.0-46-generic amd64/Oracle Corporation 1.8.0_40 (64-bit)/cpus=8,threads=1,free=425655240,total=504889344\n   [junit4]   2> NOTE: All tests run in this JVM: [GeoCircleTest]\n   [junit4] Completed [6/9] on J1 in 0.27s, 4 tests, 1 failure <<< FAILURES!\n\n "
        },
        {
            "id": "comment-14709283",
            "author": "Michael McCandless",
            "date": "2015-08-24T13:29:15+0000",
            "content": "I'd also like to know what exactly you do to \"beast\" this patch, so that I may do the same here.\n\nI use the repeatLuceneTest.py from luceneutil, but ant beast should work well too, something like:\n\n\nant beast -Dbeast.iters=100 -Dtestcase=TestGeo3DPointField -Dtestmethod=testRandomMedium -Dtests.dups=6 -Dtests.iters=10\n\n\n\nwill run 6 JVMs concurrently (I think?), each JVM repeating this one test method 10 times w/ the same master seed, and those 6 JVMs will stop and start 100 times. "
        },
        {
            "id": "comment-14709296",
            "author": "Karl Wright",
            "date": "2015-08-24T13:37:25+0000",
            "content": "Hmm, I don't see that in my workarea (before synching anyway).  Let me dig. "
        },
        {
            "id": "comment-14709303",
            "author": "Karl Wright",
            "date": "2015-08-24T13:41:47+0000",
            "content": "Michael McCandless ant clean test in my workarea yields:\n\n\n-test:\n    [mkdir] Created dir: C:\\wip\\lucene\\lucene6699\\lucene\\build\\spatial3d\\test\n    [mkdir] Created dir: C:\\wip\\lucene\\lucene6699\\lucene\\build\\spatial3d\\test\\te\nmp\n   [junit4] <JUnit4> says ??! Master seed: C9F7F99B0030A6AB\n   [junit4] Your default console's encoding may not display certain unicode glyp\nhs: windows-1252\n   [junit4] Executing 9 suites with 3 JVMs.\n   [junit4]\n   [junit4] Started J1 PID(8768@localhost).\n   [junit4] Started J2 PID(1576@localhost).\n   [junit4] Started J0 PID(9308@localhost).\n   [junit4] Suite: org.apache.lucene.geo3d.GeoCircleTest\n   [junit4] Completed [1/9] on J1 in 0.19s, 4 tests\n   [junit4]\n   [junit4] Suite: org.apache.lucene.geo3d.GeoBBoxTest\n   [junit4] Completed [2/9] on J2 in 0.23s, 4 tests\n   [junit4]\n   [junit4] Suite: org.apache.lucene.geo3d.GeoModelTest\n   [junit4] Completed [3/9] on J1 in 0.01s, 2 tests\n   [junit4]\n   [junit4] Suite: org.apache.lucene.geo3d.GeoPolygonTest\n   [junit4] Completed [4/9] on J2 in 0.01s, 2 tests\n   [junit4]\n   [junit4] Suite: org.apache.lucene.geo3d.PlaneTest\n   [junit4] Completed [5/9] on J1 in 0.01s, 2 tests\n   [junit4]\n   [junit4] Suite: org.apache.lucene.geo3d.XYZSolidTest\n   [junit4] Completed [6/9] on J2 in 0.05s, 2 tests\n   [junit4]\n   [junit4] Suite: org.apache.lucene.geo3d.GeoPathTest\n   [junit4] Completed [7/9] on J1 in 0.03s, 5 tests\n   [junit4]\n   [junit4] Suite: org.apache.lucene.geo3d.GeoConvexPolygonTest\n   [junit4] Completed [8/9] on J2 in 0.00s, 2 tests\n   [junit4]\n   [junit4] Suite: org.apache.lucene.bkdtree3d.TestGeo3DPointField\n   [junit4] IGNOR/A 0.09s J0 | TestGeo3DPointField.testRandomBig\n   [junit4]    > Assumption #1: 'nightly' test group is disabled (@Nightly())\n   [junit4] Completed [9/9] on J0 in 5.18s, 6 tests, 1 skipped\n   [junit4]\n   [junit4] JVM J0:     1.86 ..     8.29 =     6.43s\n   [junit4] JVM J1:     1.86 ..     3.37 =     1.51s\n   [junit4] JVM J2:     1.86 ..     3.36 =     1.50s\n   [junit4] Execution time total: 8.30 sec.\n   [junit4] Tests summary: 9 suites, 29 tests, 1 ignored (1 assumption)\n     [echo] 5 slowest tests:\n[junit4:tophints]   9.50s | org.apache.lucene.bkdtree3d.TestGeo3DPointField\n[junit4:tophints]   1.73s | org.apache.lucene.bkdtree3d.TestBKD3DTree\n[junit4:tophints]   0.20s | org.apache.lucene.geo3d.XYZSolidTest\n[junit4:tophints]   0.19s | org.apache.lucene.geo3d.GeoCircleTest\n[junit4:tophints]   0.16s | org.apache.lucene.geo3d.GeoBBoxTest\n\n-check-totals:\n\ncommon.test:\n\nBUILD SUCCESSFUL\nTotal time: 16 seconds\n\n\n\nAfter sync:\n\n\nC:\\wip\\lucene\\lucene6699\\lucene\\spatial3d>svn status\n?       capture\n\nC:\\wip\\lucene\\lucene6699\\lucene\\spatial3d>\n\n\n\nA repeat \"ant clean test\" also succeeds at that point.  So I'm puzzled.  Did you run \"ant clean\" first?  Changing MINIMUM_RESOLUTION does require that, seemingly... "
        },
        {
            "id": "comment-14709317",
            "author": "Karl Wright",
            "date": "2015-08-24T13:52:34+0000",
            "content": "Running the beaster made it through 6 rounds, but then failed with this:\n\n\n  [beaster]   2> sie 24, 2015 3:48:21 PM com.carrotsearch.randomizedtesting.Rand\nomizedRunner$QueueUncaughtExceptionsHandler uncaughtException\n  [beaster]   2> WARNING: Uncaught exception in thread: Thread[T0,5,TGRP-TestGeo\n3DPointField]\n  [beaster]   2> java.lang.AssertionError: expected WITHIN (1) or OVERLAPS (2) b\nut got 3; shape=GeoCircle: {planetmodel=PlanetModel.SPHERE, center=[lat=-0.00216\n27146783861745, lon=-0.0017298167021592304], radius=2.0818312293195752E-4(0.0119\n28014309854351)}; XYZSolid=XYZSolid: {planetmodel=PlanetModel.SPHERE, isWholeWor\nld=false, minXplane=[A=1.0, B=0.0, C=0.0, D=-0.9999955669921241, side=1.0], maxX\nplane=[A=1.0, B=0.0, C=0.0, D=-0.9999967200767939, side=-1.0], minYplane=[A=0.0,\n B=1.0, C=0.0, D=0.0019379945667919352, side=1.0], maxYplane=[A=0.0, B=1.0, C=0.\n0, D=0.0015216289462746052, side=-1.0], minZplane=[A=0.0, B=0.0, C=1.0, D=0.0023\n708955797907497, side=1.0], maxZplane=[A=0.0, B=0.0, C=1.0, D=0.0019545303111802\n707, side=-1.0]}\n  [beaster]   2>        at __randomizedtesting.SeedInfo.seed([485BDCE0789B5CDC]:\n0)\n  [beaster]   2>        at org.apache.lucene.bkdtree3d.PointInGeo3DShapeQuery$1.\nscorer(PointInGeo3DShapeQuery.java:105)\n  [beaster]   2>        at org.apache.lucene.search.LRUQueryCache$CachingWrapper\nWeight.scorer(LRUQueryCache.java:589)\n  [beaster]   2>        at org.apache.lucene.search.Weight.bulkScorer(Weight.jav\na:135)\n  [beaster]   2>        at org.apache.lucene.search.AssertingWeight.bulkScorer(A\nssertingWeight.java:69)\n  [beaster]   2>        at org.apache.lucene.search.AssertingWeight.bulkScorer(A\nssertingWeight.java:69)\n  [beaster]   2>        at org.apache.lucene.search.IndexSearcher.search(IndexSe\narcher.java:618)\n  [beaster]   2>        at org.apache.lucene.search.AssertingIndexSearcher.searc\nh(AssertingIndexSearcher.java:92)\n  [beaster]   2>        at org.apache.lucene.search.IndexSearcher.search(IndexSe\narcher.java:425)\n  [beaster]   2>        at org.apache.lucene.bkdtree3d.TestGeo3DPointField$4._ru\nn(TestGeo3DPointField.java:587)\n  [beaster]   2>        at org.apache.lucene.bkdtree3d.TestGeo3DPointField$4.run\n(TestGeo3DPointField.java:521)\n  [beaster]   2>\n  [beaster]   2> NOTE: reproduce with: ant test  -Dtestcase=TestGeo3DPointField\n-Dtests.method=testRandomMedium -Dtests.seed=485BDCE0789B5CDC -Dtests.slow=true\n-Dtests.locale=pl_PL -Dtests.timezone=Africa/Tripoli -Dtests.asserts=true -Dtest\ns.file.encoding=ISO-8859-1\n  [beaster] [09:48:13.669] ERROR   11.3s J0 | TestGeo3DPointField.testRandomMedi\num {#0 seed=[485BDCE0789B5CDC:F585EB4839FE3FBA]} <<<\n  [beaster]    > Throwable #1: com.carrotsearch.randomizedtesting.UncaughtExcept\nionError: Captured an uncaught exception in thread: Thread[id=17, name=T0, state\n=RUNNABLE, group=TGRP-TestGeo3DPointField]\n  [beaster]    >        at __randomizedtesting.SeedInfo.seed([485BDCE0789B5CDC:F\n585EB4839FE3FBA]:0)\n  [beaster]    > Caused by: java.lang.AssertionError: expected WITHIN (1) or OVE\nRLAPS (2) but got 3; shape=GeoCircle: {planetmodel=PlanetModel.SPHERE, center=[l\nat=-0.0021627146783861745, lon=-0.0017298167021592304], radius=2.081831229319575\n2E-4(0.011928014309854351)}; XYZSolid=XYZSolid: {planetmodel=PlanetModel.SPHERE,\n isWholeWorld=false, minXplane=[A=1.0, B=0.0, C=0.0, D=-0.9999955669921241, side\n=1.0], maxXplane=[A=1.0, B=0.0, C=0.0, D=-0.9999967200767939, side=-1.0], minYpl\nane=[A=0.0, B=1.0, C=0.0, D=0.0019379945667919352, side=1.0], maxYplane=[A=0.0,\nB=1.0, C=0.0, D=0.0015216289462746052, side=-1.0], minZplane=[A=0.0, B=0.0, C=1.\n0, D=0.0023708955797907497, side=1.0], maxZplane=[A=0.0, B=0.0, C=1.0, D=0.00195\n45303111802707, side=-1.0]}\n  [beaster]    >        at __randomizedtesting.SeedInfo.seed([485BDCE0789B5CDC]:\n0)\n  [beaster]    >        at org.apache.lucene.bkdtree3d.PointInGeo3DShapeQuery$1.\nscorer(PointInGeo3DShapeQuery.java:105)\n  [beaster]    >        at org.apache.lucene.search.LRUQueryCache$CachingWrapper\nWeight.scorer(LRUQueryCache.java:589)\n  [beaster]    >        at org.apache.lucene.search.Weight.bulkScorer(Weight.jav\na:135)\n  [beaster]    >        at org.apache.lucene.search.AssertingWeight.bulkScorer(A\nssertingWeight.java:69)\n  [beaster]    >        at org.apache.lucene.search.AssertingWeight.bulkScorer(A\nssertingWeight.java:69)\n  [beaster]    >        at org.apache.lucene.search.IndexSearcher.search(IndexSe\narcher.java:618)\n  [beaster]    >        at org.apache.lucene.search.AssertingIndexSearcher.searc\nh(AssertingIndexSearcher.java:92)\n  [beaster]    >        at org.apache.lucene.search.IndexSearcher.search(IndexSe\narcher.java:425)\n  [beaster]    >        at org.apache.lucene.bkdtree3d.TestGeo3DPointField$4._ru\nn(TestGeo3DPointField.java:587)\n  [beaster]    >        at org.apache.lucene.bkdtree3d.TestGeo3DPointField$4.run\n(TestGeo3DPointField.java:521)\n  [beaster]   2> NOTE: test params are: codec=Asserting(Lucene53): {}, docValues\n:{}, sim=RandomSimilarityProvider(queryNorm=false,coord=no): {}, locale=pl_PL, t\nimezone=Africa/Tripoli\n  [beaster]   2> NOTE: Windows 7 6.1 amd64/Oracle Corporation 1.8.0_05 (64-bit)/\ncpus=4,threads=1,free=154135784,total=308805632\n  [beaster]   2> NOTE: All tests run in this JVM: [TestGeo3DPointField]\n  [beaster]\n  [beaster] Tests with failures:\n  [beaster]   - org.apache.lucene.bkdtree3d.TestGeo3DPointField.testRandomMedium\n {#0 seed=[485BDCE0789B5CDC:F585EB4839FE3FBA]}\n  [beaster]\n  [beaster]\n\n\n\nI will have a look at this as soon as possible. "
        },
        {
            "id": "comment-14709383",
            "author": "Karl Wright",
            "date": "2015-08-24T14:33:18+0000",
            "content": "Coding this up as its own explicit test yields the following:\n\n\n   [junit4]   2> Shape edge points:\n   [junit4]   2>  Point 0.9999965937741284 -0.0017298125353661473 -0.001954530310113696: isWithin? false; minx=1.0267820043097231E-6, maxx=-1.2630266543744995E-7, miny=2.0818203142578787E-4, maxy=-2.0818358909154206E-4, minz=4.1636526967705383E-4, maxz=1.0665747798843661E-12\n\n\n\nSo the bounds object that's computed fails to contain the edgepoint for the circle, by a very small amount (1.0665747798843661E-12).  That's 7% larger than the MINIMUM_RESOLUTION value.\n\nI'm going to look first at whether there are any ways I can think of to reduce the error.  First I'll see how far the edgepoint is from the circle plane.  Presuming that's not the source of most of the error, then the next step would be to look at the bounds computation itself for error reduction.  If all else fails, then MINIMUM_RESOLUTION will have to grow by 7%. "
        },
        {
            "id": "comment-14709389",
            "author": "Karl Wright",
            "date": "2015-08-24T14:39:48+0000",
            "content": "\n   [junit4]   2> Distance to circle plane = 2.220446049250313E-16\n\n\n\n... which is 4 orders of magnitude less than MINIMUM_RESOLUTION.  Clearly not the problem.  Looking at getBounds() next... "
        },
        {
            "id": "comment-14709402",
            "author": "Karl Wright",
            "date": "2015-08-24T14:50:12+0000",
            "content": "getBounds() also seems to have low error when computing the Z bound:\n\n\n   [junit4]   2> this.evaluate(point)=1.1102230246251565E-16; normalizedZPlane.evaluate(point)=0.0\n   [junit4]   2> this.evaluate(point)=0.0; normalizedZPlane.evaluate(point)=2.1684043449710089E-19\n\n "
        },
        {
            "id": "comment-14709579",
            "author": "Karl Wright",
            "date": "2015-08-24T16:38:16+0000",
            "content": "I wound up discovering that the delta between a shape and the XYZBounds that might be returned for a shape was more than 10x 1.5e-12.   That's not a number I can increase MINIMUM_RESOLUTION to, unfortunately.\n\nThe cause of the delta is that very same case of a very small circle on or about z=0.  The delta between the geocircle's plane and the maxz value may only be 1e-16, but if the circle is small enough that delta translates to a delta in Z of 5e-11 or so, which is way outside the MINIMUM_RESOLUTION in z.\n\nThe solution I'm exploring now is to simply add a \"fudge factor\" to all bounds values. This fudge factor is designed to cover any deltas due to error values being magnified in this way.  So far (beasting round 20) it seems to be working.  I may also reduce MINIMUM_RESOLUTION to a lower value if this seems to be effective for all of our test cases. "
        },
        {
            "id": "comment-14709739",
            "author": "Karl Wright",
            "date": "2015-08-24T18:01:32+0000",
            "content": "Michael McCandless: Here's a patch that allows beasting to succeed. "
        },
        {
            "id": "comment-14709749",
            "author": "Michael McCandless",
            "date": "2015-08-24T18:05:55+0000",
            "content": "Thanks Karl Wright I committed that last patch...\n\nHmm, I don't see that in my workarea (before synching anyway). Let me dig.\n\nUgh sorry, when I did an \"ant clean\" then this test stopped failing ... "
        },
        {
            "id": "comment-14709771",
            "author": "Michael McCandless",
            "date": "2015-08-24T18:14:47+0000",
            "content": "206 beast iters then I hit:\n\n\n[junit4:pickseed] Seed property 'tests.seed' already defined: DDC21670DAEA1F6B\n   [junit4] <JUnit4> says ciao! Master seed: DDC21670DAEA1F6B\n   [junit4] Executing 1 suite with 1 JVM.\n   [junit4] \n   [junit4] Started J0 PID(16168@localhost).\n   [junit4] Suite: org.apache.lucene.bkdtree3d.TestGeo3DPointField\n   [junit4]   2> ago 24, 2015 8:15:51 PM com.carrotsearch.randomizedtesting.RandomizedRunner$QueueUncaughtExceptionsHandler uncaughtException\n   [junit4]   2> WARNING: Uncaught exception in thread: Thread[T1,5,TGRP-TestGeo3DPointField]\n   [junit4]   2> java.lang.AssertionError: expected WITHIN (1) or OVERLAPS (2) but got 0; shape=GeoCircle: {planetmodel=PlanetModel.SPHERE, center=[lat=-0.004431288600558495, lon=-0.003687846671278374], radius=1.704543429364245E-8(9.7663144499327E-7)}; XYZSolid=XYZSolid: {planetmodel=PlanetModel.SPHERE, isWholeWorld=false, minXplane=[A=1.0, B=0.0, C=0.0, D=-0.9999833816746712, side=1.0], maxXplane=[A=1.0, B=0.0, C=0.0, D=-0.9999833819746712, side=-1.0], minYplane=[A=0.0, B=1.0, C=0.0, D=0.00368780225430909, side=1.0], maxYplane=[A=0.0, B=1.0, C=0.0, D=0.00368780195430909, side=-1.0], minZplane=[A=0.0, B=0.0, C=1.0, D=0.004431274248206893, side=1.0], maxZplane=[A=0.0, B=0.0, C=1.0, D=0.004431273948206893, side=-1.0]}\n   [junit4]   2> \tat __randomizedtesting.SeedInfo.seed([DDC21670DAEA1F6B]:0)\n   [junit4]   2> \tat org.apache.lucene.bkdtree3d.PointInGeo3DShapeQuery$1.scorer(PointInGeo3DShapeQuery.java:105)\n   [junit4]   2> \tat org.apache.lucene.search.LRUQueryCache$CachingWrapperWeight.scorer(LRUQueryCache.java:581)\n   [junit4]   2> \tat org.apache.lucene.search.Weight.bulkScorer(Weight.java:135)\n   [junit4]   2> \tat org.apache.lucene.search.AssertingWeight.bulkScorer(AssertingWeight.java:69)\n   [junit4]   2> \tat org.apache.lucene.search.AssertingWeight.bulkScorer(AssertingWeight.java:69)\n   [junit4]   2> \tat org.apache.lucene.search.IndexSearcher.search(IndexSearcher.java:618)\n   [junit4]   2> \tat org.apache.lucene.search.AssertingIndexSearcher.search(AssertingIndexSearcher.java:92)\n   [junit4]   2> \tat org.apache.lucene.search.IndexSearcher.search(IndexSearcher.java:425)\n   [junit4]   2> \tat org.apache.lucene.bkdtree3d.TestGeo3DPointField$4._run(TestGeo3DPointField.java:587)\n   [junit4]   2> \tat org.apache.lucene.bkdtree3d.TestGeo3DPointField$4.run(TestGeo3DPointField.java:521)\n   [junit4]   2> \n   [junit4]   2> NOTE: reproduce with: ant test  -Dtestcase=TestGeo3DPointField -Dtests.method=testRandomMedium -Dtests.seed=DDC21670DAEA1F6B -Dtests.slow=true -Dtests.linedocsfile=/lucenedata/hudson.enwiki.random.lines.txt.fixed -Dtests.locale=it_CH -Dtests.timezone=Africa/Blantyre -Dtests.asserts=true -Dtests.file.encoding=UTF-8\n   [junit4] ERROR   1.08s | TestGeo3DPointField.testRandomMedium <<<\n   [junit4]    > Throwable #1: com.carrotsearch.randomizedtesting.UncaughtExceptionError: Captured an uncaught exception in thread: Thread[id=16, name=T1, state=RUNNABLE, group=TGRP-TestGeo3DPointField]\n\n\n\nLooks like a miniscule radius? "
        },
        {
            "id": "comment-14709972",
            "author": "Karl Wright",
            "date": "2015-08-24T20:05:27+0000",
            "content": "yup, when the radius gets that small, the error gets magnified enormously.  Essentially it becomes infinite when the radius becomes zero.   But practically speaking, anything less than MINIMUM_RESOLUTION will be rejected out of hand.  So probably the right thing to do is just to multiply the fudge factor by an additional factor of 10.  I'll also add another test. "
        },
        {
            "id": "comment-14709980",
            "author": "Karl Wright",
            "date": "2015-08-24T20:13:59+0000",
            "content": "Michael McCandless: Increase the fudge factor still more, to account for an even more ridiculously small radius.\n\nI'm hoping this does it. "
        },
        {
            "id": "comment-14710967",
            "author": "Michael McCandless",
            "date": "2015-08-25T09:17:54+0000",
            "content": "OK after a long time beasting, I hit this:\n\n\n   [junit4]   2> NOTE: reproduce with: ant test  -Dtestcase=TestGeo3DPointField -Dtests.method=testRandomMedium -Dtests.seed=E5F94C1E10DF27A2 -Dtests.multiplier=5 -Dtests.locale=fr_FR -Dtests.timezone=Africa/Djibouti -Dtests.asserts=true -Dtests.file.encoding=UTF-8\n   [junit4] ERROR   8.48s | TestGeo3DPointField.testRandomMedium <<<\n   [junit4]    > Throwable #1: com.carrotsearch.randomizedtesting.UncaughtExceptionError: Captured an uncaught exception in thread: Thread[id=15, name=T1, state=RUNNABLE, group=TGRP-TestGeo3DPointField]\n   [junit4]    > \tat __randomizedtesting.SeedInfo.seed([E5F94C1E10DF27A2:58277BB651BA44C4]:0)\n   [junit4]    > Caused by: java.lang.RuntimeException: java.lang.RuntimeException: FAILED\n   [junit4]    > \tat __randomizedtesting.SeedInfo.seed([E5F94C1E10DF27A2]:0)\n   [junit4]    > \tat org.apache.lucene.bkdtree3d.TestGeo3DPointField$4.run(TestGeo3DPointField.java:524)\n   [junit4]    > Caused by: java.lang.RuntimeException: FAILED\n   [junit4]    > \tat org.apache.lucene.bkdtree3d.BKD3DTreeReader.addAll(BKD3DTreeReader.java:159)\n   [junit4]    > \tat org.apache.lucene.bkdtree3d.BKD3DTreeReader.intersect(BKD3DTreeReader.java:205)\n   [junit4]    > \tat org.apache.lucene.bkdtree3d.BKD3DTreeReader.intersect(BKD3DTreeReader.java:307)\n   [junit4]    > \tat org.apache.lucene.bkdtree3d.BKD3DTreeReader.intersect(BKD3DTreeReader.java:321)\n   [junit4]    > \tat org.apache.lucene.bkdtree3d.BKD3DTreeReader.intersect(BKD3DTreeReader.java:321)\n   [junit4]    > \tat org.apache.lucene.bkdtree3d.BKD3DTreeReader.intersect(BKD3DTreeReader.java:307)\n   [junit4]    > \tat org.apache.lucene.bkdtree3d.BKD3DTreeReader.intersect(BKD3DTreeReader.java:297)\n   [junit4]    > \tat org.apache.lucene.bkdtree3d.BKD3DTreeReader.intersect(BKD3DTreeReader.java:331)\n   [junit4]    > \tat org.apache.lucene.bkdtree3d.BKD3DTreeReader.intersect(BKD3DTreeReader.java:282)\n   [junit4]    > \tat org.apache.lucene.bkdtree3d.BKD3DTreeReader.intersect(BKD3DTreeReader.java:297)\n   [junit4]    > \tat org.apache.lucene.bkdtree3d.BKD3DTreeReader.intersect(BKD3DTreeReader.java:331)\n   [junit4]    > \tat org.apache.lucene.bkdtree3d.BKD3DTreeReader.intersect(BKD3DTreeReader.java:115)\n   [junit4]    > \tat org.apache.lucene.bkdtree3d.PointInGeo3DShapeQuery$1.scorer(PointInGeo3DShapeQuery.java:114)\n   [junit4]    > \tat org.apache.lucene.search.LRUQueryCache$CachingWrapperWeight.scorer(LRUQueryCache.java:581)\n   [junit4]    > \tat org.apache.lucene.search.Weight.bulkScorer(Weight.java:135)\n   [junit4]    > \tat org.apache.lucene.search.AssertingWeight.bulkScorer(AssertingWeight.java:69)\n   [junit4]    > \tat org.apache.lucene.search.AssertingWeight.bulkScorer(AssertingWeight.java:69)\n   [junit4]    > \tat org.apache.lucene.search.IndexSearcher.search(IndexSearcher.java:618)\n   [junit4]    > \tat org.apache.lucene.search.AssertingIndexSearcher.search(AssertingIndexSearcher.java:92)\n   [junit4]    > \tat org.apache.lucene.search.IndexSearcher.search(IndexSearcher.java:425)\n   [junit4]    > \tat org.apache.lucene.bkdtree3d.TestGeo3DPointField$4._run(TestGeo3DPointField.java:587)\n   [junit4]    > \tat org.apache.lucene.bkdtree3d.TestGeo3DPointField$4.run(TestGeo3DPointField.java:521)\n   [junit4]   2> NOTE: test params are: codec=Asserting(Lucene53): {}, docValues:{}, sim=RandomSimilarityProvider(queryNorm=false,coord=crazy): {}, locale=fr_FR, timezone=Africa/Djibouti\n   [junit4]   2> NOTE: Linux 3.13.0-46-generic amd64/Oracle Corporation 1.8.0_40 (64-bit)/cpus=8,threads=1,free=408338576,total=455081984\n   [junit4]   2> NOTE: All tests run in this JVM: [TestGeo3DPointField]\n\n\n\nIt's a case where we checked up above that a BKD cell was fully contained in the shape, but then we assert every point we see inside that cell is also within the shape, and that failed... "
        },
        {
            "id": "comment-14711040",
            "author": "Karl Wright",
            "date": "2015-08-25T10:14:23+0000",
            "content": "The solution to this problem is the reduce the MINIMUM_RESOLUTION.  But I'd like to code up the specific case in order to be sure I catch it.  Would you be able to find details, as you did last time? "
        },
        {
            "id": "comment-14711202",
            "author": "Karl Wright",
            "date": "2015-08-25T12:48:16+0000",
            "content": "Michael McCandless: Here's a patch that addresses the latest failure, by halving MINIMUM_RESOLUTION and doubling FUDGE_FACTOR.\n\nI don't have a standalone test for this case because I'm not quite sure the best way to extract it from the failure. "
        },
        {
            "id": "comment-14712139",
            "author": "Michael McCandless",
            "date": "2015-08-25T22:59:37+0000",
            "content": "\nAnother failure, where the cell is within the shape, so BKD tree\nrecurses into addAll, yet a doc within the cell is not within the\nshape:\n\n\n   [junit4]   2> NOTE: reproduce with: ant test  -Dtestcase=TestGeo3DPointField -Dtests.method=testRandomMedium -Dtests.seed=D75138C6C25D1BCF -Dtests.multiplier=10 -Dtests.slow=true -Dtests.locale=de_GR -Dtests.timezone=America/Managua -Dtests.asserts=true -Dtests.file.encoding=US-ASCII\n   [junit4] ERROR   9.88s | TestGeo3DPointField.testRandomMedium <<<\n   [junit4]    > Throwable #1: com.carrotsearch.randomizedtesting.UncaughtExceptionError: Captured an uncaught exception in thread: Thread[id=28, name=T0, state=RUNNABLE, group=TGRP-TestGeo3DPointField]\n   [junit4]    > \tat __randomizedtesting.SeedInfo.seed([D75138C6C25D1BCF:6A8F0F6E833878A9]:0)\n   [junit4]    > Caused by: java.lang.RuntimeException: java.lang.RuntimeException: FAILED\n   [junit4]    > \tat __randomizedtesting.SeedInfo.seed([D75138C6C25D1BCF]:0)\n   [junit4]    > \tat org.apache.lucene.bkdtree3d.TestGeo3DPointField$4.run(TestGeo3DPointField.java:524)\n   [junit4]    > Caused by: java.lang.RuntimeException: FAILED\n   [junit4]    > \tat org.apache.lucene.bkdtree3d.BKD3DTreeReader.addAll(BKD3DTreeReader.java:159)\n   [junit4]    > \tat org.apache.lucene.bkdtree3d.BKD3DTreeReader.intersect(BKD3DTreeReader.java:203)\n   [junit4]    > \tat org.apache.lucene.bkdtree3d.BKD3DTreeReader.intersect(BKD3DTreeReader.java:329)\n   [junit4]    > \tat org.apache.lucene.bkdtree3d.BKD3DTreeReader.intersect(BKD3DTreeReader.java:295)\n   [junit4]    > \tat org.apache.lucene.bkdtree3d.BKD3DTreeReader.intersect(BKD3DTreeReader.java:305)\n   [junit4]    > \tat org.apache.lucene.bkdtree3d.BKD3DTreeReader.intersect(BKD3DTreeReader.java:329)\n   [junit4]    > \tat org.apache.lucene.bkdtree3d.BKD3DTreeReader.intersect(BKD3DTreeReader.java:319)\n   [junit4]    > \tat org.apache.lucene.bkdtree3d.BKD3DTreeReader.intersect(BKD3DTreeReader.java:295)\n   [junit4]    > \tat org.apache.lucene.bkdtree3d.BKD3DTreeReader.intersect(BKD3DTreeReader.java:280)\n   [junit4]    > \tat org.apache.lucene.bkdtree3d.BKD3DTreeReader.intersect(BKD3DTreeReader.java:270)\n   [junit4]    > \tat org.apache.lucene.bkdtree3d.BKD3DTreeReader.intersect(BKD3DTreeReader.java:270)\n   [junit4]    > \tat org.apache.lucene.bkdtree3d.BKD3DTreeReader.intersect(BKD3DTreeReader.java:295)\n   [junit4]    > \tat org.apache.lucene.bkdtree3d.BKD3DTreeReader.intersect(BKD3DTreeReader.java:319)\n   [junit4]    > \tat org.apache.lucene.bkdtree3d.BKD3DTreeReader.intersect(BKD3DTreeReader.java:115)\n   [junit4]    > \tat org.apache.lucene.bkdtree3d.PointInGeo3DShapeQuery$1.scorer(PointInGeo3DShapeQuery.java:114)\n   [junit4]    > \tat org.apache.lucene.search.LRUQueryCache$CachingWrapperWeight.scorer(LRUQueryCache.java:589)\n   [junit4]    > \tat org.apache.lucene.search.Weight.bulkScorer(Weight.java:135)\n   [junit4]    > \tat org.apache.lucene.search.AssertingWeight.bulkScorer(AssertingWeight.java:69)\n   [junit4]    > \tat org.apache.lucene.search.AssertingWeight.bulkScorer(AssertingWeight.java:69)\n   [junit4]    > \tat org.apache.lucene.search.IndexSearcher.search(IndexSearcher.java:618)\n   [junit4]    > \tat org.apache.lucene.search.AssertingIndexSearcher.search(AssertingIndexSearcher.java:92)\n   [junit4]    > \tat org.apache.lucene.search.IndexSearcher.search(IndexSearcher.java:425)\n   [junit4]    > \tat org.apache.lucene.bkdtree3d.TestGeo3DPointField$4._run(TestGeo3DPointField.java:587)\n   [junit4]    > \tat org.apache.lucene.bkdtree3d.TestGeo3DPointField$4.run(TestGeo3DPointField.java:521)\n   [junit4]   2> NOTE: test params are: codec=Asserting(Lucene53): {}, docValues:{}, sim=RandomSimilarityProvider(queryNorm=true,coord=crazy): {}, locale=de_GR, timezone=America/Managua\n   [junit4]   2> NOTE: Linux 3.19.0-21-generic amd64/Oracle Corporation 1.8.0_51 (64-bit)/cpus=72,threads=1,free=426307304,total=504889344\n   [junit4]   2> NOTE: All tests run in this JVM: [TestGeo3DPointField]\n\n\n\nI added verbosity and extracted the details:\n\nHere's the query shape:\n\n\n   [junit4]   2> Thread[T0,5,TGRP-TestGeo3DPointField]: TEST: iter=64 shape=GeoCircle: {planetmodel=PlanetModel.WGS84, center=[lat=-7.573175600018171E-4, lon=-0.001184769535031697], radius=0.007585721238160122(0.4346298115093282)}\n\n\n\nBKD switched to addAll when this cell was contained inside the shape:\n\n   [junit4]   1> Thread[T0,5,TGRP-TestGeo3DPointField]: switch to addAll at cell x=1.0010740213026637 to 1.0010824106377934 y=-0.007656353133570567 to -0.007315722331086044 z=-0.0047688666958216885 to -0.0042476080955227875\n\n\n\nBut then this doc (which is within the cell) is supposedly not within the shape:\n\n\n   [junit4]   1> T0:  accept docID=71226 point: x=1.0010781049211872 y=-0.007656353133570567 z=-0.0047688666958216885\n   [junit4]   1> \n   [junit4]   1> T0: FAILED: docID=71226\n\n "
        },
        {
            "id": "comment-14712212",
            "author": "Karl Wright",
            "date": "2015-08-25T23:59:08+0000",
            "content": "This one is different.  Basically, this time the XYZSolid is definitely within the GeoCircle.  So the membership operation between the point and the circle is failing but should not be.  Evaluating the circle plane at the point yields: 1.1158007851008733E-10, which is indeed outside the shape value.  But, the point is clearly not quite on the surface, so that can happen.\n\nSo here we have a case where the packing resolution is definitely causing the assertion failure.\n\nWhat I think better behavior might be is to simply disable the assert.  This will mean that points that are technically outside the shape will still get returned once in a while, but I imagine that this would basically just wind up making the boundary a bit fuzzy.  I could add a method that would check for membership at a lower resolution but that's a fair bit of work just to support the one assertion.\n\nThoughts? "
        },
        {
            "id": "comment-14712793",
            "author": "Michael McCandless",
            "date": "2015-08-26T09:28:01+0000",
            "content": "OK I'll disable this assert: it is too anal. "
        },
        {
            "id": "comment-14713598",
            "author": "Michael McCandless",
            "date": "2015-08-26T14:55:12+0000",
            "content": "Oh wait, we need to do more than simply disable the assert, because the test will still fail, just a bit later when it verifies all hits (the assert was just \"early detection\"):\n\n\n   [junit4] Suite: org.apache.lucene.bkdtree3d.TestGeo3DPointField\n   [junit4]   2> Aug 26, 2015 8:48:39 AM com.carrotsearch.randomizedtesting.RandomizedRunner$QueueUncaughtExceptionsHandler uncaughtException\n   [junit4]   2> WARNING: Uncaught exception in thread: Thread[T0,5,TGRP-TestGeo3DPointField]\n   [junit4]   2> java.lang.AssertionError: T0: iter=63 id=71226 docID=71226 lat=-0.004763555725376775 lon=-0.0076479587074575126 expected false but got: true deleted?=false\n   [junit4]   2>   point1=[lat=-0.004763555725376775, lon=-0.0076479587074575126], iswithin=true\n   [junit4]   2>   point2=[X=1.0010781049211872, Y=-0.007656353133570567, Z=-0.0047688666958216885], iswithin=false\n   [junit4]   2>   query=PointInGeo3DShapeQuery: field=point:PlanetModel: PlanetModel.WGS84 Shape: GeoCircle: {planetmodel=PlanetModel.WGS84, center=[lat=-7.573175600018171E-4, lon=-0.001184769535031697], radius=0.007585721238160122(0.4346298115093282)}\n   [junit4]   2> \tat __randomizedtesting.SeedInfo.seed([D75138C6C25D1BCF]:0)\n   [junit4]   2> \tat org.junit.Assert.fail(Assert.java:93)\n   [junit4]   2> \tat org.apache.lucene.bkdtree3d.TestGeo3DPointField$4._run(TestGeo3DPointField.java:625)\n   [junit4]   2> \tat org.apache.lucene.bkdtree3d.TestGeo3DPointField$4.run(TestGeo3DPointField.java:521)\n   [junit4]   2> \n   [junit4]   2> Aug 26, 2015 8:48:40 AM com.carrotsearch.randomizedtesting.RandomizedRunner$QueueUncaughtExceptionsHandler uncaughtException\n   [junit4]   2> WARNING: Uncaught exception in thread: Thread[T2,5,TGRP-TestGeo3DPointField]\n   [junit4]   2> java.lang.AssertionError: T2: iter=62 id=71226 docID=71226 lat=-0.004763555725376775 lon=-0.0076479587074575126 expected false but got: true deleted?=false\n   [junit4]   2>   point1=[lat=-0.004763555725376775, lon=-0.0076479587074575126], iswithin=true\n   [junit4]   2>   point2=[X=1.0010781049211872, Y=-0.007656353133570567, Z=-0.0047688666958216885], iswithin=false\n   [junit4]   2>   query=PointInGeo3DShapeQuery: field=point:PlanetModel: PlanetModel.WGS84 Shape: GeoCircle: {planetmodel=PlanetModel.WGS84, center=[lat=-7.573175600018171E-4, lon=-0.001184769535031697], radius=0.007585721238160122(0.4346298115093282)}\n   [junit4]   2> \tat __randomizedtesting.SeedInfo.seed([D75138C6C25D1BCF]:0)\n   [junit4]   2> \tat org.junit.Assert.fail(Assert.java:93)\n   [junit4]   2> \tat org.apache.lucene.bkdtree3d.TestGeo3DPointField$4._run(TestGeo3DPointField.java:625)\n   [junit4]   2> \tat org.apache.lucene.bkdtree3d.TestGeo3DPointField$4.run(TestGeo3DPointField.java:521)\n   [junit4]   2> \n   [junit4]   2> NOTE: reproduce with: ant test  -Dtestcase=TestGeo3DPointField -Dtests.method=testRandomMedium -Dtests.seed=D75138C6C25D1BCF -Dtests.multiplier=10 -Dtests.slow=true -Dtests.locale=de_GR -Dtests.timezone=America/Managua -Dtests.asserts=true -Dtests.file.encoding=US-ASCII\n   [junit4] ERROR   62.4s | TestGeo3DPointField.testRandomMedium <<<\n\n\n\nSo how to correspondingly fix the test?  Right now, in (intentionally) quantizes the double x,y,z of the point to match what the doc values pack/unpack did ...\n\nMaybe, we could just fix the test so that if isWithin differs between the quantized and unquantized x,y,z, we skip checking that hit? "
        },
        {
            "id": "comment-14714399",
            "author": "Karl Wright",
            "date": "2015-08-26T16:02:56+0000",
            "content": "Michael McCandless Yes, that should do it.  If you have both, anyways.  "
        },
        {
            "id": "comment-14715191",
            "author": "David Smiley",
            "date": "2015-08-26T17:25:28+0000",
            "content": "Maybe, we could just fix the test so that if isWithin differs between the quantized and unquantized x,y,z, we skip checking that hit?\n\nYes; this is also the approach done RandomSpatialOpFuzzyPrefixTreeTest.  The \"fuzzy\" in the name here because of the issue being discussed. "
        },
        {
            "id": "comment-14715397",
            "author": "Karl Wright",
            "date": "2015-08-26T19:48:56+0000",
            "content": "ok, I'm finally done travelling for the moment.  Michael McCandless, where do things stand?  I notice that my latest patch didn't get committed, FWIW.  Also, do you want me to implement your idea of having both isWithin's need to pass before the assert triggers? "
        },
        {
            "id": "comment-14715521",
            "author": "Michael McCandless",
            "date": "2015-08-26T21:09:41+0000",
            "content": "Ugh sorry I thought I had committed the latest patch ... I'll do that shortly.\n\nAnd I'll also fix the test to skip checking a hit when the quantization changed the expected result... "
        },
        {
            "id": "comment-14715623",
            "author": "Michael McCandless",
            "date": "2015-08-26T22:12:26+0000",
            "content": "OK I committed, beasted, hit this failure:\n\n\nant test  -Dtestcase=TestGeo3DPointField -Dtests.method=testRandomMedium* -Dtests.seed=E1D51F3E8B12E79D -Dtests.multiplier=10 -Dtests.iters=5 -Dtests.slow=true -Dtests.linedocsfile=/lucenedata/hudson.enwiki.random.lines.txt.fixed -Dtests.locale=pl -Dtests.timezone=America/Inuvik -Dtests.asserts=true -Dtests.file.encoding=UTF-8\n\n[junit4:pickseed] Seed property 'tests.seed' already defined: E1D51F3E8B12E79D\n   [junit4] <JUnit4> says \u4eca\u65e5\u306f! Master seed: E1D51F3E8B12E79D\n   [junit4] Executing 1 suite with 1 JVM.\n   [junit4] \n   [junit4] Started J0 PID(62227@localhost).\n   [junit4] Suite: org.apache.lucene.bkdtree3d.TestGeo3DPointField\n   [junit4] OK      70.2s | TestGeo3DPointField.testRandomMedium {#0 seed=[E1D51F3E8B12E79D:5C0B2896CA7784FB]}\n   [junit4]   2> sie 26, 2015 4:11:15 PM com.carrotsearch.randomizedtesting.RandomizedRunner$QueueUncaughtExceptionsHandler uncaughtException\n   [junit4]   2> WARNING: Uncaught exception in thread: Thread[T0,5,TGRP-TestGeo3DPointField]\n   [junit4]   2> java.lang.AssertionError: T0: iter=425 id=1237 docID=1237 lat=0.005231514023315527 lon=0.0034278119211296914 expected false but got: true deleted?=false\n   [junit4]   2>   point1=[lat=0.005231514023315527, lon=0.0034278119211296914], iswithin=false\n   [junit4]   2>   point2=[X=1.0010991445151618, Y=0.003431592678386528, Z=0.00523734247369568], iswithin=false\n   [junit4]   2>   query=PointInGeo3DShapeQuery: field=point:PlanetModel: PlanetModel.WGS84 Shape: GeoCircle: {planetmodel=PlanetModel.WGS84, center=[lat=0.006204988457123483, lon=0.003379977917811208], radius=7.780831828380698E-4(0.04458088248672737)}\n   [junit4]   2> \tat __randomizedtesting.SeedInfo.seed([E1D51F3E8B12E79D]:0)\n   [junit4]   2> \tat org.junit.Assert.fail(Assert.java:93)\n   [junit4]   2> \tat org.apache.lucene.bkdtree3d.TestGeo3DPointField$4._run(TestGeo3DPointField.java:632)\n   [junit4]   2> \tat org.apache.lucene.bkdtree3d.TestGeo3DPointField$4.run(TestGeo3DPointField.java:521)\n\n "
        },
        {
            "id": "comment-14715658",
            "author": "Karl Wright",
            "date": "2015-08-26T22:43:29+0000",
            "content": "So I tried to reproduce this in geo3d-land exclusively, and coded this:\n\n\n    c = new GeoCircle(PlanetModel.WGS84,0.006204988457123483,0.003379977917811208,7.780831828380698E-4);\n    p1 = new GeoPoint(PlanetModel.WGS84,0.005231514023315527,0.0034278119211296914);\n    assertTrue(!c.isWithin(p1));\n    xyzb = new XYZBounds();\n    c.getBounds(xyzb);\n    area = GeoAreaFactory.makeGeoArea(PlanetModel.WGS84, \n      xyzb.getMinimumX(), xyzb.getMaximumX(), xyzb.getMinimumY(), xyzb.getMaximumY(), xyzb.getMinimumZ(), xyzb.getMaximumZ());\n    // Doesn't have to be true, but is...\n    assertTrue(!area.isWithin(p1));\n\n\n\n\nThe exact point in question shows up as outside of even the bounds computed for the circle.  So honestly I don't know how it wound up getting included?  Unless, perhaps, the descent decisions were made based on the approximation?\n\nLooking at the code to see how to delve deeper... "
        },
        {
            "id": "comment-14715680",
            "author": "Karl Wright",
            "date": "2015-08-26T23:00:12+0000",
            "content": "Huh. Even odder, tried the \"repro\" line and got this:\n\n\nant test  -Dtestcase=TestGeo3DPointField -Dtests.method=testRandomMedium* -Dtests.seed=E1D51F3E8B12E79D -Dtests.multiplier=10 -Dtests.iters=5 -Dtests.slow=true -Dtests.linedocsfile=/lucenedata/hudson.enwiki.random.lines.txt.fixed -Dtests.locale=pl -Dtests.timezone=America/Inuvik -Dtests.asserts=true -Dtests.file.encoding=UTF-8\n\n...\n\nBUILD SUCCESSFUL\nTotal time: 13 minutes 14 seconds\n\n\n\nSo now I'm very puzzled, Michael McCandless. "
        },
        {
            "id": "comment-14715759",
            "author": "Karl Wright",
            "date": "2015-08-26T23:44:57+0000",
            "content": "I did a repeat run, being sure to \"ant clean\" first, and it still passed.\n\nHmm. "
        },
        {
            "id": "comment-14716268",
            "author": "Michael McCandless",
            "date": "2015-08-27T08:24:56+0000",
            "content": "Grrr, also not consistently reproducing for me ... it does repro on one box but not another; odd.  On differences is Java 1.8.0_51 vs 1.8.0_40 ...\n\nI'll turn on the debugging prints and try to get more details about the BKD descent. "
        },
        {
            "id": "comment-14716278",
            "author": "Michael McCandless",
            "date": "2015-08-27T08:38:09+0000",
            "content": "Ugh, I take that back: after ant clean I cannot reproduce the failure anymore ... I'll re-beast.\n\nBut one thing did occur to me: I think we may have an ob1 when we compute the cell that BKD asks geo3d to compare to the shape.\n\nThe cell is bounded by x/y/zMin,Max 32 bit values, but these are all inclusive, and because of the quantization, each of those values represents a range of values in 64 bit space, and so I think for the max values we need to do +1 before converting back to doubles? "
        },
        {
            "id": "comment-14716303",
            "author": "Michael McCandless",
            "date": "2015-08-27T08:52:36+0000",
            "content": "Here's a patch showing how I think we should fix the ob1 issue.... "
        },
        {
            "id": "comment-14716491",
            "author": "Karl Wright",
            "date": "2015-08-27T11:16:58+0000",
            "content": "Hi Michael McCandless: Patch has the right idea but should deal with negative numbers reasonably also?  Unless, of course, your mapping to signed doubles starts with an int value that is always positive.  "
        },
        {
            "id": "comment-14716565",
            "author": "Michael McCandless",
            "date": "2015-08-27T12:17:49+0000",
            "content": "Karl Wright Ahh you're right, it must also subtract one from the mins when they are negative!  I'll fix ... "
        },
        {
            "id": "comment-14716567",
            "author": "Michael McCandless",
            "date": "2015-08-27T12:18:54+0000",
            "content": "Here's a newish looking failure (repros even after ant clean with the previous patch I attached):\n\n\n   [junit4] Started J0 PID(48425@localhost).\n   [junit4] Suite: org.apache.lucene.bkdtree3d.TestGeo3DPointField\n   [junit4]   2> ao\u00fbt 27, 2015 4:16:47 AM com.carrotsearch.randomizedtesting.RandomizedRunner$QueueUncaughtExceptionsHandler uncaughtException\n   [junit4]   2> WARNING: Uncaught exception in thread: Thread[T0,5,TGRP-TestGeo3DPointField]\n   [junit4]   2> java.lang.RuntimeException: java.lang.NullPointerException\n   [junit4]   2> \tat __randomizedtesting.SeedInfo.seed([9B02953CBA892483]:0)\n   [junit4]   2> \tat org.apache.lucene.bkdtree3d.TestGeo3DPointField$4.run(TestGeo3DPointField.java:524)\n   [junit4]   2> Caused by: java.lang.NullPointerException\n   [junit4]   2> \tat org.apache.lucene.geo3d.BaseXYZSolid.isWithin(BaseXYZSolid.java:82)\n   [junit4]   2> \tat org.apache.lucene.geo3d.BaseXYZSolid.isShapeInsideArea(BaseXYZSolid.java:111)\n   [junit4]   2> \tat org.apache.lucene.geo3d.XYZSolid.getRelationship(XYZSolid.java:267)\n   [junit4]   2> \tat org.apache.lucene.bkdtree3d.PointInGeo3DShapeQuery$1.scorer(PointInGeo3DShapeQuery.java:105)\n   [junit4]   2> \tat org.apache.lucene.search.LRUQueryCache$CachingWrapperWeight.scorer(LRUQueryCache.java:589)\n   [junit4]   2> \tat org.apache.lucene.search.Weight.bulkScorer(Weight.java:135)\n   [junit4]   2> \tat org.apache.lucene.search.AssertingWeight.bulkScorer(AssertingWeight.java:69)\n   [junit4]   2> \tat org.apache.lucene.search.AssertingWeight.bulkScorer(AssertingWeight.java:69)\n   [junit4]   2> \tat org.apache.lucene.search.IndexSearcher.search(IndexSearcher.java:618)\n   [junit4]   2> \tat org.apache.lucene.search.AssertingIndexSearcher.search(AssertingIndexSearcher.java:92)\n   [junit4]   2> \tat org.apache.lucene.search.IndexSearcher.search(IndexSearcher.java:425)\n   [junit4]   2> \tat org.apache.lucene.bkdtree3d.TestGeo3DPointField$4._run(TestGeo3DPointField.java:587)\n   [junit4]   2> \tat org.apache.lucene.bkdtree3d.TestGeo3DPointField$4.run(TestGeo3DPointField.java:521)\n   [junit4]   2> \n   [junit4]   2> NOTE: reproduce with: ant test  -Dtestcase=TestGeo3DPointField -Dtests.method=testRandomTiny -Dtests.seed=9B02953CBA892483 -Dtests.multiplier=5 -Dtests.slow=true -Dtests.linedocsfile=/lucenedata/hudson.enwiki.random.lines.txt.fixed -Dtests.locale=fr_LU -Dtests.timezone=America/Juneau -Dtests.asserts=true -Dtests.file.encoding=UTF-8\n\n "
        },
        {
            "id": "comment-14716592",
            "author": "Karl Wright",
            "date": "2015-08-27T12:43:32+0000",
            "content": "This is a circle that did not initialize properly, probably due to edge effects once again.  I bet the radius is miniscule.  I'll chase it down. "
        },
        {
            "id": "comment-14716601",
            "author": "Karl Wright",
            "date": "2015-08-27T12:49:00+0000",
            "content": "Yup, tiny:\n\n\n   [junit4]    > Caused by: java.lang.RuntimeException: java.lang.RuntimeException: Null path point! Shape = GeoCircle: {planetmodel=PlanetModel.SPHERE, center=[lat=-0.006204510641448213, lon=0.004660366014742108], radius=1.2622491508618621E-8(7.232154903835664E-7)}\n\n\n\nIt's still three orders of magnitude larger than the limit, but when things get that small the math gets less stable.  I am tempted to catch these things during construction of the GeoCircle and throw an IllegalArgumentException whenever the math falls apart.  It's unlikely that anyone in the real world, except for missile designers, would be interested in centimeter resolution anyway.   What do you think?\n "
        },
        {
            "id": "comment-14716613",
            "author": "Michael McCandless",
            "date": "2015-08-27T13:02:16+0000",
            "content": "+1\n\nLet's hope missile designers don't try to use this  "
        },
        {
            "id": "comment-14716631",
            "author": "Karl Wright",
            "date": "2015-08-27T13:13:18+0000",
            "content": "Michael McCandless Here's a patch that throws IllegalArgumentException when we try to construct a GeoCircle but it cannot resolve what it needs.  Test still fails but perhaps you can detect IllegalArgumentException and act accordingly? "
        },
        {
            "id": "comment-14716635",
            "author": "Michael McCandless",
            "date": "2015-08-27T13:14:50+0000",
            "content": "Thanks Karl Wright, I'll commit this and fix the test ... "
        },
        {
            "id": "comment-14716724",
            "author": "Michael McCandless",
            "date": "2015-08-27T14:09:27+0000",
            "content": "OK here's another attempt to deal with the quantization (properly handling negative numbers I think?) during BKD descent ... "
        },
        {
            "id": "comment-14716755",
            "author": "Karl Wright",
            "date": "2015-08-27T14:23:41+0000",
            "content": "Looks ok, except this doesn't seem like it should be there anymore:\n\n\n+                                             if (cellXMaxEnc < Integer.MAX_VALUE) {\n+                                               cellXMaxEnc++;\n+                                             }\n+                                             if (cellYMaxEnc < Integer.MAX_VALUE) {\n+                                               cellYMaxEnc++;\n+                                             }\n+                                             if (cellZMaxEnc < Integer.MAX_VALUE) {\n+                                               cellZMaxEnc++;\n+                                             }\n+\n\n\n\nIt seems like the cell*MaxEnc and cell*MinEnc values are all positive integers?\n "
        },
        {
            "id": "comment-14716847",
            "author": "Michael McCandless",
            "date": "2015-08-27T15:25:34+0000",
            "content": "Duh, I'll remove that old code, you're right.\n\nIt seems like the cell*MaxEnc and cell*MinEnc values are all positive integers?\n\nArgh, you're right.  x,y,z are always >= 0.0 right (and <= PlanetModel.getMaximumMagnitude())?  So we are only using 31 bits now ... I don't like that.  I'll fix the encoding to use all 32 bits. "
        },
        {
            "id": "comment-14716861",
            "author": "Michael McCandless",
            "date": "2015-08-27T15:31:35+0000",
            "content": "x,y,z are always >= 0.0 right\n\nWait, they are not \n\nThe planet models have the earth's center at the origin, so they span +/- 1.0 for the simple sphere (and a bit bigger for the squashed elipsoid)?\n\nSo I think we are in fact using the full 32 bit space now, and the int values are sometimes negative... "
        },
        {
            "id": "comment-14716870",
            "author": "Michael McCandless",
            "date": "2015-08-27T15:34:53+0000",
            "content": "OK I committed the last patch (after removing the old code), and I also changed the encoding max to be exactly WGS84's max.  I'll restart beasting... "
        },
        {
            "id": "comment-14716888",
            "author": "Michael McCandless",
            "date": "2015-08-27T15:39:41+0000",
            "content": "I also changed the encoding max to be exactly WGS84's max.\n\nHmm, this is now causing test failures, like this:\n\n\n   [junit4]   2> \u0622\u0628 27, 2015 11:37:34 \u0635 com.carrotsearch.randomizedtesting.RandomizedRunner$QueueUncaughtExceptionsHandler uncaughtException\n   [junit4]   2> WARNING: Uncaught exception in thread: Thread[T1,5,TGRP-TestGeo3DPointField]\n   [junit4]   2> java.lang.RuntimeException: java.lang.IllegalArgumentException: value=1.0011188430720466 is out-of-bounds (greater than MAX_VALUE=1.0011188180735464)\n   [junit4]   2> \tat __randomizedtesting.SeedInfo.seed([8CCB7BD6BCA68E54]:0)\n   [junit4]   2> \tat org.apache.lucene.bkdtree3d.TestGeo3DPointField$4.run(TestGeo3DPointField.java:524)\n   [junit4]   2> Caused by: java.lang.IllegalArgumentException: value=1.0011188430720466 is out-of-bounds (greater than MAX_VALUE=1.0011188180735464)\n   [junit4]   2> \tat org.apache.lucene.bkdtree3d.Geo3DDocValuesFormat.encodeValue(Geo3DDocValuesFormat.java:127)\n   [junit4]   2> \tat org.apache.lucene.bkdtree3d.PointInGeo3DShapeQuery$1.scorer(PointInGeo3DShapeQuery.java:115)\n   [junit4]   2> \tat org.apache.lucene.search.LRUQueryCache$CachingWrapperWeight.scorer(LRUQueryCache.java:581)\n   [junit4]   2> \tat org.apache.lucene.search.Weight.bulkScorer(Weight.java:135)\n   [junit4]   2> \tat org.apache.lucene.search.AssertingWeight.bulkScorer(AssertingWeight.java:69)\n   [junit4]   2> \tat org.apache.lucene.search.AssertingWeight.bulkScorer(AssertingWeight.java:69)\n   [junit4]   2> \tat org.apache.lucene.search.IndexSearcher.search(IndexSearcher.java:618)\n   [junit4]   2> \tat org.apache.lucene.search.AssertingIndexSearcher.search(AssertingIndexSearcher.java:92)\n   [junit4]   2> \tat org.apache.lucene.search.IndexSearcher.search(IndexSearcher.java:425)\n   [junit4]   2> \tat org.apache.lucene.bkdtree3d.TestGeo3DPointField$4._run(TestGeo3DPointField.java:592)\n   [junit4]   2> \tat org.apache.lucene.bkdtree3d.TestGeo3DPointField$4.run(TestGeo3DPointField.java:521)\n   [junit4]   2> \n   [junit4]   2> NOTE: reproduce with: ant test  -Dtestcase=TestGeo3DPointField -Dtests.method=testRandomTiny -Dtests.seed=8CCB7BD6BCA68E54 -Dtests.multiplier=5 -Dtests.slow=true -Dtests.linedocsfile=/lucenedata/hudson.enwiki.random.lines.txt.fixed -Dtests.locale=ar_LB -Dtests.timezone=US/East-Indiana -Dtests.asserts=true -Dtests.file.encoding=UTF-8\n\n\n\nSo at first I thought it's because we do the +/- 2 * MINIMUM_RESOLUTION on the top bbox to the BKD tree, so I fixed Geo3DDocValuesFormat.encodeValue to use a max of +/- 5 * MINIMUM_RESOLUTION, but the test is still failing.  I guess the math that computes a bounding box for a shape can go beyond the planet model's min/max?  I'll just add back in a min/max to make sure it's bounded by the planet's bounds ... "
        },
        {
            "id": "comment-14716898",
            "author": "Karl Wright",
            "date": "2015-08-27T15:48:44+0000",
            "content": "Ok, the reason I was asking was because if the integer can go negative, your code seems unable to handle \"roundUp\" and \"roundDown\" right in that case.  "
        },
        {
            "id": "comment-14716908",
            "author": "Karl Wright",
            "date": "2015-08-27T15:53:35+0000",
            "content": "Hmm, I think I'd try to give some leeway here.  The XYZBounds FUDGE_FACTOR definitely contributes to bounds being outside of the planet min and max.  "
        },
        {
            "id": "comment-14716913",
            "author": "Michael McCandless",
            "date": "2015-08-27T15:55:22+0000",
            "content": "Ok, the reason I was asking was because if the integer can go negative, your code seems unable to handle \"roundUp\" and \"roundDown\" right in that case. \n\nUh oh, I tried to handle that in what I committed \n\nCan you make a patch correcting it? "
        },
        {
            "id": "comment-14716983",
            "author": "Karl Wright",
            "date": "2015-08-27T16:25:15+0000",
            "content": "Michael McCandless In fact, I would take -2.0 to 2.0 as the min/max values for your encoding.  You'll still use all the bits, just not quite as efficiently. \n "
        },
        {
            "id": "comment-14717032",
            "author": "Michael McCandless",
            "date": "2015-08-27T16:48:11+0000",
            "content": "Hmm, why so much waste?  This would mean each \"pixel\" is almost 2X larger than it needs to be, at least by current needs, right?\n\nWhat earth surface resolution would this quantization translate to?\n\nOr are you thinking of other \"much more squashed\" planets use cases? "
        },
        {
            "id": "comment-14717040",
            "author": "Michael McCandless",
            "date": "2015-08-27T16:51:30+0000",
            "content": "Maybe instead ...\n\nWe shouldn't make a hardwired max for the encoding?  We could require a PlanetModel to Geo3DDVFormat at indexing time, pull the max value at that point, write that into the DV files, and use that for decoding at search time (and, to confirm the PlanetModel used at search time is likely the same used at index time)...\n\nThis seems safer. "
        },
        {
            "id": "comment-14717042",
            "author": "Karl Wright",
            "date": "2015-08-27T16:52:19+0000",
            "content": "Ok, remember that this is logarithmic.  With -2.0 to 2.0, you are wasting most of a single bit.  But if you pick -1.25 to 1.25, you waste very little (25% of a bit at most).\n\nI am worried a little that we'd require a reindexing if we adjusted any of the PlanetModel parameters by even a tiny bit.  Best leave a little slack.  Even -1.10 to 1.10 would be probably fine... "
        },
        {
            "id": "comment-14717048",
            "author": "Karl Wright",
            "date": "2015-08-27T16:54:10+0000",
            "content": "Ah, missed this reply.\n\nYes, this sounds good, PROVIDED we don't assert anywhere that XYZBounds has to be within the planetary min/max value. "
        },
        {
            "id": "comment-14717054",
            "author": "Karl Wright",
            "date": "2015-08-27T16:55:58+0000",
            "content": "I can't handle it until I know what the rounding is doing.\n\nIf you have an integer value of -2, say, and you do a \"roundUp()\" on it, what value do you want to get back?  How about a \"roundDown()\"?\n "
        },
        {
            "id": "comment-14717159",
            "author": "Michael McCandless",
            "date": "2015-08-27T17:47:17+0000",
            "content": "I am worried a little that we'd require a reindexing if we adjusted any of the PlanetModel parameters by even a tiny bit. \n\nWell, if we write the max into the index, and check that at search time, which I think is important, so we catch accidental mise-use, then we cannot change an existing PlanetModel, i.e. we would have to make a new PlanetModel if the old one needs fixing. "
        },
        {
            "id": "comment-14717163",
            "author": "Michael McCandless",
            "date": "2015-08-27T17:48:37+0000",
            "content": "Even -1.10 to 1.10 would be probably fine...\n\nWell I had 1.002 before but the waste even with that makes no sense to me.\n\nWhy not have the lowest quantization error you can? "
        },
        {
            "id": "comment-14717174",
            "author": "Michael McCandless",
            "date": "2015-08-27T17:56:50+0000",
            "content": "I can't handle it until I know what the rounding is doing.\n\nThat logic needs to \"reverse\" the quantizing done by Geo3DDVFormat.encodeValue, when passed a bounding box in quantized space, to translate it into a containing bbox in unquantized space.\n\nThe min/max (quantized) values are inclusive values, and a single value in quantized space (a pixel) is really a volume in unquantized space, so we have to move the boundaries of the bbox to the outer volume of the edges of the quantized bbox ...\n\nI thought I did it correctly in what's committed but probably not  "
        },
        {
            "id": "comment-14717175",
            "author": "Karl Wright",
            "date": "2015-08-27T17:56:59+0000",
            "content": "Generally I agree; I responded in kind above, with the caveat that we don't treat XYZ bounds that are outside of the maximum encoding bounds as being illegal.  "
        },
        {
            "id": "comment-14717178",
            "author": "Michael McCandless",
            "date": "2015-08-27T17:58:54+0000",
            "content": "OK I'll try to change the DV format to record the max into the index. "
        },
        {
            "id": "comment-14717195",
            "author": "Karl Wright",
            "date": "2015-08-27T18:07:16+0000",
            "content": "Ok, I will check it with that in mind when my current meeting is done. "
        },
        {
            "id": "comment-14717707",
            "author": "Karl Wright",
            "date": "2015-08-27T22:56:21+0000",
            "content": "Michael McCandless: So, your code:\n\n\n    long y = (long) (x * (Integer.MAX_VALUE / max));\n\n\n\n... can be rewritten:\n\n\n    long y = (long) (x / max * Integer.MAX_VALUE);\n\n\n\nSo it is basically scaling so that Integer.MAX_VALUE is returned for a value of max.  So far so good.\n\nBut in order to do that, it's rounding down for positive numbers, and rounding up for negative ones.  So:\n\n1.5 -> 1\n1.1 -> 1\n1.9 -> 1\n2.1 -> 2\n-1.5 -> -1\n-1.9 -> -1\n\nBut:\n0.9 -> 0\n-0.9 -> 0\n\nSo, the cell at 0 is in fact representing a range that is twice as great as the cell at 1 or the cell at -1.  I'm not sure you really want that. \n\n\n\n "
        },
        {
            "id": "comment-14717900",
            "author": "Karl Wright",
            "date": "2015-08-28T01:58:50+0000",
            "content": "I had a very challenging day, but tomorrow I may have some time to propose an actual patch, if you are interested.  "
        },
        {
            "id": "comment-14718188",
            "author": "Michael McCandless",
            "date": "2015-08-28T08:11:34+0000",
            "content": "New failure, reproduces for me even after ant clean:\n\n\n    [mkdir] Created dir: /l/3dbkd/lucene/build/spatial3d/test\n[junit4:pickseed] Seed property 'tests.seed' already defined: 4E8589FB677FE9DD\n    [mkdir] Created dir: /l/3dbkd/lucene/build/spatial3d/test/temp\n   [junit4] <JUnit4> says \u05e9\u05dc\u05d5\u05dd! Master seed: 4E8589FB677FE9DD\n   [junit4] Executing 1 suite with 1 JVM.\n   [junit4] \n   [junit4] Started J0 PID(20396@localhost).\n   [junit4] Suite: org.apache.lucene.bkdtree3d.TestGeo3DPointField\n   [junit4]   2> \u0e2a.\u0e04. \u0e52\u0e58, \u0e52\u0e55\u0e55\u0e58 \u0e51:\u0e50\u0e59:\u0e52\u0e51 \u0e01\u0e48\u0e2d\u0e19\u0e40\u0e17\u0e35\u0e48\u0e22\u0e07 com.carrotsearch.randomizedtesting.RandomizedRunner$QueueUncaughtExceptionsHandler uncaughtException\n   [junit4]   2> WARNING: Uncaught exception in thread: Thread[T3,5,TGRP-TestGeo3DPointField]\n   [junit4]   2> java.lang.AssertionError: T3: iter=131 id=262776 docID=262776 lat=0.007197150578698408 lon=0.0010389455251423893 expected false but got: true deleted?=false\n   [junit4]   2>   point1=[lat=0.007197150578698408, lon=0.0010389455251423893], iswithin=false\n   [junit4]   2>   point2=[X=0.9999735606834169, Y=0.0010389182721445888, Z=0.007197088099642232], iswithin=false\n   [junit4]   2>   query=PointInGeo3DShapeQuery: field=point:PlanetModel: PlanetModel.SPHERE Shape: GeoCircle: {planetmodel=PlanetModel.SPHERE, center=[lat=0.004729080495762766, lon=-7.023094095867159E-5], radius=0.002549346432178953(0.14606679108058837)}\n   [junit4]   2> \tat __randomizedtesting.SeedInfo.seed([4E8589FB677FE9DD]:0)\n   [junit4]   2> \tat org.junit.Assert.fail(Assert.java:93)\n   [junit4]   2> \tat org.apache.lucene.bkdtree3d.TestGeo3DPointField$4._run(TestGeo3DPointField.java:668)\n   [junit4]   2> \tat org.apache.lucene.bkdtree3d.TestGeo3DPointField$4.run(TestGeo3DPointField.java:552)\n   [junit4]   2> \n   [junit4]   2> \u0e2a.\u0e04. \u0e52\u0e58, \u0e52\u0e55\u0e55\u0e58 \u0e51:\u0e50\u0e59:\u0e52\u0e51 \u0e01\u0e48\u0e2d\u0e19\u0e40\u0e17\u0e35\u0e48\u0e22\u0e07 com.carrotsearch.randomizedtesting.RandomizedRunner$QueueUncaughtExceptionsHandler uncaughtException\n   [junit4]   2> WARNING: Uncaught exception in thread: Thread[T0,5,TGRP-TestGeo3DPointField]\n   [junit4]   2> java.lang.AssertionError: T0: iter=133 id=262776 docID=262776 lat=0.007197150578698408 lon=0.0010389455251423893 expected false but got: true deleted?=false\n   [junit4]   2>   point1=[lat=0.007197150578698408, lon=0.0010389455251423893], iswithin=false\n   [junit4]   2>   point2=[X=0.9999735606834169, Y=0.0010389182721445888, Z=0.007197088099642232], iswithin=false\n   [junit4]   2>   query=PointInGeo3DShapeQuery: field=point:PlanetModel: PlanetModel.SPHERE Shape: GeoCircle: {planetmodel=PlanetModel.SPHERE, center=[lat=0.004729080495762766, lon=-7.023094095867159E-5], radius=0.002549346432178953(0.14606679108058837)}\n   [junit4]   2> \tat __randomizedtesting.SeedInfo.seed([4E8589FB677FE9DD]:0)\n   [junit4]   2> \tat org.junit.Assert.fail(Assert.java:93)\n   [junit4]   2> \tat org.apache.lucene.bkdtree3d.TestGeo3DPointField$4._run(TestGeo3DPointField.java:668)\n   [junit4]   2> \tat org.apache.lucene.bkdtree3d.TestGeo3DPointField$4.run(TestGeo3DPointField.java:552)\n   [junit4]   2> \n   [junit4]   2> NOTE: reproduce with: ant test  -Dtestcase=TestGeo3DPointField -Dtests.method=testRandomBig -Dtests.seed=4E8589FB677FE9DD -Dtests.nightly=true -Dtests.slow=true -Dtests.linedocsfile=/lucenedata/hudson.enwiki.random.lines.txt.fixed -Dtests.locale=th_TH_TH_#u-nu-thai -Dtests.timezone=Etc/GMT+7 -Dtests.asserts=true -Dtests.file.encoding=UTF-8\n\n "
        },
        {
            "id": "comment-14718244",
            "author": "Karl Wright",
            "date": "2015-08-28T09:06:13+0000",
            "content": "Hi Mike,\n\nThis code demonstrates the arrangement, as far as I have been able to research so far:\n\n\n    c = new GeoCircle(PlanetModel.SPHERE,0.004729080495762766,-7.023094095867159E-5,0.002549346432178953);\n    p1 = new GeoPoint(PlanetModel.SPHERE,0.007197150578698408,0.0010389455251423893);\n    assertTrue(!c.isWithin(p1));\n    xyzb = new XYZBounds();\n    c.getBounds(xyzb);\n    area = GeoAreaFactory.makeGeoArea(PlanetModel.SPHERE, \n      xyzb.getMinimumX(), xyzb.getMaximumX(), xyzb.getMinimumY(), xyzb.getMaximumY(), xyzb.getMinimumZ(), xyzb.getMaximumZ());\n    relationship = area.getRelationship(c);\n    assertTrue(relationship == GeoArea.OVERLAPS || relationship == GeoArea.WITHIN);\n    // Point is actually inside the bounds, but outside the shape\n    assertTrue(area.isWithin(p1));\n\n\n\nSo somewhere along the line during the bkd descent for the point in question, the point is being included when it shouldn't be, possibly because a CONTAINS result is being returned for a subarea.  But we don't yet know what that is.\n\nMichael McCandless, what I think we need for debugging situations of this kind is a test method that can be called that starts with a shape and descends solely with the view of analyzing a single provided point.  It may be that your architecture works great for this already, but I'm not sure.  For the moment I'm going to try assuming that the problem is a CONTAINS result that should have been an OVERLAPS, and adjusting the MINIMUM_RESOLUTION etc.\n "
        },
        {
            "id": "comment-14718250",
            "author": "Karl Wright",
            "date": "2015-08-28T09:14:30+0000",
            "content": "Adjusting MINIMUM_RESOLUTION by a full order of magnitude does not provide any relief, so we're going to need that debugging assist.\n "
        },
        {
            "id": "comment-14718252",
            "author": "Karl Wright",
            "date": "2015-08-28T09:19:34+0000",
            "content": "I suggest using Math.round() instead of just a cast.  That will keep the numbers well-behaved for both positive and negative.\n\nOf course, your roundUp() and roundDown() methods then also need to change.  Working that out now. "
        },
        {
            "id": "comment-14718279",
            "author": "Karl Wright",
            "date": "2015-08-28T09:37:16+0000",
            "content": "Michael McCandless: This patch fixes the encoding/decoding issues. "
        },
        {
            "id": "comment-14718283",
            "author": "Karl Wright",
            "date": "2015-08-28T09:40:31+0000",
            "content": "It also happens to fix the failing testcase, but that may be accidental.  "
        },
        {
            "id": "comment-14718480",
            "author": "Michael McCandless",
            "date": "2015-08-28T12:37:59+0000",
            "content": "what I think we need for debugging situations of this kind is a test method that can be called that starts with a shape and descends solely with the view of analyzing a single provided point\n\nOr maybe I can make a simple randomized test, not using BKD, that just does something similar as BKD: slices up encoded space, recursing, \"targetting\" the given docID.  This ought to be a more efficient way to ferret out the relation issues, since we don't have to writer/read anything to disk ... I'll see if I can do this. "
        },
        {
            "id": "comment-14718513",
            "author": "Karl Wright",
            "date": "2015-08-28T12:56:26+0000",
            "content": "That would certainly work, yes. "
        },
        {
            "id": "comment-14721050",
            "author": "Michael McCandless",
            "date": "2015-08-29T10:18:19+0000",
            "content": "OK I committed a new test case, testGeo3DRelations.  It tries to do what BKD does (splitting the containing bbox to smaller and smaller cells, checking relations), but w/o actually creating a BKD tree.  It should also be much more easily debugged: from a failing doc, if you run w/ -Dtests.verbose=true, you can trace back to see why that doc was rejected or accepted.  You can trace each cell back with it's parent cell ID.\n\nIt could very well have its own bugs!!  It's a bit hairy.\n\nIt's current failing, e.g.:\n\n\n   [junit4] \n   [junit4] Started J0 PID(25192@localhost).\n   [junit4] Suite: org.apache.lucene.bkdtree3d.TestGeo3DPointField\n   [junit4]   1> doc=609 did not match but should\n   [junit4]   1>   point=[lat=-5.236470872437899E-4, lon=3.992578692654256E-4]\n   [junit4]   1>   quantized=[X=0.99999978300184, Y=3.9925798792357463E-4, Z=-5.236472936922905E-4]\n   [junit4]   1> doc=616 did not match but should\n   [junit4]   1>   point=[lat=5.643216334344694E-4, lon=1.5443991269764145E-4]\n   [junit4]   1>   quantized=[X=0.9999998286366462, Y=1.5443982563653953E-4, Z=5.643214101736999E-4]\n   [junit4]   1> doc=692 did not match but should\n   [junit4]   1>   point=[lat=7.345633383289542E-5, lon=1.4914911140318868E-4]\n   [junit4]   1>   quantized=[X=0.9999999860301614, Y=1.4914898208768525E-4, Z=7.345620546185235E-5]\n   [junit4]   1> doc=724 did not match but should\n   [junit4]   1>   point=[lat=-1.5122222798433137E-4, lon=-3.60525332492502E-4]\n   [junit4]   1>   quantized=[X=0.9999999236315489, Y=-3.6052521334985514E-4, Z=-1.5122210613974468E-4]\n   [junit4]   2> NOTE: reproduce with: ant test  -Dtestcase=TestGeo3DPointField -Dtests.method=testGeo3DRelations -Dtests.seed=7DD33C95035C93C9 -Dtests.slow=true -Dtests.linedocsfile=/lucenedata/hudson.enwiki.random.lines.txt.fixed -Dtests.locale=hu -Dtests.timezone=America/Belize -Dtests.asserts=true -Dtests.file.encoding=UTF-8\n   [junit4] FAILURE 0.11s | TestGeo3DPointField.testGeo3DRelations <<<\n   [junit4]    > Throwable #1: java.lang.AssertionError\n   [junit4]    > \tat __randomizedtesting.SeedInfo.seed([7DD33C95035C93C9:CDAC41018C113D55]:0)\n   [junit4]    > \tat org.apache.lucene.bkdtree3d.TestGeo3DPointField.testGeo3DRelations(TestGeo3DPointField.java:673)\n   [junit4]    > \tat java.lang.Thread.run(Thread.java:745)\n   [junit4]   2> NOTE: test params are: codec=Asserting(Lucene53): {}, docValues:{}, sim=RandomSimilarityProvider(queryNorm=true,coord=yes): {}, locale=hu, timezone=America/Belize\n   [junit4]   2> NOTE: Linux 3.19.0-21-generic amd64/Oracle Corporation 1.8.0_51 (64-bit)/cpus=72,threads=1,free=415285240,total=514850816\n   [junit4]   2> NOTE: All tests run in this JVM: [TestGeo3DPointField]\n   [junit4] Completed [1/1] in 0.42s, 1 test, 1 failure <<< FAILURES!\n\n\n\nWhen I run with verbose, it seems like we are getting an incorrect GeoArea.DISJOINT at one point, causing this doc to be dropped. "
        },
        {
            "id": "comment-14721072",
            "author": "Karl Wright",
            "date": "2015-08-29T11:34:26+0000",
            "content": "That's exactly what is happening.\n\nThis code fails:\n\n\n    c= GeoBBoxFactory.makeGeoBBox(PlanetModel.SPHERE, 0.006607096847842122, -0.002828135860810422, -0.0012934461873348349, 0.006727418645092394);\n    solid = GeoAreaFactory.makeGeoArea(PlanetModel.SPHERE,0.9999995988328008,1.0000000002328306,-0.0012934708508166816,0.006727393021214471,-0.002828157275369464,0.006607074060760007);\n    point = new GeoPoint(PlanetModel.SPHERE, -5.236470872437899E-4, 3.992578692654256E-4);\n    assertTrue(c.isWithin(point));\n    assertTrue(solid.isWithin(point));\n    relationship = solid.getRelationship(c);\n    // Fails\n    assertTrue(relationship == GeoArea.OVERLAPS || relationship == GeoArea.CONTAINS || relationship == GeoArea.WITHIN);\n\n\n\nI've augmented the new test with enough diagnostics to allow me to reproduce failures easily, and removed the funky bounds extension for the initial root cell, which I believe was incorrect in any case.   I'll submit all this along with whatever patch is needed to fix the problem.\n\nThanks! "
        },
        {
            "id": "comment-14721091",
            "author": "Karl Wright",
            "date": "2015-08-29T12:06:04+0000",
            "content": "What is happening is that the XYZSolid being constructed does not appear to intersect at all with the planet surface.  That's normally fine, but in this case it cannot be strictly true because we can find a point (indeed, four points) which are on the planet surface that are within the solid.\n\nSo I'll have to look at where the math is going wrong, and see if I can find a solution.  Normally computing plane intersection with planet surface is highly accurate, so this is a little strange. "
        },
        {
            "id": "comment-14721119",
            "author": "Karl Wright",
            "date": "2015-08-29T14:11:09+0000",
            "content": "Hah, figured it out.  There's a case that isn't covered properly, when the planet surface is inside of all corners of the xyzsolid, but one of the edge planes intersects the surface nonetheless.  There is a test for this condition, but it is insufficiently general.\n\nWorking on a solution now. "
        },
        {
            "id": "comment-14721135",
            "author": "Karl Wright",
            "date": "2015-08-29T15:08:54+0000",
            "content": "Fix for the latest failure.\n\nThis changes the conditions under which we try to detect intersection of a plane with the planet, without any bounds, for XYZSolid family of shapes. "
        },
        {
            "id": "comment-14721139",
            "author": "Michael McCandless",
            "date": "2015-08-29T15:24:46+0000",
            "content": "OK I committed that, thanks!\n\nI beasted to another failure:\n\n\n   [junit4] Started J0 PID(43463@localhost).\n   [junit4] Suite: org.apache.lucene.bkdtree3d.TestGeo3DPointField\n   [junit4]   1> doc=22 did not match but should\n   [junit4]   1>   point=[lat=0.3719987557178081, lon=1.4529582778845198]\n   [junit4]   1>   quantized=[X=0.1095243613745665, Y=0.9251421568566663, Z=0.3634782030077084]\n   [junit4]   1> doc=51 did not match but should\n   [junit4]   1>   point=[lat=0.3550593281585007, lon=1.4440272624039077]\n   [junit4]   1>   quantized=[X=0.11854384984753275, Y=0.9301019399101389, Z=0.34764599350637104]\n   [junit4]   1> doc=509 did not match but should\n   [junit4]   1>   point=[lat=-0.5244228380357197, lon=1.428808348987751]\n   [junit4]   1>   quantized=[X=0.12249408854287774, Y=0.8569020949569075, Z=-0.5007134892515436]\n   [junit4]   1> doc=732 did not match but should\n   [junit4]   1>   point=[lat=-0.13193716208829576, lon=1.4548335154684928]\n   [junit4]   1>   quantized=[X=0.11469750111675706, Y=0.9846511264260165, Z=-0.13155471446530648]\n   [junit4]   1> doc=878 did not match but should\n   [junit4]   1>   point=[lat=-0.3770013985278945, lon=1.4408350899329265]\n   [junit4]   1>   quantized=[X=0.12049455015011809, Y=0.9219318520845527, Z=-0.3681341108717649]\n   [junit4]   2> NOTE: reproduce with: ant test  -Dtestcase=TestGeo3DPointField -Dtests.method=testGeo3DRelations -Dtests.seed=50CFE2FCB9E04483 -Dtests.slow=true -Dtests.linedocsfile=/lucenedata/hudson.enwiki.random.lines.txt.fixed -Dtests.locale=tr_TR -Dtests.timezone=America/Iqaluit -Dtests.asserts=true -Dtests.file.encoding=UTF-8\n   [junit4] FAILURE 0.16s | TestGeo3DPointField.testGeo3DRelations <<<\n   [junit4]    > Throwable #1: java.lang.AssertionError\n   [junit4]    > \tat __randomizedtesting.SeedInfo.seed([50CFE2FCB9E04483:E0B09F6836ADEA1F]:0)\n   [junit4]    > \tat org.apache.lucene.bkdtree3d.TestGeo3DPointField.testGeo3DRelations(TestGeo3DPointField.java:678)\n   [junit4]    > \tat java.lang.Thread.run(Thread.java:745)\n   [junit4]   2> NOTE: test params are: codec=Lucene53, sim=DefaultSimilarity, locale=tr_TR, timezone=America/Iqaluit\n   [junit4]   2> NOTE: Linux 3.19.0-21-generic amd64/Oracle Corporation 1.8.0_51 (64-bit)/cpus=72,threads=1,free=415284600,total=514850816\n   [junit4]   2> NOTE: All tests run in this JVM: [TestGeo3DPointField]\n   [junit4] Completed [1/1] in 0.47s, 1 test, 1 failure <<< FAILURES!\n\n\n\nMaybe another incorrect DISJOINT?  But still remember this new test could easily be buggy too! "
        },
        {
            "id": "comment-14721276",
            "author": "Karl Wright",
            "date": "2015-08-29T22:24:06+0000",
            "content": "Looks very similar to the previous failure.  The following code reproduces it:\n\n\n    c= GeoBBoxFactory.makeGeoBBox(PlanetModel.SPHERE, 0.7570958596622309, -0.7458670829264561, -0.9566079379002148, 1.4802570961901191);\n    solid = GeoAreaFactory.makeGeoArea(PlanetModel.SPHERE,0.10922258701604912,0.1248184603754517,-0.8172414690802067,0.9959041483215542,-0.6136586624726926,0.6821740363641521);\n    point = new GeoPoint(PlanetModel.SPHERE, 0.3719987557178081, 1.4529582778845198);\n    assertTrue(c.isWithin(point));\n    assertTrue(solid.isWithin(point));\n    relationship = solid.getRelationship(c);\n    assertTrue(relationship == GeoArea.OVERLAPS || relationship == GeoArea.CONTAINS || relationship == GeoArea.WITHIN);\n\n\n\nLooking at what the cause is now. "
        },
        {
            "id": "comment-14721321",
            "author": "Karl Wright",
            "date": "2015-08-30T00:46:25+0000",
            "content": "Found the cause, which is that the edgepoints are insufficient for some cases of intersection of the xyzsolid and the planet.  For some reason I only thought there could be two disconnected shapes of intersection, but on reflection I realized there can be at least six (one for each plane).  Rethinking that logic overnight to be sure it's right. "
        },
        {
            "id": "comment-14721327",
            "author": "Karl Wright",
            "date": "2015-08-30T01:05:50+0000",
            "content": "Patch to include guaranteed sufficient edge points for XYZsolid family objects. "
        },
        {
            "id": "comment-14721379",
            "author": "Karl Wright",
            "date": "2015-08-30T04:50:28+0000",
            "content": "Same patch as before, minus the System.err line inadvertantly left in. "
        },
        {
            "id": "comment-14721385",
            "author": "Karl Wright",
            "date": "2015-08-30T05:06:29+0000",
            "content": "Michael McCandless A beasting run with this patch succeeds, so I think it's safe to try this... "
        },
        {
            "id": "comment-14723200",
            "author": "Michael McCandless",
            "date": "2015-08-31T08:22:47+0000",
            "content": "New failure:\n\n\n[junit4:pickseed] Seed property 'tests.seed' already defined: 5996DA90E40439B7\n   [junit4] <JUnit4> says \u05e9\u05dc\u05d5\u05dd! Master seed: 5996DA90E40439B7\n   [junit4] Executing 1 suite with 1 JVM.\n   [junit4] \n   [junit4] Started J0 PID(9221@localhost).\n   [junit4] Suite: org.apache.lucene.bkdtree3d.TestGeo3DPointField\n   [junit4]   1> doc=1230 did not match but should\n   [junit4]   1>   point=[lat=-0.01580760332365284, lon=-0.03956004622490505]\n   [junit4]   1>   quantized=[X=1.0002097244024128, Y=-0.039588997133820684, Z=-0.015824616624664598]\n   [junit4]   2> NOTE: reproduce with: ant test  -Dtestcase=TestGeo3DPointField -Dtests.method=testGeo3DRelations -Dtests.seed=5996DA90E40439B7 -Dtests.multiplier=5 -Dtests.slow=true -Dtests.linedocsfile=/lucenedata/hudson.enwiki.random.lines.txt.fixed -Dtests.locale=nl_NL -Dtests.timezone=Asia/Ulaanbaatar -Dtests.asserts=true -Dtests.file.encoding=UTF-8\n   [junit4] FAILURE 3.16s | TestGeo3DPointField.testGeo3DRelations <<<\n   [junit4]    > Throwable #1: java.lang.AssertionError\n   [junit4]    > \tat __randomizedtesting.SeedInfo.seed([5996DA90E40439B7:E9E9A7046B49972B]:0)\n   [junit4]    > \tat org.apache.lucene.bkdtree3d.TestGeo3DPointField.testGeo3DRelations(TestGeo3DPointField.java:681)\n   [junit4]    > \tat java.lang.Thread.run(Thread.java:745)\n   [junit4]   2> NOTE: test params are: codec=Asserting(Lucene53): {}, docValues:{}, sim=DefaultSimilarity, locale=nl_NL, timezone=Asia/Ulaanbaatar\n   [junit4]   2> NOTE: Linux 3.19.0-21-generic amd64/Oracle Corporation 1.8.0_51 (64-bit)/cpus=72,threads=1,free=482881640,total=514850816\n   [junit4]   2> NOTE: All tests run in this JVM: [TestGeo3DPointField]\n   [junit4] Completed [1/1] in 3.49s, 1 test, 1 failure <<< FAILURES!\n   [junit4] \n   [junit4] \n   [junit4] Tests with failures:\n   [junit4]   - org.apache.lucene.bkdtree3d.TestGeo3DPointField.testGeo3DRelations\n   [junit4] \n   [junit4] \n   [junit4] JVM J0:     0.74 ..     4.72 =     3.97s\n   [junit4] Execution time total: 4.75 sec.\n   [junit4] Tests summary: 1 suite, 1 test, 1 failure\n\n "
        },
        {
            "id": "comment-14723281",
            "author": "Karl Wright",
            "date": "2015-08-31T10:25:30+0000",
            "content": "Reproduces for me.  Looking into it as soon as I have a moment. "
        },
        {
            "id": "comment-14723282",
            "author": "Karl Wright",
            "date": "2015-08-31T10:29:21+0000",
            "content": "Hmm, Michael McCandless, I think this must be a test bug.  The missing doc is 1230, and:\n\n\n   [junit4]   1>     addAll doc=1230\n\n\n\nIt also seems to be checked multiple times, but I expect the test is supposed to do that...  On the other hand, addAll doc=1230 is called multiple times, and that's DEFINITELY not kosher... "
        },
        {
            "id": "comment-14723300",
            "author": "Karl Wright",
            "date": "2015-08-31T11:05:55+0000",
            "content": "Here's all activity pertaining to the infamous document 1230:\n\n\n   [junit4]   1>   doc=1230: [lat=-0.01580760332365284, lon=-0.03956004622490505]\n   [junit4]   1>     check doc=1230: match!\n   [junit4]   1>     check doc=1230: match!\n   [junit4]   1>     addAll doc=1230\n   [junit4]   1>     addAll doc=1230\n   [junit4]   1>     addAll doc=1230\n   [junit4]   1>     addAll doc=1230\n   [junit4]   1>     check doc=1230: match!\n   [junit4]   1>     addAll doc=1230\n   [junit4]   1>     addAll doc=1230\n   [junit4]   1>     addAll doc=1230\n   [junit4]   1>     addAll doc=1230\n   [junit4]   1>     addAll doc=1230\n   [junit4]   1>     addAll doc=1230\n   [junit4]   1>     addAll doc=1230\n   [junit4]   1>     addAll doc=1230\n   [junit4]   1>     addAll doc=1230\n   [junit4]   1>     check doc=1230: match!\n   [junit4]   1>     addAll doc=1230\n   [junit4]   1>     addAll doc=1230\n   [junit4]   1>     addAll doc=1230\n   [junit4]   1>     check doc=1230: match!\n   [junit4]   1>     check doc=1230: match!\n   [junit4]   1>     check doc=1230: match!\n   [junit4]   1>     check doc=1230: match!\n   [junit4]   1>     addAll doc=1230\n   [junit4]   1>     addAll doc=1230\n   [junit4]   1>     addAll doc=1230\n   [junit4]   1>     addAll doc=1230\n   [junit4]   1>     addAll doc=1230\n   [junit4]   1>     addAll doc=1230\n   [junit4]   1>     addAll doc=1230\n   [junit4]   1>     addAll doc=1230\n   [junit4]   1>     addAll doc=1230\n   [junit4]   1>     check doc=1230: match!\n   [junit4]   1>     check doc=1230: match!\n   [junit4]   1>     addAll doc=1230\n   [junit4]   1>     addAll doc=1230\n   [junit4]   1>     addAll doc=1230\n   [junit4]   1>     addAll doc=1230\n   [junit4]   1>     check doc=1230: match!\n   [junit4]   1>     addAll doc=1230\n   [junit4]   1>     addAll doc=1230\n   [junit4]   1>     addAll doc=1230\n   [junit4]   1>     addAll doc=1230\n   [junit4]   1>     addAll doc=1230\n   [junit4]   1>     addAll doc=1230\n   [junit4]   1>     check doc=1230: match!\n   [junit4]   1>     check doc=1230: no match\n   [junit4]   1>     check doc=1230: match!\n   [junit4]   1>     addAll doc=1230\n   [junit4]   1>     addAll doc=1230\n   [junit4]   1>     addAll doc=1230\n   [junit4]   1>     check doc=1230: match!\n   [junit4]   1>     check doc=1230: match!\n   [junit4]   1>     check doc=1230: match!\n   [junit4]   1>     check doc=1230: match!\n   [junit4]   1>     check doc=1230: no match\n   [junit4]   1>     check doc=1230: match!\n   [junit4]   1>     addAll doc=1230\n   [junit4]   1>     addAll doc=1230\n   [junit4]   1>     addAll doc=1230\n   [junit4]   1>     addAll doc=1230\n   [junit4]   1>     addAll doc=1230\n   [junit4]   1>     addAll doc=1230\n   [junit4]   1>     addAll doc=1230\n   [junit4]   1>     addAll doc=1230\n   [junit4]   1>     check doc=1230: match!\n   [junit4]   1>     check doc=1230: match!\n   [junit4]   1>     check doc=1230: match!\n   [junit4]   1>     check doc=1230: match!\n   [junit4]   1>     check doc=1230: match!\n   [junit4]   1>     check doc=1230: match!\n   [junit4]   1>     check doc=1230: match!\n   [junit4]   1>     check doc=1230: match!\n   [junit4]   1>     check doc=1230: match!\n   [junit4]   1>     check doc=1230: match!\n   [junit4]   1>     check doc=1230: match!\n   [junit4]   1>     check doc=1230: match!\n   [junit4]   1>     addAll doc=1230\n   [junit4]   1>     addAll doc=1230\n   [junit4]   1>     addAll doc=1230\n   [junit4]   1>     addAll doc=1230\n   [junit4]   1>     addAll doc=1230\n   [junit4]   1>     check doc=1230: match!\n   [junit4]   1>     check doc=1230: match!\n   [junit4]   1>     check doc=1230: match!\n   [junit4]   1>     addAll doc=1230\n   [junit4]   1>     addAll doc=1230\n   [junit4]   1>     addAll doc=1230\n   [junit4]   1>     check doc=1230: match!\n   [junit4]   1>     check doc=1230: match!\n   [junit4]   1>     addAll doc=1230\n   [junit4]   1>     addAll doc=1230\n   [junit4]   1>     addAll doc=1230\n   [junit4]   1>     check doc=1230: match!\n   [junit4]   1>     check doc=1230: match!\n   [junit4]   1>     check doc=1230: no match\n   [junit4]   1>     check doc=1230: match!\n   [junit4]   1>     addAll doc=1230\n   [junit4]   1>     addAll doc=1230\n   [junit4]   1>     addAll doc=1230\n   [junit4]   1>     addAll doc=1230\n   [junit4]   1>     check doc=1230: match!\n   [junit4]   1>     check doc=1230: match!\n   [junit4]   1>     check doc=1230: match!\n   [junit4]   1>     check doc=1230: match!\n   [junit4]   1>     check doc=1230: match!\n   [junit4]   1> doc=1230 did not match but should\n\n\n "
        },
        {
            "id": "comment-14723329",
            "author": "Karl Wright",
            "date": "2015-08-31T11:55:03+0000",
            "content": "More data:  For \"TEST: iter=121\", the ONLY mention of doc=1230 is the very last line.  So that document is overlooked from the start.  Maybe it's outside the initial bounds but not outside the shape?  Looking at that now...\n "
        },
        {
            "id": "comment-14723354",
            "author": "Karl Wright",
            "date": "2015-08-31T12:22:26+0000",
            "content": "Michael McCandless ooh, this is interesting.  This test passes:\n\n\n    // BKD failure\n    points = new ArrayList<GeoPoint>();\n    points.add(new GeoPoint(PlanetModel.WGS84, -0.36716183577912814, 1.4836349969188696));\n    points.add(new GeoPoint(PlanetModel.WGS84, 0.7846038240742979, -0.02743348424931823));\n    points.add(new GeoPoint(PlanetModel.WGS84, -0.7376479402362607, -0.5072961758807019));\n    points.add(new GeoPoint(PlanetModel.WGS84, -0.3760415907667887, 1.4970455334565513));\n    \n    c = GeoPolygonFactory.makeGeoPolygon(PlanetModel.WGS84, points, 1);\n    System.err.println(\"c=\"+c);\n    \n    point = new GeoPoint(PlanetModel.WGS84, -0.01580760332365284, -0.03956004622490505);\n    assertTrue(c.isWithin(point));\n    xyzb = new XYZBounds();\n    c.getBounds(xyzb);\n    area = GeoAreaFactory.makeGeoArea(PlanetModel.WGS84,\n      xyzb.getMinimumX(), xyzb.getMaximumX(), xyzb.getMinimumY(), xyzb.getMaximumY(), xyzb.getMinimumZ(), xyzb.getMaximumZ());\n    assertTrue(area.isWithin(point));\n    System.err.println(\"area=\"+area);\n\n\n\nThe shape and the bounds it prints out look like this:\n\n\n   [junit4] Started J0 PID(11304@localhost).\n   [junit4] Suite: org.apache.lucene.geo3d.GeoPolygonTest\n   [junit4]   2> c=GeoCompositeMembershipShape: {[GeoCompositeMembershipShape: {[GeoConvexPolygon: {planetmodel=PlanetModel.WGS84, points=[[lat=-0.36716183577912814, lon=1.4836349969188696], [lat=-0.7376479402362607, lon=-0.5072961758807019], [lat=-0.3760415907667887, lon=1.4970455334565513]]}]}, GeoConvexPolygon: {planetmodel=PlanetModel.WGS84, points=[[lat=0.7846038240742979, lon=-0.02743348424931823], [lat=-0.7376479402362607, lon=-0.5072961758807019], [lat=-0.36716183577912814, lon=1.4836349969188696]]}]}\n   [junit4]   2> area=XYZSolid: {planetmodel=PlanetModel.WGS84, isWholeWorld=false, minXplane=[A=1.0, B=0.0, C=0.0, D=-0.06858082595452562, side=1.0], maxXplane=[A=1.0, B=0.0, C=0.0, D=-1.0011188430710465, side=-1.0], minYplane=[A=0.0, B=1.0, C=0.0, D=0.3602066444438738, side=1.0], maxYplane=[A=0.0, B=1.0, C=0.0, D=-0.9487384224599528, side=-1.0], minZplane=[A=0.0, B=0.0, C=1.0, D=0.7797276450646676, side=1.0], maxZplane=[A=0.0, B=0.0, C=1.0, D=-0.7061485118699775, side=-1.0]}\n   [junit4] OK      0.06s | GeoPolygonTest.testPolygonBounds\n   [junit4] Completed [1/1] in 0.11s, 1 test\n\n\n\nCompare/contrast the XYZSolid bounds with the bounds that the bkd test printed before.  Note that the signs are flipped; D is the negative of the min/max values:\n\n\n   [junit4]   1>   root cell: cell=35789 x: 147111611 TO 2147483647, y: -772673398 TO 2035123315, z: -1672581053 TO 1514747655, splits: 0\n   [junit4]   1>   cycle: cell=35789 x: 147111611 TO 2147483647, y: -772673398 TO 2035123315, z: -1672581053 TO 1514747655, splits: 0 queue.size()=0\n   [junit4]   1>     minx=0.06858082567195825 maxx=1.0011188183041375 miny=-0.3602066448989628 maxy=0.948738422799356 minz=-0.7797276453057644 maxz=0.7061485123150968\n\n\n\nSo the Geo3d bounds are right, but when the root cell is constructed it's not actually using those bounds, but instead something smaller, probably because it's max'd (or min'd) out.  I suspected this might happen...\n\nThere are two ways forward.  First way: if the bounds exceeds the planetmodel max/min, set to Integer.MAX_VALUE or Integer.MIN_VALUE, respectively, rather than convert from the double.  That's easy to try.  If that doesn't work, then we have to change the encoding to allow for a slightly larger value. "
        },
        {
            "id": "comment-14723357",
            "author": "Karl Wright",
            "date": "2015-08-31T12:30:42+0000",
            "content": "Hmm, pegging to MAX_VALUE or -MAX_VALUE didn't fix it.  So it looks like we'll have to compute world bounds slightly differently... "
        },
        {
            "id": "comment-14723371",
            "author": "Karl Wright",
            "date": "2015-08-31T12:53:04+0000",
            "content": "Michael McCandless: Here's a patch that allows the test to pass.  I also tried adding Vector.MINIMUM_RESOLUTION, and even 10.0 * Vector.MINIMUM_RESOLUTION, to the planetary maximum magnitude, but that wasn't enough.  I'm not entirely sure why the representation maximum value needs to be the maximum size of the world XYZBounds value but it appears to need to be. "
        },
        {
            "id": "comment-14723393",
            "author": "Karl Wright",
            "date": "2015-08-31T13:30:11+0000",
            "content": "Revised patch that makes the encoding and decoding align "
        },
        {
            "id": "comment-14723842",
            "author": "Michael McCandless",
            "date": "2015-08-31T18:42:06+0000",
            "content": "It's a bit alarming to me that FUDGE_FACTOR has found its way down into the encoding we write into the index   What if we need to later increase it even more?\n\nI'm not entirely sure why the representation maximum value needs to be the maximum size of the world XYZBounds value but it appears to need to be.\n\nMaybe we need to understand this better.  Maybe it's a bug in the test?  That global bbox is supposed to just be an optimization, allowing the recursion to quickly narrow itself to the cells that overlap instead of having to compute relations all the way down to that point.  And if the explanation is correct (the bbox is beyond the planet max), why didn't cutting over to Int.MAX_VALUE fix it?  I'm confused... "
        },
        {
            "id": "comment-14723853",
            "author": "Karl Wright",
            "date": "2015-08-31T18:50:31+0000",
            "content": "So what I think may be happening is that when the bounds of the shape are greater than the \"size of the world\", even just by a little bit, the recursion does not continue (in that dimension, at least).  Basically I think the code simply doesn't expect a starting cell that large.  There's no way, remember, to even represent such a condition with integers, so the decision is a perfectly reasonable one, but it's wrong.\n\nI can try to demonstrate this with appropriate output.  But I've already demonstrated that geo3d is doing the right thing; it has the proper relationships between all objects and between the point and the shape and the area.  So it has to be decision-making in the bkd descent that is problematic.\n\nAs for whether making FUDGE_FACTOR impact the docvalues encoding \u2013 I agree this is not ideal.  I presented the patch solely because it worked.\n "
        },
        {
            "id": "comment-14723867",
            "author": "Michael McCandless",
            "date": "2015-08-31T18:58:35+0000",
            "content": "There's no way, remember, to even represent such a condition with integers\n\nBut then why didn't the +/- Integer.MAX_VALUE solve it?  Is it possible the non-lenient encode is overflowing int?\n\nSo it has to be decision-making in the bkd descent that is problematic.\n\nOK but in this test case there is no BKD code... I mean, the logic is all in the test (splitting up cells and recursing).  Maybe there is a bug in that logic? "
        },
        {
            "id": "comment-14723895",
            "author": "Karl Wright",
            "date": "2015-08-31T19:23:34+0000",
            "content": "Hmm.\n\nFor a start, I'd like to revise the structure of encoding and decoding so that PlanetModel doesn't propagate into the encoder methods.  As I play with this I keep tripping over the dichotomy between encode and decode and all that entails.  Any objection if I submit a structural patch as the first order of business? "
        },
        {
            "id": "comment-14723899",
            "author": "Karl Wright",
            "date": "2015-08-31T19:25:35+0000",
            "content": "Replacing my previous patch attempt with a structural change that means decode and encode methods receive the same info, which is calculated elsewhere. This does NOT fix the failure, but Michael McCandless, if you have no objection, this will make it easier to iterate for me. "
        },
        {
            "id": "comment-14723918",
            "author": "Michael McCandless",
            "date": "2015-08-31T19:36:23+0000",
            "content": "Thanks Karl Wright that makes sense, I'll commit that except for the +/- Integer.MAX_VALUE clipping since we are still digging on that. "
        },
        {
            "id": "comment-14723926",
            "author": "Michael McCandless",
            "date": "2015-08-31T19:39:55+0000",
            "content": "OK I committed that, minus a couple parts that are about debugging this test failure, and I consistently renamed max to planetMax.  Let me know if I screwed up, but tests passed once! "
        },
        {
            "id": "comment-14724368",
            "author": "Karl Wright",
            "date": "2015-08-31T23:14:36+0000",
            "content": "Ok, two issues.\n\nFirst issue: the problem I was initially debugging was iteration 121.  This problem is occurring on iteration 122.  It's a different shape, and all the analysis/tests that were done are no longer pertinent.  I guess that's good.\n\nFor iteration 122, the shape is a GeoPath.  The problem is simply that the root cell does not contain document 1230.  Neither does the xyzbounds.  But the shape itself does.\n\nSome debugging output:\n\n   [junit4]   1> TEST: iter=122 shape=GeoPath: {planetmodel=PlanetModel.WGS84, width=0.7766715171374766(44.5), points={[[lat=-0.2751718361148076, lon=-0.7786721269011477], [lat=0.5728375851539309, lon=-1.2700115736820465]]}}\n   [junit4]   1>   root cell: cell=36178 x: -1068861352 TO 2145533482, y: -2147483647 TO 66660163, z: -1855240006 TO 2086587766, splits: 0 contains 1230? false GeoArea contains 1230? false shape contains point? true maximum X > maxPlanet? false\n   [junit4]   1>   doc 1230 encoding: x=2145533565 y=-84921712 z=-33945127\n\n\n\nSo, it's the x dimension that is insufficient; the x upper bound for the root cell is too small by 83.\n\nI'll set this up in its own Geo3D test and analyze it further. "
        },
        {
            "id": "comment-14724486",
            "author": "Karl Wright",
            "date": "2015-09-01T00:42:05+0000",
            "content": "Fixes the problem by increasing FUDGE_FACTOR still further.\n\nOther changes include testing additions/improvements.\n\nMichael McCandless, this should not be controversial; commit when ready... "
        },
        {
            "id": "comment-14725099",
            "author": "Michael McCandless",
            "date": "2015-09-01T09:51:58+0000",
            "content": "OK I committed a test fix so we only see verbose logging for the iteration that failed.\n\nAlso I hit a new failure, GeoPath again:\n\n\n[junit4:pickseed] Seed property 'tests.seed' already defined: 24B39D6EB4A89D20\n   [junit4] <JUnit4> says ciao! Master seed: 24B39D6EB4A89D20\n   [junit4] Executing 1 suite with 1 JVM.\n   [junit4] \n   [junit4] Started J0 PID(14785@localhost).\n   [junit4] Suite: org.apache.lucene.bkdtree3d.TestGeo3DPointField\n   [junit4]   2> NOTE: reproduce with: ant test  -Dtestcase=TestGeo3DPointField -Dtests.method=testGeo3DRelations -Dtests.seed=24B39D6EB4A89D20 -Dtests.multiplier=5 -Dtests.slow=true -Dtests.linedocsfile=/lucenedata/hudson.enwiki.random.lines.txt.fixed -Dtests.locale=zh -Dtests.timezone=America/Grenada -Dtests.asserts=true -Dtests.file.encoding=UTF-8\n   [junit4] FAILURE 4.56s | TestGeo3DPointField.testGeo3DRelations <<<\n   [junit4]    > Throwable #1: java.lang.AssertionError: invalid hits for shape=GeoPath: {planetmodel=PlanetModel.WGS84, width=0.6894050545377601(39.5), points={[[lat=-0.0788176065762948, lon=0.9431251741731624], [lat=0.510387871458147, lon=0.5327078872484678], [lat=-0.5624521609859962, lon=1.5398841746888388], [lat=-0.5025171434638661, lon=-0.5895998642788894]]}}\n   [junit4]    > \tat __randomizedtesting.SeedInfo.seed([24B39D6EB4A89D20:94CCE0FA3BE533BC]:0)\n   [junit4]    > \tat org.apache.lucene.bkdtree3d.TestGeo3DPointField.testGeo3DRelations(TestGeo3DPointField.java:708)\n   [junit4]    > \tat java.lang.Thread.run(Thread.java:745)\n   [junit4]   2> NOTE: test params are: codec=CheapBastard, sim=DefaultSimilarity, locale=zh, timezone=America/Grenada\n   [junit4]   2> NOTE: Linux 3.19.0-21-generic amd64/Oracle Corporation 1.8.0_51 (64-bit)/cpus=72,threads=1,free=372695208,total=514850816\n   [junit4]   2> NOTE: All tests run in this JVM: [TestGeo3DPointField]\n   [junit4] Completed [1/1] in 4.87s, 1 test, 1 failure <<< FAILURES!\n   [junit4] \n   [junit4] \n   [junit4] Tests with failures:\n   [junit4]   - org.apache.lucene.bkdtree3d.TestGeo3DPointField.testGeo3DRelations\n\n "
        },
        {
            "id": "comment-14725159",
            "author": "Karl Wright",
            "date": "2015-09-01T10:34:22+0000",
            "content": "Was able to reproduce this with a small test case.  XYZBounds again.  Only this time increasing FUDGE_FACTOR by even a further factor of 5 doesn't address it, so digging deeper into the bounds computation...\n\nFWIW, it may be worthwhile having the randomized test sometimes use a completely artificial planet model (e.g. where ab and c are rather different) in order to tease out actual elliptical geometry bugs a bit more readily.  I'll look at that too. "
        },
        {
            "id": "comment-14725265",
            "author": "Karl Wright",
            "date": "2015-09-01T11:52:11+0000",
            "content": "The path is a four-point one.  The part of the path that contains the point is the first segment.  This segment has four bounding planes and four corner points.  The point in question has the following coordinates:\n\n\n   [junit4]   2> Point.x = 1.0005691667476262; point.y=0.023149205146987442; point.z=0.023676292209381222\n\n\n\nMy augmented output for getting the bounds for the segment shows that it is the upper connecting plane that determines the maxX boundary for the shape:\n\n\n   [junit4]   2>  upperConnectingPlane...\n   [junit4]   2>     computing Z bound\n   [junit4]   2>     not degenerate\n   [junit4]   2>     computing X bound\n   [junit4]   2>     not degenerate; B=-0.5302912804708979; C=-0.5331856607581867\n   [junit4]   2>       Point = [X=1.0005682443631527, Y=0.022204817350270467, Z=0.02459563634844797]; this.evaluate(point)=0.0; normalizedXPlane.evaluate(point)=4.163336342344337E-17\n   [junit4]   2>     computing Y bound\n   [junit4]   2>     not degenerate\n\n\n\nThe point of maximum excursion's X value, though, is X=1.0005682443631527.  The actual X value of the point we're checking is Point.x = 1.0005691667476262.  So that's the disagreement.  The next step is to see how that difference arises.  Specifically, the point found is on the upperConnectingPlane (eval = 0.0), and on the plane I have constructed that should represent a perpendicular to the upperConnectingPlane going through the point of maximum excursion.  I'll have to verify that that is indeed the case. "
        },
        {
            "id": "comment-14725402",
            "author": "Karl Wright",
            "date": "2015-09-01T13:37:59+0000",
            "content": "The computation that determines the perpendicular plane that is intersected with the original plane to find the X or Y bounds is as follows:\n\n(1) Create a perpendicular plane which includes the X axis (or Y axis, depending)\n(2) Evaluate that plane at the two Z points that represent the maximum excursions in Z for the plane intersecting the planet\n(3) Take the average of the evaluations, and construct a new plane that is parallel to the first perpendicular plane but offset by that amount\n\nIn this case, the following is produced:\n\n\n   [junit4]   2> zPoint: [X=0.09847149376598374, Y=-0.07921875599763584, Z=-0.9897798734262737]\n   [junit4]   2> zPoint: [X=0.7398138828430078, Y=-0.5951685429682101, Z=0.31625095037048134]\n...\n   [junit4]   2>     computing X bound\n   [junit4]   2>     not degenerate; B=-0.5302912804708979; C=-0.5331856607581867\n   [junit4]   2>     originPlane.evaluate(zpoint)=-0.6418043015460514\n   [junit4]   2>     originPlane.evaluate(zpoint)=0.6450052856365084\n\n\n\nSo, the D value being computed is the average of two fairly large numbers, which are largely canceling each other out.  Unfortunately, however, that kind of floating-point calculation leads to a fairly high error value, which I believe to be the source of the problem we're seeing.\n\nI will ponder if there's a better way to compute what we need here. "
        },
        {
            "id": "comment-14725438",
            "author": "Karl Wright",
            "date": "2015-09-01T14:02:03+0000",
            "content": "Patch increasing FUDGE_FACTOR still further.  Analysis indicates that we just have a rather large error value to deal with given how XYZ bounds computation works.  Looking for a better way to do the computation, but until then, this is the only solution. "
        },
        {
            "id": "comment-14725542",
            "author": "Michael McCandless",
            "date": "2015-09-01T15:18:05+0000",
            "content": "Thanks Karl Wright, I committed that.\n\nWe could alternatively remove this optimization?  I.e. descend from the entire planet every time, instead of starting from the bbox? "
        },
        {
            "id": "comment-14725567",
            "author": "Karl Wright",
            "date": "2015-09-01T15:32:00+0000",
            "content": "Michael McCandless Even though the bounds calculation for X and Y has a \"large\" error, it's still on the order of 1 meter on the planet surface.  So unless we simply cannot find a reasonable error bound, we should leave it as is. "
        },
        {
            "id": "comment-14727281",
            "author": "Michael McCandless",
            "date": "2015-09-02T12:51:26+0000",
            "content": "I think this is finally ready!  I'm attaching a clean patch against latest trunk ... I'll beast a bit more and the commit soon if no new failures.\n\nWe can open followon issues for e.g. randomizing the PlanetModel. "
        },
        {
            "id": "comment-14727343",
            "author": "David Smiley",
            "date": "2015-09-02T13:34:38+0000",
            "content": "Congrats guys! "
        }
    ]
}