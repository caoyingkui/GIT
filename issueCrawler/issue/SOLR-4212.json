{
    "id": "SOLR-4212",
    "title": "Let facet queries hang off of pivots",
    "details": {
        "affect_versions": "4.0",
        "status": "Closed",
        "fix_versions": [
            "5.3",
            "6.0"
        ],
        "components": [
            "search"
        ],
        "type": "Sub-task",
        "priority": "Major",
        "labels": "",
        "resolution": "Fixed"
    },
    "description": "Facet pivot provide hierarchical support for computing data used to populate a treemap or similar visualization. TreeMaps usually offer users extra information by applying an overlay color on top of the existing square sizes based on hierarchical counts. This second count is based on user choices, representing, usually with gradient, the proportion of the square that fits the user's choices.\n\nThe proposition is to use local parameters to specify facet query to apply for pivot which matches a tag set on facet query. Parameter format would look like:\n\nfacet.pivot=\n{!query=r1}\ncategory,manufacturer\nfacet.query=\n{!tag=r1}somequery\nfacet.query={!tag=r1}\nsomedate:[NOW-1YEAR TO NOW]",
    "attachments": {
        "patch-4212.txt": "https://issues.apache.org/jira/secure/attachment/12561622/patch-4212.txt",
        "SOLR-6353-4212.patch": "https://issues.apache.org/jira/secure/attachment/12742146/SOLR-6353-4212.patch",
        "SOLR-4212.patch": "https://issues.apache.org/jira/secure/attachment/12654180/SOLR-4212.patch",
        "SOLR-4212-multiple-q.patch": "https://issues.apache.org/jira/secure/attachment/12671844/SOLR-4212-multiple-q.patch",
        "SOLR-6353-6686-4212.patch": "https://issues.apache.org/jira/secure/attachment/12703945/SOLR-6353-6686-4212.patch"
    },
    "issue_links": {},
    "comments": [
        {
            "author": "Steve Molloy",
            "id": "comment-13535553",
            "date": "2012-12-19T01:56:27+0000",
            "content": "Initial patch proposal. "
        },
        {
            "author": "Otis Gospodnetic",
            "id": "comment-13808321",
            "date": "2013-10-29T19:08:31+0000",
            "content": "Thanks Steve!\nHad a quick look at the patch - seems very small, very simple (1 new method), has a test, clean formatting and ASL in place.  Would be great to have one of the more active Solr developers check this out and commit. "
        },
        {
            "author": "Uwe Schindler",
            "id": "comment-13971100",
            "date": "2014-04-16T12:57:09+0000",
            "content": "Move issue to Solr 4.9. "
        },
        {
            "author": "Steve Molloy",
            "id": "comment-14052938",
            "date": "2014-07-05T18:30:44+0000",
            "content": "Adjust for latest patch for SOLR-2894 and 4.9 code. "
        },
        {
            "author": "Steve Molloy",
            "id": "comment-14055482",
            "date": "2014-07-08T20:35:06+0000",
            "content": "Fix latest patch which wasn't properly merging q-counts from shards "
        },
        {
            "author": "Steve Molloy",
            "id": "comment-14125996",
            "date": "2014-09-08T19:51:49+0000",
            "content": "(right attchment this time) Adapted patch for 4.10 code and ensured all tests passed. "
        },
        {
            "author": "Steve Molloy",
            "id": "comment-14152066",
            "date": "2014-09-29T18:55:20+0000",
            "content": "Add support for multiple queries per field. "
        },
        {
            "author": "Steve Molloy",
            "id": "comment-14153572",
            "date": "2014-09-30T19:07:39+0000",
            "content": "Add test and build map of parsed queries once "
        },
        {
            "author": "Hoss Man",
            "id": "comment-14158312",
            "date": "2014-10-03T18:32:00+0000",
            "content": "I haven't had a chance to review this patch, but in response to a dev@lucene thread about it...\n\nBase idea is to have something like: facet.pivot=field1,field2,field3f.field2.facet.pivot.q=somequery&f.field3.facet.pivot.q=somedate:[NOW-1YEAR TO NOW]&f.field3.facet.pivot.q=someotherquery ... Which would add results similar to facet queries, at the appropriate level in the pivots.\n\nFrom a functionality standpoint, what you are setting out to do here seems like a great idea \u2013 but personally i think that syntax looks really cumbersome?\n\nFrom a user API standpoint, It seems your gola here would gel really well with the syntax i proposed in SOLR-6348/(SOLR-6351,SOLR-6352,SOLR-6353) if you think about it in terms of \"hanging query facets off of pivots\" ... ie:\n\n\nfacet.pivot={!query=r1}category,manufacturer\nfacet.query={!tag=r1}somequery\nfacet.query={!tag=r1}somedate:[NOW-1YEAR TO NOW]\n\n\n\nthat seems like it might be cleaner, and fit better with some of the other ongoing work, what do you think? "
        },
        {
            "author": "Steve Molloy",
            "id": "comment-14158374",
            "date": "2014-10-03T18:58:09+0000",
            "content": "That's what I'm starting to realize by looking into SOLR-6351...  It makes a lot of sense, I'll try to adapt and see if I can get facet ranges (SOLR-6353) covered at the same time, they should be similar with your proposed approach. "
        },
        {
            "author": "Steve Molloy",
            "id": "comment-14163472",
            "date": "2014-10-08T13:22:59+0000",
            "content": "Following approach under SOLR-6348, facet queries and facet reanges now included in facet pivots if their tag matches the localparam facet.query or facet.range of the facet.pivot request parameter. Added distributed unit tests for both as well as Solrj test additions. This also covers SOLR-6353. "
        },
        {
            "author": "Steve Molloy",
            "id": "comment-14202121",
            "date": "2014-11-07T15:03:14+0000",
            "content": "Small adjustments to fit latest changes in SOLR-6351. "
        },
        {
            "author": "Shalin Shekhar Mangar",
            "id": "comment-14341591",
            "date": "2015-02-28T15:35:28+0000",
            "content": "Here's a patch updated to trunk. "
        },
        {
            "author": "Shalin Shekhar Mangar",
            "id": "comment-14357191",
            "date": "2015-03-11T16:58:33+0000",
            "content": "I decided to combine the patches for SOLR-4212 and SOLR-6686 because the refactoring in SOLR-6686 is useful here as well.\n\nChanges:\n\n\tI borrowed the refactoring of SimpleFacets in SOLR-6686 here which simplifies things by a lot\n\tA new RangeFacetProcessor is refactored out of SimpleFacets on the same lines as PivotFacetProcessor\n\tFacetComponent does the work of adding range and date facets to the response\n\tThe above breaks a bunch of tests which expected facet_counts to be ordered in a certain way so the patch sets the facet_counts to be unordered\n\n "
        },
        {
            "author": "Steve Molloy",
            "id": "comment-14357519",
            "date": "2015-03-11T20:19:44+0000",
            "content": "Shalin Shekhar Mangar Thanks for updating the patch. Took a quick look and seems good, will try to find time to actually try it tomorrow. "
        },
        {
            "author": "Shalin Shekhar Mangar",
            "id": "comment-14378795",
            "date": "2015-03-24T22:26:20+0000",
            "content": "\n\tFurther refactored and shared code between FacetComponent and PivotFacetField/PivotFacetHelper for range faceting\n\tRemoved dependency on mahout-collections. I found that using it actually made the merging logic more complex involving reordering the facet results in the output\n\tIntroduced a RangeFacetAccumulator which is actually quite simple and encapsulates all logic for tracking and merging range facet results from different shards and enforcing mincount requirements.\n\tI couldn't find a nice way to re-use merging logic for queries but since merging them is so simple, I let it be and just have a bit of duplicated code in PivotFacetHelper.\n\n\n\nAll tests pass. A review would be appreciated. "
        },
        {
            "author": "Hoss Man",
            "id": "comment-14381038",
            "date": "2015-03-25T23:38:14+0000",
            "content": "I didn't get a chance to review as in depth as i would have liked, but here are some comments based on a quick skim, followed by some more detailed review of a few classes...\n\n\n\tit seems verbose and confusing to use \"facet.range\" and \"facet.query\" as the local params for this...\n\t\n\t\tConfusing: these local params refer to tag names where as people might think they can inline arbitrary query expressions / field names to compute ranges on\n\t\tverbose: why not just \"ranges\" and \"queries\" for the local param names, similar to how \"stats\" is already used?\n\t\n\t\n\tI'm not a big fan of the fact that this patch breaks the determinism of the order that the different types of facets are returned in \u2013 It's probably not a blocker, but i suspect there may be some clients (or perhaps even client libraries other then SolrJ) which will be broken by this.\n\tIn the SolrJ PivotField class, this patch adds \"NamedList<Object> getRanges()\" and \"NamedList<Integer> getQueryCounts()\" methods.  We should really be consistent with the existing equivalent methods in QueryResponse...\n\t\n\t\t\"Map<String,Integer>getFacetQuery()\"\n\t\t\"List<RangeFacet> getFacetRanges()\"\n\t\n\t\n\tin PivotFacetValue: \"// named list with objects because depending on how big the counts are we may get either a long or an int\"\n\t\n\t\tFWIW: I had seriously never noticed until today that these facet counts had variable type\n\t\twhy can't we just use \"Number\" instead of \"Object\" in this new code since that's the lavel all of the casting code that deals with this list seems to use anyway?\n\t\tdoesn't this break the SolrJ code if/when it returns a Long? (see above new method \"NamedList<Integer> getQueryCounts()\")\n\t\n\t\n\tDateFacetProcessor\n\t\n\t\tthis entire class should be marked deprecated\n\t\tmaybe i'm missing something, but what exactly is the advantage of this subclassing RangeFacetProcessor? ... if they are sharing code it's not obvious to me, and if they aren't (intentionally) sharing code then this subclass relationship seems dangerous if/when future improvements to range faceting are made.\n\t\n\t\n\tFacetComponent\n\t\n\t\twhy does doDistribRanges() still need to exist? why not just move that casting logic directly into RangeFacetAccumulator.mergeContributionFromShard like the rest of the code that use to be here and call it directly?\n\t\tnow that these skethy \"num()\" functions are no longer private, can we please get some javadocs on them.\n\t\n\t\n\tPivotFacetProcessor\n\t\n\t\tunless i'm missunderstanding the usage, the way addPivotQueriesAndRanges (and removeUnwantedQueriesAndRanges) works means that every facet.query and facet.range param value (with all localparams) is going to be reparsed over and over and over again for every unique value in every pivot field \u2013 just to check the \"tag\" values and see if it's one that should be computed for this pivot.\n\t\t\n\t\t\tThis seems really unneccessary \u2013 why not parse each param once into a simple datastructure (isn't that what the new ParsedParams\" class is designed for?), and then put them in a map by tag available fro mthe request context \u2013 just like we did for the stats with StatsInfo.getStatsFieldsByTag(String) ?\n\t\t\tin particular won't this slow down existing requests containing both facet.pivot and facet.range || facet.query) ... even if the later aren't tagged or hung off of the pivots at all? because they'll still get parsed over and over again won't they?\n\t\t\n\t\t\n\t\tthis logic also seems to completely break instances of facet.query used w/o linking it to a face.tpivot\n\t\t\n\t\t\thttp://localhost:8983/solr/techproducts/select?q=*:*&rows=0&stats=true&facet.query=inStock:true&facet=true&facet.pivot=manu_id_s,inStock\n\t\t\t\njava.lang.NullPointerException\n\tat org.apache.solr.handler.component.PivotFacetProcessor.removeUnwantedQueriesAndRanges(PivotFacetProcessor.java:399)\n\tat org.apache.solr.handler.component.PivotFacetProcessor.addPivotQueriesAndRanges(PivotFacetProcessor.java:371)\n\tat org.apache.solr.handler.component.PivotFacetProcessor.doPivots(PivotFacetProcessor.java:273)\n\tat org.apache.solr.handler.component.PivotFacetProcessor.processSingle(PivotFacetProcessor.java:194)\n\tat org.apache.solr.handler.component.PivotFacetProcessor.process(PivotFacetProcessor.java:135)\n\tat org.apache.solr.handler.component.FacetComponent.process(FacetComponent.java:121)\n\tat org.apache.solr.handler.component.SearchHandler.handleRequestBody(SearchHandler.java:222)\n\tat \n\n\n\t\t\n\t\t\n\t\talso broken: neither of these requests should result in the facet.query hanging off of the pivots, but because of how StringUtils.contains() is used they both do erroniously...\n\nhttp://localhost:8983/solr/techproducts/select?q=*:*&rows=0&stats=true&facet.query={!tag=ttt}inStock:true&facet=true&facet.pivot={!facet.query=t}manu_id_s,inStock\nhttp://localhost:8983/solr/techproducts/select?q=*:*&rows=0&stats=true&facet.query={!tag=t}inStock:true&hang=&facet=true&facet.pivot={!facet.query=$hang}manu_id_s,inStock\n\n\n\t\n\t\n\ttests...\n\t\n\t\ta lot of code in the new test classes seems to have been copied verbatim from other existing tests \u2013 in some cases this is fine, because the copied test logic has been modified to include new params+asserts of the new functionality \u2013 but theres still a lot of redundent copy/past cruft w/o any logic changes\n\t\t\n\t\t\teg: DistributedFacetPivotQuerySmallTest lines 428-532 seem to be verbatim copied from DistributedFacetPivotSmallTest w/o any additions to test the racet.query logic, or even new negative-assertions that stra facet.queries are hung off by mistake (ie: to catch the bugs i mentioned above)\n\t\t\tdito for DistributedFacetPivotRangeSmallTest\n\t\t\n\t\t\n\t\tthere doesn't seem to be any new tests that show hanging both ranges & queries onto a pivot at the same time \u2013 let alone combining it with the existing stats logic\n\t\tlikewise i don't see any testing of using the same tag with multiple facet.query instances (or multiple facet.range instances) and confirming that both get hung off of the same pivot.\n\t\n\t\n\n\n "
        },
        {
            "author": "Mike Murphy",
            "id": "comment-14383043",
            "date": "2015-03-27T00:27:50+0000",
            "content": "Per SOLR-7296, shouldn't this go into lucene facets?\nAlso, does the new facet module in SOLR-7214 already have this?\nThis is continuing down the path of adding more different APIs to do the same thing. "
        },
        {
            "author": "Steve Molloy",
            "id": "comment-14383792",
            "date": "2015-03-27T13:10:46+0000",
            "content": "Indeed, we need to find a way to reconcile, but as the JSON API will be experimental in 5.1, I don't think we should stop this new functionality from getting in. It's in line with all the other work under this unbrella, some of which is already in 5.0. Whether it ends up in Lucene, Solr facet component or facet module, the functionality is something needed and I don't think we should hold it up as it is still the official facet implementation after all... "
        },
        {
            "author": "Yonik Seeley",
            "id": "comment-14383795",
            "date": "2015-03-27T13:17:11+0000",
            "content": "Experimental has nothing to do with \"officialness\" - everything we release is official.  It's only the degree to which we try to keep backward compatibility, and it can be a good idea for any sufficiently complex enough API.  So \"experimental\" only means \"hey, we still have a chance to easily improve the API before it gets locked down harder\". "
        },
        {
            "author": "Shalin Shekhar Mangar",
            "id": "comment-14499518",
            "date": "2015-04-17T09:16:16+0000",
            "content": "Thanks for the detailed review, Hoss.\n\nverbose: why not just \"ranges\" and \"queries\" for the local param names, similar to how \"stats\" is already used?\n\nThat was an oversight. Fixed.\n\nI'm not a big fan of the fact that this patch breaks the determinism of the order that the different types of facets are returned in \u2013 It's probably not a blocker, but i suspect there may be some clients (or perhaps even client libraries other then SolrJ) which will be broken by this\n\nFixed.\n\nIn the SolrJ PivotField class, this patch adds \"NamedList<Object> getRanges()\" and \"NamedList<Integer> getQueryCounts()\" methods. We should really be consistent with the existing equivalent methods in QueryResponse\n\nFixed.\n\nwhy can't we just use \"Number\" instead of \"Object\" in this new code since that's the lavel all of the casting code that deals with this list seems to use anyway?\n\nDone.\n\ndoesn't this break the SolrJ code if/when it returns a Long? (see above new method \"NamedList<Integer> getQueryCounts()\")\n\nYes it does. And the current SolrJ code for range & query facets also needs to be fixed. I'll open another issue to fix the client side of things.\n\nDateFacetProcessor \u2013 this entire class should be marked deprecated\n\nDone.\n\nmaybe i'm missing something, but what exactly is the advantage of this subclassing RangeFacetProcessor? ... if they are sharing code it's not obvious to me, and if they aren't (intentionally) sharing code then this subclass relationship seems dangerous if/when future improvements to range faceting are made.\n\nThis was an oversight. Fixed.\n\nFacetComponent \u2013 why does doDistribRanges() still need to exist? why not just move that casting logic directly into RangeFacetAccumulator.mergeContributionFromShard like the rest of the code that use to be here and call it directly?\n\nI inlined the method into FacetComponent.countFacets. I didn't move the casting logic though. The mergeContributionFromShard method could in theory accept an object and cast it to the right type but a method accepting just a java.lang.Object doesn't feel right to me.\n\nFacetComponent \u2013 now that these skethy \"num()\" functions are no longer private, can we please get some javadocs on them.\n\nDone.\n\n\n\n\tPivotFacetProcessor\n\t\n\t\tunless i'm missunderstanding the usage, the way addPivotQueriesAndRanges (and removeUnwantedQueriesAndRanges) works means that every facet.query and facet.range param value (with all localparams) is going to be reparsed over and over and over again for every unique value in every pivot field \u2013 just to check the \"tag\" values and see if it's one that should be computed for this pivot.\nThis seems really unneccessary \u2013 why not parse each param once into a simple datastructure (isn't that what the new ParsedParams\" class is designed for?), and then put them in a map by tag available fro mthe request context \u2013 just like we did for the stats with StatsInfo.getStatsFieldsByTag(String) ?\n\t\tin particular won't this slow down existing requests containing both facet.pivot and facet.range || facet.query) ... even if the later aren't tagged or hung off of the pivots at all? because they'll still get parsed over and over again won't they?\n\t\n\t\n\n\n\nYou're right. This was horrible and I should've noticed it myself. We now cache the ParsedParam by tags and use them instead of removing unwanted ranges/queries and re-parsing the request.\n\nthis logic also seems to completely break instances of facet.query used w/o linking it to a face.tpivot\n\nThis is also fixed.\n\nalso broken: neither of these requests should result in the facet.query hanging off of the pivots, but because of how StringUtils.contains() is used they both do erroniously...\n\nAlso fixed.\n\n\n\n\ttests...\n\t\n\t\ta lot of code in the new test classes seems to have been copied verbatim from other existing tests \u2013 in some cases this is fine, because the copied test logic has been modified to include new params+asserts of the new functionality \u2013 but theres still a lot of redundent copy/past cruft w/o any logic changes\n\t\t\n\t\t\teg: DistributedFacetPivotQuerySmallTest lines 428-532 seem to be verbatim copied from DistributedFacetPivotSmallTest w/o any additions to test the racet.query logic, or even new negative-assertions that stra facet.queries are hung off by mistake (ie: to catch the bugs i mentioned above)\n\t\t\tdito for DistributedFacetPivotRangeSmallTest\n\t\t\n\t\t\n\t\tthere doesn't seem to be any new tests that show hanging both ranges & queries onto a pivot at the same time \u2013 let alone combining it with the existing stats logic\n\t\tlikewise i don't see any testing of using the same tag with multiple facet.query instances (or multiple facet.range instances) and confirming that both get hung off of the same pivot.\n\t\n\t\n\n\n\n\n\tI refactored and folded in the test logic back inside the DistributedFacetPivotSmallTest.\n\tThere was really no need to duplicate the PivotFieldComparator, UnorderedEqualityArrayList and ComparablePivotField classes.\n\tDistributedFacetPivotSmallTest.testNegativeFacetQuery and testNegativeFacetRange test for negative assertions to ensure that extra facet.queries and facet.ranges are not hung by mistake\n\tDistributedFacetPivotSmallTest.testPivotFacetRangeAndQuery tests range and queries hanging off pivots together along with stats\n\n "
        },
        {
            "author": "Mike Murphy",
            "id": "comment-14500475",
            "date": "2015-04-17T19:22:07+0000",
            "content": "A new RangeFacetProcessor is refactored out of SimpleFacets\n\nIt's great that you are re-factoring code out of the horror that is SimpleFacets, but there is already a class called FacetRangeProcessor in the new facet module.  That was very confusing when I was trying to make sense of this in eclipse. "
        },
        {
            "author": "Hoss Man",
            "id": "comment-14509892",
            "date": "2015-04-23T21:47:59+0000",
            "content": "feedback on the latest patch...\n\n\n\tDateFacetProcessor and RangeFacetProcessor should be moved into handler/component along side PivotFacetProcessor - SimpleFacts is only in the the request subpackage for historical reasons, we shouldn't keep making that mistake\n\tWhy was SimpleFacets.getFacetCounts() removed completely?\n\t\n\t\tin the current patch, the existing callers of that method (FacetComponent and MLT Handler) now have cut/paste duplicated code.\n\t\twhy can't that method continue to exist (modified to use the new processors) to eliminate this duplication?\n\t\n\t\n\tPivotFacetProcessor.getTaggedFacets\n\t\n\t\twhy is this method returning a map of one entry (which is the tag name?)\n\t\tthe parsing bugs from the last patch are gone, but the way this method is used still has a lot of the same \"parse facet params over and over again\" redundency \u2013 although admitedly to a lesser extent \u2013 that seems inefficient...\n\t\t\n\t\t\tthis method will be called for every facet.pivot param that has a \"range\" or \"query\" local param\n\t\t\twithin this method, every facet.range / facet.query param in the request will be parsed (again) to see if it has the specified tag.\n\t\t\n\t\t\n\t\tI still think that hanging \"facets\" off of pivots should follow the same model as hanging \"stats\" off of pivots (as i mentioned before: see StatsInfo.getStatsFieldsByTag)...\n\t\t\n\t\t\tall of the param parsing is done in StatsComponent.prepare, and datastrucutres (StatsInfo) with all the information/logic needed to accumulate stats are put in the request context\n\t\t\tthe main stats logic iterates over all StatsField instances to compute stats over the entire result set\n\t\t\teach facet.pivot param, as it's processed, gets the StatsInfo from the request context and does a simple map lookup to find the relevant StatsField instances based on it's tag\n\t\t\n\t\t\n\t\tis there a a reason not to do the same approach in this issue? ie...\n\t\t\n\t\t\tall logic related to parsing facet.range and facet.query params can be done once in FacetComponent.prepare and the resulting data structures can be put in the request context where they can be reused.\n\t\t\tno matter how many times a range facet or query facet is hung off of something else (by tag) it doesn't need to be reparsed, the caller can just fetch the neccessary object from the context and ask it for a processor/accumulator/whatever to compute the results relative to a docset.\n\t\t\n\t\t\n\t\n\t\n\tPivotFacetProcessor.removeUnwantedQueriesAndRanges\n\t\n\t\tthis is dead code correct?\n\t\n\t\n\tFWIW: ant precommit is currently failing because of nocommits .. not sure if there are other precommit checks beyond that that might be problematic\n\n\n "
        },
        {
            "author": "Tim Underwood",
            "id": "comment-14563130",
            "date": "2015-05-28T15:52:10+0000",
            "content": "Any progress on this?  I'd love to see SOLR-6686 fixed for 5.2. "
        },
        {
            "author": "Shalin Shekhar Mangar",
            "id": "comment-14571266",
            "date": "2015-06-03T16:12:56+0000",
            "content": "Changes:\n\n\tDateFacetProcessor and DateFacetProcessor are moved to handler/component package\n\tSimpleFacets.getFacetCounts() was removed because it would have been weird for SimpleFacets to create and use its own sub-class RangeFacetProcessor/DateFacetProcessor. However, in this patch I have replaced that bit of code with a static method in FacetComponent which should eliminate the repetition in MLTHandler.\n\tNow FacetComponent tries to do a similar thing as StatsComponent i.e. to parse params in prepare method and re-use in PivotFacetProcessor. I tried many designs before the current patch:\n\t\n\t\tCreate FacetInfo in prepare method and re-use throughout. However this doesn't work because there is no separation of concerns in the constituents of FacetInfo. They serve a dual purpose of parsing and aggregating. So when we try creating it in prepare it would throw NPEs inside shard requests trying to access rb.shards.\n\t\tCreate a FacetContext class which parses and keeps the params and use it in PivotFacetProcessor. We can't use ParsedParam because it has DocSet etc which are just not available in the prepare method.\n\t\tFinally I settled for a crude approach of enhancing FacetBase with tags and just parsing the facet queries and ranges and putting them in the request context. Not super happy about it but un-entangling FacetInfo and related classes is too big a task for this issue.\n\t\n\t\n\n\n\tPivotFacetProcessor.removeUnwantedQueriesAndRanges was dead code and it has been removed.\n\tI removed the RangeFacetAccumulator class and replaced it with a LinkedHashMap of facetStr to RangeFacet. This RangeFacet class extends FacetBase just like PivotFacetValue and is responsible for aggregation of a single facet value. This increases a bit of code i.e. looping over all range facets and aggregating but it is no different from what other facet types were doing.\n\tTests and precommit both pass.\n\n\n\nTBH, this faceting code makes my head hurt and a massive refactoring is required. I have some ideas around it but I chose not to do any more to avoid scope creep. Once this is committed, we can open a few issues to clean up.\n\nMike Murphy - I know the class names are same but what's a better name? This patch is older than the new code and is on the same lines as PivotFacetProcessor. "
        },
        {
            "author": "Hoss Man",
            "id": "comment-14584299",
            "date": "2015-06-13T00:01:15+0000",
            "content": "\nOk, I managed to review a little over half of the the current patch (trying to start with the small changes first and work my way up) \u2013 comments below...\n\n\n\n\nGeneral feedback: This patch, on the whole, would be a lot easier to review \u2013 and the final code a lot easier to make sense of \u2013 if there were more class/method javadocs explaining what the purpose of everything was.  I realize that could be said for a lot of the existing Solr code, but adding/refactoring classses/methods is the best time to try and improve the situation since that's when you're thining about it the most.\n\n\n\n\"SimpleFacets.getFacetCounts() was removed because it would have been weird for SimpleFacets to create and use its own sub-class RangeFacetProcessor/DateFacetProcessor. However, in this patch I have replaced that bit of code with a static method in FacetComponent which should eliminate the repetition in MLTHandler.\n\nIf you don't think it makes sense to keep this method where it is that's fine, but it is a public method designed for people writting custom request handlers to use to add faceting to their stuff \u2013 so at the very least you should leave a deprecated stub in it's place that calls your new method.\n\nIt also confuses the hell out of me that in the process of moving this method you made the method signature more complicated to use (more args to understand, more exceptions to deal with) and got rid of the javadocs so the new more complicated call signature is even harder to understand \u2013 and I, frankly, can't make sense of why any of that is neccessary (even if should now live in a diff class because of the inheritence)...\n\n\n\twhy does the caller have to pass in an empty NamedList to be mutated? why can't the method just return a NamedList like the old method did?\n\twhy does the caller have to instantiate the date & range processors themselves?\n\t\n\t\tin both of the places this method is called, the processors are constructed just to pass to this method and then thrown away.\n\t\tSo why can't this static method construct them internally (using the request, docset, params, and response builder from the SimpleFacets object that's also passed as an arg) and keep the method signature simple?\n\t\n\t\n\twhy does this new method catch & wrap SyntaxErrors but not IOExceptions like the old method?\n\n\n\n(If there reasons for these changes then great \u2013 but they aren't clear just from reading the patch, and there's no javadocs to get guidance from)\n\n\n\nI removed the RangeFacetAccumulator class and replaced it with a LinkedHashMap of facetStr to RangeFacet. This RangeFacet class extends FacetBase just like PivotFacetValue and is responsible for aggregation of a single facet value.\n\n\n\tI don't see a class called \"RangeFacet\" ... it looks like you talking about RangeFacetValue?\n\t\n\t\tFWIW: PivotFacetValue doesn't extend FacetBase because it models a single (value,count) pair in the context of a PivotFacetField (which may be hierarchical) ... you may be thinking of \"PivotFacet\"\n\t\t... in which case, should this class atually be named \"RangeFacet\" ?\n\t\teither way: can we please beef up the javadocs of this class to be crystal clear about what it's modeling \u2013 at first glance I thought it was just modeling a facet.range param (with the field, start, end, calculator) before I realized it not only models the field + the indiviual buckets, but also the values in those buckets (but not the other params)\n\t\n\t\n\tIsn't RangeFacetValue.fieldName redundent here? - it's already handled by FacetBase.facetOn.\n\tI don't think there is any reason to initialize shardFieldValues in mergeContributionFromShard before the rangeFacet = rangeFromShard short-circut, it's just wasted cycles the first time the method gets called, correct?\n\n\n\n\n\nLooking at the changes to PivotFacetValue...\n\n\n\twhy a \"Map<String, RangeFacetValue>\" for rangeCounts instead of a NamedList?\n\t\n\t\tit seems like a really bad idea for these to not be returned in a deterministic order \u2013 it should be in the same order as the top level facet.range results (which is hte order of the facet.range params in the request)\n\t\tno idea if this HashMap usage currently causes problems in the shard merging, but it smells fishy \u2013 and either way the user should be able to count on getting the range facets back in the same order the asked for them\n\t\n\t\n\ti didn't dig into the full ramifications of this, but you've got PivotFacetValue constructing RangeFacetValue objects and passing the response key in as the \"fieldName\" argument to the constructor \u2013 those aren't the same thing.  Either the method call here is wrong, or the constructor arg should be renamed \u2013 either way any usage of this \"fieldName\" constructor arg and internal usage should be sanity checked to ensure it's used consistnetly everywhere\n\t\n\t\tare there tests of using a diff response key from the fieldName when hanging ranges under pivots? (both single node and cloud?)\n\t\n\t\n\twhy is PivotFacetValue.createFromNamedList conditionally calling RangeFacetValue.mergeContributionFromShard?\n\t\n\t\tUnless i'm missing something, that method is only ever creating entirely new instances of PivotFacetValue, so there shouldn't be any existing data to merge into ... correct?\n\t\n\t\n\tin PivotFacetValue.mergeContributionFromShard, the dozen or so lines of looping over each shard's response to either construct a new RangeFacetValue or call RangeFacetValue.mergeContributionFromShard seems like it could/should be refactored into a static helper method (in the RangeFacetValue class)\n\t\n\t\tthe exact same loop is used in the only other place mergeContributionFromShard is called (FacetComponent)\n\t\tif PivotFacetValue.createFromNamedList really does need to conditional merge (see previuos comment), then it's loop would also be exactly the same, and it could use the same static helper method.\n\t\n\t\n\n\n\n\n\nSince the input to PivotFacetHelper.mergeQueryCounts is already in the correct response format (ie: no special objects need constructed to model the simple counts) can't it just return \"querycounts\" if \"receivingMap\" is null?  (instead of looping & adding)\n\n\n\nWith the current patch, something is wrong with how localparams are dealt with when trying to use facet.ranges inside of pivots.  These queries are examples of doing range queries on the same field with diff gap params, and (independently) doing a pivot...\n\n\nhttp://localhost:8983/solr/techproducts/select?q=*:*&rows=0&facet=true&facet.pivot=manu_id_s,cat&facet.range={!key=key1%20tag=t1%20facet.range.start=0%20facet.range.end=1000%20facet.range.gap=200}price&facet.range={!key=key2%20tag=t1%20facet.range.start=0%20facet.range.end=500%20facet.range.gap=100}price\n\nhttp://localhost:8983/solr/techproducts/select?q=*:*&rows=0&facet=true&facet.pivot=manu_id_s,cat&facet.range={!key=key1%20tag=t1%20facet.range.gap=200}price&f.price.facet.range.start=0&f.price.facet.range.end=1000&facet.range={!key=key2%20tag=t1%20facet.range.gap=100}price\n\n\n\n...but as soon as you try to hang those ranges on the pivot you get a local errors...\n\n\nhttp://localhost:8983/solr/techproducts/select?q=*:*&rows=0&facet=true&facet.pivot={!range=t1}manu_id_s,cat&facet.range={!key=key1%20tag=t1%20facet.range.start=0%20facet.range.end=1000%20facet.range.gap=200}price&facet.range={!key=key2%20tag=t1%20facet.range.start=0%20facet.range.end=500%20facet.range.gap=100}price\n...\nMissing required parameter: f.price.facet.range.start (or default: facet.range.start)\n\n\nhttp://localhost:8983/solr/techproducts/select?q=*:*&rows=0&facet=true&facet.pivot={!range=t1}manu_id_s,cat&facet.range={!key=key1%20tag=t1%20facet.range.gap=200}price&f.price.facet.range.start=0&f.price.facet.range.end=1000&facet.range={!key=key2%20tag=t1%20facet.range.gap=100}price\n...\nMissing required parameter: f.price.facet.range.gap (or default: facet.range.gap)\n\n\n\n...the fact that this error only pops up when combining pivots + ranges suggests that the patch didn't break the existing code controlling how the param parsing is done, it aparently just isn't re-using the exact same parsing code in both situations?  Which also means that within a single request, the range facet params are still getting parsed (at least) twice \u2013 once (correctly) for the top level facets, and (at least) once (incorrectly) when hanging off of the pivot.\n\n...Finally I settled for a crude approach of enhancing FacetBase with tags and just parsing the facet queries and ranges and putting them in the request context. ...\n\nHmmm....\n\nI haven't seen this piece of code yet, but it sounds like it only prevents the \"tags\" from being parsed over and over again \u2013 from what I've seen so far, RangeFacetProcessor.getFacetRangeCounts(ParsedParams,NamedList) which delegates to RangeFacetProcessor.getFacetRangeCounts(SchemaField,RangeEndpointCalculator,ParsedParams)\nis still going to cause a new RangeEndpointCalculator to be constructed, and the exact same start/end/include/etc... Strings to be parsed over and over and over again, for every pivot value, at every level.  These things should really just be parsed once in prepare(), put into the request context, and reused at every level of every pivot.\n\nTo put it another way...\n\n\nWith the patch right now, if you do the following query using the techproducts example data:\n\n\nhttp://localhost:8983/solr/techproducts/select?rows=0&q=*:*&facet=true&facet.range=manufacturedate_dt&facet.range.start=2000-01-01T00:00:00Z&facet.range.end=2010-01-01T00:00:00Z&facet.range.gap=%2B1YEAR\n\n\n\n... then 41 DateRangeEndpointCalculator objects get instantated even though 1 is plenty;  the start value of \"2000-01-01T00:00:00Z\" and the end value \"2010-01-01T00:00:00Z\" each get parsed into Date objects 41 times, even though the result is always exactly the same.  That seems really inefficient ... doesn't it defeat the purpose of doing that param parsing in prepare()?\n\n "
        },
        {
            "author": "Shalin Shekhar Mangar",
            "id": "comment-14600060",
            "date": "2015-06-24T20:11:05+0000",
            "content": "Thanks for the review Hoss. This patch should take care of all the concerns you outlined.\n\n\nIf you don't think it makes sense to keep this method where it is that's fine, but it is a public method designed for people writting custom request handlers to use to add faceting to their stuff \u2013 so at the very least you should leave a deprecated stub in it's place that calls your new method.\nIt also confuses the hell out of me that in the process of moving this method you made the method signature more complicated to use (more args to understand, more exceptions to deal with) and got rid of the javadocs so the new more complicated call signature is even harder to understand \u2013 and I, frankly, can't make sense of why any of that is neccessary (even if should now live in a diff class because of the inheritence)...\nwhy does the caller have to pass in an empty NamedList to be mutated? why can't the method just return a NamedList like the old method did?\nwhy does the caller have to instantiate the date & range processors themselves?\nin both of the places this method is called, the processors are constructed just to pass to this method and then thrown away.\nSo why can't this static method construct them internally (using the request, docset, params, and response builder from the SimpleFacets object that's also passed as an arg) and keep the method signature simple?\nwhy does this new method catch & wrap SyntaxErrors but not IOExceptions like the old method?\n(If there reasons for these changes then great \u2013 but they aren't clear just from reading the patch, and there's no javadocs to get guidance from)\n\n\n\tI have restored the old method but marked it as deprecated.\n\tIt internally calls the new static helper method to add all kinds of facets.\n\tThe signature is also simplified. It now accepts a SimpleFacets class and constructs all other required processors internally and returns a NamedList like the old method did.\n\tNot wrapping IOException was a mistake. This is fixed.\n\n\n\n\nI don't see a class called \"RangeFacet\" ... it looks like you talking about RangeFacetValue?\nFWIW: PivotFacetValue doesn't extend FacetBase because it models a single (value,count) pair in the context of a PivotFacetField (which may be hierarchical) ... you may be thinking of \"PivotFacet\"\n... in which case, should this class atually be named \"RangeFacet\" ?\neither way: can we please beef up the javadocs of this class to be crystal clear about what it's modeling \u2013 at first glance I thought it was just modeling a facet.range param (with the field, start, end, calculator) before I realized it not only models the field + the indiviual buckets, but also the values in those buckets (but not the other params)\nIsn't RangeFacetValue.fieldName redundent here? - it's already handled by FacetBase.facetOn.\nI don't think there is any reason to initialize shardFieldValues in mergeContributionFromShard before the rangeFacet = rangeFromShard short-circut, it's just wasted cycles the first time the method gets called, correct?\n\nI further refactored the code into into three separate classes to divide the responsibilities clearly. \n\n\tThe first called RangeFacetRequest models a single facet.range request along with all request parameters, appropriate calculator and ranges (gaps). Instances of this class are now created once in FacetComponent.prepare and cached in the context and re-used for non-distrib facet.range calculation as well as in pivot facet classes.\n\tThe second RangeFacetRequest.DistribRangeFacet models the full 'facet_ranges' to be returned to the user for a distrib request and has helper methods for merging contributions of individual shards.\n\tThe third RangeFacetRequest.FacetRange models a single range i.e. an individual gap for which the count has to be computed. A list of this class is created by the calculator (inside RangeFacetRequest's constructor)\n\n\n\nThis is actually almost the same as the framework in the Analytics component with some minor modifications. Once this issue is committed, I'll open issues to refactor common code in a single place and re-use. It's funny that I started writing a class to pre-compute the gaps and ended up with almost the same code as RangeFacetRequest in Analytics but a little uglier so I threw that code away and started from the Analytics Component's design and tweaked it to fit our use-case.\n\n\nwhy a \"Map<String, RangeFacetValue>\" for rangeCounts instead of a NamedList?\nit seems like a really bad idea for these to not be returned in a deterministic order \u2013 it should be in the same order as the top level facet.range results (which is hte order of the facet.range params in the request)\nno idea if this HashMap usage currently causes problems in the shard merging, but it smells fishy \u2013 and either way the user should be able to count on getting the range facets back in the same order the asked for them\n\nThis is now a LinkedHashMap and its key/values are added in the same order as the NamedList from a shard's response. Though I do not agree about the user counting on the same order because this is not a list but a complex object in all our responses. But I digress.\n\n\ni didn't dig into the full ramifications of this, but you've got PivotFacetValue constructing RangeFacetValue objects and passing the response key in as the \"fieldName\" argument to the constructor \u2013 those aren't the same thing. Either the method call here is wrong, or the constructor arg should be renamed \u2013 either way any usage of this \"fieldName\" constructor arg and internal usage should be sanity checked to ensure it's used consistnetly everywhere\n\nThis is no longer an issue since we use the DistribRangeFacet class which has no need for a key at all.\n\n\nare there tests of using a diff response key from the fieldName when hanging ranges under pivots? (both single node and cloud?)\n\nYes, see DistributedFacetPivotSmallTest.testFacetPivotRange() and SolrExampleTests.testPivotFacetsRanges()\n\n\nin PivotFacetValue.mergeContributionFromShard, the dozen or so lines of looping over each shard's response to either construct a new RangeFacetValue or call RangeFacetValue.mergeContributionFromShard seems like it could/should be refactored into a static helper method (in the RangeFacetValue class)\n\nThat bit of code has been refactored into DistribRangeFacet.mergeFacetRangesFromShardResponse method.\n\n\nwhy is PivotFacetValue.createFromNamedList conditionally calling RangeFacetValue.mergeContributionFromShard?\n\nLaziness on my part, really. Now that this bit of code has been refactored into DistribRangeFacet.mergeFacetRangesFromShardResponse, I use the same here as well. The extra null check wouldn't hurt here.\n\n\nSince the input to PivotFacetHelper.mergeQueryCounts is already in the correct response format (ie: no special objects need constructed to model the simple counts) can't it just return \"querycounts\" if \"receivingMap\" is null? (instead of looping & adding)\n\nGood point, done.\n\n\nWith the current patch, something is wrong with how localparams are dealt with when trying to use facet.ranges inside of pivots. These queries are examples of doing range queries on the same field with diff gap params, and (independently) doing a pivot\n\nFixed. I am not sure why that happened but once I refactored the code to do all the parsing and calculation in prepare, I could not reproduce the issue.\n\n\nI haven't seen this piece of code yet, but it sounds like it only prevents the \"tags\" from being parsed over and over again \u2013 from what I've seen so far, RangeFacetProcessor.getFacetRangeCounts(ParsedParams,NamedList) which delegates to RangeFacetProcessor.getFacetRangeCounts(SchemaField,RangeEndpointCalculator,ParsedParams)\nis still going to cause a new RangeEndpointCalculator to be constructed, and the exact same start/end/include/etc... Strings to be parsed over and over and over again, for every pivot value, at every level. These things should really just be parsed once in prepare(), put into the request context, and reused at every level of every pivot.\n\nThis is also done as I noted earlier in my comment. The class RangeFacetRequest is the one to be looked at. "
        },
        {
            "author": "Shalin Shekhar Mangar",
            "id": "comment-14603102",
            "date": "2015-06-26T16:01:57+0000",
            "content": "Here's a new patch (SOLR-6353-4212.patch) which applies after the SOLR-6686 commit. "
        },
        {
            "author": "Hoss Man",
            "id": "comment-14612528",
            "date": "2015-07-02T21:11:57+0000",
            "content": "Updated patch wit ha few small changes, details mentioned below.\n\nComments in no particular order...\n\n\n\nI reiterate my earlier comment about javadocs \u2013 it's really hard to review a patch this size with so many new methods that don't have any javadocs at all.  Everytime I see a method mentioned in the new code, I look it up to jog my memory about what exactly it does and i wind up needing to re-read/skim each method over and over to remind myself what it does becaase they don't have any javadocs.  (I can't imagine how how any developer will ever be able to make sense of any of this code down the road w/o more method level docs)\n\nOn the flip side: PivotFacetHelper.mergeQueryCounts does have javadocs, but it doesn't look like they match what the method does \u2013 I'm pretty sure either the javadocs are wrong, or the method has a bug in it and isn't working as documented.\n\n\n\nI further refactored the code into into three separate classes to divide the responsibilities clearly. \n\nCool ... This organization makes a lot more sense then previous patches.\n\n\n\nFixed. I am not sure why that happened but once I refactored the code to do all the parsing and calculation in prepare, I could not reproduce the issue.\n\nWell, the best way to be sure it's fixed is to add a test showing that it works.\n\nI've updated your patch to add a request like this to DistributedFacetPivotLargeTest.\n\nIn order to get it to work, I had to also modify the Map<String,RangeFacetRequest> created by FacetComponent.prepare to be a LinkedHashMap (see more comments on this below) because otherwise it was a huge pain in the ass to try and write code to do anything with teh response in a clean way.\n\n\n\nThough I do not agree about the user counting on the same order because this is not a list but a complex object in all our responses. But I digress.\n\nI don't really understand the basis for your comment.\n\nMy argument is simple:\n\n\n\tGiven:\n\t\n\t\t(top level) Range Facet reults have always been returned as a NamedList, in the same order as specified by the facet.range params that requested them.\n\t\tThis order is modeled in SolrJ's QueryResponse class as List<RangeFacet> getFacetRanges()\n\t\n\t\n\tTherefore:\n\t\n\t\tWe should be consistent and return Range Facet results with the same predictible order when they are nested under pivots.\n\t\tThis is already true in the SolrJ modeling in your patch, which adds List<RangeFacet> getFacetRanges() to PivotField.\n\t\n\t\n\n\n\nIf nothing else, having the RangeFacets returned in the same order for both the top level results and the per-pivot results is the only sane/simple way for users to compute ratios between the top level range counts and the per pivot value counts when dealing with many/variable ranges \u2013 otherwise they have to sort them themselves to corrolate.\n\n\n\nAs I mentioned above regarding my test additions, I fixed the consistent ordering problem by changing the Map<String,RangeFacetRequest> created by FacetComponent.prepare to also be a LinkedHashMap.  But I still don't understand the purpose of this being a Map (where the keys are the original values of the facet.range params, not to be confused with having a Map keyed off of the tags associated with the list of RangeFacetRequests that use that tag discussed below) at all.\n\nAs far as i can tell all usages of this Map<String,RangeFacetRequest> either:\n\n\n\titerate over every entry in the Map and only look at the values.\n\titerate over every facet.range param string (in order), and use it to \"get()\" the RangeFacetRequest object that corrisponds with that param string.\n\n\n\n...wouldn't both of those usages be much simplier if instead of this Map there was just a List<RangeFacetRequest> that could be iterated over when the caller cares about looping over all RangeFacetRequest instances?\n\nIs there some other purpose for having this Map<String,RangeFacetRequest> that i'm not understanding?\n\n(see below for comments about creating a reused Map<String,List<RangeFacetRequest>> for when dealing with tags ... that's one of the current \"loop over all RangeFacetRequest\" usages that seems wrong to me anyway)\n\n\n\nI think you should revive your earlier idea of having a \"FacetContext\" object to put in the request context and use it to track the RangeFacetRequests and FacetBase (FACET_QUERY) objects.  (Either that, or just use the existing FacetInfo class for this since that's pretty much it's current purpose.  Is the reason you didn't already do that because FacetInfo isn't currently in the single node code path?)\n\nEither way (with or w/o a new FacetContext class, with or w/o reusing FacetInfo) the code to access the Map/List of all RangeFacetRequests and FacetBase objects should really be encapsulated in some way \u2013 if nothing else to reduce the amount of casting when consumers have to pull them out of req.getContext(...), but also to help future proof us against attempts to access those structures before they've been initialized by FacetComponent.prepare.  (ie: throw IllegalAccessException if !req.getContext().containsKey(WHATEVER_CONTEXT_KEY)\n\nexample...\n\n\nclass FacetComponent {\n  // ...\n  public static List<RangeFacetRequest> getAllRangeFacetRequestsFromContext(SolrQueryRequest req) {\n    List<RangeFacetRequest> result = (List<RangeFacetRequest>) req.getContext().get(MAGIC_CONTEXT_KEY);\n    if (null == result) {\n      throw new IllegalAccessException(\"RangeFacetRequests can't be accessed from context they are initalized\");\n    }\n    return result;\n  }\n  // etc...\n\n\n\n...or better still, with the FacetContext container...\n\n\nclass FacetContext {\n  public static FacetContext getFacetContext(SolrQueryRequest req) {\n    FacetContext result = (FacetContext) req.getContext().get(MAGIC_CONTEXT_KEY);\n    if (null == result) {\n      throw new IllegalAccessException(\"FacetContext can't be accessed before it's initalized in request context\");\n    }\n    return result;\n  }\n  private final List<RangeFacetRequest> allRangeFacets; // init in constructor\n  private final List<FacetBase> allQueryFacets; // init in constructor\n  public List<RangeFacetRequest> getAllRangeFacetRequests() { ... }\n  public List<FacetBase> getAllQueryFacets() { ... }\n \n  // // (see next comment about PivotFacetProcessor.getTaggedRangeFacets)\n  // private final Map<String,List<RangeFacetRequest>> taggedRangeFacets; // init in constructor\n  // private final Map<String,List<FacetBase>> taggedQueryFacets; // init in constructor\n  // public List<RangeFacetRequest> getRangeFacetRequestsForTag(String tag) { ... }\n  // public List<FacetBase> getAllQueryFacetsForTag(String tag) { ... }\n}\n\n\n\n\n\nPivotFacetProcessor.getTaggedRangeFacets (and getTaggedQueryFacets) seem really inefficient to me...\n\n\n\tunless i'm missreading these, every facet.pivot param is going to cause the the list(s) of all facet.range RangeFacetRequest objects (and all facet.query FacetBase objects) to be iterated over to say \"do you match this tag\"\n\t\n\t\tin the case of facet.pivot refinement requests, that's going to mean a lot of looping over the same lists over and over.\n\t\n\t\n\n\n\n\n\twhy doesn't this follow the same pattern as PivotFacetProcessor.getTaggedStatsFields (and StatsInfo.getStatsFieldsByTag)?\n\t\n\t\twhen the RangeFacetRequest (or facet.query FacetBase objects) are constructed, why isn't there a Map<String,List<RangeFacetRequest>> (and Map<String,List<FacetBase>>) keyed off of the \"tag\" values returning each each RangeFacetRequest (and each FacetBase) built so that getTaggedRangeFacets and getTaggedQueryFacets can just be fast/simple lookups on these Maps instead of constantly looping over the same lists repeatedly?\n\t\n\t\n\n\n\n(this \"tag->RangeFacetRequest\" mapping could easily be accessed via the same FacetContext mentioned above, see commented out part of that example code)\n\n\n\nThe way RangeFacetProcessor deals with FacetRangeOther seems really confusing and sketchy.  It took me a while to understand why those Exceptions were \"safe to ignore\"\n\nRather then rely on \"expected exceptions\" when looping over the List of FacetRanges, wouldn't the code be alot easier to understand if we changed FacetRange to look something like...\n\n\n/** null if this range doesn't corrispond to an {@link FacetRangeOther} */\npublic final FacetRange other;\n// ...other existing vars...\nprivate FacetRange(FacetRangeOther other, String name, ...) {\n  ...\n}\npublic FacetRange(String name,...) {\n  this(null, name, ...);\n}\npublic FacetRange(FacetRangeOther other, ...) {\n  this(other, other.name, ...);\n}\n\n\n\n...And then simplified the response building RangeFacetProcessor to look something like...\n\n\nfinal NamedList<Object> res = new SimpleOrderedMap<>();\nfinal NamedList<Integer> counts = new NamedList<>();\nres.add(\"counts\", counts); // built up below\n\n// explicitly return the gap.  compute this early so we are more\n// likely to catch parse errors before attempting math\nres.add(\"gap\", rfr.getGapObj());\n\n// explicitly return the start and end so all the counts\n// (including before/after/between) are meaningful - even if mincount\n// has removed the neighboring ranges\nres.add(\"start\", rfr.getStartObj());\nres.add(\"end\", rfr.getEndObj());\n\nfor (RangeFacetRequest.FacetRange range : rfr.getFacetRanges()) {\n  final int count = rangeCount(rfr, range);\n  if (null == range.getFacetRangeOther()) {\n    // normal range, added to count depending on mincount conditions...\n    if (count >= rfr.getMinCount()) {\n      counts.add(range.name, count);\n    }\n  } else {\n    // special 'other' count, added to higher level res\n    res.add(range.name, count);\n  }\n}\n\nreturn res;\n\n\n\n?\n\nIf I'm missing something, and there's a reason the current dual loops over all FacetRanges w/exception checking is better for some reason, then at a bare minimum those empty catch blocks need to make it a lot more clear why they are there and why the exceptions are there.\n\n\n\n\n    // TODO: slight optimization would prevent double-parsing of any localParams\n    Query qobj = QParser.getParser(parsed.facetValue, null, req).getQuery();\n\n\n\nI added a nocommit here to ensure we don't forget to file a jira to track this.\n\nIt's not just an issue of localparams, but also the parsing & construction of the Query object \u2013 doing that once per request (just like the way you've changed the range faceting to do all the bucket calculation once) could give us some serious performance savings when facet.query params are hung of of many and/or large pivot trees.  (should just mean a pretty trivial new subclass of FacetBase that also has a public Query getQuery() accessor)\n\n\n\nRangeFacetRequest implementation weirdness...\n\n\n\tIt's really weird that none of the public accessor methods (getStart, getEnd, getGap, getGapObj, etc...) have any javadocs, even though many of the protected variables they return do have jdocs (and the info in those jdocs seems pretty important to the method callers \u2013 like the distinction betwen end vs endObj).\n\n\n\n\n\tThe method signature & jdocs for createCalculator look dangerous \u2013 it says it will return a calculator based on the \"rangeFacetRequest\" argument, but it's a non static method and in a couple places (schemaField, facetOn) it ignores the \"rangeFacetRequest\" arg and uses properties of \"this\" (and in other places vice vesa) \u2013 suggesting either this method should be static so it doesn't accidently use \"this\", or it should be changed to not take any arguments and always refer to \"this\" (which seems to be the intention based on the place i see this method being called currently.)\n\n\n\n\n\tThere's a weird bit of \"format and immediately reparse\" logic in RangeFacetRequest + RangeEndpointCalculator that makes no sense to me...\n\t\n\t\tRangeEndpointCalculator knows the type specific \"end\" after looping over the ranges in computeRanges()\n\t\tRangeEndpointCalculator uses \"formatValue(end)\" to build \"endStr\"\n\t\tRangeEndpointCalculator.getComputedEnd() returns \"endStr\"\n\t\tRangeFacetRequest calls getComputedEnd() and then passes that String to RangeEndpointCalculator.getValue(String) to parse it back into a type specific object\n\t\twhy not just have a public T getComputedEnd() method return the original (type specific) \"end\" object the calculator already figured out?\n\t\n\t\n\tlikewise: the type specific start value...\n\t\n\t\tRangeEndpointCalculator.computeRanges() already figures out final T start = getValue(rfr.getStart());\n\t\tso why make RangeFacetRequest ask the calculator to reparse the original start string with calculator.getValue(start); ?\n\t\twhy not just have a public T getStart() method on the calculator to return that value it already parsed?\n\t\n\t\n\tlikewise: gap\n\t\n\t\tshould change RangeEndpointCalculator.getGap(String) to just getGap()\n\t\twon't save us any parsing round trips like the start / end changes suggested above, but will keep the API consistent\n\t\tfor the same reason the old code had this comment...\n\n// explicitly return the gap.  compute this early so we are more \n// likely to catch parse errors before attempting math\n\n\n...RangeEndpointCalculator should call & remember the value of parseGap() early in it's constructor, and then getGap() can just be a trivial accessor method.\n\t\n\t\n\n\n\n\n\nPivotFacetProcessor.addPivotQueriesAndRanges concerns...\n\n\n\tthis method was doing a lot of null checking against the facetQueries and facetRanges Lists \u2013 even though there was never any possibility of those lists being null\n\t(partly because of these null checks that always passed) things like SimpleFacets instances and RangeFacetProcessors were getting constructed for every Pivot value (even on refinement) even when there are no ranges or facet queries hanging off of a pivot.\n\n\n\nSo in the updated patch I also cleaned this method up a bit to assert the lists are non null and keep the logicc minimal when they are empty. (had to try it myself to be certain i wans't missing anything)\n\nI also tightened up the error handling to be more specific about where the SyntaxErrors are coming from.\n "
        },
        {
            "author": "Shalin Shekhar Mangar",
            "id": "comment-14614145",
            "date": "2015-07-05T06:14:36+0000",
            "content": "\nOn the flip side: PivotFacetHelper.mergeQueryCounts does have javadocs, but it doesn't look like they match what the method does \u2013 I'm pretty sure either the javadocs are wrong, or the method has a bug in it and isn't working as documented.\n\nFixed. This method was refactored and I forgot to update the javadocs.\n\n\nI've updated your patch to add a request like this to DistributedFacetPivotLargeTest.\n\nThanks!\n\n\n\n...wouldn't both of those usages be much simplier if instead of this Map there was just a List<RangeFacetRequest> that could be iterated over when the caller cares about looping over all RangeFacetRequest instances?\n\nI changed the Map to a List.\n\n\n\nI think you should revive your earlier idea of having a \"FacetContext\" object to put in the request context and use it to track the RangeFacetRequests and FacetBase (FACET_QUERY) objects. \n\nI have created a new FacetContext class which holds all parsed range facets and query facets and also has a map of tag vs list of parsed facets such that we can do quick lookups by tag.\n\n\n\n(Either that, or just use the existing FacetInfo class for this since that's pretty much it's current purpose. Is the reason you didn't already do that because FacetInfo isn't currently in the single node code path?)\n\nYeah, that\u2019s pretty much it. The current FacetInfo is exclusively used for merging distributed results which makes it a bit inflexible for our requirements.\n\n\nThe way RangeFacetProcessor deals with FacetRangeOther seems really confusing and sketchy. It took me a while to understand why those Exceptions were \"safe to ignore\"\n\nI refactored as you suggested. This is much cleaner, thank you!\n\n\nI added a nocommit here to ensure we don't forget to file a jira to track this.\nIt's not just an issue of localparams, but also the parsing & construction of the Query object \u2013 doing that once per request (just like the way you've changed the range faceting to do all the bucket calculation once) could give us some serious performance savings when facet.query params are hung of of many and/or large pivot trees. (should just mean a pretty trivial new subclass of FacetBase that also has a public Query getQuery() accessor)\n\nI opened SOLR-7753\n\n\nIt's really weird that none of the public accessor methods (getStart, getEnd, getGap, getGapObj, etc...) have any javadocs, even though many of the protected variables they return do have jdocs (and the info in those jdocs seems pretty important to the method callers \u2013 like the distinction betwen end vs endObj).\n\nDone. Initially I had kept the fields as public final but later I changed them to private and added accessor methods. Didn\u2019t remember to move the javadocs. I have added copious amounts of javadocs to each one of them now.\n\n\nThe method signature & jdocs for createCalculator look dangerous\n\nYou\u2019re right. I changed it to a private method which operates on \u201cthis\u201d.\n\n\nThere's a weird bit of \"format and immediately reparse\" logic in RangeFacetRequest + RangeEndpointCalculator that makes no sense to me\n\nFixed, as you suggested.\n\n\nPivotFacetProcessor.addPivotQueriesAndRanges concerns...\nthis method was doing a lot of null checking against the facetQueries and facetRanges Lists \u2013 even though there was never any possibility of those lists being null\n(partly because of these null checks that always passed) things like SimpleFacets instances and RangeFacetProcessors were getting constructed for every Pivot value (even on refinement) even when there are no ranges or facet queries hanging off of a pivot.\nSo in the updated patch I also cleaned this method up a bit to assert the lists are non null and keep the logicc minimal when they are empty. (had to try it myself to be certain i wans't missing anything)\nI also tightened up the error handling to be more specific about where the SyntaxErrors are coming from.\n\nThank you, looks really good.\n\nI think this is ready. Please give it another look and let me know if it's good to go in. "
        },
        {
            "author": "Shalin Shekhar Mangar",
            "id": "comment-14614552",
            "date": "2015-07-06T05:12:12+0000",
            "content": "I found a test failure with the last patch. I'll upload a new patch shortly. "
        },
        {
            "author": "Shalin Shekhar Mangar",
            "id": "comment-14615003",
            "date": "2015-07-06T13:07:29+0000",
            "content": "This patch passes all tests and precommit.\n\nThe test failure that I saw earlier was in TestDistributedSearch where a facet request is made with the same facet range repeated twice. The FacetComponent deduplicates all facet parameters before execution but I was not doing that in the prepare method where all the range facets were being parsed. I fixed this by moving the deduplication step in prepare and putting the modified parameter object back in the request. "
        },
        {
            "author": "Shalin Shekhar Mangar",
            "id": "comment-14616915",
            "date": "2015-07-07T16:11:31+0000",
            "content": "Two changes in this patch:\n\n\tI moved the DocSet calculation down to the rangeCount method in RangeFacetProcessor but that lead to repeated calculation of the DocSet if any grouping or exclusions were involved. In this patch, the doc set is calculated once in RangeFacetProcessor.getFacetRangeCounts and passed down to the rangeCount method.\n\tI changed FacetContext.getFacetContext method to throw IllegalStateException instead of IllegalAccessException.\n\n "
        },
        {
            "author": "Hoss Man",
            "id": "comment-14616990",
            "date": "2015-07-07T17:05:55+0000",
            "content": "\nIn this patch, the doc set is calculated once in RangeFacetProcessor.getFacetRangeCounts and passed down to the rangeCount method.\n\n...good catch.\n\nI changed FacetContext.getFacetContext method to throw IllegalStateException instead of IllegalAccessException.\n\nyeah, my bad \u2013 sorry about that.\n\n\n\nThe current patch looks really solid to me, only one thing i think we definitely need to clean up (and a few less important nitpicks/concerns) ...\n\n\nI have created a new FacetContext class which holds all parsed range facets and query facets and also has a map of tag vs list of parsed facets such that we can do quick lookups by tag.\n\n(Either that, or just use the existing FacetInfo class for this since that's pretty much it's current purpose. Is the reason you didn't already do that because FacetInfo isn't currently in the single node code path?)\n\nYeah, that\u2019s pretty much it. The current FacetInfo is exclusively used for merging distributed results which makes it a bit inflexible for our requirements.\n\n...can you please add some specifics to the FacetContext and FacetInfo class jdocs that point to eachother and explain/compare/contrast the differences (ie: explain when/why each is used so people trying to make sense of various bits of code get the distinction)\n\n\n\nNit-Picks...\n\n\n\tlooking at how FacetContext.setFacetContext is used, i'm wondering if a cleaner API would be to make the FacetContext constructor private, and replace setFacetContext with something like...\n\npublic static void initFacetContext(ResponseBuilder rb) {\n  if (rb.getContext().containsKey(MAGIC_KEY)) {\n    throw new IllegalStateException(\"Context must only be initialized once per request...\");\n  }\n  // ...Parse params into things like RangeFacetRequest & build Lists & Maps for context\n}\n\n\n...that seems like it would be safer and guard against agcidental missuse of redundent \"new FacetContext\" or \"FacetContext.setFacetContext(...)\" by devs in the future\n\twith the new FacetContext object, PivotFacetProcessor.getTaggedQueryFacets and PivotFacetProcessor.getTaggedRangeFacets seem fairly unneccessary \u2013 if we just move the \"if null use emptyList()\" logic into the FacetContext equivilents can't we just refactor them into oblivion?\n\n\n "
        },
        {
            "author": "Shalin Shekhar Mangar",
            "id": "comment-14617323",
            "date": "2015-07-07T20:28:07+0000",
            "content": "\n...can you please add some specifics to the FacetContext and FacetInfo class jdocs that point to eachother and explain/compare/contrast the differences (ie: explain when/why each is used so people trying to make sense of various bits of code get the distinction)\n\nYeah, absolutely. I added the following:\n\n/**\n* Encapsulates facet ranges and facet queries such that their parameters\n* are parsed and cached for efficient re-use.\n* <p/>\n* An instance of this class is initialized and kept in the request context via the static\n* method {@link org.apache.solr.handler.component.FacetComponent.FacetContext#initContext(ResponseBuilder)} and\n* can be retrieved via {@link org.apache.solr.handler.component.FacetComponent.FacetContext#getFacetContext(SolrQueryRequest)}\n* <p/>\n* This class is used exclusively in a single-node context (i.e. non distributed requests or an individual shard\n* request). Also see {@link org.apache.solr.handler.component.FacetComponent.FacetInfo} which is\n* dedicated exclusively for merging responses from multiple shards and plays no role during computation of facet\n* counts in a single node request.\n*\n* <b>This API is experimental and subject to change</b>\n*\n* @see org.apache.solr.handler.component.FacetComponent.FacetInfo\n*/\npublic static class FacetContext {\n...\n}\n\n/**\n* This class is used exclusively for merging results from each shard\n* in a distributed facet request. It plays no role in the computation\n* of facet counts inside a single node.\n*\n* A related class {@link org.apache.solr.handler.component.FacetComponent.FacetContext}\n* exists for assisting computation inside a single node.\n*\n* <b>This API is experimental and subject to change</b>\n*\n* @see org.apache.solr.handler.component.FacetComponent.FacetContext\n*/\npublic static class FacetInfo {\n...\n}\n\n\n\n\nLooking at how FacetContext.setFacetContext is used, i'm wondering if a cleaner API would be to make the FacetContext constructor private, and replace setFacetContext with something like...\n\nGood idea. This patch has:\n\n/**\n* Initializes FacetContext using request parameters and saves it in the request\n* context which can be retrieved via {@link #getFacetContext(SolrQueryRequest)}\n*\n* @param rb the ResponseBuilder object from which the request parameters are read\n*           and to which the FacetContext object is saved.\n*/\npublic static void initContext(ResponseBuilder rb)  {\n...\n}\n\nprivate FacetContext(List<RangeFacetRequest> allRangeFacets, List<FacetBase> allQueryFacets) {\n...\n}\n\n/**\n* Return the {@link org.apache.solr.handler.component.FacetComponent.FacetContext} instance\n* cached in the request context.\n*\n* @param req the {@link SolrQueryRequest}\n* @return the cached FacetContext instance\n* @throws IllegalAccessException if no cached FacetContext instance is found in the request context\n*/\npublic static FacetContext getFacetContext(SolrQueryRequest req) throws IllegalStateException {\n...\n}\n\n\n\n\nwith the new FacetContext object, PivotFacetProcessor.getTaggedQueryFacets and PivotFacetProcessor.getTaggedRangeFacets seem fairly unneccessary \u2013 if we just move the \"if null use emptyList()\" logic into the FacetContext equivilents can't we just refactor them into oblivion?\n\nDone. The null check is moved inside FacetContext methods and the methods are inlined into PivotFacetProcessor.process().\n\nI'll commit this tomorrow morning my time unless there are any objections. "
        },
        {
            "author": "Hoss Man",
            "id": "comment-14617381",
            "date": "2015-07-07T20:51:22+0000",
            "content": "\nI'll commit this tomorrow morning my time unless there are any objections.\n\n+1 "
        },
        {
            "author": "ASF subversion and git services",
            "id": "comment-14618157",
            "date": "2015-07-08T07:46:11+0000",
            "content": "Commit 1689802 from shalin@apache.org in branch 'dev/trunk'\n[ https://svn.apache.org/r1689802 ]\n\nSOLR-4212: SOLR-6353: Let facet queries and facet ranges hang off of pivots "
        },
        {
            "author": "ASF subversion and git services",
            "id": "comment-14618413",
            "date": "2015-07-08T11:05:28+0000",
            "content": "Commit 1689839 from shalin@apache.org in branch 'dev/branches/branch_5x'\n[ https://svn.apache.org/r1689839 ]\n\nSOLR-4212: SOLR-6353: Let facet queries and facet ranges hang off of pivots "
        },
        {
            "author": "ASF subversion and git services",
            "id": "comment-14618417",
            "date": "2015-07-08T11:07:14+0000",
            "content": "Commit 1689840 from shalin@apache.org in branch 'dev/trunk'\n[ https://svn.apache.org/r1689840 ]\n\nSOLR-4212: SOLR-6353: Added attribution in changes.txt "
        },
        {
            "author": "ASF subversion and git services",
            "id": "comment-14618419",
            "date": "2015-07-08T11:07:56+0000",
            "content": "Commit 1689841 from shalin@apache.org in branch 'dev/branches/branch_5x'\n[ https://svn.apache.org/r1689841 ]\n\nSOLR-4212: SOLR-6353: Added attribution in changes.txt "
        },
        {
            "author": "Shalin Shekhar Mangar",
            "id": "comment-14618423",
            "date": "2015-07-08T11:09:00+0000",
            "content": "Thanks Steve and Hoss! "
        },
        {
            "author": "Shalin Shekhar Mangar",
            "id": "comment-14713237",
            "date": "2015-08-26T13:06:10+0000",
            "content": "Bulk close for 5.3.0 release "
        }
    ]
}