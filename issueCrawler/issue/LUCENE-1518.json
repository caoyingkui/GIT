{
    "id": "LUCENE-1518",
    "title": "Merge Query and Filter classes",
    "details": {
        "labels": "",
        "priority": "Major",
        "components": [
            "core/search"
        ],
        "type": "Improvement",
        "fix_versions": [
            "5.1",
            "6.0"
        ],
        "affect_versions": "2.4",
        "resolution": "Fixed",
        "status": "Closed"
    },
    "description": "This issue presents a patch, that merges Queries and Filters in a way, that the new Filter class extends Query. This would make it possible, to use every filter as a query.\n\nThe new abstract filter class would contain all methods of ConstantScoreQuery, deprecate ConstantScoreQuery. If somebody implements the Filter's getDocIdSet()/bits() methods he has nothing more to do, he could just use the filter as a normal query.\n\nI do not want to completely convert Filters to ConstantScoreQueries. The idea is to combine Queries and Filters in such a way, that every Filter can automatically be used at all places where a Query can be used (e.g. also alone a search query without any other constraint). For that, the abstract Query methods must be implemented and return a \"default\" weight for Filters which is the current ConstantScore Logic. If the filter is used as a real filter (where the API wants a Filter), the getDocIdSet part could be directly used, the weight is useless (as it is currently, too). The constant score default implementation is only used when the Filter is used as a Query (e.g. as direct parameter to Searcher.search()). For the special case of BooleanQueries combining Filters and Queries the idea is, to optimize the BooleanQuery logic in such a way, that it detects if a BooleanClause is a Filter (using instanceof) and then directly uses the Filter API and not take the burden of the ConstantScoreQuery (see LUCENE-1345).\n\nHere some ideas how to implement Searcher.search() with Query and Filter:\n\n\tUser runs Searcher.search() using a Filter as the only parameter. As every Filter is also a ConstantScoreQuery, the query can be executed and returns score 1.0 for all matching documents.\n\tUser runs Searcher.search() using a Query as the only parameter: No change, all is the same as before\n\tUser runs Searcher.search() using a BooleanQuery as parameter: If the BooleanQuery does not contain a Query that is subclass of Filter (the new Filter) everything as usual. If the BooleanQuery only contains exactly one Filter and nothing else the Filter is used as a constant score query. If BooleanQuery contains clauses with Queries and Filters the new algorithm could be used: The queries are executed and the results filtered with the filters.\n\n\n\nFor the user this has the main advantage: That he can construct his query using a simplified API without thinking about Filters oder Queries, you can just combine clauses together. The scorer/weight logic then identifies the cases to use the filter or the query weight API. Just like the query optimizer of a RDB.",
    "attachments": {
        "LUCENE-1518.patch": "https://issues.apache.org/jira/secure/attachment/12397710/LUCENE-1518.patch"
    },
    "issue_links": {},
    "comments": [
        {
            "date": "2009-01-12T19:50:33+0000",
            "content": "This is the patch.\n\nMost tests pass. Problems are only in the tests that check the explanations (TestSimpleExplanations) when wrapping the deprecated ConstantScoreQuery. For that the test must be rewritten to directly get the explanation from the Filter class (that is now a query). ConstantScoreQuery is just a no-op that rewrites to the wrapped Filter itsself but returns no weight and no explanation.\n\nSome small problems are the handling of toString()/toString(fieldname). The abstract Filter class has no toString(fieldname), but Query has one (but abstract). So there must be a default or Field implementations must be extended to provide one (bc break). The patch uses some bad workaround for that, maybe somebody has a better idea how to handle this. ",
            "author": "Uwe Schindler",
            "id": "comment-12663064"
        },
        {
            "date": "2009-01-12T19:56:56+0000",
            "content": "Further patches must now remove the deprecated ConstantScoreQuery from the core and contrib classes (RangeQuery gets identical to RangeFilter and so on).\n\nThe rewrite method (inherited from the Filter API) may then be changed in RangeQuery to return a BooleanQuery when useConstantScoreRewrite==false. In this case the RangeFilter gets the same as the Query and when used as Query, can also rewrite to TermQueries. But as I know, this is to be removed in Lucene 3.0. In this case every RangeFilter and the others can simply be constant score or filters. ",
            "author": "Uwe Schindler",
            "id": "comment-12663069"
        },
        {
            "date": "2009-01-12T20:24:14+0000",
            "content": "> the query can be executed and returns score 1.0 for all matching documents\n\nWhy 1.0 and not 0.0?  I chose to use 0.0 in KS because then a Filter would effectively perform only binary filtering and never affect scores.\n\nPerhaps your envisioned query optimization algo ensures that the Filter will only serve as a DocIDSetIterator unless it's used as a top-level Query?  Can we agree that a Filter used as a sub-clause in a complex query should not contribute to the aggregate score?\n\nUPDATE: A closer reading reveals that the original issue text contains the answer to this question (we agree), so the only remaining question is whether a top level query would return hits with scores of 0.0 or 1.0. Which is probably a bikeshed painting issue. ",
            "author": "Marvin Humphrey",
            "id": "comment-12663077"
        },
        {
            "date": "2009-01-12T20:49:59+0000",
            "content": "> Why 1.0 and not 0.0?\n\n0.0 does seem more appropriate, since scores are typically added, not multiplied.  There used to be places that filtered anything with a 0.0 score however.  Are any of those left? ",
            "author": "Doug Cutting",
            "id": "comment-12663090"
        },
        {
            "date": "2009-01-12T20:59:38+0000",
            "content": "Why 1.0 and not 0.0? I chose to use 0.0 in KS because then a Filter would effectively perform only binary filtering and never affect scores.\n\nYou are right. I was coming from the ConstantScoreQuery that has a score of 1.0 in the result.\n\n\nPerhaps your envisioned query optimization algo ensures that the Filter will only serve as a DocIDSetIterator unless it's used as a top-level Query? Can we agree that a Filter used as a sub-clause in a complex query should not contribute to the aggregate score?\n\nUPDATE: A closer reading reveals that the original issue text contains the answer to this question (we agree), so the only remaining question is whether a top level query would return hits with scores of 0.0 or 1.0. Which is probably a bikeshed painting issue.\n\nThis is exactly what I was thinking about. But it is not only a top level query. In the case of a BooleanQuery containing only one clause that is a filter, the constant score implementation must also used (as a Filter alone is useless).\n\nConstantScoreQuery returns 1.0 if executed alone or alone in a BooleanQuery.\n\nFor backwards compatibility, I think we should just use the following logic:\nA filter is a query, but can also be used as a query (if alone). The default implementation for this is a constant score query as currently when wrapping a filter with ConstantScoreQuery. In all other cases (combined with other boolean clauses and not alone), the score calculation is removed and you can say 0.0f (if additive). ",
            "author": "Uwe Schindler",
            "id": "comment-12663091"
        },
        {
            "date": "2009-01-12T22:20:13+0000",
            "content": "nice, \nyou did it top down (api), Paul takes it bottom up (speed). \n\nthis makes some really crazy things possible, e.g. implementing normal TermQuery as a \"DirectFilter\" and when the optimization of the BooleanQuery gets done (no Score calculation, direct usage of DocIdSetIterators) you can speed up some queries containing TermQuery  without really instantiating Filter. Of course only for cases where tf/idf/norm can be ignored. \n\nKind of middle-ground between Filter and full ranked TermQuery (better said any BooleanQuery!), Faster than ranked case due to the switched off score calculation and more comfortable than Filter usage, no instantiation of DocIdSet-s... \n\nvery nice indeed, smooth mix between ranked and \"pure boolean\" model with both benefits.   ",
            "author": "Eks Dev",
            "id": "comment-12663120"
        },
        {
            "date": "2009-01-12T22:36:24+0000",
            "content": "There used to be places that filtered anything with a 0.0 score however. Are any of those left?\nThey should be gone by now, even from the javadocs. ",
            "author": "Paul Elschot",
            "id": "comment-12663131"
        },
        {
            "date": "2009-01-12T22:38:03+0000",
            "content": "Hopefully this will allow caching of individual term queries even if they are a part of a boolean query? ",
            "author": "Jason Rutherglen",
            "id": "comment-12663133"
        },
        {
            "date": "2009-01-12T22:38:45+0000",
            "content": "In my opinion, both approches could be combined. I do not know how the scoring and the whole BooleanQery works, I did only the merging of the API. If we have consensus, that this may be good, I could remove the rest of deprecated ConstantScoreQuery. The new code then works without any problems and backwards compatible as before, but with no optimization.\n\nThen Paul could adapt his patch to not create new methods to add Filter clauses to BooleanQueries, but do just some difference in the whole BooleanQuery logic like that:\n\nif (clause.query instanceof Filter) \n{ do only filter optimization from Paul's patch }\n else \n{ do conventional boolean scoring }\n\nIf he cannot do the optimization (because the Filter is alone in BooleanQuery) he could just fall back to the standard query logic (that uses implicit the current ConstantScoreQuery algorithm).\n\nBut before start implementing more for removing the deprecated class, I wanted to hear some more ideas, maybe something completely different (like every query can also automatically be a filter): Only one superclass \"Query\" no filter anymore, every query clause can implement a filter and/or a query with always a Fallback to the other side (if no filter implementation provided, a filter is provided by a algorithm like QueryFilter; if no weight/rewrite, constant score weight is provided).\n\nJust ideas... ",
            "author": "Uwe Schindler",
            "id": "comment-12663134"
        },
        {
            "date": "2009-01-16T08:28:27+0000",
            "content": "Broadly, the patch moves the internal ConstantScorer class from ConstantScoreQuery to Filter.\n\nThat means that to add a Filter to a BooleanQuery as a clause, the user will need an option whether or not to have the Filter take part in the scoring.\nSo, with this for BooleanQuery an option of scoring/non scoring in the API for adding clauses will be needed,\nwhereas without this the possibility to add a Filter will be needed. I don't care either way.\n\nAre there other places where a Query is used now in which a Filter could also be useful?\nAnd are there other use cases for ConstantScoreQuery than on top of a Filter? ",
            "author": "Paul Elschot",
            "id": "comment-12664432"
        },
        {
            "date": "2009-01-16T08:33:06+0000",
            "content": "That means that to add a Filter to a BooleanQuery as a clause, the user will need an option whether or not to have the Filter take part in the scoring.\n\nWhy is this needed? A constant score query does not effect the scoring at all. Why not simply optimize the scoreing of filters away in BooleanQuery in all cases (if there are other queries available in the BooleanQuery that do scoring)? ",
            "author": "Uwe Schindler",
            "id": "comment-12664433"
        },
        {
            "date": "2009-01-16T17:18:39+0000",
            "content": "The option is needed because the coordination factor in the result score depends on the number of matching query clauses.\n\nAlso, without the option, a check will have to be done whether the score is constant and 0. I'm not even sure whether that would always work for subclasses of Filter that change the score to a possibly non constant value. ",
            "author": "Paul Elschot",
            "id": "comment-12664569"
        },
        {
            "date": "2009-01-21T08:01:04+0000",
            "content": "Even now that this has had some time, I still think LUCENE-1345 should go before this, and implement Filter clauses to BooleanQuery using the current simple Filter in a backward compatible way.\n\nThen, in case the resulting BooleanQuery really turns out to be too complicated for general use, this issue could be taken up again. ",
            "author": "Paul Elschot",
            "id": "comment-12665750"
        },
        {
            "date": "2009-01-21T11:03:40+0000",
            "content": "I have no problem with this. I was waiting for more comments on this befor starting to factor out ConstantScoreQuery from the rest of the core/contrib lasses. In principle the current patch is backwards compatible, so you could also use it as basis for your work. In the case that my idea is not the way to go, this may be lost time (but: as always queries are rewritten before execution, the unneeded ConstantScoreQuery rewrites to the filter, and your instanceof check in BooleanScorer/-Query should correctly detect all filters). ",
            "author": "Uwe Schindler",
            "id": "comment-12665796"
        },
        {
            "date": "2009-01-21T12:02:19+0000",
            "content": "I don't think the time is lost. In case there is a way to really simplify/unify Query and Filter, I want to know, too.\n\nBtw. there is no instanceof check in the patch at LUCENE-1345. The reason for that is that adding a Filter as a clause is done by another method than the method to add a Query, so the compiler can deal with the difference. ",
            "author": "Paul Elschot",
            "id": "comment-12665809"
        },
        {
            "date": "2009-02-09T13:36:52+0000",
            "content": "At first blush, this patch seems backwards: shouldn't the base class\nbe a Filter (which does \"pure matching\" with no scoring) and then\nsubclass of that (Query) would add in scoring?\n\nBut, then I think I appreciate why we did this: it's because we accept\nQuery all over the place now, so it's a far less disruptive change to\nhave Filter be the subclass.\n\nOr... we might want to allow scoring without matching, so maybe they\nshould be fully independent?\n\nEG when I want to dynamically boost relevance scores (eg by recency,\npopularity, personalizaztion, etc.), I would want to make a \"pure\nscorer\" that has absolutely no matching role, whose score gets \"mixed\nin\" based on the sub-query's boost.\n\nValueSourceQuery is an example: it has a \"degenerate\" matcher (matches\nall docs) whose only purpose is to produce custom per-doc scoring.\n\nShouldn't I be able to add a \"purer scorer\" (no matching) as a clause\nonto BooleanQuery? ",
            "author": "Michael McCandless",
            "id": "comment-12671851"
        },
        {
            "date": "2009-02-10T07:53:55+0000",
            "content": "This patch does not want to completely merge queries and filters. It only gives the possibility to use a Filter directly as a query. So ValueSourceQuery will stay direct subclass of Query and not of Filter and can be used as scorer only. I think completely merging both is not a good idea.\n\nBut for easy usage, the idea of making filter automatically work as query (using a constant score algorithm) may be good. So queries (e.g. without matching, also conventional queries)  can stay alive, but filters can be used as query (and BooleanQuery could automatically have filters as clauses, and is able to optimize and factor away scoring).\n\nThe user only has an easy understandable API and would not be affected with thinking about \"is it better to use a ConstantScoreQuery or should I just filter the results of the other boolean query clauses? What if I only have the filter, do I need a MatchAllDocsQuery and filter it, or better use ConstantScore in this case?\". ",
            "author": "Uwe Schindler",
            "id": "comment-12672199"
        },
        {
            "date": "2009-04-17T21:00:26+0000",
            "content": "What's the status of this patch? Have we agreed on how the class\nstructure is going to look and what the optimizations will look\nlike? ",
            "author": "Jason Rutherglen",
            "id": "comment-12700325"
        },
        {
            "date": "2009-04-18T09:15:10+0000",
            "content": "My opinion is that the attached patch has most backwards-compatibility (with some small toString() issues), but it makes Filter a subclass of query with the default constant score logic. Further work to remove the extra Filter classes for MultiTermQueries (RangeFilter, PrefixFilter,...) and so on can be done later or as part of this patch (did'nt want to start with this before being sure, that the API looks good). \n\nThis will not make anything faster, but make the API for users simplier. No longer differentiate between query and filter.\n\nThe optimization can be part of LUCENE-1345. In this case, BooleanQuery API does not need to be changed (no extra Filter clauses, because Filters can be added directly as normal Query clauses). The optimizations from 1345 then could directltly test with instanceof, if something is a filter.\n\nWAS: One problem is Fuzzy Query that can also be used as Filter (subclass of MultiTermQuery), but there scoring is important.\n\nEDIT:\nThis is not a problem: MultiTermQuery will also be a filter and vice versa. It depends on what rewrite does. If ConstantScoreMode is on, it will return itsself (through super.rewrite()), if it rewrites to boolean query, it should do it. In this case the result of rewrite is no longer a filter, and filter optimization do not apply. So important with this new API is, that rewrite is called first (even for filters, but as filters are queries now, this would automatically be done). The optimizations in 1345 then would only get the result of the rewrite (and instanceof checks would be on the rewritten one, which maybe a filter or not). ",
            "author": "Uwe Schindler",
            "id": "comment-12700437"
        },
        {
            "date": "2009-04-18T15:05:07+0000",
            "content": "> Have we agreed on how the class structure is going to look and what the\n> optimizations will look like?\n\nI don't think this problem is solved.  \n\nI thought I had come up with a grand unifying OO design solution with my\nMatcher proposal for Lucy.  Matcher was to be the base class for any matching\niterator, whether the task was scoring, filtering, or deletions (a specialized\nkind of filter).  A provisional implementation has been completed in KS svn\ntrunk.\n\nUnfortunately, McCandless's benchmarks on iterated vs. random access filters\nhave blown a hole in the Matcher approach.  Whether it can be mended, or\nwhether starting over from scratch is the best idea, I don't know.  I really\nhate the hasRandomAccess() approach from an OO design standpoint, but I have\nto admit that I don't have anything better.  However, I do think that it's\nessential for any Filter refactoring to answer Mike's challenge in full.\n\nRight now, we don't have search-time benchmarking capabilities for Lucy/KS,\nand I don't think it's possible for me, at least, to pursue any further\nexperimentation until we acquire those capabilities.  For the time being, I've\nturned my attention to other concerns, and I don't expect to push this issue\nforward for a little while.   ",
            "author": "Marvin Humphrey",
            "id": "comment-12700490"
        },
        {
            "date": "2009-04-19T11:14:44+0000",
            "content": "\nI really hate the hasRandomAccess() approach from an OO design standpoint, but I have to admit that I don't have anything better.\n\nI think we need to approach this as a structural optimization problem;\nI think there should be an \"optimize()\" step after (or during)\nrewrite().  The optimize phase would structure the matching to run as\nquickly as possible.\n\nIe, on detecting somehow that a filter is random access, we should\nmultiply it out (down) to each TermScorer.  If deletes are\npre-multiplied in the filter, we tell each TermScorer not to check\ndeletes.\n\n[We may need a filter manager to go along w/ this, eg that will\nconvert a filter to random-access (if it's going to be reused),\nmultiply in deletes (and re-do that whenever new reader is opened),\netc.]\n\nLikewise, LUCENE-1252 splits matching of queries that consult\npositional information into two steps (roughly \"cheap\" and\n\"expensive\") and does all \"cheap\" tests across each \"and\" clause and\n\"expensive\" only when necessary.  So optimize() would return two\nmatchers for such queries, and we'd \"collate\" the cheap matchers\ntogether first, followed by the expensive one.\n\nNot requiring an implicit next() after skipTo() ... so optimize would\ndecide which matchers should \"drive\" the iteration, and which others\nshould do random-access test.  Some next()'s (eg OR or AND matchers)\nare far more costly than other next()'s (eg, TermScorer).  Some are\nfar more restrictive than others, etc.\n\nOf course, some filters require iterator access, so clearly we must\naccept that.\n\nAt some point, there will be too much splintering of options and\nsource code specialization should [somehow] take over in enumerating\nall the combinations.  EG the field-sort collectors are already\ngetting close to this (record score or not, compute max score or not,\nsingle field vs multi field, docID required for tie breaking or not,\netc). ",
            "author": "Michael McCandless",
            "id": "comment-12700577"
        },
        {
            "date": "2009-04-30T06:35:05+0000",
            "content": "I would like to query why do we need to make Filter and Query of the same type? After all, they both do different things, even though it looks like they are similar. Attempting to do this yields those peculiarities:\n\n\tIf Filter extends Query, it now has to implement all sorts of methods like weight, toString, rewrite, getTerms and scoresDocInOrder (an addition from LUCENE-1593).\n\tIf Query extends Filter, it has to implement getDocIdSet.\n\tIntroduce instanceof checks in places just to check if a given Query is actually a Filter or not.\n\n\n\nBoth (1) and (2) are completely redundant for both Query and Filter, i.e. why should Filter implement toString(term) or scoresDocInOrder when it does score docs? Why should Query implement getDocIdSet when it already implements a weight().scorer() which returns a DocIdSetIterator?\n\nI read the different posts on this issue and I don't understand why we think that the API is not clear enough today, or is not convenient:\n\n\n\tIf I want to just filter the entire index, I have two ways: (1) execute a search with MatchAllDocsQuery and a Filter (2) Wrap a filter with ConstantScoreQuery. I don't see the difference between the two, and I don't think it forces any major/difficult decision on the user.\n\tIf I want to have a BooleanQuery with several clauses and I want a clause to be a complex one with a Filter, I can wrap the Filter with CSQ.\n\tIf I want to filter a Query, there is already API today on Searcher which accepts both Query and Filter.\n\n\n\nAt least as I understand it, Queries are supposed to score documents, while Filters to just filter. If there is an API which requires Queries only, then I can wrap my Filter with CSQ, but I'd prefer to check if we can change that API first (for example, allowing BooleanClause to accept a Filter, and implement a weight(IndexReader) rather than just getQuery()).\n\nSo if Filters just filter and Queries just score, the API on both is very clear: Filter returns a DISI and Query returns a Scorer (which is also a DISI). I don't see the advantage of having the code unaware to the fact a certain Query is actually a Fitler - I prefer it to be upfront. That way, we can do all sorts of optimizations, like asking the Filter for next() first, if we know it's supposed to filter most of the documents.\n\nAt the end of the day, both Filter and Query iterate on documents. The difference lies in the purpose of iteration. In my code there are several Query implementations today that just filter documents, and I plan to change all of them to implement Filter instead (that was originally the case because Filter had just bits() and now it's more efficient with the iterator() version, at least to me). I want to do this for a couple of reasons, clarity being one of the most important. If Filter just filters, I don't see why it should inherit all the methods from Query (or vice versa BTW), especially when I have this CSQ wrapper.\nTo me, as a Lucene user, I make far more complicated decisions every day than deciding whether I want to use a Filter as a Query or not. If I pass it directly to IndexSearcher, I use it as a filter. If I use a different API which accepts just Query, I wrap it with CSQ. As simple as that.\n\nBut that's just my two cents. ",
            "author": "Shai Erera",
            "id": "comment-12704499"
        },
        {
            "date": "2009-04-30T10:30:14+0000",
            "content": "imo, it is really not all that important to make Filter and Query the same (that is just one alternative to achieve goal). \n\nBasic problem we try  to solve is adding Filter directly to BoolenQuery, and making optimizations after that easier. Wrapping with CSQ is just adding anothe layer between Lucene search machinery and Filter, making these optimizations harder.\n\nOn the other hand, I must accept, conceptually FIter and Query are \"the same\", supporting together following options:\n1. Pure boolean model: You do not care about scores (today we can do it only wia CSQ, as Filter does not enter BoolenQuery)\n2. Mixed boolean and ranked: you have to define Filter contribution to the documents (CSQ)\n3. Pure ranked: No filters, all gets scored (the same as 2.)\n\nIdeally, as a user, I define only Query (Filter based or not) and for each clause in my Query define \nQuery.setScored(true/false) or useConstantScore(double score); \n\nalso I should be able to say, \"Dear Lucene please materialize this \"Query_Filter\" for me as I would like to have it cached and please store only DocIds (Filter today).  Maybe open possibility to open possibility to cache scores of the documents as well. \n\none thing is concept  and another is optimization. From optimization point of view, we have couple of decisions to make:\n\n\n\tDocID Set supports random access, yes or no (my \"Materialized Query\")\n\tDecide if clause should / should not be scored/ or should be constant\n\n\n\nSo, for each \"Query\" we need to decide/support:\n\n\n\tscoring\n{yes, no, constant}\n and\n\topening option to \"materialize Query\" (that is how we today create Filters today)\n\tthese Materialized Queries (aka Filter) should be able to tell us if they support random access, if they cache only doc id's or scores as well\n\n\n\n\nnothing usefull in this email, just  thinking aloud, sometimes helps \n\n\n\n ",
            "author": "Eks Dev",
            "id": "comment-12704561"
        },
        {
            "date": "2009-04-30T11:52:56+0000",
            "content": "Wrapping with CSQ is just adding anothe layer between Lucene search machinery and Filter, making these optimizations harder.\n\nRight. But making Filter sub-class Query and check in BQ 'if (query instanceof Filter) { Filter f = (Filter) query)' is not going to improve anything. It adds instanceof and casting, and I'd think those are more expensive than wrapping a Filter with CSQ and returning an appropriate Scorer, which will use the Filter in its next() and skipTo() calls.\n\nOn the other hand, I must accept, conceptually FIter and Query are \"the same\", supporting together following options\n\nI think that if we allow BooleanClause to implement a Weight(IndexReader) (just like Query) we'll be one more step closer to that goal? BQ uses this method to construct BooleanWeight, only today it calls clause.getQuery().createWeight(). Instead it could do clause.getWeight, and if the BooleanClause holds a Filter it will return a FilterWeight, otherwise delegate that call to the contained Query.\n\nRegarding pure ranked, CSQ is really what we need, no?\n\nSo how about the following:\n\n\tAdd add(Filter, Occur) to BooleanClause.\n\tAdd weight(Searcher) to BooleanClause.\n\tCreate a FilterWeight which wraps a Filter and provide a Scorer implementation with a constant score. (This does not handle the \"no scoring\" mode, unless \"no scoring\" can be achieved with score=0.0f, while constant is any other value, defaulting to 1.0f).\n\tAdd isRandomAccess to Filter.\n\tCreate a RandomAccessFilter which extends Filter and defines an additional seek(target) method.\n\tAdd asRandomAccessFilter() to Filter, which will materialize that Filter into memory, or into another RandomAccess data structure (e.g. keeping it on disk but still provide random access to it, even if not very efficient) and return a RandomAccessFilter type, which will implement seek(target) and possibly override next() and skipTo(), but still use whatever other methods this Filter declares.\n\t\n\t\tI think we should default it to throw UOE providing that we document that isRandomAccess should first be called.\n\t\n\t\n\n\n\nI'm thinking out loud just like you, so I hope my stuff makes sense . ",
            "author": "Shai Erera",
            "id": "comment-12704597"
        },
        {
            "date": "2009-04-30T12:01:32+0000",
            "content": "Let's not forget we also have \"provides scores but NOT filtering\" type things as well, eg function queries, MatchAllDocsQuery, \"I want to boost documents by recency\" use case (which sort of a Scorer filter in that it takes another Scorer and modifies its output, per doc), etc.\n\nIt's just that very often the \"scoring part\" is in fact very much intertwined with the \"filtering\" part.  EG a TermQuery iterates a SegmentTermDocs, and reads & holds freq/doc in pairs. ",
            "author": "Michael McCandless",
            "id": "comment-12704600"
        },
        {
            "date": "2009-04-30T12:13:54+0000",
            "content": "opening option to \"materialize Query\" (that is how we today create Filters today)\n\nHow about materializing the DocIds and the score values? ",
            "author": "Paul Elschot",
            "id": "comment-12704605"
        },
        {
            "date": "2009-04-30T12:22:48+0000",
            "content": "Create a FilterWeight which wraps a Filter and provide a Scorer implementation with a constant score. (This does not handle the \"no scoring\" mode, unless \"no scoring\" can be achieved with score=0.0f, while constant is any other value, defaulting to 1.0f).\n\nThe current patch at LUCENE-1345 does not need such a FilterWeight; the no scoring case is handled by not asking for score values.\nUsing score=0.0f for no scoring might not work for BooleanQuery because it also has a coordination factor that depends on the number of matching query clauses. The patch at 1345 does not change that coordination factor for backward compatibility, even though the coordination factor might also depend on the number of a matching filter clauses. ",
            "author": "Paul Elschot",
            "id": "comment-12704609"
        },
        {
            "date": "2009-04-30T12:32:16+0000",
            "content": "Shai, \n----Regarding pure ranked, CSQ is really what we need, no? \u2014 \n\nYep, it would work for Filters, but why not making it possible to have normal Query \"constant score\". For these cases,  I am just not sure if this aproach gets max performance (did not look at this code for quite a while).  \n\nImagine you have a Query and you are not interested in Scoring at all, this can be acomplished with only DocID iterator arithmetic, ignoring  score() totally.  But that is only an optimization (maybe allready there?)\n\nPaul, \n---How about materializing the DocIds and the score values?---\nexactly,  that would open full caching posibility (original purpose of Filters).  Think Search Results caching ... that is practically another name for search() method. It is easy to create this, but using it again would require some bigger changes  \n\nFilter_on_Steroids materialize(boolean without_score); \n ",
            "author": "Eks Dev",
            "id": "comment-12704613"
        },
        {
            "date": "2009-04-30T12:40:14+0000",
            "content": "Paul: ...The current patch at LUCENE-1345 does not need such a FilterWeight; the no scoring case is handled by not asking for score values...\n\nMe: ...Imagine you have a Query and you are not interested in Scoring at all, this can be acomplished with only DocID iterator arithmetic, ignoring score() totally. But that is only an optimization (maybe allready there?)...\n\nI knew Paul will kick in at this place, he sad exactly the same thing I did, but, as oposed to me, he made formulation that executes  \nPfff, I feel bad \n\n\n ",
            "author": "Eks Dev",
            "id": "comment-12704618"
        },
        {
            "date": "2009-06-15T13:50:34+0000",
            "content": "This issue is marked as part of LUCENE-1345, which has been pushed to 3.1. Also, it has not yet found an assignee. Speak out, or I will push this to 3.1. ",
            "author": "Mark Miller",
            "id": "comment-12719558"
        },
        {
            "date": "2009-06-15T14:07:17+0000",
            "content": "Push to 3.1! \u2013 Uwe ",
            "author": "Uwe Schindler",
            "id": "comment-12719567"
        },
        {
            "date": "2012-11-12T06:52:56+0000",
            "content": "This issue may seem like ancient history but I'm nonetheless looking forward to it being realized.  I think it will really simplify things.  Do we re-target this at 5.0/trunk? ",
            "author": "David Smiley",
            "id": "comment-13495121"
        },
        {
            "date": "2012-11-12T07:34:27+0000",
            "content": "Yeah, thanks for touching the issue, so it gets back into my mind.\n\nOf course the patch non this issue is heavily outdated and the \"simple\" aproach of making Filter extend ConstantScoreQuery is no longer applicable as implemented there (because Filters can now be applied as random access bits down-low), so making them a query like proposed here would make them stop using RA bits. The better approach would be (as Eks Dev pointed out on LUCENE-4548) to mark the \"Filter\" as \"non-scoring\" and then scorers from e.g. BooleanWeight can optimize on that case (and possibly use bits instead of leap-frogging iterators).\n\nThe idea in this patch to make the \"Filter\" class still available to users (as a convenience way to create a non-scoring query without having to implement a full query with weight and scorers) is what I like from this issue. But a Filter is just a \"standard\" query and can be used anywhere like e.g. in BooleanQuery. The main work to implement this would be in BooleanQuery to implement the features of FilteredQuery (which would go away together with QueryWrapperFilter and similar classes). ",
            "author": "Uwe Schindler",
            "id": "comment-13495138"
        },
        {
            "date": "2013-07-23T18:44:42+0000",
            "content": "Bulk move 4.4 issues to 4.5 and 5.0 ",
            "author": "Steve Rowe",
            "id": "comment-13717031"
        },
        {
            "date": "2014-04-16T12:54:54+0000",
            "content": "Move issue to Lucene 4.9. ",
            "author": "Uwe Schindler",
            "id": "comment-13970921"
        },
        {
            "date": "2015-02-11T16:14:54+0000",
            "content": "I'd like to revisit this issue now that queries can be configured to not produce scores and that boolean queries accept filter clauses. Here is a new patch. Like Uwe's patch, it makes Filter extend Query and removes the ContantScoreQuery(Filter) constructor. So Filter is now mostly a helper class in order to build queries that do not produce scores (Scorer.score() always returns 0). I also added changes to Filter in order not to break existing Filter implementations (this is why I override equals() and hashCode() in Filter to go back to the way that they are implemented in Object).\n\nUwe Schindler what do you think? ",
            "author": "Adrien Grand",
            "id": "comment-14316442"
        },
        {
            "date": "2015-02-11T19:08:41+0000",
            "content": "Long time ago \n\nSo this looks fine, makes it easy to use Filters as real queries. There is only one thing: The score returned is now always be 0. If you want to get the old behaviour where you get the boost as score, you just have to wrap the Filter with ConstantScoreQuery, like it was before?\n\nThere is a typo in description of Filter: \"Convenient base class for building queries that only perform matching, but no scoring. The scorer produced by such queries always returns 0.\" - i think it should be \"returns 0 as score\".\n\nOne other thing: QueryWrapperFilter is now obsolete, or not?\n\nSo looks really fine. ",
            "author": "Uwe Schindler",
            "id": "comment-14316785"
        },
        {
            "date": "2015-02-11T19:15:46+0000",
            "content": "So this looks fine, makes it easy to use Filters as real queries. There is only one thing: The score returned is now always be 0. If you want to get the old behaviour where you get the boost as score, you just have to wrap the Filter with ConstantScoreQuery, like it was before?\n\nExactly.\n\nOne other thing: QueryWrapperFilter is now obsolete, or not?\n\nI didn't want to remove it yet because we still have some APIs that take a filter and not a query (eg. IndexSearcher.search, FilteredQuery). I want to remove it eventually but I think it's still a bit early? ",
            "author": "Adrien Grand",
            "id": "comment-14316802"
        },
        {
            "date": "2015-02-13T16:01:36+0000",
            "content": "Commit 1659585 from Adrien Grand in branch 'dev/trunk'\n[ https://svn.apache.org/r1659585 ]\n\nLUCENE-1518: Make Filter extend Query. ",
            "author": "ASF subversion and git services",
            "id": "comment-14320330"
        },
        {
            "date": "2015-02-13T16:18:12+0000",
            "content": "Commit 1659587 from Adrien Grand in branch 'dev/branches/branch_5x'\n[ https://svn.apache.org/r1659587 ]\n\nLUCENE-1518: Make Filter extend Query. ",
            "author": "ASF subversion and git services",
            "id": "comment-14320348"
        },
        {
            "date": "2015-02-13T16:33:28+0000",
            "content": "Awesome work guys!  Too bad this didn't make it into 5.0, from a major vs minor version stand-point. ",
            "author": "David Smiley",
            "id": "comment-14320359"
        },
        {
            "date": "2015-02-13T16:42:29+0000",
            "content": "I would have been nice to have to have queries and filters merged in 5.0 indeed, but I don't think we are there yet, we still need things like LUCENE-6198 for queries and filters to be on par. And like Uwe noticed, we still need a lot of changes before being able to actually consider queries and filters merged, like making FIlteredQuery rewrite to a boolean query with a filter clause, replacing all our APIs that take Filters with Queries (eg. IndexSearcher, the filter cache), removing QueryWrapperFilter, etc. So I don't feel too bad for pushing it into a minor release, maybe having queries and filters fully merged will be a highlight of 6.0.  ",
            "author": "Adrien Grand",
            "id": "comment-14320372"
        },
        {
            "date": "2015-03-02T15:58:38+0000",
            "content": "I am considering reverting this change: in the beginning it felt like a nice step to help the filter -> query transition but it ends up being quite trappy. For instance existing filters inherit from the default clone implementation which might not clone deeply enough, and existing \"equals\" impls do not pass QueryUtils checks since they do not take the boost into account. ",
            "author": "Adrien Grand",
            "id": "comment-14343296"
        },
        {
            "date": "2015-03-03T13:19:25+0000",
            "content": "I opened LUCENE-6328 to discuss options for this problem... ",
            "author": "Adrien Grand",
            "id": "comment-14345052"
        },
        {
            "date": "2015-04-15T00:30:40+0000",
            "content": "Bulk close after 5.1 release ",
            "author": "Timothy Potter",
            "id": "comment-14495341"
        }
    ]
}