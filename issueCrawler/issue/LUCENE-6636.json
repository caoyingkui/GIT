{
    "id": "LUCENE-6636",
    "title": "Filtered Search Fails against toParentBlockJoinQuery",
    "details": {
        "resolution": "Invalid",
        "affect_versions": "5.1,                                            5.2.1",
        "components": [],
        "labels": "",
        "fix_versions": [],
        "priority": "Major",
        "status": "Closed",
        "type": "Bug"
    },
    "description": "I'm able to get this to fail against a slightly larger test case than what is run in your test suite.  I noticed it first in 5.1 against a much larger index and created a more concise test case to reproduce it in both 5.1 and 5.2.  I have similar code running in 4.10.4 that does not fail.  I'm assuming this is a bug, but haven't identified the underlying issue in Lucene.  I thought at one point this was related to the SOLR issue 7606  but this example seems to eliminate that possibility.\n\nStack Trace:\n\nException in thread \"main\" java.lang.IllegalStateException: child query must only match non-parent docs, but parent docID=2147483647 matched childScorer=class org.apache.lucene.search.TermScorer\n\tat org.apache.lucene.search.join.ToParentBlockJoinQuery$BlockJoinScorer.nextDoc(ToParentBlockJoinQuery.java:334)\n\tat org.apache.lucene.search.join.ToParentBlockJoinIndexSearcher.search(ToParentBlockJoinIndexSearcher.java:63)\n\tat org.apache.lucene.search.IndexSearcher.search(IndexSearcher.java:485)\n\tat org.lexevs.lucene.prototype.BlockJoinTestQuery.run(BlockJoinTestQuery.java:53)\n\tat org.lexevs.lucene.prototype.BlockJoinTestQuery.main(BlockJoinTestQuery.java:71)\n\nIndexing class:\n\npackage org.lexevs.lucene.prototype;\n\nimport java.io.IOException;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.lucene.analysis.Analyzer;\nimport org.apache.lucene.analysis.standard.StandardAnalyzer;\nimport org.apache.lucene.analysis.util.CharArraySet;\nimport org.apache.lucene.document.Document;\nimport org.apache.lucene.document.Field;\nimport org.apache.lucene.index.IndexWriter;\nimport org.apache.lucene.index.IndexWriterConfig;\nimport org.apache.lucene.store.Directory;\nimport org.apache.lucene.store.MMapDirectory;\n\npublic class SmallTestIndexBuilder {\n\tpublic enum Code\n{\n\t\tC1234,C23432,C4234,C2308, C8958;\n\t}\n\tpublic SmallTestIndexBuilder() \n{\n\t\t// TODO Auto-generated constructor stub\n\t}\n\n\tpublic void init(){\n\t\ttry {\n\t\t\tLuceneContentBuilder builder = new LuceneContentBuilder();\n\t\t\tPath path = Paths.get(\"/Users/m029206/Desktop/index\");\n\t\t\tDirectory dir = new MMapDirectory(path);\n\t\t\tAnalyzer analyzer=new StandardAnalyzer(new CharArraySet( 0, true));\n\t\t\tIndexWriterConfig iwc= new IndexWriterConfig(analyzer);\n\t\t\tIndexWriter writer = new IndexWriter(dir, iwc);\n\t\t\tcreateCodingSchemeIndex(builder, writer );\n\t\t\twriter.commit();\n\t\t\twriter.close();\n\t\t} catch (IOException e) {\n\t\t\t// TODO Auto-generated catch block\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\tprivate void createCodingSchemeIndex(LuceneContentBuilder builder,\n\t\t\tIndexWriter writer) throws IOException {\n\t\t\tfor(Code c :Code.values()){\n\t\t\tList<Document> list = createBlockJoin(c.name());\n\t\t\twriter.addDocuments(list);\n\t\t\tlist = createBlockJoin2(c.name());\n\t\t\twriter.addDocuments(list);\n\t\t\t}\n\t}\n\n\tprivate List<Document> createBlockJoin(String code) {\n\t\tList<Document> list = new ArrayList<Document>();\n\t\n\t\tDocument doc = new Document();\n\t\tdoc.add(new org.apache.lucene.document.TextField(\"propertyValue\", \"Blood\", Field.Store.YES));\n\t\tlist.add(doc);\n\t\tdoc = new Document();\n\t\tdoc.add(new org.apache.lucene.document.TextField(\"propertyValue\", \"Mud\", Field.Store.YES));\n\t\tlist.add(doc);\n\t\tdoc = new Document();\n\t\tdoc.add(new org.apache.lucene.document.TextField(\"propertyValue\", \"Suds\", Field.Store.YES));\n\t\tlist.add(doc);\n\t\tdoc = new Document();\n\t\tdoc.add(new org.apache.lucene.document.TextField(\"propertyValue\", \"coagulant\", Field.Store.YES));\n\t\tlist.add(doc);\n\t\tdoc = new Document();\n\t\tdoc.add(new org.apache.lucene.document.TextField(\"propertyValue\", \"hepa\", Field.Store.YES));\n\t\tlist.add(doc);\n\t\tdoc = new Document();\n\t\tdoc.add(new org.apache.lucene.document.TextField(\"propertyValue\", \"hematoma\", Field.Store.YES));\n\t\tlist.add(doc);\n\t\tdoc = new Document();\n\t\tdoc.add(new org.apache.lucene.document.TextField(\"propertyValue\", \"normal\", Field.Store.YES));\n\t\tlist.add(doc);\n\t\tdoc = new Document();\n\t\tdoc.add(new org.apache.lucene.document.TextField(\"propertyValue\", \"abnormal\", Field.Store.YES));\n\t\tlist.add(doc);\n\t\tdoc = new Document();\n\t\tdoc.add(new org.apache.lucene.document.TextField(\"propertyValue\", \"notfound\", Field.Store.YES));\n\t\tlist.add(doc);\n\t\tdoc = new Document();\n\t\tdoc.add(new org.apache.lucene.document.TextField(\"propertyValue\", \"red blood cells\", Field.Store.YES));\n\t\tlist.add(doc);\n\t\tdoc = new Document();\n\t\tdoc.add(new org.apache.lucene.document.TextField(\"propertyValue\", \"Blood\", Field.Store.YES));\n\t\tlist.add(doc);\n\t\tdoc = new Document();\n\t\tdoc.add(new org.apache.lucene.document.TextField(\"propertyValue\", \"Blood\", Field.Store.YES));\n\t\tlist.add(doc);\n\t\t\n\t\tDocument par = new Document();\n\t\tpar.add(new org.apache.lucene.document.TextField(\"codingSchemeName\", \"TestScheme\", Field.Store.YES));\n\t\tpar.add(new org.apache.lucene.document.TextField(\"parentDoc\", \"yes\", Field.Store.YES));\n\t\tpar.add(new org.apache.lucene.document.TextField(\"entityCode\", code, Field.Store.YES));\n\t\tlist.add(par);\n\t\treturn list;\n\t}\n\n\tprivate List<Document> createBlockJoin2(String code) {\n\t\tList<Document> list = new ArrayList<Document>();\n\t\n\t\tDocument doc = new Document();\n\t\tdoc.add(new org.apache.lucene.document.TextField(\"propertyValue\", \"Blood\", Field.Store.YES));\n\t\tlist.add(doc);\n\t\tdoc = new Document();\n\t\tdoc.add(new org.apache.lucene.document.TextField(\"propertyValue\", \"Mud\", Field.Store.YES));\n\t\tlist.add(doc);\n\t\tdoc = new Document();\n\t\tdoc.add(new org.apache.lucene.document.TextField(\"propertyValue\", \"Suds\", Field.Store.YES));\n\t\tlist.add(doc);\n\t\tdoc = new Document();\n\t\tdoc.add(new org.apache.lucene.document.TextField(\"propertyValue\", \"coagulant\", Field.Store.YES));\n\t\tlist.add(doc);\n\t\tdoc = new Document();\n\t\tdoc.add(new org.apache.lucene.document.TextField(\"propertyValue\", \"hepa\", Field.Store.YES));\n\t\tlist.add(doc);\n\t\tdoc = new Document();\n\t\tdoc.add(new org.apache.lucene.document.TextField(\"propertyValue\", \"hematoma\", Field.Store.YES));\n\t\tlist.add(doc);\n\t\tdoc = new Document();\n\t\tdoc.add(new org.apache.lucene.document.TextField(\"propertyValue\", \"normal\", Field.Store.YES));\n\t\tlist.add(doc);\n\t\tdoc = new Document();\n\t\tdoc.add(new org.apache.lucene.document.TextField(\"propertyValue\", \"abnormal\", Field.Store.YES));\n\t\tlist.add(doc);\n\t\tdoc = new Document();\n\t\tdoc.add(new org.apache.lucene.document.TextField(\"propertyValue\", \"notfound\", Field.Store.YES));\n\t\tlist.add(doc);\n\t\tdoc = new Document();\n\t\tdoc.add(new org.apache.lucene.document.TextField(\"propertyValue\", \"red blood cells\", Field.Store.YES));\n\t\tlist.add(doc);\n\t\tdoc = new Document();\n\t\tdoc.add(new org.apache.lucene.document.TextField(\"propertyValue\", \"Blood\", Field.Store.YES));\n\t\tlist.add(doc);\n\t\tdoc = new Document();\n\t\tdoc.add(new org.apache.lucene.document.TextField(\"propertyValue\", \"Blood\", Field.Store.YES));\n\t\tlist.add(doc);\n\t\t\n\t\tDocument par = new Document();\n\t\tpar.add(new org.apache.lucene.document.TextField(\"codingSchemeName\", \"TestSchemeToo\", Field.Store.YES));\n\t\tpar.add(new org.apache.lucene.document.TextField(\"parentDoc\", \"yes\", Field.Store.YES));\n\t\tpar.add(new org.apache.lucene.document.TextField(\"entityCode\", code, Field.Store.YES));\n\t\tlist.add(par);\n\t\treturn list;\n\t}\n\tpublic static void main(String[] args) {\n\t\tnew SmallTestIndexBuilder().init();\n\n\t}\n\n}\n\nQuerying Code: \n\npackage org.lexevs.lucene.prototype;\n\nimport java.io.IOException;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\n\nimport org.apache.lucene.analysis.standard.StandardAnalyzer;\nimport org.apache.lucene.analysis.util.CharArraySet;\nimport org.apache.lucene.document.Document;\nimport org.apache.lucene.index.DirectoryReader;\nimport org.apache.lucene.index.IndexReader;\nimport org.apache.lucene.queryparser.classic.ParseException;\nimport org.apache.lucene.queryparser.classic.QueryParser;\nimport org.apache.lucene.search.IndexSearcher;\nimport org.apache.lucene.search.Query;\nimport org.apache.lucene.search.QueryWrapperFilter;\nimport org.apache.lucene.search.Sort;\nimport org.apache.lucene.search.BooleanClause.Occur;\nimport org.apache.lucene.search.grouping.GroupDocs;\nimport org.apache.lucene.search.grouping.TopGroups;\nimport org.apache.lucene.search.join.BitDocIdSetCachingWrapperFilter;\nimport org.apache.lucene.search.join.BitDocIdSetFilter;\nimport org.apache.lucene.search.join.ScoreMode;\nimport org.apache.lucene.search.join.ToParentBlockJoinCollector;\nimport org.apache.lucene.search.join.ToParentBlockJoinIndexSearcher;\nimport org.apache.lucene.search.join.ToParentBlockJoinQuery;\nimport org.apache.lucene.store.Directory;\nimport org.apache.lucene.store.MMapDirectory;\n\npublic class BlockJoinTestQuery {\n\n\tpublic BlockJoinTestQuery() {\t\t// TODO Auto-generated constructor stub\t}\n\n\tpublic void run(){\n\tPath path = Paths.get(\"/Users/m029206/Desktop/index\");\n\tDirectory index;\n\ttry {\n\t\tindex = new MMapDirectory(path);\n\n\tIndexReader reader =  DirectoryReader.open(index);\n\tIndexSearcher searcher = new ToParentBlockJoinIndexSearcher(reader);\n\tToParentBlockJoinCollector collector = new ToParentBlockJoinCollector(Sort.RELEVANCE, 2, true, true);\n\tBitDocIdSetFilter codingScheme = new BitDocIdSetCachingWrapperFilter(\n              new QueryWrapperFilter(new QueryParser(\"codingSchemeName\", new StandardAnalyzer(new CharArraySet( 0, true))).parse(\"TestScheme\")));\n\n\t  Query query = new QueryParser(null, new StandardAnalyzer(new CharArraySet( 0, true))).createBooleanQuery(\"propertyValue\", \"Blood\", Occur.MUST);\n\t  ToParentBlockJoinQuery termJoinQuery = new ToParentBlockJoinQuery(\n\t\t\t    query, \n\t\t\t    codingScheme,\n\t\t\t    ScoreMode.Avg);\n\t  searcher.search(termJoinQuery, collector);\n\t  TopGroups<Integer> getTopGroupsResults = collector.getTopGroups(termJoinQuery, null, 0, 10, 0, true);\n\t  String ecode = null;\n\t  for (GroupDocs<Integer> result : getTopGroupsResults.groups) \n{\n\t\t  Document parent = searcher.doc(result.groupValue);\n\t\t ecode = parent.get(\"entityCode\");\n\t\t System.out.println(\"entityCode: \" + ecode);\n\t  }\n\t} catch (IOException e) \n{\n\t\t// TODO Auto-generated catch block\n\t\te.printStackTrace();\n\t} catch (ParseException e) {\t\t// TODO Auto-generated catch block\t\te.printStackTrace();\t}\n\t}\n\n\tpublic static void main(String[] args) \n{\n\t\tnew BlockJoinTestQuery().run();\n\n\t}\n\n}",
    "attachments": {},
    "issue_links": {},
    "comments": [
        {
            "id": "comment-14607960",
            "author": "Adrien Grand",
            "date": "2015-06-30T08:45:31+0000",
            "content": "This error is expected: you have child documents in the second block whose parent does not match the parent filter (it matches \"TestSchemeToo\", but not \"TestScheme\"), so they look like orphans to Lucene.\n\nInstead, you should set \"parent:yes\" as a parent filter, and then create a boolean query that intersects your ToParentBlockJoinQuery with a term query on codingSchemeName:TestScheme. "
        }
    ]
}