{
    "id": "LUCENE-530",
    "title": "Extend NumberTools to support int/long/float/double to string",
    "details": {
        "labels": "",
        "priority": "Minor",
        "components": [
            "modules/analysis"
        ],
        "type": "Improvement",
        "fix_versions": [],
        "affect_versions": "1.9",
        "resolution": "Won't Fix",
        "status": "Closed"
    },
    "description": "Extend Number tools to support int/long/float/double to string \n\nSo you can search using range queries on int/long/float/double, if you want.\n\nHere is the basis for how NumberTools cold be extended to support int/long/double/float.\nAs I only write these values to the index and fix tokenisation in searchesI was not so fussed about the reverse transformations back to Strings.\n\n\n\npublic class NumericEncoder\n{\n    /*\n\n\tConstants for integer encoding\n     */\n\n\n\n    static int INTEGER_SIGN_MASK = 0x80000000;\n\n    /*\n\n\tConstants for long encoding\n     */\n\n\n\n    static long LONG_SIGN_MASK = 0x8000000000000000L;\n\n    /*\n\n\tConstants for float encoding\n     */\n\n\n\n    static int FLOAT_SIGN_MASK = 0x80000000;\n\n    static int FLOAT_EXPONENT_MASK = 0x7F800000;\n\n    static int FLOAT_MANTISSA_MASK = 0x007FFFFF;\n\n    /*\n\n\tConstants for double encoding\n     */\n\n\n\n    static long DOUBLE_SIGN_MASK = 0x8000000000000000L;\n\n    static long DOUBLE_EXPONENT_MASK = 0x7FF0000000000000L;\n\n    static long DOUBLE_MANTISSA_MASK = 0x000FFFFFFFFFFFFFL;\n\n    private NumericEncoder()\n    {\n        super();\n    }\n\n    /**\n     * Encode an integer into a string that orders correctly using string\n     * comparison Integer.MIN_VALUE encodes as 00000000 and MAX_VALUE as\n     * ffffffff.\n     * \n     * @param intToEncode\n     * @return\n     */\n    public static String encode(int intToEncode)\n    {\n        int replacement = intToEncode ^ INTEGER_SIGN_MASK;\n        return encodeToHex(replacement);\n    }\n\n    /**\n     * Encode a long into a string that orders correctly using string comparison\n     * Long.MIN_VALUE encodes as 0000000000000000 and MAX_VALUE as\n     * ffffffffffffffff.\n     * \n     * @param longToEncode\n     * @return\n     */\n    public static String encode(long longToEncode)\n    {\n        long replacement = longToEncode ^ LONG_SIGN_MASK;\n        return encodeToHex(replacement);\n    }\n\n    /**\n     * Encode a float into a string that orders correctly according to string\n     * comparison. Note that there is no negative NaN but there are codings that\n     * imply this. So NaN and -Infinity may not compare as expected.\n     * \n     * @param floatToEncode\n     * @return\n     */\n    public static String encode(float floatToEncode)\n    {\n        int bits = Float.floatToIntBits(floatToEncode);\n        int sign = bits & FLOAT_SIGN_MASK;\n        int exponent = bits & FLOAT_EXPONENT_MASK;\n        int mantissa = bits & FLOAT_MANTISSA_MASK;\n        if (sign != 0)\n        {\n            exponent ^= FLOAT_EXPONENT_MASK;\n            mantissa ^= FLOAT_MANTISSA_MASK;\n        }\n        sign ^= FLOAT_SIGN_MASK;\n        int replacement = sign | exponent | mantissa;\n        return encodeToHex(replacement);\n    }\n\n    /**\n     * Encode a double into a string that orders correctly according to string\n     * comparison. Note that there is no negative NaN but there are codings that\n     * imply this. So NaN and -Infinity may not compare as expected.\n     * \n     * @param doubleToEncode\n     * @return\n     */\n    public static String encode(double doubleToEncode)\n    {\n        long bits = Double.doubleToLongBits(doubleToEncode);\n        long sign = bits & DOUBLE_SIGN_MASK;\n        long exponent = bits & DOUBLE_EXPONENT_MASK;\n        long mantissa = bits & DOUBLE_MANTISSA_MASK;\n        if (sign != 0)\n        {\n            exponent ^= DOUBLE_EXPONENT_MASK;\n            mantissa ^= DOUBLE_MANTISSA_MASK;\n        }\n        sign ^= DOUBLE_SIGN_MASK;\n        long replacement = sign | exponent | mantissa;\n        return encodeToHex(replacement);\n    }\n\n    private static String encodeToHex(int i)\n    {\n        char[] buf = new char[] { '0', '0', '0', '0', '0', '0', '0', '0' };\n        int charPos = 8;\n        do\n        {\n            buf[--charPos] = DIGITS[i & MASK];\n            i >>>= 4;\n        }\n        while (i != 0);\n        return new String(buf);\n    }\n\n    private static String encodeToHex(long l)\n    {\n        char[] buf = new char[] { '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0' };\n        int charPos = 16;\n        do\n        {\n            buf[--charPos] = DIGITS[(int) l & MASK];\n            l >>>= 4;\n        }\n        while (l != 0);\n        return new String(buf);\n    }\n\n    private static final char[] DIGITS = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e',\n            'f' };\n\n    private static final int MASK = (1 << 4) - 1;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\npublic class NumericEncodingTest extends TestCase\n{\n\n    public NumericEncodingTest()\n    {        super();    }\n\n    public NumericEncodingTest(String arg0)\n    {\n        super(arg0);\n    }\n\n    /**\n\n\tDo an exhaustive test for integers\n\t     */\n    public void xtestAllIntegerEncodings()\n    {\n        String lastString = null;\n        String nextString = null;\n        for (long i = Integer.MIN_VALUE; i <= Integer.MAX_VALUE; i++)\n        Unknown macro: {            nextString = NumericEncoder.encode((int) i);            if (lastString != null)            {\n                assertFalse(lastString.compareTo(nextString) > 0);\n            }            lastString = nextString;        } \n    }\n\n\n\n    /**\n\n\tDo an exhaustive test for float\n\t     */\n    public void xtestAllFloatEncodings()\n    {\n        Float last = null;\n        Float next = null;\n        String lastString = null;\n        String nextString = null;\n\n\n\n        for (int sign = 1; sign >= 0; sign--)\n        {\n            if (sign == 0)\n            {\n                for (int exponent = 0; exponent <= 0xFF; exponent++)\n                {\n                    for (int mantissa = 0; mantissa <= 0x007FFFFF; mantissa++)\n                    {\n                        int bitPattern = sign << 31 | exponent << 23 | mantissa;\n                        next = Float.intBitsToFloat(bitPattern);\n\n                        if (!next.equals(Float.NaN) && (last != null) && (last.compareTo(next) > 0))\n                        {\n                            System.err.println(last + \" > \" + next);\n                        }\n                        if (!next.equals(Float.NaN))\n                        {\n                            nextString = NumericEncoder.encode(next);\n                            if ((lastString != null) && (lastString.compareTo(nextString) > 0))\n                            {\n                                System.err.println(lastString + \" > \" + nextString);\n                            }\n                            lastString = nextString;\n                        }\n                        last = next;\n\n                    }\n                }\n            }\n            else\n            {\n                for (int exponent = 0xFF; exponent >= 0; exponent--)\n                {\n                    for (int mantissa = 0x007FFFFF; mantissa >= 0; mantissa--)\n                    {\n                        int bitPattern = sign << 31 | exponent << 23 | mantissa;\n                        next = Float.intBitsToFloat(bitPattern);\n                        if (!next.equals(Float.NaN) && (last != null) && (last.compareTo(next) > 0))\n                        {                            System.err.println(last + \" > \" + next);                        }\n                        if (!next.equals(Float.NaN))\n                        {\n                            nextString = NumericEncoder.encode(next);\n                            if ((lastString != null) && (lastString.compareTo(nextString) > 0))\n                            {\n                                System.err.println(lastString + \" > \" + nextString);\n                            }\n                            lastString = nextString;\n                        }\n                        last = next;\n                    }\n                }\n            }\n        }\n    }\n\n    /*\n\n\tSample test for int\n     */\n\n\n\n    public void testIntegerEncoding()\n    {\n        assertEquals(\"00000000\", NumericEncoder.encode(Integer.MIN_VALUE));\n        assertEquals(\"00000001\", NumericEncoder.encode(Integer.MIN_VALUE + 1));\n        assertEquals(\"7fffffff\", NumericEncoder.encode(-1));\n        assertEquals(\"80000000\", NumericEncoder.encode(0));\n        assertEquals(\"80000001\", NumericEncoder.encode(1));\n        assertEquals(\"fffffffe\", NumericEncoder.encode(Integer.MAX_VALUE - 1));\n        assertEquals(\"ffffffff\", NumericEncoder.encode(Integer.MAX_VALUE));\n    }\n\n    /*\n\n\tSample test for long\n     */\n\n\n\n    public void testLongEncoding()\n    {\n        assertEquals(\"0000000000000000\", NumericEncoder.encode(Long.MIN_VALUE));\n        assertEquals(\"0000000000000001\", NumericEncoder.encode(Long.MIN_VALUE + 1));\n        assertEquals(\"7fffffffffffffff\", NumericEncoder.encode(-1L));\n        assertEquals(\"8000000000000000\", NumericEncoder.encode(0L));\n        assertEquals(\"8000000000000001\", NumericEncoder.encode(1L));\n        assertEquals(\"fffffffffffffffe\", NumericEncoder.encode(Long.MAX_VALUE - 1));\n        assertEquals(\"ffffffffffffffff\", NumericEncoder.encode(Long.MAX_VALUE));      \n    }\n\n    /*\n\n\tSample test for float\n     */\n\n\n\n    public void testFloatEncoding()\n    {\n        assertEquals(\"007fffff\", NumericEncoder.encode(Float.NEGATIVE_INFINITY));\n        assertEquals(\"00800000\", NumericEncoder.encode(-Float.MAX_VALUE));\n        assertEquals(\"7ffffffe\", NumericEncoder.encode(-Float.MIN_VALUE));\n        assertEquals(\"7fffffff\", NumericEncoder.encode(-0f));\n        assertEquals(\"80000000\", NumericEncoder.encode(0f));\n        assertEquals(\"80000001\", NumericEncoder.encode(Float.MIN_VALUE));\n        assertEquals(\"ff7fffff\", NumericEncoder.encode(Float.MAX_VALUE));\n        assertEquals(\"ff800000\", NumericEncoder.encode(Float.POSITIVE_INFINITY));\n        assertEquals(\"ffc00000\", NumericEncoder.encode(Float.NaN));\n\n    }\n\n    /*\n\n\tSample test for double\n     */\n\n\n\n    public void testDoubleEncoding()\n    {\n        assertEquals(\"000fffffffffffff\", NumericEncoder.encode(Double.NEGATIVE_INFINITY));\n        assertEquals(\"0010000000000000\", NumericEncoder.encode(-Double.MAX_VALUE));\n        assertEquals(\"7ffffffffffffffe\", NumericEncoder.encode(-Double.MIN_VALUE));\n        assertEquals(\"7fffffffffffffff\", NumericEncoder.encode(-0d));\n        assertEquals(\"8000000000000000\", NumericEncoder.encode(0d));\n        assertEquals(\"8000000000000001\", NumericEncoder.encode(Double.MIN_VALUE));\n        assertEquals(\"ffefffffffffffff\", NumericEncoder.encode(Double.MAX_VALUE));\n        assertEquals(\"fff0000000000000\", NumericEncoder.encode(Double.POSITIVE_INFINITY));\n        assertEquals(\"fff8000000000000\", NumericEncoder.encode(Double.NaN));\n\n    }\n}",
    "attachments": {},
    "issue_links": {},
    "comments": [
        {
            "date": "2006-03-23T02:17:18+0000",
            "content": "Here is how Solr did it:\nhttp://svn.apache.org/viewcvs.cgi/incubator/solr/trunk/src/java/org/apache/solr/util/NumberUtils.java?rev=382610&view=markup\n\nIt's a binary representation transformed to sort correctly and fit in to chars.\nA 4 byte int or float is transformed into 3 java chars\nAn 8 byte long or double is transformed into 5 java chars ",
            "author": "Yonik Seeley",
            "id": "comment-12371446"
        },
        {
            "date": "2007-06-12T07:52:40+0000",
            "content": "I just want to know if this works fine why they don't add it to the Lucene's API? Now I need this in my search engine program ",
            "author": "Mohammad Norouzi",
            "id": "comment-12503769"
        },
        {
            "date": "2007-07-16T06:18:56+0000",
            "content": "Hi\nI am using this nice class but because of my requirements I had to add following method, this will ease using this class\n\npublic static String encode(String stringToEncode,Class type) {\n\t\ttry {\n\t\t\tMethod valueOf = type.getMethod(\"valueOf\",new Class[] \n{String.class}\n);\n\t\t\tObject value = valueOf.invoke(null,new Object[] \n{stringToEncode}\n); \n\t\t\tMethod encode = NumericEncoder.class.getMethod(\"encode\",new Class[] \n{type}\n);\n\t\t\tString result = (String)encode.invoke(null,new Object[] \n{value}\n);\n\t\t\treturn result;\n\t\t} catch (SecurityException e) \n{\n\t\t\te.printStackTrace();\n\t\t} catch (NoSuchMethodException e) {\t\t\te.printStackTrace();\t\t}\n catch (IllegalArgumentException e) \n{\n\t\t\te.printStackTrace();\n\t\t} catch (IllegalAccessException e) {\t\t\te.printStackTrace();\t\t}\n catch (InvocationTargetException e) \n{\n\t\t\tlogger.error(\"Exception in target method.\");\n\t\t\te.printStackTrace();\n\t\t}\n\t\treturn null;\n\t}\n\n\nby this method you no longer need to use if else statements, \nalso this class needs a decode() method ",
            "author": "Mohammad Norouzi",
            "id": "comment-12512866"
        },
        {
            "date": "2011-01-27T10:55:46+0000",
            "content": "NumberTools is deprecated since Lucene 2.9 and only available to support reading old indexes using this class. You should use NumericField and NumericRangeQuery to search on numeric/date ranges.\n\nClosing this issue. ",
            "author": "Uwe Schindler",
            "id": "comment-12987491"
        }
    ]
}