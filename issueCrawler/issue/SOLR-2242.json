{
    "id": "SOLR-2242",
    "title": "Get distinct count of names for a facet field",
    "details": {
        "affect_versions": "4.0-ALPHA",
        "status": "Resolved",
        "fix_versions": [
            "5.2",
            "6.0"
        ],
        "components": [
            "Response Writers"
        ],
        "type": "New Feature",
        "priority": "Minor",
        "labels": "",
        "resolution": "Duplicate"
    },
    "description": "When returning facet.field=<name of field> you will get a list of matches for distinct values. This is normal behavior. This patch tells you how many distinct values you have (# of rows). Use with limit=-1 and mincount=1.\n\n\nThe feature is called \"namedistinct\". Here is an example:\n\nParameters:\nfacet.numTerms or f.<field>.facet.numTerms = true (default is false) - turn on distinct counting of terms\n\nfacet.field - the field to count the terms\nIt creates a new section in the facet section...\n\nhttp://localhost:8983/solr/select?shards=localhost:8983/solr,localhost:7574/solr&indent=true&q=*:*&facet=true&facet.mincount=1&facet.numTerms=true&facet.limit=-1&facet.field=price\n\nhttp://localhost:8983/solr/select?shards=localhost:8983/solr,localhost:7574/solr&indent=true&q=*:*&facet=true&facet.mincount=1&facet.numTerms=false&facet.limit=-1&facet.field=price\n\nhttp://localhost:8983/solr/select?shards=localhost:8983/solr,localhost:7574/solr&indent=true&q=*:*&facet=true&facet.mincount=1&facet.numTerms=true&facet.limit=-1&facet.field=price\n\nThis currently only works on facet.field.\n\n\n<lst name=\"facet_counts\">\n<lst name=\"facet_queries\"/>\n<lst name=\"facet_fields\">...</lst>\n<lst name=\"facet_numTerms\">\n<lst name=\"localhost:8983/solr/\">\n<int name=\"price\">14</int>\n</lst>\n<lst name=\"localhost:8080/solr/\">\n<int name=\"price\">14</int>\n</lst>\n</lst>\n<lst name=\"facet_dates\"/>\n<lst name=\"facet_ranges\"/>\n</lst>\n\nOR with no sharding-\n\n<lst name=\"facet_numTerms\">\n<int name=\"price\">14</int>\n</lst>\n\n\n \n\nSeveral people use this to get the group.field count (the # of groups).",
    "attachments": {
        "SOLR-2242.patch": "https://issues.apache.org/jira/secure/attachment/12477604/SOLR-2242.patch",
        "SOLR-2242-solr40-3.patch": "https://issues.apache.org/jira/secure/attachment/12519844/SOLR-2242-solr40-3.patch",
        "SOLR.2242.solr3.1.patch": "https://issues.apache.org/jira/secure/attachment/12476332/SOLR.2242.solr3.1.patch",
        "SOLR-2242.solr3.1-fix.patch": "https://issues.apache.org/jira/secure/attachment/12492579/SOLR-2242.solr3.1-fix.patch",
        "SOLR-2242.solr3.1.patch": "https://issues.apache.org/jira/secure/attachment/12477615/SOLR-2242.solr3.1.patch",
        "SOLR-2242-3x.patch": "https://issues.apache.org/jira/secure/attachment/12520110/SOLR-2242-3x.patch",
        "SOLR-2242.shard.withtests.patch": "https://issues.apache.org/jira/secure/attachment/12483873/SOLR-2242.shard.withtests.patch",
        "SOLR-2242-3x_5_tests.patch": "https://issues.apache.org/jira/secure/attachment/12521100/SOLR-2242-3x_5_tests.patch"
    },
    "issue_links": {},
    "comments": [
        {
            "author": "Bill Bell",
            "id": "comment-12933246",
            "date": "2010-11-18T00:06:29+0000",
            "content": "https://issues.apache.org/jira/secure/attachment/12459815/SOLR-236-distinctFacet.patch "
        },
        {
            "author": "Jonathan Rochkind",
            "id": "comment-13006432",
            "date": "2011-03-14T14:37:58+0000",
            "content": "I would love to see this feature in trunk, I could really use it.  "
        },
        {
            "author": "Peter Sturge",
            "id": "comment-13006445",
            "date": "2011-03-14T14:54:48+0000",
            "content": "+1 Yep, me too. Useful feature, this. "
        },
        {
            "author": "Bill Bell",
            "id": "comment-13006747",
            "date": "2011-03-15T00:44:29+0000",
            "content": "I am pretty new to patching stuff. Can I get some sort of committer to\ngive me feedback?\n\nI would also LOVE to get this in the TRUNK.\n\n\n\n "
        },
        {
            "author": "Yonik Seeley",
            "id": "comment-13006750",
            "date": "2011-03-15T01:03:55+0000",
            "content": "It feels like we should have an option to return the number of constraints that match the criteria (mincount, etc) w/o having to specify facet.limit=-1, and you should be able to get this info in addition to the normal facet counts.  We can also improve the efficiency by not building the complete list in memory just to return it's count.\n\nWe've also talked before about having an extra metadata level for each facet.\n\nCurrent:\n\n\"facet fields\" : {\"hgid\" : [\"constraint\",10,...]}\n\n\n\nProposed:\n\n\"facet fields\" : {\"hgid\" : {\n  \"missing\" : 25,\n  \"constraints\" : 1250,\n  \"counts\" : [\"constraint\",10,...]\n}}\n\n "
        },
        {
            "author": "Bill Bell",
            "id": "comment-13006756",
            "date": "2011-03-15T01:28:54+0000",
            "content": "Thanks.\n\nNot sure how to get the facet distinct count without looping, but I'll\nlook into that. Not sure what \"constraints\" means?\n\nI agree that you should not have to specify limit, but mincount should\napply, since many times I want 1 or higher.\n\nWould be always include this or just add it as an option?\n\nf.hgid.facet.namedistinct=1 ?\n\nProposed:\n\n\"facet fields\" : {\"hgid\" : {\n  \"missing\" : 25,\n  \"namedistinct\" : 1250,\n  \"counts\" : [\"constraint\",10,...]\n}}\n\n\n\n\nThen we add others as needed?\n\nOr do you mean?\n\nf.hgid.facet.constraints = namedistinct() with the option to specify more\nthan one?\n\nf.hgid.facet.constraints = namedistinct(),missing()\n\n\nProposed:\n\n\"facet fields\" : {\"hgid\" : {\n  \"constraints\" : [\"missing()\",25,\"namedistinct()\",1250],\n  \"counts\" : [\"constraint\",10,...]\n}}\n\n "
        },
        {
            "author": "Yonik Seeley",
            "id": "comment-13006758",
            "date": "2011-03-15T01:36:33+0000",
            "content": "Not sure what \"constraints\" means?\n\nIt's a facet value like \"HGPY0000045FD36D4000A\" in your example.\n\nWould be always include this or just add it as an option?\n\nIt will require disabling certain optimizations, and should thus be optional (and off by default).\n\nFYI, the missing I threw in is also a different way to represent the count calculated via facet.missing=true, instead of being added in with the other counts as a null key (which JSON does not support). "
        },
        {
            "author": "Bill Bell",
            "id": "comment-13006767",
            "date": "2011-03-15T02:20:26+0000",
            "content": "OK. So you like the work \"constraints\" instead of \"namedistinct\". I am okay with it.\n\nI am going to work on this tonight.\n "
        },
        {
            "author": "Bill Bell",
            "id": "comment-13006774",
            "date": "2011-03-15T02:57:24+0000",
            "content": "Btw,\n\nI hope constraints means unique names. It is different than number of\nconstraints. There might be a need for number of constraints, but that is\nnot what this ticket is for.\n\nSo, I think I am going to reject your proposed naming for mine:\n\n\nProposed:\n\"facet fields\" : {\"hgid\" : {\n  \"missing\" : 25,\n  \"namedistinct\" : 25,\n  \"constraints\": 1250,\n  \"counts\" : [\"constraint\",10,...]\n}}\n\n\n\n\nThose are 2 different things. "
        },
        {
            "author": "Bill Bell",
            "id": "comment-13006775",
            "date": "2011-03-15T02:58:29+0000",
            "content": "Btw,\n\nI hope constraints means unique names. It is different than number of\nconstraints. There might be a need for number of constraints, but that is\nnot what this ticket is for.\n\nSo, I think I am going to reject your proposed naming for mine:\n\n\nProposed:\n\"facet fields\" : {\"hgid\" : {\n  \"missing\" : 25,\n  \"namedistinct\" : 25,\n  \"constraints\": 1250,\n  \"counts\" : [\"constraint\",10,...]\n}}\n\n\n\n\nThose are 2 different things.\n\n\n\n\n "
        },
        {
            "author": "Jonathan Rochkind",
            "id": "comment-13006776",
            "date": "2011-03-15T03:06:29+0000",
            "content": "If the naming is the sticking point. So the value here is the total count of facet values, the number of facet values you'd get if you did facet.limit=-1, but without the need to assemble every facet value in memory and send it accross the wire. This is quite analagous to numFound in the main response, the total number of documents matching your query that you'd get if you set rows=-1, but without needing actually assemble all those and send em accross the wire. Is there some way to use this parallelism in the name of the total count of facet values?  numFacetsFound?  "
        },
        {
            "author": "Bill Bell",
            "id": "comment-13006779",
            "date": "2011-03-15T03:21:53+0000",
            "content": "No actually namedistinct is not the number of values. It is the number of names.\n\n\n- <lst name=\"facet_fields\">\n- <lst name=\"hgid\">\n   <int name=\"HGPY0000045FD36D4000A\">1</int>\n   <int name=\"HGPY00000FBC6690453A9\">1</int>\n   <int name=\"HGPY00001E44ED6C4FB3B\">1</int>\n   <int name=\"HGPY00001FA631034A1B8\">1</int>\n   <int name=\"HGPY00003317ABAC43B48\">1</int>\n   <int name=\"HGPY00003A17B2294CB5A\">5</int>\n   <int name=\"HGPY00003ADD2B3D48C39\">1</int>\n   </lst>\n   </lst>\n\n\n\nBecomes:\n\n\n<lst name=\"facet_fields\">\n  <lst name=\"hgid\">\n   <int name=\"namedistinct\">7</int>  <!-- this is not 11 -->\n   <lst name=\"counts\">\n   \t<int name=\"HGPY0000045FD36D4000A\">1</int>\n   \t<int name=\"HGPY00000FBC6690453A9\">1</int>\n   \t<int name=\"HGPY00001E44ED6C4FB3B\">1</int>\n   \t<int name=\"HGPY00001FA631034A1B8\">1</int>\n   \t<int name=\"HGPY00003317ABAC43B48\">1</int>\n   \t<int name=\"HGPY00003A17B2294CB5A\">5</int>\n   \t<int name=\"HGPY00003ADD2B3D48C39\">1</int>\n   </lst>\n  </lst>\n</lst>\n\n "
        },
        {
            "author": "Jonathan Rochkind",
            "id": "comment-13006782",
            "date": "2011-03-15T03:44:30+0000",
            "content": "There is clearly a semantic problem here. i call that the number of 'facet values', what you are calling a 'name' I am calilng a 'facet value'. I have no idea what you are calling a 'value', honestly.  I'm pretty sure we're talking about the same thing. I have no idea what word to use that will mean that to both of us and everyone else. \n\nI guess what you are calling 'number of values',if I understand properly,  I'd call 'sum of the facet counts'.  facet counts are already called facet counts. Summing them up is the sum of them. It's not a 'number of values'. (I also can't imagine any use case where you'd want a sum of facet counts; for a single-valued field with no facet.missing, the sum of the facet counts will equal the document count, numRows. In other cases it may not, and I have no idea why you'd ever want it in those cases).   But the name is less important than the functionality, I guess. (Except for that lack of establishment of consistent terminology in Solr is what leads us to this confusion). Okay, wait, numFacetTerms, is that maybe clear, 'terms', since Solr 'terms' is in fact what appear as the values/names in Solr facetting? From the wiki page for facet.field: \"It will iterate over each Term in the field and generate a facet count using that Term as the constraint. \"\n\nBut also perhaps I misunderstood, the functionality is of use/interest to me only if it does NOT require me to set facet.limit=-1 to get this count of distinct values/names/terms.  If I'm setting facet.limit=-1 anyway, that number is already implicit in the response, not much value added making it explicit.  What I have need of is a way to get this number without setting facet.limit=-1, since in my use cases I can have a million or more, um, values/names/terms. (Which Solr 1.4.1 with facet.method=fc handles with aplomb!).  If your patch only works if facet.limit=-1, it does not actually address my need.  "
        },
        {
            "author": "Bill Bell",
            "id": "comment-13006792",
            "date": "2011-03-15T04:49:53+0000",
            "content": "I am going to use your suggestion. You will not have to set the limit. Getting the numFacetTerms will be optional, and you also will be able to NOT get the hgids as well. I propose this (please comment):\n\nThis will ONLY output the numFacetTerms (no hgid facet counts):\nhttp://localhost:8983/solr/select?q=*:*&facet=true&facet.field=hgid&f.hgid.facet.numFacetTerms=1\n\nThis assumes the count will be limit=-1\n\n\n<lst name=\"facet_fields\">\n  <lst name=\"hgid\">\n   <int name=\"numFacetTerms\">7</int>  <!-- this is not 11 -->\n  </lst>\n</lst>\n\n\n\nThis will output the numFacetTerms AND hgid:\nhttp://localhost:8983/solr/select?q=*:*&facet=true&facet.field=hgid&facet.mincount=1&f.hgid.facet.numFacetTerms=2\n\n\n<lst name=\"facet_fields\">\n  <lst name=\"hgid\">\n   <int name=\"numFacetTerms\">7</int>  <!-- this is not 11 -->\n   <lst name=\"counts\">\n   \t<int name=\"HGPY0000045FD36D4000A\">1</int>\n   \t<int name=\"HGPY00000FBC6690453A9\">1</int>\n   \t<int name=\"HGPY00001E44ED6C4FB3B\">1</int>\n   \t<int name=\"HGPY00001FA631034A1B8\">1</int>\n   \t<int name=\"HGPY00003317ABAC43B48\">1</int>\n   \t<int name=\"HGPY00003A17B2294CB5A\">5</int>\n   \t<int name=\"HGPY00003ADD2B3D48C39\">1</int>\n   </lst>\n  </lst>\n</lst>\n\n "
        },
        {
            "author": "Bill Bell",
            "id": "comment-13006805",
            "date": "2011-03-15T06:02:18+0000",
            "content": "OK this is complete.\n\nSample query:\n\nhttp://localhost:8983/solr/select?q=*:*&facet=true&facet.field=cat&rows=0&facet.numFacetTerms=2&facet.limit=4\n\nSample output:\n\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?> \n<response>\n  <lst name=\"responseHeader\">\n    <int name=\"status\">0</int> \n    <int name=\"QTime\">0</int> \n    <lst name=\"params\">\n      <str name=\"facet.numfacetterms\">2</str> \n      <str name=\"facet\">true</str> \n      <str name=\"q\">*:*</str> \n      <str name=\"facet.limit\">4</str> \n      <str name=\"facet.field\">cat</str> \n      <str name=\"rows\">0</str> \n    </lst>\n  </lst>\n  <result name=\"response\" numFound=\"17\" start=\"0\" /> \n  <lst name=\"facet_counts\">\n    <lst name=\"facet_queries\" /> \n    <lst name=\"facet_fields\">\n      <lst name=\"cat\">\n        <int name=\"numFacetTerms\">14</int> \n        <lst name=\"counts\">\n          <int name=\"electronics\">14</int> \n          <int name=\"memory\">3</int> \n          <int name=\"connector\">2</int> \n          <int name=\"graphics card\">2</int> \n        </lst>\n      </lst>\n    </lst>\n    <lst name=\"facet_dates\" /> \n    <lst name=\"facet_ranges\" /> \n  </lst>\n  </response>\n\n\n\nIn Json:\n\n\n\"facet_fields\":{\"cat\":[\"numFacetTerms\",14,\"counts\",[\"electronics\",14,\"memory\",3,\"connector\",2,\"graphics card\",2]]},\"facet_dates\":{},\"facet_ranges\":{}}}\n\n "
        },
        {
            "author": "Otis Gospodnetic",
            "id": "comment-13006807",
            "date": "2011-03-15T06:16:55+0000",
            "content": "Would this be more consistent?  facet.numfacetterms => facet.numFacetTerms "
        },
        {
            "author": "Bill Bell",
            "id": "comment-13006809",
            "date": "2011-03-15T06:18:42+0000",
            "content": "I am changing it. Since there is one example of upper/lower.\n\nfacet.enum.cache.minDf\n "
        },
        {
            "author": "Bill Bell",
            "id": "comment-13007345",
            "date": "2011-03-16T04:08:22+0000",
            "content": "OK I did the required work, can we get more feedback or get it committed? What else is needed? "
        },
        {
            "author": "Bill Bell",
            "id": "comment-13008825",
            "date": "2011-03-19T21:09:04+0000",
            "content": "Can someone look this patch over?\n\nAlso requested +1 from Isha Garg <isha.garg@orkash.com>\n\nThanks,. "
        },
        {
            "author": "Dmitry Drozdov",
            "id": "comment-13019828",
            "date": "2011-04-14T13:39:19+0000",
            "content": "Thanks for the patch!\nIt also works for version 3.1, just the line numbers differ - attaching the adopted patch for 3.1 just in case. "
        },
        {
            "author": "Bill Bell",
            "id": "comment-13021948",
            "date": "2011-04-20T03:57:46+0000",
            "content": "OK how do we get this committed? "
        },
        {
            "author": "Lance Norskog",
            "id": "comment-13024966",
            "date": "2011-04-25T21:26:20+0000",
            "content": "From the patch:\npublic static final String FACET_NAMEDISTINCT = FACET + \".numFacetTerms\";\nSo- in this issue, a name is what everything else calls a term, and a value is what everyone else calls a \"count of documents with this term in this field\". Please change this in the patch.\n\n\n\n "
        },
        {
            "author": "James Dyer",
            "id": "comment-13026089",
            "date": "2011-04-28T03:13:29+0000",
            "content": "I noticed that with the original patch applied, SimpleFacetsTest would fail.  The reason is a tiny bug that affects backwards-compatibility in that this would wrap the counts with a \"counts\" element in the response.  This is valid if using the \"namedistinct\" param, but if a user doesn't specify this, it shouldn't affect old behavior.  This updated patch corrects this little issue and SimpleFacetsTest now passes.  "
        },
        {
            "author": "Bill Bell",
            "id": "comment-13026103",
            "date": "2011-04-28T03:50:27+0000",
            "content": "Lance Norskog,\n\nWhat do you want it to be called? I would use a committer to take this issue on. It has several votes, and lots of downloads. People are using it successfully already.\n\nDo you want me to switch the numFacetTerms to numFacetNames ? Anything else? I feel like we are going in circles on this issue.\n\n\nThis will output the numFacetTerms AND hgid:\nhttp://localhost:8983/solr/select?q=*:*&facet=true&facet.field=hgid&facet.mincount=1&f.hgid.facet.numFacetNames=2\n\n<lst name=\"facet_fields\">\n  <lst name=\"hgid\">\n   <int name=\"numFacetNames\">7</int>  <!-- this is not 11 -->\n   <lst name=\"counts\">\n   \t<int name=\"HGPY0000045FD36D4000A\">1</int>\n   \t<int name=\"HGPY00000FBC6690453A9\">1</int>\n   \t<int name=\"HGPY00001E44ED6C4FB3B\">1</int>\n   \t<int name=\"HGPY00001FA631034A1B8\">1</int>\n   \t<int name=\"HGPY00003317ABAC43B48\">1</int>\n   \t<int name=\"HGPY00003A17B2294CB5A\">5</int>\n   \t<int name=\"HGPY00003ADD2B3D48C39\">1</int>\n   </lst>\n  </lst>\n</lst>\n\n\n "
        },
        {
            "author": "Lance Norskog",
            "id": "comment-13026124",
            "date": "2011-04-28T05:28:41+0000",
            "content": "Putting up or shutting up \n\nThis splits apart whether to count terms v.s. whether to count docs per term. They are independent concepts.\n\nInstead of 'numFacetTerms=0/1/2' it is 'numTerms=true/false'.\nif you set 'numTerms=true', it counts terms.\nIf you set facet.limit=0, it does not do the facet search. It does not count docs per term.\nIf you set 'numTerms=false' and 'facet.limit=0', it does nothing.\n\n'numFacetTerms' is redundant- we know it's all about facets. Thus, 'numTerms'. "
        },
        {
            "author": "Jonathan Rochkind",
            "id": "comment-13026297",
            "date": "2011-04-28T13:06:03+0000",
            "content": "Wonderful much better, thanks Lance, this is a much more clear and flexible api consistent with other parts of Solr. (For a feature I could definitely really use, thanks Bill). \n\nBut I wonder... should it be facet.numTerms to group with other facetting related params? Or wait, is it already? "
        },
        {
            "author": "Lance Norskog",
            "id": "comment-13026823",
            "date": "2011-04-29T03:22:26+0000",
            "content": "I changed it to 'facet.numTerms'.\n\nThere is still a big performance problem: numTerms builds the entire list of facets and then reports the length of the list. This could be done more efficiently.  "
        },
        {
            "author": "Bill Bell",
            "id": "comment-13026826",
            "date": "2011-04-29T03:39:29+0000",
            "content": "I am not seeing the performance problem.\n\nIf you are outputting facets anyways, the loop and list is going to be called. So in that case it is as efficient as probably can be.\nThat is why I had the 0/1/2. I was reusing the code and just looking at the list size:\n\ncountFacetTerms.size()\ncounts.size()\n\nThere is a lot of logic in getListedTermCounts() and getTermCountsLimit(). If we optimize, and just add a counter, we need to make sure \nthe new methods are not forgotten about (test cases?). I have seen that happen numerous times.\n\n "
        },
        {
            "author": "Bill Bell",
            "id": "comment-13026827",
            "date": "2011-04-29T03:41:11+0000",
            "content": "Also I thought you wanted to change the name to numNames? I am okay with numTerms too. "
        },
        {
            "author": "Bill Bell",
            "id": "comment-13026828",
            "date": "2011-04-29T03:43:00+0000",
            "content": "It would be good to be able to cache the value, instead of building a list that is cached too. "
        },
        {
            "author": "Lance Norskog",
            "id": "comment-13026863",
            "date": "2011-04-29T05:51:17+0000",
            "content": "There is a lot of logic in getListedTermCounts() and getTermCountsLimit(). If we optimize, and just add a counter, we need to make sure the new methods are not forgotten about (test cases?). I have seen that happen numerous times.\nAyup. In fact this breaks SimpleFacetsTest. Everything in facets need tests. "
        },
        {
            "author": "Bill Bell",
            "id": "comment-13031539",
            "date": "2011-05-11T04:48:46+0000",
            "content": "OK. Can you point me in the right direction. Are you a committer? Can we get this committed? "
        },
        {
            "author": "Bill Bell",
            "id": "comment-13040096",
            "date": "2011-05-27T07:01:57+0000",
            "content": "From rajini:\n\n\n     The patch solr 2242 for getting count of distinct facet terms doesn't\nwork for distributedProcess\n\n(https://issues.apache.org/jira/browse/SOLR-2242)\n\nThe error log says\n\nHTTP ERROR 500\nProblem accessing /solr/select. Reason:\n\n    For input string: \"numFacetTerms\"\n\njava.lang.NumberFormatException: For input string: \"numFacetTerms\"\nat\njava.lang.NumberFormatException.forInputString(NumberFormatException.java:48)\nat java.lang.Long.parseLong(Long.java:403)\nat java.lang.Long.parseLong(Long.java:461)\nat org.apache.solr.schema.TrieField.readableToIndexed(TrieField.java:331)\nat org.apache.solr.schema.TrieField.toInternal(TrieField.java:344)\nat\norg.apache.solr.handler.component.FacetComponent$DistribFieldFacet.add(FacetComponent.java:619)\nat\norg.apache.solr.handler.component.FacetComponent.countFacets(FacetComponent.java:265)\nat\norg.apache.solr.handler.component.FacetComponent.handleResponses(FacetComponent.java:235)\nat\norg.apache.solr.handler.component.SearchHandler.handleRequestBody(SearchHandler.java:290)\nat\norg.apache.solr.handler.RequestHandlerBase.handleRequest(RequestHandlerBase.java:131)\nat org.apache.solr.core.SolrCore.execute(SolrCore.java:1316)\nat\norg.apache.solr.servlet.SolrDispatchFilter.execute(SolrDispatchFilter.java:338)\nat\norg.apache.solr.servlet.SolrDispatchFilter.doFilter(SolrDispatchFilter.java:241)\nat\norg.mortbay.jetty.servlet.ServletHandler$CachedChain.doFilter(ServletHandler.java:1212)\nat org.mortbay.jetty.servlet.ServletHandler.handle(ServletHandler.java:399)\nat\norg.mortbay.jetty.security.SecurityHandler.handle(SecurityHandler.java:216)\nat org.mortbay.jetty.servlet.SessionHandler.handle(SessionHandler.java:182)\nat org.mortbay.jetty.handler.ContextHandler.handle(ContextHandler.java:766)\nat org.mortbay.jetty.webapp.WebAppContext.handle(WebAppContext.java:450)\nat org.mortbay.jetty.handler.HandlerWrapper.handle(HandlerWrapper.java:152)\nat org.mortbay.jetty.Server.handle(Server.java:326)\nat org.mortbay.jetty.HttpConnection.handleRequest(HttpConnection.java:542)\nat\norg.mortbay.jetty.HttpConnection$RequestHandler.headerComplete(HttpConnection.java:928)\nat org.mortbay.jetty.HttpParser.parseNext(HttpParser.java:549)\nat org.mortbay.jetty.HttpParser.parseAvailable(HttpParser.java:212)\nat org.mortbay.jetty.HttpConnection.handle(HttpConnection.java:404)\nat\norg.mortbay.io.nio.SelectChannelEndPoint.run(SelectChannelEndPoint.java:410)\nat\norg.mortbay.thread.QueuedThreadPool$PoolThread.run(QueuedThreadPool.java:582)\n\n\nThe query I passed :\nhttp://localhost:8983/solr/select?q=*:*&facet=true&facet.field=2&facet.field=648&facet.mincount=1&facet.limit=-1&f.2.facet.numFacetTerms=1&rows=0&shards=localhost:8983/solr,localhost:8985/solrtwo\n\nAnyone can suggest me the changes i need to make to enable the same\nfuncionality for shards?\n\nWhen i do it across single core.. I get the correct results. I have applied\nthe solr 2242 patch in solr1.4.1\n\nAwaiting for reply\n\nRegards,\nRajani "
        },
        {
            "author": "Bill Bell",
            "id": "comment-13044727",
            "date": "2011-06-06T06:23:50+0000",
            "content": "Since we changed the output of the facet_fields, the FacetComponent.java needs to change. This also impacts the DistribFieldFacet type. This code is not going to work, since price does not just have a list of numbers. It now has multiple lists (if we set the param). We might want to always return \"counts\" list in all cases. Then sharding can easily pick up on this... The DistribFieldFacet needs to be refactored.\n\n\n<lst name=\"facet_fields\">\n  <lst name=\"price\">\n    <int name=\"numFacetTerms\">14</int>\n    <lst name=\"counts\"><int name=\"0.0\">3</int><int name=\"11.5\">1</int><int name=\"19.95\">1</int><int name=\"74.99\">1</int><int name=\"92.0\">1</int><int name=\"179.99\">1</int><int name=\"185.0\">1</int><int name=\"279.95\">1</int><int name=\"329.95\">1</int><int name=\"350.0\">1</int><int name=\"399.0\">1</int><int name=\"479.95\">1</int><int name=\"649.99\">1</int><int name=\"2199.0\">1</int>\n    </lst>\n  </lst>\n</lst>\n\n\n\n "
        },
        {
            "author": "Bill Bell",
            "id": "comment-13044730",
            "date": "2011-06-06T06:52:16+0000",
            "content": "It would be easier for Sharding to not have multiple lists... I could use some help if we want to change it - since I have not played with FacetComponent.java.\n\nOtherwise, it would a more simpler fix to just add it and flatten the lists.\n\n\n<lst name=\"facet_fields\">\n  <lst name=\"price\">\n    <int name=\"numFacetTerms\">14</int>\n    <int name=\"0.0\">3</int><int name=\"11.5\">1</int><int name=\"19.95\">1</int><int name=\"74.99\">1</int><int name=\"92.0\">1</int><int name=\"179.99\">1</int><int name=\"185.0\">1</int><int name=\"279.95\">1</int><int name=\"329.95\">1</int><int name=\"350.0\">1</int><int name=\"399.0\">1</int><int name=\"479.95\">1</int><int name=\"649.99\">1</int><int name=\"2199.0\">1</int>\n  </lst>\n</lst>\n\n\n\nNot ideal, but easier for v1 ? I could also just remove numFacetTerms=2 for now.\n\nWill only require an if statement to ignore the type check for \"numFacetTerms\".\n\nHere is a patch that works with sharding.\n\nhttp://localhost:8983/solr/select?shards=localhost:8983/solr,localhost:7574/solr&indent=true&q=*:*&facet=true&facet.mincount=1&facet.numFacetTerms=2&facet.limit=-1&facet.field=price\n\nEnjoy.\n\nBill\n\n\n "
        },
        {
            "author": "Bill Bell",
            "id": "comment-13048461",
            "date": "2011-06-13T03:58:08+0000",
            "content": "Can we PLEASE commit this?  What else do we need to add? "
        },
        {
            "author": "Mark Miller",
            "id": "comment-13048466",
            "date": "2011-06-13T04:45:05+0000",
            "content": "Hmm...yeah, fair amount of work went on here and a fair amount of interest... unfortunately, not my field (and I'm sick, on vacation, out of the country, and blah blah blah  ). But, if no one takes this, I can get up to speed eventually - I doubt that soon though. Sorry Bill - not a lot of committers fluent in this area that are not very busy with other things. "
        },
        {
            "author": "Lance Norskog",
            "id": "comment-13048471",
            "date": "2011-06-13T05:40:17+0000",
            "content": "Yeah, my itch started just now also \n\n\"Constraint\" means any facet value: terms, numerical ranges, query results.\n\nRange queries have the same situation: when I give range endpoints and a gap, I want to know how many intervals it made from the gap.That would be the analog of this count. \n\nI'm not saying this patch has to do range counts also, but pointing out the eventual scope of this feature. Therefore, 'numTerms' is not the word we're looking for. 'count' or 'total' seem right.\n\nBelow, both features:{ and popularity:{ need counts. \n\n\n\"facet_counts\":{\n    \"facet_queries\":{\n      \"*:*\":27},\n    \"facet_fields\":{\n      \"features\":[\n        \"facet_terms\",[\n          \"2\",7,]]}\n    \"facet_ranges\":{\n      \"popularity\":{\n        \"counts\":[\n          \"0\",3,\n          \"2\",0,\n          \"4\",1,\n          \"6\",9],\n        \"gap\":2,\n        \"start\":0,\n        \"end\":8}}}}\n\n\n\n\np.s.\nI got the above from the example electronic shop database with this query:\nclick to see "
        },
        {
            "author": "Lance Norskog",
            "id": "comment-13048474",
            "date": "2011-06-13T05:49:15+0000",
            "content": "If I was a committer which I'm not, I would demand:\n\n\tparams would be as simple as possible. 'namedistinct' would be a symbol like 'facet.method=enum'. Facets have exploded in complexity, and I can't follow how everything interlocks. The API may have to change later.\n\tno white-space glitches\n\tconsistencyConsistencyConsistency.\n\tthere has to to be a way to use less memory when we're only pulling a count.\n\tunit tests. It's somewhat unfair to expect you to write all the unit tests required to make sure this does not break anything else, give that so much of facet features do not have tests.\n\n\n\nAnyway, food calls. Hope this helps. "
        },
        {
            "author": "Lance Norskog",
            "id": "comment-13048480",
            "date": "2011-06-13T06:02:23+0000",
            "content": "There is a lot of complexity here, and having a bunch of orthogonal parameters is not quite enough. Looking at everything around facets, and group collapse, and the join trick, the Solr query syntax looks like the database world right before SQL.  "
        },
        {
            "author": "Bill Bell",
            "id": "comment-13048964",
            "date": "2011-06-14T02:44:24+0000",
            "content": "Lance,\n\nThere is literally 15 lines of code changes. Not sure how you cannot follow it. I could use no memory and just loop through the results, but that would not be cached - so the speed would still be slow since I need to pull in the array in order to count it.\n\nThe field is not called namedistinct anymore... It is called facet.numFacetTerms=2,1,0.\n\nAll other parameters are good. Also you do not need anything else to get it to work, since I set the defaults to work for you now.\n\nI'll see if I can write some more tests. Here is the rub: I would be happy to wrote hundreds of test cases if I knew someone was going to actually help me get this done. I am used to having a committer actually work with me - Mike McCandless is awesome and we worked on several issues together. But I have seen tons of features die when no one is willing to help. So here I am wanting, willing and able to get this done. And I have no one willing to assist from a committer perspective... The patch works fine in sharded and normal mode. So people can use it today. It is just not committed.\n\nI have 4 clients using it in production and one has 100M page views a year, and so far no problems.\n\nhttp://localhost:8983/solr/select?shards=localhost:8983/solr,localhost:7574/solr&indent=true&q=*:*&facet=true&facet.mincount=1&facet.numFacetTerms=2&facet.limit=-1&facet.field=price\n\n "
        },
        {
            "author": "Bill Bell",
            "id": "comment-13048966",
            "date": "2011-06-14T02:52:53+0000",
            "content": "Thanks Mike.\n\nI think it is committable since shards work now. We might need to fix some broken tests (and I am willing to do that).\n\nThen we can move to range and queries...\n\nThanks.  "
        },
        {
            "author": "Bill Bell",
            "id": "comment-13048967",
            "date": "2011-06-14T02:54:25+0000",
            "content": "Lance,\n\nThis patch just takes the # of lines coming out of the facet section for a field and tells you how many you have.\n\nIt does not do anything to change the facet, or deal with white space, or anything complicated.\n\nThis is a simple counter.\n\nBill "
        },
        {
            "author": "Simon Willnauer",
            "id": "comment-13049014",
            "date": "2011-06-14T06:53:00+0000",
            "content": "Bill, this seems like an important issue. Many votes etc. I am on travel right now so give me some days to come back and I will work with you to get this done.\nThanks for your patience\n\nsimon "
        },
        {
            "author": "Simon Willnauer",
            "id": "comment-13049077",
            "date": "2011-06-14T09:30:38+0000",
            "content": "Hey bill,\nI looked at your patch and I have some comments:\n\n\n\tyou should fix white-spaces within the try {} catch block in SimpleFacets\n\n\n\n\n\tI think you should alsom make the constant came consistent with facet parameter s/FACET_NAMEDISTINCT/FACTE_NUM_FACET_TERMS/\n\tas lance noted (in a not necessarily appropriate tone but this is a different issue)switch to a constant / enum rather than a number something like [ COUNTS, COUNTS_AND_VALUES ]\n\tif the termList is not null the results are all implicit meaning its always the number of terms you specify in the term list, right? I think we should not support this eg. only compute the count if no term list is specified\n\tIf you are asking for COUNTS_AND_FACETS (the 2 case) if seems we should check if the limit is already -1 so we don't comput that twice?\n\tI think you should use a switch / case or an if ELSE construct instead of having 3 plain if statements\n\n\n\nI only considered the last patch you uploaded let me know if I should look at something else?\n\nSimon "
        },
        {
            "author": "Bill Bell",
            "id": "comment-13053080",
            "date": "2011-06-22T06:59:12+0000",
            "content": "Simon,\n\nI made all those changes except for the termsList one. I think it is useful to have the count based on terms.\n\nSee attachment. "
        },
        {
            "author": "Bill Bell",
            "id": "comment-13053081",
            "date": "2011-06-22T07:01:10+0000",
            "content": "New patch ready for commit? "
        },
        {
            "author": "Simon Willnauer",
            "id": "comment-13053113",
            "date": "2011-06-22T07:59:35+0000",
            "content": "New patch ready for commit?\n\nbill, I still see lots of whitespace / indentation problems  in that latest patch. Anyway I looked at it and I wonder if we could restructure this a little like we could first check if termList != null and do all the cases there and if termList == null we get the TermCountsLimit that would remove all the redundant getTermCountsLimit / getListedTermCounts calls. Like the termList==null case seems very easy and straight forward:\n\n           if (termList != null) {\n            NamedList<Integer> counts = getListedTermCounts(facetValue, termList);\n            switch (numFacetTerms) {\n            case COUNTS:\n              final NamedList<Integer> resCount = new NamedList<Integer>();\n              counts = resCount;\n            case COUNTS_AND_VALUES:\n              counts.add(\"numFacetTerms\", counts.size());\n              break;\n            }\n            res.add(key, counts);\n          } else {\n            ...\n\n\n\nyet, its hard to refactor this without a single test (note, there might be a bug). I would be really happy to see a test-case for this that tests all the variations.\nRegarding the constants, I think the default case should be a constant too. If you use NamedList can you make sure you put the right generic to it if possible, otherwise my IDE goes wild and adds warnings all over the place. In your case NamedList<Integer> works fine.\n\nsimon "
        },
        {
            "author": "Bill Bell",
            "id": "comment-13054931",
            "date": "2011-06-25T16:25:36+0000",
            "content": "re: whitespace\n\nWhat are the settings supposed to be for tabs? Because on my editor it looks perfect. 4 space, tabs, 2 space per tab? ??\n\nI will add some tests.\n\nI think switching from if to switch and the movement to termList != null is mostly just style and does not really improve anything. I actually think it confuses things and makes the overall patch larger and more risky that we miss something or mess it up.\n\nI will also look at the Integer generic... Thanks.\n\nBill "
        },
        {
            "author": "Bill Bell",
            "id": "comment-13054932",
            "date": "2011-06-25T16:26:53+0000",
            "content": "Just so you know I have been using the original patch in production for over 5 months. I would say that the original one is tested.\n\nBut now that we are changing it, I agree that we need more coverage.\n\nThat will be my #1 priority. "
        },
        {
            "author": "Bill Bell",
            "id": "comment-13055151",
            "date": "2011-06-26T19:07:18+0000",
            "content": "OK. Here are some test cases.\n\nI am getting a weird error on running it: ant -Dtestcase=NumFacetTermsFacetsTest test\n\n\njunit-sequential:\n    [junit] Testsuite: org.apache.solr.request.NumFacetTermsFacetsTest\n    [junit] Tests run: 1, Failures: 1, Errors: 0, Time elapsed: 4.072 sec\n    [junit] \n    [junit] ------------- Standard Error -----------------\n    [junit] NOTE: reproduce with: ant test -Dtestcase=NumFacetTermsFacetsTest -Dtestmethod=testNumFacetTermsFacetCounts -Dtests.seed=3921835369594659663:-3219730304883530389\n    [junit] *** BEGIN org.apache.solr.request.NumFacetTermsFacetsTest.testNumFacetTermsFacetCounts: Insane FieldCache usage(s) ***\n    [junit] SUBREADER: Found caches for descendants of DirectoryReader(segments_3 _0(4.0):C6)+hgid_i1\n    [junit] \t'DirectoryReader(segments_3 _0(4.0):C6)'=>'hgid_i1',class org.apache.lucene.search.FieldCache$DocTermsIndex,org.apache.lucene.search.cache.DocTermsIndexCreator@603bb3eb=>org.apache.lucene.search.cache.DocTermsIndexCreator$DocTermsIndexImpl#1026179434 (size =~ 372 bytes)\n    [junit] \t'org.apache.lucene.index.SegmentCoreReaders@7e8905bd'=>'hgid_i1',int,org.apache.lucene.search.cache.IntValuesCreator@30781822=>org.apache.lucene.search.cache.CachedArray$IntValues#291172425 (size =~ 92 bytes)\n    [junit] \n    [junit] *** END org.apache.solr.request.NumFacetTermsFacetsTest.testNumFacetTermsFacetCounts: Insane FieldCache usage(s) ***\n    [junit] ------------- ---------------- ---------------\n    [junit] Testcase: testNumFacetTermsFacetCounts(org.apache.solr.request.NumFacetTermsFacetsTest):\tFAILED\n    [junit] org.apache.solr.request.NumFacetTermsFacetsTest.testNumFacetTermsFacetCounts: Insane FieldCache usage(s) found expected:<0> but was:<1>\n    [junit] junit.framework.AssertionFailedError: org.apache.solr.request.NumFacetTermsFacetsTest.testNumFacetTermsFacetCounts: Insane FieldCache usage(s) found expected:<0> but was:<1>\n    [junit] \tat org.apache.lucene.util.LuceneTestCase.assertSaneFieldCaches(LuceneTestCase.java:725)\n    [junit] \tat org.apache.lucene.util.LuceneTestCase.tearDown(LuceneTestCase.java:620)\n    [junit] \tat org.apache.solr.SolrTestCaseJ4.tearDown(SolrTestCaseJ4.java:96)\n    [junit] \tat org.apache.lucene.util.LuceneTestCase$LuceneTestCaseRunner.runChild(LuceneTestCase.java:1430)\n    [junit] \tat org.apache.lucene.util.LuceneTestCase$LuceneTestCaseRunner.runChild(LuceneTestCase.java:1348)\n    [junit] \n    [junit] \n    [junit] Test org.apache.solr.request.NumFacetTermsFacetsTest FAILED\n\n\n "
        },
        {
            "author": "Bill Bell",
            "id": "comment-13055152",
            "date": "2011-06-26T19:09:47+0000",
            "content": "The test case gives an error. Not familiar with this error "
        },
        {
            "author": "Bill Bell",
            "id": "comment-13055155",
            "date": "2011-06-26T19:23:50+0000",
            "content": "I think it has to do with a NPE in group ion 4.0 it fails on other code. Nothing to do with this patch.\n\n\n  assertQ(\"check group and facet counts with numFacetTerms=1\",\n            req(\"q\", \"id:[1 TO 6]\"\n                ,\"indent\", \"on\"\n                ,\"facet\", \"true\"\n                ,\"group\", \"true\"\n                ,\"group.field\", \"hgid_i1\"\n                ,\"f.hgid_i1.facet.limit\", \"-1\"\n                ,\"f.hgid_i1.facet.mincount\", \"1\"\n                ,\"f.hgid_i1.facet.numFacetTerms\", \"1\"\n                ,\"facet.field\", \"hgid_i1\"\n                )\n            ,\"*[count(//arr[@name='groups'])=1]\"\n            ,\"*[count(//lst[@name='facet_fields']/lst[@name='hgid_i1']/int)=1]\" // there are 1 unique items\n            ,\"//lst[@name='hgid_i1']/int[@name='numFacetTerms'][.='4']\"\n            );\n\n\n "
        },
        {
            "author": "Bill Bell",
            "id": "comment-13055158",
            "date": "2011-06-26T19:46:10+0000",
            "content": "\njunit-sequential:\n    [junit] Testsuite: org.apache.solr.request.NumFacetTermsFacetsTest\n    [junit] Tests run: 1, Failures: 0, Errors: 0, Time elapsed: 3.48 sec\n    [junit] \n\n\n\nI fixed the NamedList() generic too.\n\n "
        },
        {
            "author": "Bill Bell",
            "id": "comment-13055159",
            "date": "2011-06-26T19:47:39+0000",
            "content": "I left the group in there, we can uncomment when it starts working again (if it does). "
        },
        {
            "author": "Simon Willnauer",
            "id": "comment-13056413",
            "date": "2011-06-28T09:35:45+0000",
            "content": "Bill, thanks for the unit test. I need to look into the FieldCache issue before we go further though. Yet, I don't see a NPE here though.\n\nI fixed some whitespace issues in the patch and refactored your impl to use a switch statement instead of if / else I think is less verbose and has less duplication but as you said thats a style issue mainly.\n\nI will look into the FC issue and move forward here ASAP. Thanks Bill "
        },
        {
            "author": "Bill Bell",
            "id": "comment-13058205",
            "date": "2011-07-01T03:52:16+0000",
            "content": "Thanks... If you look at my tests that I commented out, you will notice you get the Insane FieldCache usage(s) problem.\n\nIt does it every time on my PC...\n\nThis patch does not appear to gave any issues until you pull in the group issue. "
        },
        {
            "author": "Bill Bell",
            "id": "comment-13061785",
            "date": "2011-07-08T06:26:22+0000",
            "content": "Are we ready to commit? "
        },
        {
            "author": "Simon Willnauer",
            "id": "comment-13061839",
            "date": "2011-07-08T08:26:15+0000",
            "content": "Are we ready to commit?\nbill, isnt't there a test failure still on this issue related to FC? Yonik mentioned BW compat issues here and promised to comment. I will ping him again.\n\nthanks for the patience\n\nsimon "
        },
        {
            "author": "Bill Bell",
            "id": "comment-13062348",
            "date": "2011-07-09T08:56:13+0000",
            "content": "Just replace this test file to fix the insanity. "
        },
        {
            "author": "Yonik Seeley",
            "id": "comment-13064144",
            "date": "2011-07-12T21:23:23+0000",
            "content": "This issue was a bit tricky to review, given that the output doesn't seem to quite match the examples.\nI also wasn't exactly sure what the latest patch was, so I just looked at the patch uploaded on 28/Jun/11.\n\nHere's my summary on what the patch currently does:\n\nIf you add facet.facetTermCounts=2 to a faceting request, you get the following:\n\n\n<lst name=\"facet_fields\">\n  <lst name=\"text\">\n    <int name=\"electronics\">14</int>\n    <int name=\"inc\">8</int>\n    <int name=\"2.0\">5</int>\n    <int name=\"lcd\">5</int>\n    <int name=\"memory\">5</int>\n    <int name=\"numFacetTerms\">385</int>\n  </lst>\n</lst>\n\n\n\nIf you add facet.facetTermCounts=1 to a faceting request, you get the following:\n\n\n<lst name=\"facet_fields\">\n  <lst name=\"text\">\n    <int name=\"numFacetTerms\">385</int>\n  </lst>\n</lst>\n\n\n\nw.r.t. the interface, I agree with a number of Lance's observations.\n\n\n\tfacet.numFacetTerms name: the second \"Facet\" is a bit redundant.  And we probably should be talking in terms of \"constraints\" instead of \"terms\".  Perhaps facet.numConstraints or (facet.nconstraints to be consistent with group.ngroups).\n\tfacet.nconstraints should just be a boolean... no need for \"1\" or \"2\".  If the user doesn't want to see any constraints, then they can set facet.limit=0.  This is also consistent with grouping.\n\twe're mixing units in the same list, and that's probably not a great idea?  Constraints have units of documents (number of documents that matched that constraint) while \"numFacetTerms\" has units of number of constraints.\n\tI think this also breaks distributed faceting due to mixing of units?  The distributed faceting code thinks that numFacetTerms is a constraint.\n\tWe need to figure out what we are going to do in distributed mode... it doesn't seem easy to actually figure out the number of constraints without streaming them all back and merging (i.e. you can't just add up the numbers)\n\tI also agree that we should not built the entire list in memory just to get the size of that list.\n\n\n\nIt seems like rather than adding more magic names to the list (and risk a real collision with the actual name of a constraint), we should add more structure to the response, as previously discussed.\n\nSo if we added facet.nconstraints=true, we would get\n\n<lst name=\"facet_fields\">\n  <lst name=\"text\">\n    <int name=\"numFacetTerms\">385</int>\n    <lst name=\"counts\">\n      <int name=\"electronics\">14</int>\n      <int name=\"inc\">8</int>\n      <int name=\"2.0\">5</int>\n      <int name=\"lcd\">5</int>\n      <int name=\"memory\">5</int>\n   </lst>\n  </lst>\n</lst>\n\n\n\nAnd when we use this new format, we should consider using a separate \"missing\" name for facet.missing=true instead of using the null name in with the counts.\n\nThis format change is where we need to be careful about back compat - this interface is one of the widest used and with all the 3rd party clients and libraries out there, we should still support the old format via a facet.format parameter or something.\n\nBill: You originally opened this issue for use with grouping to get the total number of groups. Are you aware of the group.ngroups parameter that was added that does this? "
        },
        {
            "author": "Bill Bell",
            "id": "comment-13064414",
            "date": "2011-07-13T07:51:39+0000",
            "content": "Yonik,\n\nYes I know about groups.ngroups. But the use case still stands. We need a way to add up facet terms without actually counting them.\n\nI had the restructured facet_fields XML like you recommended (twice). And the issue is it breaks ALL sharding. The reason why it breaks distribution is that it is looking for <int> and not <lst>... Several people have wanted me to change the name to count, to term, to distinct... I really don't care what the name is, since it makes sense when you try it. I think changing the distribution is a MUCH larger project. If you want to jump in on the sharding/distribution to make it work with lists, then please help. The format change is a HUGE issue. The magic names could also be an issue but ONLY if you use this new feature. It is not an issue for all APIs and usage - which is why I added it as a magic variable.\n\nDo we have any examples with Boolean? I have not seen any... Do we use True/False or on/off? Do you mean like facet=true ? The reason why I have a 1 and 2 is to get the count of terms, but only return a smaller set (internal limit=-1, but user types limit=5). That is the reason for that. I believe it is very useful.\n\nHaving the numFacetTerms like every other term pretty much works with sharding/distribution. It just adds it together like any other facet count. One server returns 5, and the other returns numFacetTerms=10, and the combined result returns 15. It may break some new feature with distribution or something I am not aware of and not using...\n\nConcerning building in memory. Having it cached is what I was trying to achieve. If there is another way to cache the result then let me know other options. Not having it cached at all is a huge performance problem. If you are using mode 2, it does not matter that much since you need to return the list and in most cases you have it in memory... Mode 1 hides it a bit and builds the entire list in memory when we only need to cache the one value... Again - without breaking something else, not sure how to achieve that.\n\nAs long as there are not more gotchas in distribution, most of the other things you are listing (XML, name change, boolean) are almost preferences and the XML format change will be a huge issue, and we should be able to commit? Also, would like to not cache the entire list in memory when using this - need some assistance. \n\n1. Any other distribution/sharing issues with adding a magic variable in facet_field for a new feature? \n2. Where and how do we store a cache value without using the array that is present so we don't cache the whole facet term list when we only need to cache the resulting number?\n\nThanks.\n\n "
        },
        {
            "author": "Bill Bell",
            "id": "comment-13067500",
            "date": "2011-07-19T05:07:32+0000",
            "content": "Simon - thoughts? "
        },
        {
            "author": "Chris Male",
            "id": "comment-13068892",
            "date": "2011-07-21T10:41:03+0000",
            "content": "I'm just jumping into this issue and considering the problem of loading all constraints just to get their size (or in fact, not wanting to do this).  Is there scope in the SimpleFacets to have some sort of 'Collector' idea added? That way it would be easy to choose if we want to collect the constraints, their counts and the total number of constraints, or whether we just want to total number.\n\nDoes anybody have any thoughts on the distribution issue? "
        },
        {
            "author": "Chris Male",
            "id": "comment-13070935",
            "date": "2011-07-26T04:15:19+0000",
            "content": "Having walked through the SimpleFacet codebase, I see PerSegmentSingleValuedFaceting has already introduced a FacetCollector.  I think we should take this and make it used throughout all the different faceting 'Strategies'.  That way we can push the counting of constraints into the Collector.\n\nI've also thought about the distribution issue.  The simplest option seems to be to return the max constraint count taken from all the shards.  With this, no matter if shards have distinct or overlapping constraints sets, clients can alway see this as the minimum number of constraints that do exist. "
        },
        {
            "author": "Ryan McKinley",
            "id": "comment-13071147",
            "date": "2011-07-26T15:16:24+0000",
            "content": "The simplest option seems to be to return the max constraint count taken from all the shards\n\nThat seems reasonable \u2013 though I think we would also want to be able to have the sum when you know that all shards have unique values.\n\nI don't think bill is referring to the accuracy/meaning of distinct count in distributed search.  His problem is that if we change the output format, we also need to update the code that collects the various values and passes them along.  This patch just add a magic value (numFacetTerms) to the count list so that the value is handled with existing distributed response parsing.  This is a fine one-off solution, but I am -1 for adding any more magic field names to solr.  To add this feature, i think we need to bite the bullet and update the facet response format.\n "
        },
        {
            "author": "Chris Male",
            "id": "comment-13071156",
            "date": "2011-07-26T15:28:15+0000",
            "content": "\nThat seems reasonable \u2013 though I think we would also want to be able to have the sum when you know that all shards have unique values.\n\nPerhaps we should return the maximum and sum of all shard counts?  That way, assuming the client knew how many shards exist, they could handle most scenarios.\n\n\nI don't think bill is referring to the accuracy/meaning of distinct count in distributed search. His problem is that if we change the output format, we also need to update the code that collects the various values and passes them along. This patch just add a magic value (numFacetTerms) to the count list so that the value is handled with existing distributed response parsing. This is a fine one-off solution, but I am -1 for adding any more magic field names to solr. To add this feature, i think we need to bite the bullet and update the facet response format.\n\nAbsolutely.  I hadn't even considered the prospect of not changing the distributed response parsing. "
        },
        {
            "author": "Ryan McKinley",
            "id": "comment-13071162",
            "date": "2011-07-26T15:39:28+0000",
            "content": "Perhaps we should return the maximum and sum of all shard counts? That way, assuming the client knew how many shards exist, they could handle most scenarios.\n\nOnce we change the output format, we should be able to add a few thigns to the output.  Perhaps something like\n\n<lst name=\"text\">\n    <int name=\"numTerms\">385</int>\n    <int name=\"distribMaxTerms\">385</int>\n    <int name=\"distribSumTerms\">845</int>\n    <lst name=\"counts\">\n      ...\n\n "
        },
        {
            "author": "Bill Bell",
            "id": "comment-13072732",
            "date": "2011-07-29T08:04:54+0000",
            "content": "To make this work right with distribution, if seems that it might be more complicated... Wouldn't you have to send the full list of facet terms, consolidate them, and then loop to get the distinct number? That is why I originally sent the WHOLE list of facets, and just added the magic number to the end. \n\nOne machine:\n\nmale: 10000\nnumFacetTerms: 1\n\nAnother machine:\n\nfemale: 7000\nmale: 500\nnumFacetTerms: 2\n\nThe numFacetTerms that we want is 2. Since if you combined them and looped you get 2:\n\nmale: 10500\nfemale: 7000\nnumFacetTerms: 2\n\nIf we add numFacetTerms you get 1+2 = 3.\n\nThe other 2 are easier:\n\ndistribMaxTerms: 2\ndistribSumTerms: 3\n\nThis is not ideal but may be acceptable, the perfect solution is to send the whole list, dedupe them, and then count.... Thoughts?\n "
        },
        {
            "author": "Chris Male",
            "id": "comment-13072805",
            "date": "2011-07-29T13:09:47+0000",
            "content": "I don't think its realistic to send back the whole list, it could be huge! Besides, in the situation where we are only doing counts we aren't going to store the list anywhere.  The distributed environment is never going to be perfect in this situation, Ryan and my suggestion is to send the minimum and maximum number of constraints there could be.   "
        },
        {
            "author": "Ryan McKinley",
            "id": "comment-13072819",
            "date": "2011-07-29T13:39:17+0000",
            "content": "Ya, always sending the whole seems like asking for problems.  You can control how many terms it should pass around with facet.limit, and we could potentially add a warning message to the resposne if that is less then the total number of terms.\n\nMaybe we could also have facet.distrib.limit or something, that would bump up the number that it internally asks for, but still respect facet.limit for the final result?\n "
        },
        {
            "author": "Chris Male",
            "id": "comment-13072827",
            "date": "2011-07-29T13:46:38+0000",
            "content": "I really want to avoid having to load the list just to calculate the counts, it seems unnecessary and a waste of memory.  I think we should start simple and implement what you originally suggested. "
        },
        {
            "author": "Bill Bell",
            "id": "comment-13073334",
            "date": "2011-07-31T08:20:11+0000",
            "content": "OK, I like the warning message idea. Also, it does depend on the shard approach since some shard by date... In that many cases the maxTerms would do what I need.\n\nList:\n\n1. Change the facet.field format.\n2. Get it working with sharding.\n3. Change code to cache the numFacetTerms/numTerms and remove the code that caches the huge term list.\n\nI can do all of this except would like some help with #3.\n\nBill "
        },
        {
            "author": "Guna C",
            "id": "comment-13081906",
            "date": "2011-08-09T20:41:38+0000",
            "content": "Hi Bill\nI wanted to add that this is a great patch.  Provides a way to analyze which search terms are effective without requiring to retrieve all the docs themselves.  I was looking for a patch for 3.3.0.  Does the latest one work?  \nThanks\n-guna "
        },
        {
            "author": "Trinh Trung Kien",
            "id": "comment-13082216",
            "date": "2011-08-10T07:55:11+0000",
            "content": "Hi,\n\nI apply the patch using SOLR 4.0 revision 1140474. The patch seem working OK but i observe several issues:\n\n\n\tI have one field indexed as integer:\n<field name=\"cell_id\" type=\"integer\" indexed=\"true\" stored=\"true\"/>\n\n\n\nWhen I search for cell_id:[900 TO 1000], there is no result (actually I have lots of data with cell_id between 900 to 1000)\nThen I search for cell_id:[1000 TO *], this should return data which have cell_id>=1000, however they return me all the records, the condition seems don't have that meaning.\n\nCan you confirm that i'm using the correct version and revision?\n\nhere is my svn info for the trunk:\n\nURL: http://svn.apache.org/repos/asf/lucene/dev/trunk\nRepository Root: http://svn.apache.org/repos/asf\nRepository UUID: 13f79535-47bb-0310-9956-ffa450edef68\nRevision: 1140474\nNode Kind: directory\nSchedule: normal\nLast Changed Author: chrism\nLast Changed Rev: 1140408\nLast Changed Date: 2011-06-27 21:52:53 -0500 (Mon, 27 Jun 2011)\n\n\n\n "
        },
        {
            "author": "Nguyen Kien Trung",
            "id": "comment-13095135",
            "date": "2011-09-01T05:50:31+0000",
            "content": "I'm using Solr 3.2. Instead of patching, I extend SimpleFacets and FacetComponent, apply the changes mentioned in SOLR-2242.solr3.1.patch with a small fix (SOLR-2242.solr3.1-fix.patch).\n\nint offset = params.getFieldInt(facetValue, FacetParams.FACET_OFFSET, 0);\n....\nresCount.add(\"numTerms\", counts.size() + offset);\n\n\n\nas counts contains list of terms started from the given offset\n\nIt accepts param facet.numTerms=true|false and produce the output\n\n<lst name=\"facet_fields\">\n   <lst name=\"color\">\n      <int name=\"numTerms\">124</int>\n      <lst name=\"counts\" />\n          <int name=\"red\">4</int>\n          <int name=\"blue\">3</int>\n      </lst>\n   </lst>\n</lst>\n\n\nNot yet tested with sharding "
        },
        {
            "author": "Bill Bell",
            "id": "comment-13100095",
            "date": "2011-09-08T06:03:45+0000",
            "content": "Sharding will not work if you change the format of the facet results... We would need to fix sharding for this to go out... \n\nI am in holding pattern until a committer helps. "
        },
        {
            "author": "bronco",
            "id": "comment-13120635",
            "date": "2011-10-05T01:18:59+0000",
            "content": "Will there also be a solution for 3.5 to get the correct numFound results? "
        },
        {
            "author": "Cody Young",
            "id": "comment-13173479",
            "date": "2011-12-20T20:22:10+0000",
            "content": "Simon, any plans for this patch? \n\nThe general consensus seems to be that this is a good patch and desired functionality. The biggest issues seem to be the magic name and distributed support. I see a proposed solution by Yonik of changing the output format but that breaks distributed search. In addition, there is a worry about backwards compatibility and possibly supporting that through a parameter.\n\nWhat if we choose a format that doesn't break backwards compatibility and possibly commit without supporting distributed for the first pass (or supporting the simple case of just adding it all together). This would let us get some progress on this issue without having a magic name in the facet list.\n\nIf we went with a format like below then it wouldn't break backwards compatibility and it shouldn't affect anyone unless they choose to use the feature. This is also consistent with the way numFound works for the main search results. (Admittedly, it's different than ngroups, although we still see numFound used to represent the number of documents in a group.)\n\n\n \n<lst name=\"facet_fields\">\n  <lst name=\"text\" numFacetTerms=\"385\">\n    <int name=\"electronics\">14</int>\n    <int name=\"inc\">8</int>\n    <int name=\"2.0\">5</int>\n    <int name=\"lcd\">5</int>\n    <int name=\"memory\">5</int>\n  </lst>\n</lst>\n\n \n\nOther smaller issues that appear to be outstanding:\nChange code to cache the numFacetTerms/numTerms and remove the code that caches the huge term list.\nDetermine the parameter name: facet.nconstraints=true|false was proposed, allowing facet.count to control the rest of the behavior. "
        },
        {
            "author": "Erick Erickson",
            "id": "comment-13174152",
            "date": "2011-12-21T15:40:28+0000",
            "content": "OK, it seems like we have several themes here. I'd like to get a reasonable consensus before going forward... I'll put out a straw-man proposal here and we can go from there.\n\nBut lets figure out where we're going before revamping stuff yet again.\n\n1> Distributed support. I sure don't see a good way to support this currently. Perhaps some of the future enhancements will make this easier (thinking distributed TF/IDF & such while being totally ignorant of that code), but returning the entire list of constraints (or names or terms or whatever we call it) is just a bad idea. The first time someone tries this on a field with 1,000,000 terms (yes, I've seen this) it'll just blow things up. I'm also slightly anti the min/max idea. I'm not sure what value there is in telling someone \"there are between 10,000 and 90,000 distinct values\". And if it's a field with just a few pre-defined values, that information is already known anyway.... But if someone can show a use-case here I'm not completely against it. But I'd like to see the use case first, not \"someone might find it useful\" <G>.\n\n2> back compat. Cody's suggestion seems to be the slickest in terms of not breaking things, but we use attributes in just a few places, are there reasons NOT to do it that way? Or does this mess up JSON, PHP, etc?\n\n3> Possibly add a new JIRA for changing the facet response format to be tolerant of sub-fields, but don't do that here.\n\nAgain, I want a clearly defined end point for the concerns raised before we dive back in here....\n "
        },
        {
            "author": "Jonathan Rochkind",
            "id": "comment-13174179",
            "date": "2011-12-21T16:17:30+0000",
            "content": "I would find this feature valuable even if it simply did not work at all \non a distributed index. (Refusing to return a value rather than \nreturning a known incorrect value would seem like the right way to go).  \nBecause my index is not distributed, and I would find this feature \nvaluable, heh.\n\nI don't know if Solr currently has any policies against committing \nfeatures that can't work on distributed, but personally my 'vote' would \nbe doing that here, with clear documentation that it doesn't work on \ndistributed (and the hope that future enhancements may make it more \nfeasible to do so, as Erick suggests may possibly maybe happen).\n "
        },
        {
            "author": "Yonik Seeley",
            "id": "comment-13174184",
            "date": "2011-12-21T16:26:12+0000",
            "content": "I'm also slightly anti the min/max idea. I'm not sure what value there is in telling someone \"there are between 10,000 and 90,000 distinct values\".\n\nI think we could come up with a pretty good estimate (but we should tell them it's an estimate somehow).  Anyway, that could optionally be handled in a different issue.\n\n2> back compat. Cody's suggestion seems to be the slickest in terms of not breaking things, but we use attributes in just a few places, are there reasons NOT to do it that way? Or does this mess up JSON, PHP, etc?\n\nYes, it messes up JSON, binary format, etc.  We'd need to figure out how to add attributes into our data model (that gets sent to response writers) in a generic way.\n\n3> Possibly add a new JIRA for changing the facet response format to be tolerant of sub-fields, but don't do that here.\n\nNot sure how that's possible... it's either more magic field names in with the individual constraints, or the facet response format has got to change. "
        },
        {
            "author": "Erick Erickson",
            "id": "comment-13174441",
            "date": "2011-12-21T21:49:34+0000",
            "content": "First step in resurrecting this. This patch should apply cleanly to trunk. It incorporates the SOLR-2242.patch from 28-June and the NumFacetTermsFacetsTest from 9-July. It accounts for the fact that things seem to have been moved around a bit. All I guarantee is that the code compiles and the NumFacetTermsFacetsTest runs from inside IntelliJ. "
        },
        {
            "author": "Antoine Le Floc'h",
            "id": "comment-13174739",
            "date": "2011-12-22T10:19:24+0000",
            "content": "To help with the specification, my use case is this: I am using this patch and possibly want to add extra infos in the facet results, and want to use sharding... Basically, this is what I have today with the patch:\n\n<lst name=\"shop_id\">\n  <int name=\"numTerms\">10251</int>\n  <lst name=\"counts\">\n    <int name=\"28013756\">7032406</int>\n    <int name=\"28009589\">3616625</int>\n    <int name=\"976\">3497825</int>\n    <int name=\"635\">1398780</int>\n    <int name=\"28021713\">440118</int>\n    <int name=\"29047336\">368921</int>\n    <int name=\"411\">244689</int>\n  </lst>\n</lst>\n\n\nand I want to subclass/modify SimpleFacets to add more data for each item (since I don't see other way to do it) "
        },
        {
            "author": "Erick Erickson",
            "id": "comment-13176065",
            "date": "2011-12-27T02:04:23+0000",
            "content": "Just to be clear. I'm not volunteering to actually implement this patch. I'll gladly guide it through the process if someone wants to work on it and address the concerns raised. And I'll keep prodding it along and try to keep it from dying on the vine, and certainly volunteer to test various incarnations. Or I'll try to kill it if it comes to that.\n\nThere are two open issues really, of which the most pressing seems to be back-compat. Cody's initial suggestion doesn't work with all the various response formats. Working out a way to change the response format without breaking back-compat seems like a worthy goal in itself, but does that mean we need to create another JIRA for that and make this JIRA dependent on the new one? Note that this is the inverse of my original point <3>, I'm suggesting we fix the back-compat issue before we address this one. I have no real clue yet how to approach that mind you.\n\nAgain, I want a clear goal in mind before we put work into any solution. "
        },
        {
            "author": "Antoine Le Floc'h",
            "id": "comment-13178718",
            "date": "2012-01-03T13:06:29+0000",
            "content": "\nPeople who need to be back-compat won't be able to use \n\n &facet.numTerms=true \n\n. Isn't it fair ?\n\nAbout the distribution issue, maybe the distinct counter could be displayed per shard, something like:\n\n<lst name=\"facet_fields\">\n  <lst name=\"shop_id\">\n    <lst name=\"numTerms\"> \n      <int ip=\"192.168.0.100\">58</int>\n      <int ip=\"192.168.0.101\">158</int>\n    </lst>\n    <lst name=\"counts\">\n      <int name=\"28013756\">7032406</int>\n      <int name=\"28009589\">3616625</int>\n      <int name=\"976\">3497825</int>\n      <int name=\"635\">1398780</int>\n      <int name=\"28021713\">440118</int>\n    </lst>\n  </lst>\n</lst>\n\n\nLike this, people who don't use shards are happy, and people who do, can display what makes sense for them, waiting for better in the future. This would allow to move forward with this JIRA. "
        },
        {
            "author": "Cody Young",
            "id": "comment-13183627",
            "date": "2012-01-10T22:00:52+0000",
            "content": "Had another idea that maintains backwards compatibility. We could add a new facet section:\n\n\n \n<lst name=\"facet_fields\">\n  <lst name=\"text\">\n    <int name=\"electronics\">14</int>\n    <int name=\"inc\">8</int>\n    <int name=\"2.0\">5</int>\n    <int name=\"lcd\">5</int>\n    <int name=\"memory\">5</int>\n  </lst>\n</lst>\n<lst name=\"facet_numTerms\">\n   <int name=\"text\">124</int>\n</lst>\n\n\n\nfacet.query, facet.date and facet.range all show up in a different section, what about facet.numTerms.\n\nThat brings up an interesting question actually, we'll want to control this on a per facet field basis, what about something like facet.numTerms=FieldName. That brings it more in line with facet.date and facet.range.\n\nCody "
        },
        {
            "author": "Ethan Gruber",
            "id": "comment-13191185",
            "date": "2012-01-23T14:45:45+0000",
            "content": "+1 for me too.  I have been using this feature for almost a year.  I plan to upgrade to the newest patch/Solr trunk code, but the patch doesn't apply to the current trunk.  Do I have to check out the revision that dates to 12/21/11 to get this to work?\n\nedit: nevermind, the answer is yes.  I had to check out revision 1221500 from Dec. 20. "
        },
        {
            "author": "Antoine Le Floc'h",
            "id": "comment-13218232",
            "date": "2012-02-28T14:45:14+0000",
            "content": "About the distribution issue, it looks like https://issues.apache.org/jira/browse/SOLR-3134 has some similar thinking as my post from 03/Jan/12 : show the info per shard. Even though the counter info cannot be aggregated across shards, knowing what the counter is for each shard would allow each user to use the info as he wants. It would work in single shard too. "
        },
        {
            "author": "Bill Bell",
            "id": "comment-13233181",
            "date": "2012-03-20T04:11:25+0000",
            "content": "Cody,\n\nI love your suggestion. I am actually ready to work on it. \n\n\n<lst name=\"facet_numTerms\">\n   <int name=\"text\">124</int>\n</lst>\n\n\n\nAfter we get it committed we should then fix the shard issues as per SOLR-3134.\n\nWe can also create a new JIRA ticket for that. \n\nEveryone agreed?\n\nI will do it on SOLR 4.0 and back port to 3.5.\n\n "
        },
        {
            "author": "Bill Bell",
            "id": "comment-13233222",
            "date": "2012-03-20T05:29:48+0000",
            "content": "SOLR 4.0 TRUNK version. "
        },
        {
            "author": "Bill Bell",
            "id": "comment-13233224",
            "date": "2012-03-20T05:35:12+0000",
            "content": "How does it work?\n\n\nhttp://localhost:8983/solr/select?q=*:*&facet=true&facet.field=cat&facet.field=price&f.price.facet.numTerms=true&facet.limit=-1&f.cat.facet.numTerms=true&f.price.facet.limit=1\n\n\n\nParameters:\n\nfacet.numTerms or f.<field>.facet.numTerms = true (default is false) - turn on distinct counting of terms\nfacet.field - the field to count the terms\n\nIt creates a new section in the facet section... For example:\n\n\n<lst name=\"facet_counts\">\n  <lst name=\"facet_queries\"/>\n  <lst name=\"facet_fields\">\n    <lst name=\"cat\">\n      <int name=\"camera\">1</int>\n      <int name=\"connector\">2</int>\n      <int name=\"copier\">1</int>\n      <int name=\"currency\">4</int>\n      <int name=\"electronics\">14</int>\n      <int name=\"graphics card\">2</int>\n      <int name=\"hard drive\">2</int>\n      <int name=\"memory\">3</int>\n      <int name=\"monitor\">2</int>\n      <int name=\"multifunction printer\">1</int>\n      <int name=\"music\">1</int>\n      <int name=\"printer\">1</int>\n      <int name=\"scanner\">1</int>\n      <int name=\"search\">2</int>\n      <int name=\"software\">2</int>\n    </lst>\n    <lst name=\"price\">\n      <int name=\"0.0\">3</int>\n    </lst>\n  </lst>\n  <lst name=\"facet_numTerms\">\n    <int name=\"cat\">15</int>\n    <int name=\"price\">14</int>\n  </lst>\n  <lst name=\"facet_dates\"/>\n  <lst name=\"facet_ranges\"/>\n</lst>\n\n\n\n\n\n "
        },
        {
            "author": "Bill Bell",
            "id": "comment-13233232",
            "date": "2012-03-20T05:44:16+0000",
            "content": "See https://issues.apache.org/jira/secure/attachment/12519024/SOLR-2242-solr40.patch for the patch. "
        },
        {
            "author": "Erick Erickson",
            "id": "comment-13233354",
            "date": "2012-03-20T11:20:40+0000",
            "content": "I won't get to this for 3.6 "
        },
        {
            "author": "Antoine Le Floc'h",
            "id": "comment-13233453",
            "date": "2012-03-20T14:44:07+0000",
            "content": "Bill,\n\nJust a thought, how are you going to plug in SOLR-3134 then ?\nSince we are not able to aggregate distinct count over shards, shouldn't you do something like:\n\n<lst name=\"facet_numTerms\">\n  <lst name=\"localhost:7777/solr\">\n    <int name=\"cat\">15</int>\n    <int name=\"price\">14</int>\n  </lst>\n  <lst name=\"localhost:8888/solr\">\n    <int name=\"cat\">3</int>\n    <int name=\"price\">23</int>\n  </lst>\n</lst>\n\n "
        },
        {
            "author": "Bill Bell",
            "id": "comment-13235363",
            "date": "2012-03-22T05:38:05+0000",
            "content": "Added Sharding "
        },
        {
            "author": "Bill Bell",
            "id": "comment-13235365",
            "date": "2012-03-22T05:39:47+0000",
            "content": "I added sharding as discussed by Antoine.\n\n\n<lst name=\"facet_numTerms\">\n<lst name=\"http://localhost:8983/solr\">\n<int name=\"price\">14</int>\n<int name=\"cat\">15</int>\n</lst>\n<lst name=\"http://localhost:8081/solr\">\n<int name=\"price\">23</int>\n<int name=\"cat\">3</int>\n</lst>\n</lst>\n\n\n\nExample call\n\nhttp://localhost:8983/solr/select?shards=localhost:8983/solr,localhost:8081/solr&indent=true&q=*:*&facet=true&facet.mincount=1&facet.numTerms=true&facet.limit=-1&facet.field=price&facet.field=cat\n "
        },
        {
            "author": "Bill Bell",
            "id": "comment-13235366",
            "date": "2012-03-22T05:42:04+0000",
            "content": "https://issues.apache.org/jira/secure/attachment/12519406/SOLR-2242-solr40-2.patch is the latest patch. "
        },
        {
            "author": "Bill Bell",
            "id": "comment-13237775",
            "date": "2012-03-25T04:50:25+0000",
            "content": "Fixed order of facet_numTerms and fixed the getShard call to be consistent with SOLR 3.5\n\nI think this is ready... "
        },
        {
            "author": "Bill Bell",
            "id": "comment-13237777",
            "date": "2012-03-25T04:52:11+0000",
            "content": "PAtch for SOLR 3.5 branch. There is something wrong with branch_3x but this one commits and is on 3.5 \n\nhttp://svn.apache.org/repos/asf/lucene/dev/branches/lucene_solr_3_5\nLast Changed Rev: 1207561 "
        },
        {
            "author": "Erick Erickson",
            "id": "comment-13239434",
            "date": "2012-03-27T13:14:07+0000",
            "content": "This patch applies against the 3.x code line, Bill you might want to check it, I had to do some merging by hand. "
        },
        {
            "author": "Erick Erickson",
            "id": "comment-13239441",
            "date": "2012-03-27T13:19:39+0000",
            "content": "Bill:\n\nTests do not pass on either 3.x or trunk with this patch.\nsome 3.x failures:\n\nant test -Dtestcase=TestDistributedSearch\nant test -Dtestcase=testGroupingGroupedBasedFaceting\nant test -Dtestcase=TestDistributedGrouping\n\nsome 4x failures:\nant test -Dtestcase=BasicDistributedZkTest\nant test -Dtestcase=TestGroupingSearch\n\nI'm not sure whether these are test problems or more serious... "
        },
        {
            "author": "Yonik Seeley",
            "id": "comment-13239544",
            "date": "2012-03-27T15:10:14+0000",
            "content": "There are other JIRA issues open for adding more facet-related data as well, and adding a new section for each doesn't seem desirable.\nI think I'm still in favor of biting the bullet and changing the facet response format for 4.0, while having some sort of flag to enable the older format for back compat. "
        },
        {
            "author": "Bill Bell",
            "id": "comment-13240158",
            "date": "2012-03-28T04:32:29+0000",
            "content": "Yonik agreed.  However what is the alternative. We are talking distinct terms, and unless I limit the number of terms there could be a performance issue on using this with sharding. Since I would need to sent the terms and combine them and look for uniques. I am willing to do that work (not that much coding - more worried about CPU and network performance). The one I submitted does change the format by ADDING a new section. It shouldn't break other facets (usually adding sections to the JSON/XML output should not be a hard break). The latest version does not change the facet_field section so it is compatible.\n\nI am working on getting the tests to work. Most seem trivial fixes and not more serious. Since we changed the format...\n\nHowever, several people would like to use this. If I fix the test cases that are breaking can we consider a commit?\n "
        },
        {
            "author": "Bill Bell",
            "id": "comment-13240225",
            "date": "2012-03-28T06:23:54+0000",
            "content": "I changed the sharing response to check the size and only return the shard name if there is a response.\n\n\n<lst name=\"facet_numTerms\">\n<lst name=\"localhost:8983/solr\"/>\n</lst>\n\nChanged to \n\n<lst name=\"facet_numTerms\"/>\n\n\n\nAlso, the code for field_facets was wrong. It needs to return the name of the field even if the size is 0 or null.\n\nSee latest patch for 3x.\n\n\n "
        },
        {
            "author": "Bill Bell",
            "id": "comment-13240227",
            "date": "2012-03-28T06:26:46+0000",
            "content": "Latest 3x patch is uploaded: SOLR-2242-3x_2.patch "
        },
        {
            "author": "Bill Bell",
            "id": "comment-13240240",
            "date": "2012-03-28T07:01:11+0000",
            "content": "Found a bug and attaching new patch. "
        },
        {
            "author": "Bill Bell",
            "id": "comment-13240249",
            "date": "2012-03-28T07:12:53+0000",
            "content": "Latest 3x patch. SOLR-2242-3x_3.patch "
        },
        {
            "author": "Bill Bell",
            "id": "comment-13240261",
            "date": "2012-03-28T07:29:07+0000",
            "content": "Fixed one of the tests that was failing.\nSOLR-2242-3x_4.patch "
        },
        {
            "author": "Bill Bell",
            "id": "comment-13240270",
            "date": "2012-03-28T07:38:42+0000",
            "content": "All tests pass on branch_3x now. \n "
        },
        {
            "author": "Bill Bell",
            "id": "comment-13244960",
            "date": "2012-04-03T04:19:38+0000",
            "content": "3X version with test cases "
        },
        {
            "author": "Bill Bell",
            "id": "comment-13244961",
            "date": "2012-04-03T04:21:35+0000",
            "content": "Ready for 3x merge. Test with:\n\nant test -Dtestcase=NumFacetTermsFacetsTest "
        },
        {
            "author": "uygar bayar",
            "id": "comment-13257323",
            "date": "2012-04-19T07:15:47+0000",
            "content": "hi \n I tried it 3.6.0 with SOLR-2242-3x_5_tests.patch but it didn't work. Results are grouped but all facets empty.\n\n<lst name=\"facet_counts\">\n<lst name=\"facet_queries\"/>\n<lst name=\"facet_fields\"/>\n<lst name=\"facet_numTerms\"/>\n<lst name=\"facet_dates\"/>\n<lst name=\"facet_ranges\"/>\n\nhttp://x.x.x.x:8985/solr/ar1/select?shards=192.168.200.202:8985/solr/ar3/,192.168.200.202:8985/solr/ar4&q=hotels&group=true&group.field=site&facet=true&f.site.facet.numFacetTerms=1&facet.mincount=1&facet.limit=-1 "
        },
        {
            "author": "Terrance A. Snyder",
            "id": "comment-13275101",
            "date": "2012-05-15T00:49:30+0000",
            "content": "Hello all, new to this group and contributing. Purhaps this is a bad idea, but could we not just extend facet.pivot to drive distinct value counts of fields? Considering facet.pivot already does distinct values (it dumps everything) we can add an option to facet.pivot to return the distinct count (rather than returning every field and value). Not only does this solve the problem for distinct.facets but opens the door to using the facet.pivot option to drive \"distint counts\" multiple levels deep (see use-cases). And solves a problem for those people using facet.pivot to get the current distinct counts as they are now, or those people concerned about total network bandwidth/performance of using facet.pivot.\n\nAttached is a quick patch to facet.pivot to include a new param: \n\nfacet.pivot.distinct=[true|false]\n\nTurn on/off returning distinct counts when using the facet.pivot parameter. By specifying true the facet.pivot command will return the default format, plus an additional \"distinct\" field. The last facet specified in \"facet.pivot\" will never be returned when using facet.pivot.distinct - it will only return the total # of distinct values for that field in the parent node.\n\nUse-Case:\n\nI have a catalog of data which contains logs from a server. I want to organize my view into the logs such that I can pivot the logs by date, time, and then transaction number so that I can show a chart of the # of distinct transactions that occur by day and by hour (market analysis).\n\nI AM NOT interested in the actual \"literal\" values of the transactions, as this is likely to be a very large set of data and provides no business value. Instead, I am only interested in the distinct count of items.\n\nIt is implied that when I specify my pivot that the last item in my pivot will always be returned as the aggregate distinct count and will not return the actual values.\n\nOther use-cases:\n\nAs it stands today, the pivot feature currently does do distinct counts, the only drawback to the consuming applications is that the consuming app must \"count\" the distinct terms. \n\nIf the application doesn't care about the actual values, only the sum of distinct terms than it wastes CPU and network transmitting very large lists of data and iterating through them only to get the total count.\n\nBy allowing a user to specify facet.pivot=field1,field2 along with facet.pivot.distinct=true the user will get all distinct values for all fields. The last field will always return ONLY the distinct count and will not return physical values (thereby saving network / cpu cycles).\n\nNotes:\n\n\n\tDebated between calling the \"distinct\" count either \"distinct\", or \"num_children\", etc. YMMV, I called it distinct, but others can call it what they want\n\n\n\n\n\tNot sure of status of distributed facet.pivot? As it stand the current pivot feature does not work distributed.\n  In order to make this work 'all the time', large amounts of data would need to be shared accross all shards to determine \"distinct\" values?\n\n\n\n\n\tYMMV, but some shards are logically partitioned to ensure no overlap, take for example date or transaction #. If I partitioned my shards by date and I asked for a distinct count, I KNOW implicitly that the distinct count is additive (due to partitioning each shard can never share a transaction id) as such a distributed query could \"assume\" that each shard is an additive distinct and save bandwidth.\n\n\n\nExample 1:\n\nPivot: 2 Fields Deep with Distinct [date,transaction #]\nShows: All Distinct Dates with total # of distinct transactions in that date range\nhttp://localhost:8080/solr/orders/select?q=*:*&facet=true&facet.pivot=order_date_txt,order_tran_nbr&facet.pivot.distinct=true&rows=0\n\n\n \n...\n...\n<lst name=\"facet_pivot\">\n  <arr name=\"order_date_txt,order_tran_nbr\">\n    <lst>\n      <str name=\"field\">order_date_txt</str>\n      <str name=\"value\">2009-11-01</str>\n      <int name=\"distinct\">12566</int>\n    </lst>\n    <lst>\n      <str name=\"field\">order_date_txt</str>\n      <str name=\"value\">2009-11-02</str>\n      <int name=\"distinct\">14804</int>\n    </lst>\n    <lst>\n      <str name=\"field\">order_date_txt</str>\n      <str name=\"value\">2009-11-03</str>\n      <int name=\"distinct\">15940</int>\n    </lst>\n    <lst>\n      <str name=\"field\">order_date_txt</str>\n      <str name=\"value\">2009-11-04</str>\n      <int name=\"distinct\">15540</int>\n    </lst>\n    <lst>\n      <str name=\"field\">order_date_txt</str>\n      <str name=\"value\">2009-11-05</str>\n      <int name=\"distinct\">15656</int>\n    </lst>\n    <lst>\n      <str name=\"field\">order_date_txt</str>\n      <str name=\"value\">2009-11-06</str>\n      <int name=\"distinct\">15378</int>\n    </lst>\n    <lst>\n      <str name=\"field\">order_date_txt</str>\n      <str name=\"value\">2009-11-07</str>\n      <int name=\"distinct\">13551</int>\n    </lst>\n  </arr>\n</lst>\n...\n...\n\n \n\nExample 2:\n\nPivot: 3 Fields Deep with Distinct [date,city,transactions]\nShows: All Distinct Dates, All Distinct Citys, total distinct orders in that time within any city named \"ANAH*\"\nhttp://localhost:8080/solr/orders/select?q=*:*&facet=true&facet.pivot=order_date_txt,store_city_nm,order_tran_nbr&facet.pivot.distinct=true&rows=0&fq=store_city_nm:ANAH*\n\n\n...\n...\n<?xml version=\"1.0\"?>\n<lst name=\"facet_pivot\">\n  <arr name=\"order_date_txt,store_city_nm,order_tran_nbr\">\n    <lst>\n      <str name=\"field\">order_date_txt</str>\n      <str name=\"value\">2009-11-01</str>\n      <int name=\"distinct\">1</int>\n      <arr name=\"pivot\">\n        <lst>\n          <str name=\"field\">store_city_nm</str>\n          <str name=\"value\">ANAHEIM</str>\n          <int name=\"distinct\">189</int>\n        </lst>\n      </arr>\n    </lst>\n    <lst>\n      <str name=\"field\">order_date_txt</str>\n      <str name=\"value\">2009-11-02</str>\n      <int name=\"distinct\">1</int>\n      <arr name=\"pivot\">\n        <lst>\n          <str name=\"field\">store_city_nm</str>\n          <str name=\"value\">ANAHEIM</str>\n          <int name=\"distinct\">212</int>\n        </lst>\n      </arr>\n    </lst>\n    <lst>\n      <str name=\"field\">order_date_txt</str>\n      <str name=\"value\">2009-11-03</str>\n      <int name=\"distinct\">1</int>\n      <arr name=\"pivot\">\n        <lst>\n          <str name=\"field\">store_city_nm</str>\n          <str name=\"value\">ANAHEIM</str>\n          <int name=\"distinct\">203</int>\n        </lst>\n      </arr>\n    </lst>\n    <lst>\n      <str name=\"field\">order_date_txt</str>\n      <str name=\"value\">2009-11-04</str>\n      <int name=\"distinct\">1</int>\n      <arr name=\"pivot\">\n        <lst>\n          <str name=\"field\">store_city_nm</str>\n          <str name=\"value\">ANAHEIM</str>\n          <int name=\"distinct\">180</int>\n        </lst>\n      </arr>\n    </lst>\n    <lst>\n      <str name=\"field\">order_date_txt</str>\n      <str name=\"value\">2009-11-05</str>\n      <int name=\"distinct\">1</int>\n      <arr name=\"pivot\">\n        <lst>\n          <str name=\"field\">store_city_nm</str>\n          <str name=\"value\">ANAHEIM</str>\n          <int name=\"distinct\">252</int>\n        </lst>\n      </arr>\n    </lst>\n    <lst>\n      <str name=\"field\">order_date_txt</str>\n      <str name=\"value\">2009-11-06</str>\n      <int name=\"distinct\">1</int>\n      <arr name=\"pivot\">\n        <lst>\n          <str name=\"field\">store_city_nm</str>\n          <str name=\"value\">ANAHEIM</str>\n          <int name=\"distinct\">199</int>\n        </lst>\n      </arr>\n    </lst>\n    <lst>\n      <str name=\"field\">order_date_txt</str>\n      <str name=\"value\">2009-11-07</str>\n      <int name=\"distinct\">1</int>\n      <arr name=\"pivot\">\n        <lst>\n          <str name=\"field\">store_city_nm</str>\n          <str name=\"value\">ANAHEIM</str>\n          <int name=\"distinct\">110</int>\n        </lst>\n      </arr>\n    </lst>\n  </arr>\n</lst>\n...\n...\n\n \n\nRight now I can't make an attachment, but I posted it to my s3 account.\n\nhttps://s3.amazonaws.com/behemoth.io/distinct.pivot.patch "
        },
        {
            "author": "Jason Rutherglen",
            "id": "comment-13291803",
            "date": "2012-06-08T14:34:31+0000",
            "content": "Terrance, can you post a patch to the Jira?  It makes sense to start this Jira off non-distributed, and add a distributed version in another Jira issue... "
        },
        {
            "author": "Hoss Man",
            "id": "comment-13412084",
            "date": "2012-07-11T22:25:57+0000",
            "content": "bulk fixing the version info for 4.0-ALPHA and 4.0 all affected issues have \"hoss20120711-bulk-40-change\" in comment "
        },
        {
            "author": "Robert Muir",
            "id": "comment-13429781",
            "date": "2012-08-07T03:42:58+0000",
            "content": "rmuir20120906-bulk-40-change "
        },
        {
            "author": "Robert Muir",
            "id": "comment-13452206",
            "date": "2012-09-10T17:41:58+0000",
            "content": "moving all 4.0 issues not touched in a month to 4.1 "
        },
        {
            "author": "Bill Bell",
            "id": "comment-13495020",
            "date": "2012-11-11T22:29:23+0000",
            "content": "uygar,\n\nYou are not using it properly. SOLR-2242-3x_5_tests.patch  does indeed work.\n\nhttp://x.x.x.x:8985/solr/ar1/select?shards=192.168.200.202:8985/solr/ar3/,192.168.200.202:8985/solr/ar4&q=hotels&group=true&group.field=site&facet=true&f.site.facet.numFacetTerms=1&facet.mincount=1&facet.limit=-1\n\nYou forgot the facet.field=site and the field is f.site.facet.numTerms=true\n\nWith sample data. Do the following.\n\nCopy example to example2, and change jetty.xml on example2 to be port 8080.\n\nRun this:\n\nhttp://localhost:8983/solr/select?shards=localhost:8983/solr/,localhost:8080/solr/&q=*:*&rows=0&facet=true&facet.field=price&facet.numTerms=true&facet.mincount=1&facet.limit=-1\n "
        },
        {
            "author": "Amber Duque",
            "id": "comment-13507488",
            "date": "2012-11-30T17:45:20+0000",
            "content": "I have a question on the SOLR-2242-solr40-3.patch.\nI have applied this patch on top of the Solr 4.0 release (http://svn.apache.org/repos/asf/lucene/dev/tags/ - lucene_solr_4_0_0).\nThe patch builds fine, but several solr unit tests fail:\n\nTests with failures:\n\n\torg.apache.solr.request.TestFaceting.testFacets\n\torg.apache.solr.request.TestFaceting.testRegularBig\n\torg.apache.solr.cloud.BasicDistributedZkTest.testDistribSearch\n\torg.apache.solr.TestDistributedSearch.testDistribSearch\n\torg.apache.solr.TestDistributedGrouping.testDistribSearch\n\torg.apache.solr.request.SimpleFacetsTest (suite)\n\torg.apache.solr.TestGroupingSearch.testRandomGrouping\n\torg.apache.solr.TestGroupingSearch.testGroupingGroupedBasedFaceting\n\torg.apache.solr.cloud.BasicDistributedZk2Test.testDistribSearch\n\n\n\nDo the unit tests pass successfully for anyone (for this patch applied on top of the solr 4.0 release)?\n\nThanks! "
        },
        {
            "author": "J Mohamed Zahoor",
            "id": "comment-13570063",
            "date": "2013-02-04T08:29:30+0000",
            "content": "Does the patch provide distinct counts in the case of multiple shards? "
        },
        {
            "author": "Bill Bell",
            "id": "comment-13644287",
            "date": "2013-04-29T05:48:34+0000",
            "content": "Yeah. This issue has stalled. To get it ready for release we just need to apply the patch and run all unit tests. \n\nIssues tend to stall when we don't have a commiter leading the work to get done. If someone will step up I will commit to do the work. the last time I made a push for this there was several approaches:\n\n1. Change the facet formats (Yonik)\n2. Change the parameter names and hide the fact that we are looping through all (limit=-1).\n3. Try to get the sharding working. Although I would contend that we can release without sharding and add it later. Sharding - we can send the unique terms and combine to get exact numbers, or we can separate and send (as it is now). The former is much harder to do and could cause perf issues.\n\nThoughts? Maybe at the Lucene conference this can be discussed? "
        },
        {
            "author": "Yago Riveiro",
            "id": "comment-13644329",
            "date": "2013-04-29T07:52:03+0000",
            "content": "It is unfortunate that this feature is stalled. With sharding this feature is killer, I've been waiting for it since that I know that is in progress.\n "
        },
        {
            "author": "J Mohamed Zahoor",
            "id": "comment-13645265",
            "date": "2013-04-30T05:21:10+0000",
            "content": "+1 for this feature with sharding support.... its a killer really... "
        },
        {
            "author": "Shawn Heisey",
            "id": "comment-13690500",
            "date": "2013-06-21T17:34:49+0000",
            "content": "Bill Bell Yago Riveiro:\n\nI am having a hard time understanding what this feature actually DOES, in concrete terms.  That's my failing, the info is probably in the description and comments, it's just not sinking in.\n\nI am willing to pursue this to the best of my ability, but I will admit in advance that my ability may not be quite enough.  I'm new to the committer role, which means that I don't work very fast and I'm still learning the ropes.  I think I can commit it and backport to 4.x if the following criteria are met:\n\n*) We can get the feature to apply to trunk and consistently pass tests (not counting what's failing due to other problems).\n*) There are new tests for all new functionality.\n*) We put it up for review by other committers, particularly Robert Muir and Yonik Seeley, and there are no negative votes. "
        },
        {
            "author": "J Mohamed Zahoor",
            "id": "comment-13691078",
            "date": "2013-06-22T08:04:24+0000",
            "content": "One way to achieve this in distributed environment is to have some approximation techniques like HyperLogLog. "
        },
        {
            "author": "Jonathan Rochkind",
            "id": "comment-13692002",
            "date": "2013-06-24T14:14:17+0000",
            "content": "Shawn Heisey:  Forgive me if I'm misunderstanding what you don't understand, but, here's what this feature does, at the high level:\n\nYou can ask Solr for facet response already. You get, for instance, the first 10 (or first `facet.limit`) facet values, sorted by your chosen sort criteria. You can, already, then choose to page through all the facet values, using facet.offset combined with facet.limit. \n\nYou can page through them, but you don't know how long you'll be paging for \u2013 at some point your request with a given facet.offset will just stop returning results because you've exhausted all the facet values available. But you have no way to know when that will be until you get there. There is no way to get the total number of facet results available. \n\nThis feature is meant to add that, a way to get in the response the count of the total number of unique facet values, the ones you'd be paging through with facet.offset. \n\nApparently what makes it tricky to implement is the distributed environment?  \n\nSome of the language used in this ticket to refer to the feature is indeed confusing IMO. I hope this helps.  "
        },
        {
            "author": "Shawn Heisey",
            "id": "comment-13692023",
            "date": "2013-06-24T14:28:37+0000",
            "content": "That will indeed help as I find time to look things over. Thanks! "
        },
        {
            "author": "Robert Muir",
            "id": "comment-13692043",
            "date": "2013-06-24T14:36:37+0000",
            "content": "\nApparently what makes it tricky to implement is the distributed environment? \n\nbecause you have to merge all the values to get the unique count. "
        },
        {
            "author": "Shawn Heisey",
            "id": "comment-13692154",
            "date": "2013-06-24T17:17:41+0000",
            "content": "Which patch represents the best work?  I got SOLR-2242-solr40-3.patch to apply to trunk with a little love, but tests having to do with facets are failing.  It is also quite a bit smaller than the newest patch for 3x. "
        },
        {
            "author": "Otis Gospodnetic",
            "id": "comment-13697431",
            "date": "2013-07-02T02:35:16+0000",
            "content": "This issue looks very interesting and it looks like it's >2 years old with Bill Bell having moved on, most likely.\nBased on my reading of the last 2 years worth of comments above, Terrance A. Snyder's comment (see https://issues.apache.org/jira/browse/SOLR-2242?focusedCommentId=13275101&page=com.atlassian.jira.plugin.system.issuetabpanels:comment-tabpanel#comment-13275101) seemed the most thorough and his idea the most advanced. He posted a patch to S3.... which is no longer there. \n\nI'll email Terrance now in hopes of getting his patch attached here, but it would be great if somebody with more knowledge of faceting/pivot area of Solr could push this.  I saw Yonik Seeley did look at this issue a while back...\n "
        },
        {
            "author": "Terrance A. Snyder",
            "id": "comment-13697454",
            "date": "2013-07-02T03:11:14+0000",
            "content": "Otis Gospodnetic I got the email - I'll give some background as we've enhanced and combined but I should be able to put together a patch in the following week. There is an old version on github I need to update to trunk I'll spend time doing this, most of this work was enhancing two existing JIRA items which are wonderful.\n\nCore Work:\nhttps://issues.apache.org/jira/browse/SOLR-2894\nhttps://issues.apache.org/jira/browse/SOLR-3583\n\nNewer features:\n\n+ Some of the issues that have been discussed around distributed counting has already been done in larger installations (counting billions of items). I work in the advertising space and counting/slicing dicing things and sending between shards 90+ billion documents on highly unique facet counts such as session id, or cookie ID is hugely wasteful and doesn't scale.\n\n+ The Ad industry is great at counting stuff \"at scale\" - sessions, web events, etc. We take the stance that counting stuff can be \"roughly\" right when we get to billions + or - 0-1.5% error rate is OK when the response goes from minutes to milliseconds. As such, optional parameters for \"estimated count\" is added which will leverage a HyperLogLog implementation to do a 98.5% correct response. By default this is turned on for us - on a large installation (multiple billions of POS transactions)\n\nHyperLogLog\n\nhttp://highscalability.com/blog/2012/4/5/big-data-counting-how-to-count-a-billion-distinct-objects-us.html\nhttp://blog.aggregateknowledge.com/2012/10/25/sketch-of-the-day-hyperloglog-cornerstone-of-a-big-data-infrastructure/\nhttp://metamarkets.com/2012/fast-cheap-and-98-right-cardinality-estimation-for-big-data/\n\nSyntax\n\n../select/?q=:&facet=true&facet.pivot=impression_date,state_name,consumer_id&facet.distinct.estimate=true\n\nAgain - estimate is used as there might be 300 million uniques here (consumer_id) and sharding to 10 servers results in a huge waste of time - when we're that high of a number 98% right is good enough. As we narrow down we can throttle to 100% correct by doing \"facet.distinct.estimate=false\".\n\nWe still use \"pivot\" to drive this as the patch for distributed works - we simply send around HyperLogLog instances in serialized form and they can be unioned and intersected appropriately.\n\nQuestions as I'd like to actually do this right\n\n+ Rather than re-invent the wheel I use stream-lib (https://github.com/clearspring/stream-lib). It is apache licensed and includes HyperLogLog, HyperLogLogPlus, BloomFilters, TopK, QDigest, etc. Is this an issue?\n\n+ Test cases - I've got 82% code coverage - is this good enough?\n\n+ Documentation - I've got markdown documents that cover the commands and syntax - is this the right format?\n\n+ SOLR-2894, SOLR-3583 - It makes logical sense that these start to be joined together. When using all these I sometimes start smelling solr as an analytic engine (and it's a very nice one when combining probabilistic data structures).\n\nIf someone can answer the above questions while I sync to /trunk please let me know.\n\nOld Version for posterity until I get around to updating to latest trunk and including the HyperLogLog implementation - doesn't include HyperLogLog sketching - minor updates.\nhttps://github.com/terrancesnyder/solr-analytics/blob/master/solr/core/src/java/org/apache/solr/handler/component/PivotFacetHelper.java "
        },
        {
            "author": "J Mohamed Zahoor",
            "id": "comment-13697475",
            "date": "2013-07-02T03:48:38+0000",
            "content": "As i mentioned in my earlier comment, We have experimented with stream-lib implementation of HLL for similar purpose... and it is good.\nIt makes good sense to have probabilistic data structures for large number of docs.\nBTW, we are using SOLR as a analytics engine with great success. "
        },
        {
            "author": "Otis Gospodnetic",
            "id": "comment-13697485",
            "date": "2013-07-02T03:59:23+0000",
            "content": "Terrance A. Snyder - you're quick. \nAnswers:\n\n\tstream-lib and license - perfectly fine. At Sematext we use their stuff as well.\n\t82% test case coverage - good!\n\tdocumentation - eventually it should be put on the Solr Wiki, but don't let that stop you!\n\tsmell - precisely!\n\n "
        },
        {
            "author": "Bill Bell",
            "id": "comment-13701761",
            "date": "2013-07-08T04:30:14+0000",
            "content": "The one use case (2 parts) that I want to make sure we are satisfying is:\n\n. Ability to get total number of distinct terms in the facet.field.\n  For example, if facet.field=gender, I would expect the distinct to be 1 or 2 (Male/Female) depending on filters.\n. For Sharding, Terrance might be the right approach, but is it accurate or an approximation? For small sets sharding will work fine (< 100 results). For example, if you were asking for distinct counts from 2 shards, and the shards were setup for 20 states in one shard, and 30 in the other, I would expect distinct states = 50. Will your solution do that?\n\nThanks - so happy this is moving forward. Not sure I understand the syntax from Terrance yet...  "
        },
        {
            "author": "Steve Rowe",
            "id": "comment-13717105",
            "date": "2013-07-23T18:47:08+0000",
            "content": "Bulk move 4.4 issues to 4.5 and 5.0 "
        },
        {
            "author": "Vassil Velichkov",
            "id": "comment-13883528",
            "date": "2014-01-27T23:41:40+0000",
            "content": "I really hope that this issue will be resolved in SOLR 4.7...Fingers crossed  "
        },
        {
            "author": "Shalin Shekhar Mangar",
            "id": "comment-13911260",
            "date": "2014-02-25T05:26:30+0000",
            "content": "I think this is possible now with SOLR-5428 - StatsComponent can count distinct values of a field with stats.calcDistinct=true parameter. "
        },
        {
            "author": "Jonathan Rochkind",
            "id": "comment-13911263",
            "date": "2014-02-25T05:29:22+0000",
            "content": "I am out of the office on vacation until Wednesday February 26, 2014. I will not be checking email.\n\nFor urgent Systems Department business, please contact Mercy Anaba, manaba@jhu.edu,        (410) 516-5306. "
        },
        {
            "author": "Brett Hoerner",
            "id": "comment-13911606",
            "date": "2014-02-25T14:26:46+0000",
            "content": "Shalin Shekhar Mangar, this ticket took a turn towards approximate counts using probabilistic data structures (specifically HyperLogLog). That's to support fast approximate unique counts in systems like SolrCloud where each shard could have hundreds of millions of unique values. It sounds like stats.calcDistinct=true does the \"correct, but slow\" thing? "
        },
        {
            "author": "Shalin Shekhar Mangar",
            "id": "comment-13911611",
            "date": "2014-02-25T14:34:05+0000",
            "content": "It sounds like stats.calcDistinct=true does the \"correct, but slow\" thing?\n\nYes, that is why I did not close the ticket.\n\nthis ticket took a turn towards approximate counts using probabilistic data structures (specifically HyperLogLog). That's to support fast approximate unique counts in systems like SolrCloud where each shard could have hundreds of millions of unique values.\n\nDo you know what is the state of this patch? Are people using the hyperloglog implementation in production? Apart from a committer's attention, what does this issue need? "
        },
        {
            "author": "Brett Hoerner",
            "id": "comment-13911796",
            "date": "2014-02-25T17:56:54+0000",
            "content": "There is no public patch that I know of that does the HyperLogLog stuff. Terrance A. Snyder mentioned it in his comment above, but that's it.\n\nI haven't started any work here yet but I hoped to in the future. "
        },
        {
            "author": "Uwe Schindler",
            "id": "comment-13971158",
            "date": "2014-04-16T12:57:19+0000",
            "content": "Move issue to Solr 4.9. "
        },
        {
            "author": "Gregory Chanan",
            "id": "comment-14355860",
            "date": "2015-03-10T22:38:19+0000",
            "content": "should we update the version to something unreleased?  I'm not sure what the most appropriate version is. "
        },
        {
            "author": "Shalin Shekhar Mangar",
            "id": "comment-14580945",
            "date": "2015-06-10T18:50:35+0000",
            "content": "I think this can be closed now that SOLR-6968 has added support for fast approximate cardinality estimation. "
        },
        {
            "author": "Shalin Shekhar Mangar",
            "id": "comment-14609561",
            "date": "2015-07-01T05:00:11+0000",
            "content": "Marking as duplicate of SOLR-6968 "
        }
    ]
}