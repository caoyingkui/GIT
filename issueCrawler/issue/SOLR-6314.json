{
    "id": "SOLR-6314",
    "title": "Facet counts duplicated in the response if specified more than once on the request.",
    "details": {
        "affect_versions": "6.0",
        "status": "Resolved",
        "fix_versions": [
            "4.10",
            "6.0"
        ],
        "components": [
            "SearchComponents - other",
            "SolrCloud"
        ],
        "type": "Bug",
        "priority": "Minor",
        "labels": "",
        "resolution": "Fixed"
    },
    "description": "I am trying to work with multi-threaded faceting on SolrCloud and in the process i was hit by some issues.\n\nI am currently running the below upstream test on different SolrCloud configurations and i am getting a different result set per configuration.\nhttps://github.com/apache/lucene-solr/blob/trunk/solr/core/src/test/org/apache/solr/request/TestFaceting.java#L654\n\nSetup:\n\n\tIndexed 50 docs into SolrCloud.\n\n\n\n\n\tIf the SolrCloud has only 1 shard, the facet field query has the below output (which matches with the expected upstream test output - # facet fields ~ 50).\n\n\n\n\n$ curl  \"http://localhost:8983/solr/collection1/select?facet=true&fl=id&indent=true&q=id%3A*&facet.limit=-1&facet.threads=1000&facet.field=f0_ws&facet.field=f0_ws&facet.field=f0_ws&facet.field=f0_ws&facet.field=f0_ws&facet.field=f1_ws&facet.field=f1_ws&facet.field=f1_ws&facet.field=f1_ws&facet.field=f1_ws&facet.field=f2_ws&facet.field=f2_ws&facet.field=f2_ws&facet.field=f2_ws&facet.field=f2_ws&facet.field=f3_ws&facet.field=f3_ws&facet.field=f3_ws&facet.field=f3_ws&facet.field=f3_ws&facet.field=f4_ws&facet.field=f4_ws&facet.field=f4_ws&facet.field=f4_ws&facet.field=f4_ws&facet.field=f5_ws&facet.field=f5_ws&facet.field=f5_ws&facet.field=f5_ws&facet.field=f5_ws&facet.field=f6_ws&facet.field=f6_ws&facet.field=f6_ws&facet.field=f6_ws&facet.field=f6_ws&facet.field=f7_ws&facet.field=f7_ws&facet.field=f7_ws&facet.field=f7_ws&facet.field=f7_ws&facet.field=f8_ws&facet.field=f8_ws&facet.field=f8_ws&facet.field=f8_ws&facet.field=f8_ws&facet.field=f9_ws&facet.field=f9_ws&facet.field=f9_ws&facet.field=f9_ws&facet.field=f9_ws&rows=1&wt=xml\"\n\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<response>\n<lst name=\"responseHeader\">\n  <int name=\"status\">0</int>\n  <int name=\"QTime\">21</int>\n  <lst name=\"params\">\n    <str name=\"facet\">true</str>\n    <str name=\"fl\">id</str>\n    <str name=\"indent\">true</str>\n    <str name=\"q\">id:*</str>\n    <str name=\"facet.limit\">-1</str>\n    <str name=\"facet.threads\">1000</str>\n    <arr name=\"facet.field\">\n      <str>f0_ws</str>\n      <str>f0_ws</str>\n      <str>f0_ws</str>\n      <str>f0_ws</str>\n      <str>f0_ws</str>\n      <str>f1_ws</str>\n      <str>f1_ws</str>\n      <str>f1_ws</str>\n      <str>f1_ws</str>\n      <str>f1_ws</str>\n      <str>f2_ws</str>\n      <str>f2_ws</str>\n      <str>f2_ws</str>\n      <str>f2_ws</str>\n      <str>f2_ws</str>\n      <str>f3_ws</str>\n      <str>f3_ws</str>\n      <str>f3_ws</str>\n      <str>f3_ws</str>\n      <str>f3_ws</str>\n      <str>f4_ws</str>\n      <str>f4_ws</str>\n      <str>f4_ws</str>\n      <str>f4_ws</str>\n      <str>f4_ws</str>\n      <str>f5_ws</str>\n      <str>f5_ws</str>\n      <str>f5_ws</str>\n      <str>f5_ws</str>\n      <str>f5_ws</str>\n      <str>f6_ws</str>\n      <str>f6_ws</str>\n      <str>f6_ws</str>\n      <str>f6_ws</str>\n      <str>f6_ws</str>\n      <str>f7_ws</str>\n      <str>f7_ws</str>\n      <str>f7_ws</str>\n      <str>f7_ws</str>\n      <str>f7_ws</str>\n      <str>f8_ws</str>\n      <str>f8_ws</str>\n      <str>f8_ws</str>\n      <str>f8_ws</str>\n      <str>f8_ws</str>\n      <str>f9_ws</str>\n      <str>f9_ws</str>\n      <str>f9_ws</str>\n      <str>f9_ws</str>\n      <str>f9_ws</str>\n    </arr>\n    <str name=\"wt\">xml</str>\n    <str name=\"rows\">1</str>\n  </lst>\n</lst>\n<result name=\"response\" numFound=\"50\" start=\"0\">\n  <doc>\n    <float name=\"id\">0.0</float></doc>\n</result>\n<lst name=\"facet_counts\">\n  <lst name=\"facet_queries\"/>\n  <lst name=\"facet_fields\">\n    <lst name=\"f0_ws\">\n      <int name=\"zero_1\">25</int>\n      <int name=\"zero_2\">25</int>\n    </lst>\n    <lst name=\"f0_ws\">\n      <int name=\"zero_1\">25</int>\n      <int name=\"zero_2\">25</int>\n    </lst>\n    <lst name=\"f0_ws\">\n      <int name=\"zero_1\">25</int>\n      <int name=\"zero_2\">25</int>\n    </lst>\n    <lst name=\"f0_ws\">\n      <int name=\"zero_1\">25</int>\n      <int name=\"zero_2\">25</int>\n    </lst>\n    <lst name=\"f0_ws\">\n      <int name=\"zero_1\">25</int>\n      <int name=\"zero_2\">25</int>\n    </lst>\n    <lst name=\"f1_ws\">\n      <int name=\"one_1\">33</int>\n      <int name=\"one_3\">17</int>\n    </lst>\n    <lst name=\"f1_ws\">\n      <int name=\"one_1\">33</int>\n      <int name=\"one_3\">17</int>\n    </lst>\n    <lst name=\"f1_ws\">\n      <int name=\"one_1\">33</int>\n      <int name=\"one_3\">17</int>\n    </lst>\n    <lst name=\"f1_ws\">\n      <int name=\"one_1\">33</int>\n      <int name=\"one_3\">17</int>\n    </lst>\n    <lst name=\"f1_ws\">\n      <int name=\"one_1\">33</int>\n      <int name=\"one_3\">17</int>\n    </lst>\n    <lst name=\"f2_ws\">\n      <int name=\"two_1\">37</int>\n      <int name=\"two_4\">13</int>\n    </lst>\n    <lst name=\"f2_ws\">\n      <int name=\"two_1\">37</int>\n      <int name=\"two_4\">13</int>\n    </lst>\n    <lst name=\"f2_ws\">\n      <int name=\"two_1\">37</int>\n      <int name=\"two_4\">13</int>\n    </lst>\n    <lst name=\"f2_ws\">\n      <int name=\"two_1\">37</int>\n      <int name=\"two_4\">13</int>\n    </lst>\n    <lst name=\"f2_ws\">\n      <int name=\"two_1\">37</int>\n      <int name=\"two_4\">13</int>\n    </lst>\n    <lst name=\"f3_ws\">\n      <int name=\"three_1\">40</int>\n      <int name=\"three_5\">10</int>\n    </lst>\n\n    <lst name=\"f3_ws\">\n      <int name=\"three_1\">40</int>\n      <int name=\"three_5\">10</int>\n    </lst>\n    <lst name=\"f3_ws\">\n      <int name=\"three_1\">40</int>\n      <int name=\"three_5\">10</int>\n    </lst>\n    <lst name=\"f3_ws\">\n      <int name=\"three_1\">40</int>\n      <int name=\"three_5\">10</int>\n    </lst>\n    <lst name=\"f3_ws\">\n      <int name=\"three_1\">40</int>\n      <int name=\"three_5\">10</int>\n    </lst>\n    <lst name=\"f4_ws\">\n      <int name=\"four_1\">41</int>\n      <int name=\"four_6\">9</int>\n    </lst>\n    <lst name=\"f4_ws\">\n      <int name=\"four_1\">41</int>\n      <int name=\"four_6\">9</int>\n    </lst>\n    <lst name=\"f4_ws\">\n      <int name=\"four_1\">41</int>\n      <int name=\"four_6\">9</int>\n    </lst>\n    <lst name=\"f4_ws\">\n      <int name=\"four_1\">41</int>\n      <int name=\"four_6\">9</int>\n    </lst>\n    <lst name=\"f4_ws\">\n      <int name=\"four_1\">41</int>\n      <int name=\"four_6\">9</int>\n    </lst>\n    <lst name=\"f5_ws\">\n      <int name=\"five_1\">42</int>\n      <int name=\"five_7\">8</int>\n    </lst>\n    <lst name=\"f5_ws\">\n      <int name=\"five_1\">42</int>\n      <int name=\"five_7\">8</int>\n    </lst>\n    <lst name=\"f5_ws\">\n      <int name=\"five_1\">42</int>\n      <int name=\"five_7\">8</int>\n    </lst>\n    <lst name=\"f5_ws\">\n      <int name=\"five_1\">42</int>\n      <int name=\"five_7\">8</int>\n    </lst>\n    <lst name=\"f5_ws\">\n      <int name=\"five_1\">42</int>\n      <int name=\"five_7\">8</int>\n    </lst>\n    <lst name=\"f6_ws\">\n      <int name=\"six_1\">43</int>\n      <int name=\"six_8\">7</int>\n\n    </lst>\n    <lst name=\"f6_ws\">\n      <int name=\"six_1\">43</int>\n      <int name=\"six_8\">7</int>\n    </lst>\n    <lst name=\"f6_ws\">\n      <int name=\"six_1\">43</int>\n      <int name=\"six_8\">7</int>\n    </lst>\n    <lst name=\"f6_ws\">\n      <int name=\"six_1\">43</int>\n      <int name=\"six_8\">7</int>\n    </lst>\n    <lst name=\"f6_ws\">\n      <int name=\"six_1\">43</int>\n      <int name=\"six_8\">7</int>\n    </lst>\n    <lst name=\"f7_ws\">\n      <int name=\"seven_1\">44</int>\n      <int name=\"seven_9\">6</int>\n    </lst>\n    <lst name=\"f7_ws\">\n      <int name=\"seven_1\">44</int>\n      <int name=\"seven_9\">6</int>\n    </lst>\n    <lst name=\"f7_ws\">\n      <int name=\"seven_1\">44</int>\n      <int name=\"seven_9\">6</int>\n    </lst>\n    <lst name=\"f7_ws\">\n      <int name=\"seven_1\">44</int>\n      <int name=\"seven_9\">6</int>\n    </lst>\n    <lst name=\"f7_ws\">\n      <int name=\"seven_1\">44</int>\n      <int name=\"seven_9\">6</int>\n    </lst>\n    <lst name=\"f8_ws\">\n      <int name=\"eight_1\">45</int>\n      <int name=\"eight_10\">5</int>\n    </lst>\n    <lst name=\"f8_ws\">\n      <int name=\"eight_1\">45</int>\n      <int name=\"eight_10\">5</int>\n    </lst>\n    <lst name=\"f8_ws\">\n      <int name=\"eight_1\">45</int>\n      <int name=\"eight_10\">5</int>\n    </lst>\n    <lst name=\"f8_ws\">\n      <int name=\"eight_1\">45</int>\n      <int name=\"eight_10\">5</int>\n    </lst>\n    <lst name=\"f8_ws\">\n      <int name=\"eight_1\">45</int>\n      <int name=\"eight_10\">5</int>\n    </lst>\n    <lst name=\"f9_ws\">\n      <int name=\"nine_1\">45</int>\n      <int name=\"nine_11\">5</int>\n    </lst>\n    <lst name=\"f9_ws\">\n      <int name=\"nine_1\">45</int>\n      <int name=\"nine_11\">5</int>\n    </lst>\n\n    <lst name=\"f9_ws\">\n      <int name=\"nine_1\">45</int>\n      <int name=\"nine_11\">5</int>\n    </lst>\n    <lst name=\"f9_ws\">\n      <int name=\"nine_1\">45</int>\n      <int name=\"nine_11\">5</int>\n    </lst>\n    <lst name=\"f9_ws\">\n      <int name=\"nine_1\">45</int>\n      <int name=\"nine_11\">5</int>\n    </lst>\n  </lst>\n  <lst name=\"facet_dates\"/>\n  <lst name=\"facet_ranges\"/>\n</lst>\n</response> \n\n\n\n\n\n\tNow, if a create a new collection with 2 shards (>1 shard SolrCloud), the same above query results in a different output. (# facet fields ~ 10 ;  Expected 50)\n\n\n\n\n$ curl  \"http://localhost:8983/solr/collection1/select?facet=true&fl=id&indent=true&q=id%3A*&facet.limit=-1&facet.threads=1000&facet.field=f0_ws&facet.field=f0_ws&facet.field=f0_ws&facet.field=f0_ws&facet.field=f0_ws&facet.field=f1_ws&facet.field=f1_ws&facet.field=f1_ws&facet.field=f1_ws&facet.field=f1_ws&facet.field=f2_ws&facet.field=f2_ws&facet.field=f2_ws&facet.field=f2_ws&facet.field=f2_ws&facet.field=f3_ws&facet.field=f3_ws&facet.field=f3_ws&facet.field=f3_ws&facet.field=f3_ws&facet.field=f4_ws&facet.field=f4_ws&facet.field=f4_ws&facet.field=f4_ws&facet.field=f4_ws&facet.field=f5_ws&facet.field=f5_ws&facet.field=f5_ws&facet.field=f5_ws&facet.field=f5_ws&facet.field=f6_ws&facet.field=f6_ws&facet.field=f6_ws&facet.field=f6_ws&facet.field=f6_ws&facet.field=f7_ws&facet.field=f7_ws&facet.field=f7_ws&facet.field=f7_ws&facet.field=f7_ws&facet.field=f8_ws&facet.field=f8_ws&facet.field=f8_ws&facet.field=f8_ws&facet.field=f8_ws&facet.field=f9_ws&facet.field=f9_ws&facet.field=f9_ws&facet.field=f9_ws&facet.field=f9_ws&rows=1&wt=xml\"\n \n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<response>\n<lst name=\"responseHeader\">\n  <int name=\"status\">0</int>\n  <int name=\"QTime\">31</int>\n  <lst name=\"params\">\n    <str name=\"facet\">true</str>\n    <str name=\"fl\">id</str>\n    <str name=\"indent\">true</str>\n    <str name=\"q\">id:*</str>\n    <str name=\"facet.limit\">-1</str>\n    <str name=\"facet.threads\">1000</str>\n    <arr name=\"facet.field\">\n      <str>f0_ws</str>\n      <str>f0_ws</str>\n      <str>f0_ws</str>\n      <str>f0_ws</str>\n      <str>f0_ws</str>\n      <str>f1_ws</str>\n      <str>f1_ws</str>\n      <str>f1_ws</str>\n      <str>f1_ws</str>\n      <str>f1_ws</str>\n      <str>f2_ws</str>\n      <str>f2_ws</str>\n      <str>f2_ws</str>\n      <str>f2_ws</str>\n      <str>f2_ws</str>\n      <str>f3_ws</str>\n      <str>f3_ws</str>\n      <str>f3_ws</str>\n      <str>f3_ws</str>\n      <str>f3_ws</str>\n      <str>f4_ws</str>\n      <str>f4_ws</str>\n      <str>f4_ws</str>\n      <str>f4_ws</str>\n      <str>f4_ws</str>\n      <str>f5_ws</str>\n      <str>f5_ws</str>\n      <str>f5_ws</str>\n      <str>f5_ws</str>\n      <str>f5_ws</str>\n      <str>f6_ws</str>\n      <str>f6_ws</str>\n      <str>f6_ws</str>\n      <str>f6_ws</str>\n      <str>f6_ws</str>\n      <str>f7_ws</str>\n      <str>f7_ws</str>\n      <str>f7_ws</str>\n      <str>f7_ws</str>\n      <str>f7_ws</str>\n      <str>f8_ws</str>\n      <str>f8_ws</str>\n      <str>f8_ws</str>\n      <str>f8_ws</str>\n      <str>f8_ws</str>\n      <str>f9_ws</str>\n      <str>f9_ws</str>\n      <str>f9_ws</str>\n      <str>f9_ws</str>\n      <str>f9_ws</str>\n    </arr>\n    <str name=\"wt\">xml</str>\n    <str name=\"rows\">1</str>\n  </lst>\n</lst>\n<result name=\"response\" numFound=\"50\" start=\"0\" maxScore=\"1.0\">\n  <doc>\n    <float name=\"id\">2.0</float></doc>\n</result>\n<lst name=\"facet_counts\">\n  <lst name=\"facet_queries\"/>\n  <lst name=\"facet_fields\">\n    <lst name=\"f0_ws\">\n      <int name=\"zero_1\">25</int>\n      <int name=\"zero_2\">25</int>\n    </lst>\n    <lst name=\"f1_ws\">\n      <int name=\"one_1\">33</int>\n      <int name=\"one_3\">17</int>\n    </lst>\n    <lst name=\"f2_ws\">\n      <int name=\"two_1\">37</int>\n      <int name=\"two_4\">13</int>\n    </lst>\n    <lst name=\"f3_ws\">\n      <int name=\"three_1\">40</int>\n      <int name=\"three_5\">10</int>\n    </lst>\n    <lst name=\"f4_ws\">\n      <int name=\"four_1\">41</int>\n      <int name=\"four_6\">9</int>\n    </lst>\n    <lst name=\"f5_ws\">\n      <int name=\"five_1\">42</int>\n      <int name=\"five_7\">8</int>\n    </lst>\n    <lst name=\"f6_ws\">\n      <int name=\"six_1\">43</int>\n      <int name=\"six_8\">7</int>\n    </lst>\n    <lst name=\"f7_ws\">\n      <int name=\"seven_1\">44</int>\n      <int name=\"seven_9\">6</int>\n    </lst>\n    <lst name=\"f8_ws\">\n      <int name=\"eight_1\">45</int>\n      <int name=\"eight_10\">5</int>\n    </lst>\n    <lst name=\"f9_ws\">\n      <int name=\"nine_1\">45</int>\n      <int name=\"nine_11\">5</int>\n    </lst>\n  </lst>\n  <lst name=\"facet_dates\"/>\n  <lst name=\"facet_ranges\"/>\n</lst>\n</response>\n\n\n\nThis behavior is quite strange as it is being dependent on the number of shards in SolrCloud. It would be great if someone can shed some light on this?",
    "attachments": {
        "SOLR-6314.patch": "https://issues.apache.org/jira/secure/attachment/12660550/SOLR-6314.patch"
    },
    "issue_links": {},
    "comments": [
        {
            "author": "Erick Erickson",
            "id": "comment-14083620",
            "date": "2014-08-02T16:35:04+0000",
            "content": "I know something about that code so I'll try to take a look.\n\nI'm not entirely sure when I'll get to it though, I'm slammed. So\nif someone wants to look at it instead, please feel free.\n\nVamsee:\n\nWhat version of Solr are you seeing this on? "
        },
        {
            "author": "Vamsee Yarlagadda",
            "id": "comment-14083726",
            "date": "2014-08-02T20:59:56+0000",
            "content": "Thanks @Erick. I was able to replicate the issue on Solr trunk (5.0)\nLet me know if there is anything I can do to help in the process.  "
        },
        {
            "author": "Erick Erickson",
            "id": "comment-14088820",
            "date": "2014-08-07T04:29:28+0000",
            "content": "OK, taking a closer look at this and I wonder what the right behavior is. The totals\nare correct, it's just that they repeated in one case and not in  another. \n\nIt looks like I can restate the problem like this:\n\nWhen a facet field is requested more than one time in non-sharded cluster, then the field\nis repeated in the result set. \n\nWhen a facet field is requested more than once in a sharded cluster, then the field is only\nreturned once in the result set.\n\nIOW, specifying the same facet.field twice: &facet.field=f1&facet.field=f1\nresults in two (identical) sections in the response in a non-sharded case\nand one in the sharded case.\n\nI'll look at the code tomorrow to see where the difference happens, I suspect in the\naggregating code in the distributed case but that's just a guess.\n\nSo the question is what the right behavior really is. I can argue that specifying the\nexact same facet parameter (either query or field) more than once is a waste, and the\nfacet information should be cleaned up on the way in by removing duplicates. That would give\nthe same response in both cases and return just one entry per unique facet criteria. This is \narguably avoiding useless work (what's the value of specifying the same facet parameter\ntwice?) That would change current behavior in the single-shard case however.\n\nIf we tried to return multiple entries in the sharded case, it seems quite fragile to try to sum the\nfacet sub-counts separately. By that I mean say shard 1 returns\nf1:33\nf1:33\n\nshard two returns\nf1:78\nf1:78 \n\nYou'd like the final result to be\nf1:111\nf1:111\n\nOn the surface, some rule like \"add facets by\nposition when the key is identical and return multiple\ncounts\" seems like it would work, but it also seems\nrife for errors to creep in with arguably no added value. What happens,\nfor instance, if there are three values for \"f1\" from one shard\nand only two from another? I don't see how that would really happen,\nbut....\n\nSo, my question for you (and anyone who wants to chime in)\nis: \"Do you agree that pruning multiple identical facet criteria\nis a Good Thing?\". If not, what use case does returning multiple\nidentical facet counts support and is that use case worth the\neffort? My gut feeling is no.\n\nThanks for bringing this up it's certainly something\nthat's confusing. I suspect it's just something that hasn't been\nthought of in the past.... "
        },
        {
            "author": "Vamsee Yarlagadda",
            "id": "comment-14088833",
            "date": "2014-08-07T05:01:23+0000",
            "content": "Thanks Erick Erickson for looking into this.\n\nYes, you are right. It makes perfect sense to return a count for every unique facet request rather than repeating the facets over and over. It might be the case that the facet result that's returned in the case of multi-shard (by going through the aggregating code) is the right thing to do. Perhaps, we may want to fix the behavior for single shard system and make changes to the unit tests to reflect the same.\n\nI can't think of any particular reason why the initial implementation of multithreaded faceting created a test that will check for duplicate facet counts. It might be a test bug too?\nhttps://github.com/apache/lucene-solr/blob/trunk/solr/core/src/test/org/apache/solr/request/TestFaceting.java#L654\n\nThoughts? "
        },
        {
            "author": "Shawn Heisey",
            "id": "comment-14089341",
            "date": "2014-08-07T15:27:23+0000",
            "content": "I can't imagine any situations where having the f1 key in the results twice (with the same info) is useful, so I would argue that the non-distributed query should behave like the distributed query and only return it once.  If someone has a reasonable use case for the current behavior, then you can forget what I said and make distributed work like non-distributed ... but hopefully with an optimization in both instances so that it only calculates the results once.\n\nOne thing that a user might do is include two nearly identical keys like this, either for migration purposes, or to work around web developers who are completely clueless:\n\n\nfacet.field=f1&facet.field={!key=foo}f1\n\n\n\nThis does work properly in Solr 4.9 with a distributed facet \u2013 the original and re-keyed facets are both returned, with identical info.  I don't know if it runs the facet twice or re-uses the info that is already calculated. "
        },
        {
            "author": "Erick Erickson",
            "id": "comment-14090297",
            "date": "2014-08-08T04:42:55+0000",
            "content": "OK, here's a patch. The only real code changes are in MultimapSolrParams. There's got to be a more efficient way to check to see if there's a duplicate, but this is enough to see if this approach works.\n\nAll tests pass, although you'll note a couple were written to expect multiple duplicate return fields that I had to change. IMO they were testing the wrong behavior.\n\nNow, the thing that worries me here is that this code will be executed for all the requests coming in. Any code that counts on multiple identical parameters making it through is toast. Personally I don't see why that's a problem, but here's a chance to object.\n\nI mean fq clauses go through here. As does most anything else in the world. It's still the case that different values get multiple entries, for instance specifying\n&f.manu.facet.mincount=3&f.manu.facet.mincount=2\nresults in two entries in the f.manu.facet.mincount array. That's correct behavior though.\n\nAnyway, I'll look for a more efficient way to test other than looping through the array, mostly this is a chance for people to see if this makes sense. "
        },
        {
            "author": "Yonik Seeley",
            "id": "comment-14090870",
            "date": "2014-08-08T15:26:14+0000",
            "content": "The only real code changes are in MultimapSolrParams.\n\nI'm not sure it makes sense to \"dedup\" at that level.  That implies that repeated parameters never make sense in any context... and I don't think we can/should try to do that.  If you want to dedup facet parameters for some reason, then it should probably be done in the faceting code. "
        },
        {
            "author": "Erick Erickson",
            "id": "comment-14090909",
            "date": "2014-08-08T16:02:03+0000",
            "content": "bq: If you want to dedup facet parameters for some reason, then it should probably be \ndone in the faceting code.\n\nYeah, that's exactly what's making me uncomfortable about the patch, it's at such a low level and it\naffects everything. Unintended consequences and all that.\n\nOTOH, what's the case for allowing dups? Do you have specific cases where that's\ngood or is your comment more of a statement that we shouldn't restrict future possibilities\njust because I'm not sufficiently imaginative  ?\n\nI'm really having a tough time imagining scenarios where allowing dups is useful, and I can\ncome up with scenarios where allowing dups is harmful (imagine multiple, expensive, identical\nfq clause with cache=false for instance) that would be caught here. Hmmm, a WARN-level \nlog message is indicated for dups no matter what I think.\n\nThe counter-argument is that the user should be free to shoot themselves in the foot as\nthey want to.\n\nThe counter-counter argument is that when we identify potential traps we\nshould do something about them if we can.\n\nWhat do you think about this alternative? (note, I'm not proposing it as much as throwing it out\nfor discussion). Leave the dup-detection where it is and log a WARN level message when dups\nare detected, and move the actual de-duping out to the faceting code. Then de-dupe on a case-\nby-case basis as situations arise.\n\nWhere this started was that the exact same query over the exact same data set returns different\nresults in sharded and non-sharded situations. The results have the same information, just \nrepeated in the single shard case. Which means that somehow the sharded code manages to \nignore the extra entries. I'll look at how in a bit. At any rate, the \nsharded case manages to avoid returning the data multiple times so either there's code in there \nspecifically to deal with this or it's happening by chance, which is its own gotcha.\n\nI've seen some very large queries out in the wild and it's hard in many cases to see things\nlike this so logging a message would help the users figure out their (perhaps\nmachine-generated) code was doing things  they probably don't want.\n\nSo this is a long winded way of saying \"Hell, I don't know\". My slight preference here\nwould be to dedupe as it's being done in this patch (and log warnings when doing so). It\njust feels \"more correct\" and may prevent weird behavior in the future. But I'm not \nadamant about that, if the general consensus is that doing this on a case-by-case basis\nis a better idea I can make it so for the facet case. "
        },
        {
            "author": "Erick Erickson",
            "id": "comment-14098119",
            "date": "2014-08-15T04:18:26+0000",
            "content": "While arguably the behavior I started looking at is benign-but-annoying (if inefficient), there is bona-fide badness here. If you specify facet.query=blah twice in distributed mode, the result is twice the count it should be.\n\nTry this: URL on the test docs, simple 2-shard setup:\nhttp://localhost:8983/solr/collection1/query?q=*:*&facet=true&facet.range.mincount=1&facet.range=manufacturedate_dt&facet.range.start=NOW-100YEARS&facet.range.end=NOW&facet.range.gap=%2B10YEAR\n\nThe only non-zero entry is\n\"2004-08-14T22:53:07.852Z\",\n11\n\nNow duplicate the field by adding another copy of:\n&facet.range=manufacturedate_dt\nthe count goes to 22\noops.\n\nAdmittedly this is pilot error, but still it's incorrect.\n\nI looked at de-duping in the facet component only, but that ran into weird null pointer exceptions. Given that I slightly favored deduping at a high level anyway, I'm not willing to pursue that avenue unless there's a really good counter-argument.\n\nLong version:\n\nThe behavior is different because the distributed case is, of course, a separate code path. Part of that path is FacetComponent.parse (roughly line 1000 in trunk). That method collects the facet.field parameters into a LinkedHashMap, so multiple entries are weeded out. In the case where we specify the field twice, the params are still passed to the shards and calculated twice. And returned twice. It just happens that the facets member var (which collected the names of the fields) only has one entry for the multiply-specified field since it's a HashMap. So it only asks for the facet counts from the response packet once for each shard. Since they're identical, it's OK.\n\nHowever, take rangeFacets, roughly line 981 in FacetComponent is defined as a SimpleOrderedMap. Which checks to see if there is already an entry for the field in question... and if there is adds to it. \n\nI think that this adds weight to the somewhat invasive change I first tried. I don't know how many of these are hanging around. Based on them being SimpleOrderedMaps, I'm guessing at least date facets, pivot facets and interval facets at least have problems.\n\nSo rather than find them one-by-one I'm inclined to do the deduping at a higher level.\n\nThis is easy to demonstrate in the distributed tests, just hack TestDistributedSearch to duplicate one of the facet.range (or other facet types that use SimpleOrderedMaps) in the queries . Tests start failing.\n\nI'll probably attach a new version of the patch tonight (running tests now). It's just like the old one except it adds duplicated fields to the distributed facets test (which will fail without the patch).\n\nI spent some time trying to move the dedupe code to FacetComponent, but it's more tangled than I think is worth the effort. It's not difficult\nto dedupe the parameters, but they're passed through in a SolrParams object. So far so good. But somehow that generates a null pointer exception down the road. I think that the problem here is that there are some assumptions about how many entries should be there based on the original parameters in the request. Or something like that. Deduping on the highest level seems to avoid this altogether and I'm very afraid it's an N+1 problem.\n\nLet me know if anyone disagrees violently. Otherwise I'll commit sometime this weekend assuming tests pass. "
        },
        {
            "author": "Erick Erickson",
            "id": "comment-14098163",
            "date": "2014-08-15T05:06:07+0000",
            "content": "Latest patch as promised. "
        },
        {
            "author": "Yonik Seeley",
            "id": "comment-14098760",
            "date": "2014-08-15T17:01:25+0000",
            "content": "OTOH, what's the case for allowing dups?\n\nIt's a general parameter passing mechanism, so we're talking about all possible plugins/interfaces.\nBut here's one off the top of my head...  specifying field values with query parameters:\n\n&field.description=shoes\n&field.color=red\n&field.color=blue\n&field.size=10.5\n&field.size=10.5\n\nIt still seems like there's no bug here.\nThe root cause of the incorrect facet count appears to be an incorrect facet request, right?\nIf that's the case, the simplest answer is \"well, that behavior is undefined\".\nOr if we want to help detect the user error sooner, simply throw an exception in the facet component? "
        },
        {
            "author": "Erick Erickson",
            "id": "comment-14099319",
            "date": "2014-08-15T22:56:00+0000",
            "content": "Ahhh, OK. If I'm understanding the approach, then collapsing the identical params\nwould screw up anything that depended on relative positions (as one example). So\nsomething like this:\n\n&field.description=shoes\n&field.color=red\n&field.color=blue\n&field.color=black\n&field.size=10.5\n&field.size=10.5\n&field.size=11\n\nwhere there's an positional association between the order of the\ncolors and the shoe size you're looking for. In this case it means\nred and blue shoes of size 10.5 \nblack shoes 11\n\nand collapsing the two 10.5s would screw it up.\n\nOk, that makes sense.\n\nCertainly throwing an error in the component would be easily do-able.\n\nLet me see if I can put something together that collapses the values in \nfacet component, an approach just occurred to me. If it works we'll have \ntwo choices. Then we can all weigh in on whether it's better to \n\n1> throw an error or (possibly breaking currently-running code BTW)\nor\n2> remove the duplicates and log a warning. "
        },
        {
            "author": "ASF subversion and git services",
            "id": "comment-14101155",
            "date": "2014-08-18T19:45:19+0000",
            "content": "Commit 1618716 from Erick Erickson in branch 'dev/trunk'\n[ https://svn.apache.org/r1618716 ]\n\nSOLR-6314: Multi-threaded facet counts differ when SolrCloud has >1 shard "
        },
        {
            "author": "Erick Erickson",
            "id": "comment-14101199",
            "date": "2014-08-18T20:11:19+0000",
            "content": "Final version of patch, it's my day to forget to put them up first. "
        },
        {
            "author": "ASF subversion and git services",
            "id": "comment-14101287",
            "date": "2014-08-18T21:01:57+0000",
            "content": "Commit 1618734 from Erick Erickson in branch 'dev/branches/branch_4x'\n[ https://svn.apache.org/r1618734 ]\n\nSOLR-6314: Multi-threaded facet counts differ when SolrCloud has >1 shard "
        },
        {
            "author": "Erick Erickson",
            "id": "comment-14101289",
            "date": "2014-08-18T21:02:25+0000",
            "content": "Thanks Vamsee! "
        },
        {
            "author": "Erick Erickson",
            "id": "comment-14101292",
            "date": "2014-08-18T21:03:16+0000",
            "content": "BTW, the final solution was to NOT log any warnings in the general case and just remove the dups in the facet component that were facet-related. "
        },
        {
            "author": "Vamsee Yarlagadda",
            "id": "comment-14103564",
            "date": "2014-08-20T07:36:10+0000",
            "content": "The patch looks good to me. \nThanks Erick Erickson. "
        },
        {
            "author": "Mark Miller",
            "id": "comment-14105395",
            "date": "2014-08-21T14:10:41+0000",
            "content": "Multi-threaded facet counts differ when SolrCloud has >1 shard\n\nThis seems like the wrong title for the JIRA and especially the wrong title in CHANGES. Makes it sound like a severe bug rather than what I'm reading above. "
        },
        {
            "author": "Mark Miller",
            "id": "comment-14105397",
            "date": "2014-08-21T14:13:47+0000",
            "content": "SOLR-6314: Multi-threaded facet counts differ when SolrCloud has >1 shard (Erick Erickson)\n\nAlso missing credit for Vamsee in CHANGES. "
        },
        {
            "author": "Erick Erickson",
            "id": "comment-14105524",
            "date": "2014-08-21T16:15:02+0000",
            "content": "Yep, you're right. The counts were correct, it was just repeated unnecessarily in the response under some conditions.\n\nFixing up both. "
        },
        {
            "author": "ASF subversion and git services",
            "id": "comment-14105526",
            "date": "2014-08-21T16:16:59+0000",
            "content": "Commit 1619470 from Erick Erickson in branch 'dev/trunk'\n[ https://svn.apache.org/r1619470 ]\n\nSOLR-6314: updated bug title to be more accurate and include Vamsee in credits, all in CHNAGES.txt. No code changes "
        },
        {
            "author": "ASF subversion and git services",
            "id": "comment-14105528",
            "date": "2014-08-21T16:17:51+0000",
            "content": "Commit 1619471 from Erick Erickson in branch 'dev/branches/branch_4x'\n[ https://svn.apache.org/r1619471 ]\n\nSOLR-6314: updated bug title to be more accurate and include Vamsee in credits, all in CHNAGES.txt. No code changes "
        },
        {
            "author": "ASF subversion and git services",
            "id": "comment-14105542",
            "date": "2014-08-21T16:30:30+0000",
            "content": "Commit 1619478 from Ryan Ernst in branch 'dev/branches/lucene_solr_4_10'\n[ https://svn.apache.org/r1619478 ]\n\nSOLR-6314: updated bug title to be more accurate and include Vamsee in credits, all in CHNAGES.txt. No code changes "
        }
    ]
}