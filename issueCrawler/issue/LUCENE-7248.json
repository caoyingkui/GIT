{
    "id": "LUCENE-7248",
    "title": "Interrupting IndexWriter causing unhandled ClosedChannelException",
    "details": {
        "resolution": "Workaround",
        "affect_versions": "5.3",
        "components": [
            "core/store"
        ],
        "labels": "",
        "fix_versions": [],
        "priority": "Major",
        "status": "Closed",
        "type": "Bug"
    },
    "description": "When interrupting the IndexWriter, sometimes an InterruptedException is correctly handled but other times it isn't. When unhandled, the IndexWriter 'closes' and any other operation throws AlreadyClosedException. Here is a stack trace: \n\njava.nio.channels.ClosedChannelException\n    at sun.nio.ch.FileLockImpl.release(FileLockImpl.java:58)\n    at java.nio.channels.FileLock.close(FileLock.java:309)\n    at org.apache.lucene.store.NativeFSLockFactory$NativeFSLock.close(NativeFSLockFactory.java:194)\n    at org.apache.lucene.util.IOUtils.close(IOUtils.java:97)\n    at org.apache.lucene.util.IOUtils.close(IOUtils.java:84)\n    at org.apache.lucene.index.IndexWriter.rollbackInternal(IndexWriter.java:2103)\n    at org.apache.lucene.index.IndexWriter.tragicEvent(IndexWriter.java:4574)\n    at org.apache.lucene.index.IndexWriter.updateDocument(IndexWriter.java:1487)\n    at com.google.gerrit.lucene.AutoCommitWriter.updateDocument(AutoCommitWriter.java:100)\n    at org.apache.lucene.index.TrackingIndexWriter.updateDocument(TrackingIndexWriter.java:55)\n    at com.google.gerrit.lucene.SubIndex.replace(SubIndex.java:183)\n    at com.google.gerrit.lucene.LuceneChangeIndex.replace(LuceneChangeIndex.java:326)\n    at com.google.gerrit.server.index.ChangeIndexer$IndexTask.call(ChangeIndexer.java:243)\n    at com.google.gerrit.server.index.ChangeIndexer$IndexTask.call(ChangeIndexer.java:1)\n    at com.google.common.util.concurrent.TrustedListenableFutureTask$TrustedFutureInterruptibleTask.runInterruptibly(TrustedListenableFutureTask.java:108)\n    at com.google.common.util.concurrent.InterruptibleTask.run(InterruptibleTask.java:41)\n    at com.google.common.util.concurrent.TrustedListenableFutureTask.run(TrustedListenableFutureTask.java:77)\n    at com.google.common.util.concurrent.MoreExecutors$DirectExecutorService.execute(MoreExecutors.java:310)\n    at java.util.concurrent.AbstractExecutorService.submit(AbstractExecutorService.java:132)\n    at com.google.common.util.concurrent.AbstractListeningExecutorService.submit(AbstractListeningExecutorService.java:61)\n    at com.google.gerrit.server.index.ChangeIndexer.submit(ChangeIndexer.java:200)\n    at com.google.gerrit.server.index.ChangeIndexer.indexAsync(ChangeIndexer.java:133)\n    at com.google.gerrit.server.change.PostReviewers.addReviewers(PostReviewers.java:246)\n    at com.google.gerrit.server.change.PostReviewers.putAccount(PostReviewers.java:156)\n    at com.google.gerrit.server.change.PostReviewers.apply(PostReviewers.java:138)\n    at com.google.gerrit.sshd.commands.SetReviewersCommand.modifyOne(SetReviewersCommand.java:158)\n    at com.google.gerrit.sshd.commands.SetReviewersCommand.run(SetReviewersCommand.java:112)\n    at com.google.gerrit.sshd.SshCommand$1.run(SshCommand.java:48)\n    at com.google.gerrit.sshd.BaseCommand$TaskThunk.run(BaseCommand.java:442)\n    at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:471)\n    at java.util.concurrent.FutureTask.run(FutureTask.java:262)\n    at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:178)\n    at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:292)\n    at com.google.gerrit.server.git.WorkQueue$Task.run(WorkQueue.java:377)\n    at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1145)\n    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:615)\n    at java.lang.Thread.run(Thread.java:745)\n\n[...]\n\norg.apache.lucene.store.AlreadyClosedException: this IndexWriter is closed\n\tat org.apache.lucene.index.IndexWriter.ensureOpen(IndexWriter.java:719)\n\tat org.apache.lucene.index.IndexWriter.ensureOpen(IndexWriter.java:733)\n\tat org.apache.lucene.index.IndexWriter.updateDocument(IndexWriter.java:1471)\n\tat com.google.gerrit.lucene.AutoCommitWriter.updateDocument(AutoCommitWriter.java:100)\n\tat org.apache.lucene.index.TrackingIndexWriter.updateDocument(TrackingIndexWriter.java:55)\n\tat com.google.gerrit.lucene.SubIndex.replace(SubIndex.java:183)\n\tat com.google.gerrit.lucene.LuceneChangeIndex.replace(LuceneChangeIndex.java:326)\n\tat com.google.gerrit.server.index.ChangeIndexer$IndexTask.call(ChangeIndexer.java:243)\n\tat com.google.gerrit.server.index.ChangeIndexer$IndexTask.call(ChangeIndexer.java:1)\n\tat com.google.common.util.concurrent.TrustedListenableFutureTask$TrustedFutureInterruptibleTask.runInterruptibly(TrustedListenableFutureTask.java:108)\n\tat com.google.common.util.concurrent.InterruptibleTask.run(InterruptibleTask.java:41)\n\tat com.google.common.util.concurrent.TrustedListenableFutureTask.run(TrustedListenableFutureTask.java:77)\n\tat com.google.common.util.concurrent.MoreExecutors$DirectExecutorService.execute(MoreExecutors.java:310)\n\tat java.util.concurrent.AbstractExecutorService.submit(AbstractExecutorService.java:132)\n\tat com.google.common.util.concurrent.AbstractListeningExecutorService.submit(AbstractListeningExecutorService.java:61)\n\tat com.google.gerrit.server.index.ChangeIndexer.submit(ChangeIndexer.java:200)\n\tat com.google.gerrit.server.index.ChangeIndexer.indexAsync(ChangeIndexer.java:133)\n\tat com.google.gerrit.server.change.PostReviewers.addReviewers(PostReviewers.java:246)\n\tat com.google.gerrit.server.change.PostReviewers.putAccount(PostReviewers.java:156)\n\tat com.google.gerrit.server.change.PostReviewers.apply(PostReviewers.java:138)\n\tat com.google.gerrit.sshd.commands.SetReviewersCommand.modifyOne(SetReviewersCommand.java:158)\n\tat com.google.gerrit.sshd.commands.SetReviewersCommand.run(SetReviewersCommand.java:112)\n\tat com.google.gerrit.sshd.SshCommand$1.run(SshCommand.java:48)\n\tat com.google.gerrit.sshd.BaseCommand$TaskThunk.run(BaseCommand.java:442)\n\tat java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:471)\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:262)\n\tat java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:178)\n\tat java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:292)\n\tat com.google.gerrit.server.git.WorkQueue$Task.run(WorkQueue.java:377)\n\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1145)\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:615)\n\tat java.lang.Thread.run(Thread.java:745)\nCaused by: java.nio.channels.ClosedByInterruptException\n\tat java.nio.channels.spi.AbstractInterruptibleChannel.end(AbstractInterruptibleChannel.java:202)\n\tat sun.nio.ch.FileChannelImpl.size(FileChannelImpl.java:312)\n\tat org.apache.lucene.store.NativeFSLockFactory$NativeFSLock.ensureValid(NativeFSLockFactory.java:170)\n\tat org.apache.lucene.store.LockValidatingDirectoryWrapper.createOutput(LockValidatingDirectoryWrapper.java:43)\n\tat org.apache.lucene.store.TrackingDirectoryWrapper.createOutput(TrackingDirectoryWrapper.java:43)\n\tat org.apache.lucene.codecs.compressing.CompressingStoredFieldsWriter.<init>(CompressingStoredFieldsWriter.java:110)\n\tat org.apache.lucene.codecs.compressing.CompressingStoredFieldsFormat.fieldsWriter(CompressingStoredFieldsFormat.java:128)\n\tat org.apache.lucene.codecs.lucene50.Lucene50StoredFieldsFormat.fieldsWriter(Lucene50StoredFieldsFormat.java:183)\n\tat org.apache.lucene.index.DefaultIndexingChain.initStoredFieldsWriter(DefaultIndexingChain.java:81)\n\tat org.apache.lucene.index.DefaultIndexingChain.startStoredFields(DefaultIndexingChain.java:258)\n\tat org.apache.lucene.index.DefaultIndexingChain.processDocument(DefaultIndexingChain.java:295)\n\tat org.apache.lucene.index.DocumentsWriterPerThread.updateDocument(DocumentsWriterPerThread.java:234)\n\tat org.apache.lucene.index.DocumentsWriter.updateDocument(DocumentsWriter.java:450)\n\tat org.apache.lucene.index.IndexWriter.updateDocument(IndexWriter.java:1475)\n\t... 29 more",
    "attachments": {},
    "issue_links": {},
    "comments": [
        {
            "id": "comment-15254386",
            "author": "Scott Blum",
            "date": "2016-04-22T18:23:18+0000",
            "content": "We fixed a bunch of cases where Solr could interrupt an IndexWriter a while back: https://issues.apache.org/jira/browse/SOLR-7956\nIt would be nice to see a fix at the Lucene level that would prevent an IndexWriter from becoming permanently corrupted. "
        },
        {
            "id": "comment-15254400",
            "author": "Robert Muir",
            "date": "2016-04-22T18:28:41+0000",
            "content": "The documentation on FSDirectory warns you about ClosedChannelException. Unfortunately: there is not really anything we can do about it in lucene: its a jvm thing.\n\n * <p><b>NOTE:</b> Accessing one of the above subclasses either directly or\n * indirectly from a thread while it's interrupted can close the\n * underlying channel immediately if at the same time the thread is\n * blocked on IO. The channel will remain closed and subsequent access\n * to the index will throw a {@link ClosedChannelException}.\n * Applications using {@link Thread#interrupt()} or\n * {@link Future#cancel(boolean)} should use the slower legacy\n * {@code RAFDirectory} from the {@code misc} Lucene module instead.\n\n "
        },
        {
            "id": "comment-15254419",
            "author": "Alexandre Philbert",
            "date": "2016-04-22T18:34:13+0000",
            "content": "Thanks for the quick responses! I'm currently looking into the this project's code just in case.  "
        },
        {
            "id": "comment-15254490",
            "author": "Robert Muir",
            "date": "2016-04-22T19:09:57+0000",
            "content": "There isn't a just in case. The javadocs are clear: https://docs.oracle.com/javase/7/docs/api/java/nio/channels/InterruptibleChannel.html\n\n\nIf a thread is blocked in an I/O operation on an interruptible channel then another thread may invoke the blocked thread's interrupt method. This will cause the channel to be closed "
        },
        {
            "id": "comment-15254508",
            "author": "Alexandre Philbert",
            "date": "2016-04-22T19:27:47+0000",
            "content": "Okay thanks for the detailed responses. I'll look into Scott's 'workaround' or if RAFDirectory solves the problem.\n\nEDIT: I tried switching FSDirectory implementations and LockFactory and it seems that switching to other LockFactory implementations \"fixes\" the issue... I'm currently testing locally so it's not confirmed yet. Are there any terrible things that can happen using SingleInstanceLockFactory or NoLockFactory? "
        },
        {
            "id": "comment-15254611",
            "author": "Uwe Schindler",
            "date": "2016-04-22T20:34:22+0000",
            "content": "I tried switching FSDirectory implementations and LockFactory and it seems that switching to other LockFactory implementations \"fixes\" the issue\n\nThe whole this has really nothing to do with LockFactory. Changing it is just risky and helps nothing.\n\nAre there any terrible things that can happen using SingleInstanceLockFactory or NoLockFactory?\n\nYour index breaks and gets unuseable if you accidentally open two IndexWriters at the same time. "
        },
        {
            "id": "comment-15254638",
            "author": "Alexandre Philbert",
            "date": "2016-04-22T20:42:54+0000",
            "content": "I disagree that it has nothing to do with LockFactory. According to the stack trace, it fails when trying to release a lock using NativeFSLockFactory. Using the two others that I mentioned it doesn't fail anymore.. Probably because there aren't any locks (in the case of NoLockFactory) or they are handled differently (in the case of SingleInstanceFactory).\nAlthough it's true that it probably is risky. :/\n\nEDIT: What about SimpleFSLockFactory? The only downside I saw was that it doesn't clear the \"write.lock\" when the application shuts down.. Are there any other downsides? "
        },
        {
            "id": "comment-15254753",
            "author": "Uwe Schindler",
            "date": "2016-04-22T21:43:23+0000",
            "content": "I disagree that it has nothing to do with LockFactory.\n\nSorry the problem will still exists if you interrupt IndexWriter and it writes files at the same time. You have to stop interrupting indexwriter. The problem is not in Lucene it is in the software that sends interrupts to threads by Lucene. This is a no-go, sorry. If you cannot fix this, your only chance is to use RAFDirectory, but this slows down reading from index. "
        },
        {
            "id": "comment-15256508",
            "author": "Alexandre Philbert",
            "date": "2016-04-25T15:54:16+0000",
            "content": "Need to stop interrupting Lucene. My specific problem seems to be fixed by changing the Lock implementation, but according to contributors that isn't the case. "
        },
        {
            "id": "comment-15532140",
            "author": "Otmar Caduff",
            "date": "2016-09-29T08:21:11+0000",
            "content": "We too stumbled over this. In our setup, Lucene is run within an servlet container. So queries are executed by threads working down servlet calls. Now when a connection is closed prematurely by the client, the executing thread seems to be interrupted, leading to this problem.\n\nUsing RAFDirectory did not solve the problem.\nRAFDirectory seems to use RandomAccessFile for reading only, writing is delegated to FSDirectory, since RAFDirectory inherits from FSDirectory. Inside the RAFDirectory implementation, I cannot see anything indicating that writing would be done with RandomAccessFile as well (maybe this should be pointed out in the javadoc?).\nIn our case, index readers/searchers used to call SearcherManager.maybeRefresh(), which occasionally involves a flush to the index files:\n\nCaused by: java.nio.channels.ClosedByInterruptException: null\n\tat java.nio.channels.spi.AbstractInterruptibleChannel.end(AbstractInterruptibleChannel.java:202)\n\tat sun.nio.ch.FileChannelImpl.write(FileChannelImpl.java:216)\n\tat java.nio.channels.Channels.writeFullyImpl(Channels.java:78)\n\tat java.nio.channels.Channels.writeFully(Channels.java:101)\n\tat java.nio.channels.Channels.access$000(Channels.java:61)\n\tat java.nio.channels.Channels$1.write(Channels.java:174)\n\tat org.apache.lucene.store.FSDirectory$FSIndexOutput$1.write(FSDirectory.java:278)\n\tat java.util.zip.CheckedOutputStream.write(CheckedOutputStream.java:73)\n\tat java.io.BufferedOutputStream.flushBuffer(BufferedOutputStream.java:82)\n\tat java.io.BufferedOutputStream.flush(BufferedOutputStream.java:140)\n\tat org.apache.lucene.store.OutputStreamIndexOutput.getChecksum(OutputStreamIndexOutput.java:80)\n\tat org.apache.lucene.codecs.CodecUtil.writeCRC(CodecUtil.java:473)\n\tat org.apache.lucene.codecs.CodecUtil.writeFooter(CodecUtil.java:309)\n\tat org.apache.lucene.codecs.compressing.CompressingStoredFieldsIndexWriter.finish(CompressingStoredFieldsIndexWriter.java:205)\n\tat org.apache.lucene.codecs.compressing.CompressingStoredFieldsWriter.finish(CompressingStoredFieldsWriter.java:467)\n\tat org.apache.lucene.index.DefaultIndexingChain.flush(DefaultIndexingChain.java:108)\n\tat org.apache.lucene.index.DocumentsWriterPerThread.flush(DocumentsWriterPerThread.java:422)\n\tat org.apache.lucene.index.DocumentsWriter.doFlush(DocumentsWriter.java:503)\n\tat org.apache.lucene.index.DocumentsWriter.flushAllThreads(DocumentsWriter.java:615)\n\tat org.apache.lucene.index.IndexWriter.getReader(IndexWriter.java:424)\n\tat org.apache.lucene.index.StandardDirectoryReader.doOpenFromWriter(StandardDirectoryReader.java:286)\n\tat org.apache.lucene.index.StandardDirectoryReader.doOpenIfChanged(StandardDirectoryReader.java:261)\n\tat org.apache.lucene.index.StandardDirectoryReader.doOpenIfChanged(StandardDirectoryReader.java:251)\n\tat org.apache.lucene.index.DirectoryReader.openIfChanged(DirectoryReader.java:137)\n\tat org.apache.lucene.search.SearcherManager.refreshIfNeeded(SearcherManager.java:154)\n\tat org.apache.lucene.search.SearcherManager.refreshIfNeeded(SearcherManager.java:58)\n\tat org.apache.lucene.search.ReferenceManager.doMaybeRefresh(ReferenceManager.java:176)\n\tat org.apache.lucene.search.ReferenceManager.maybeRefresh(ReferenceManager.java:225)\n\n\nI changed our code so that SearcherManager.maybeRefresh() is called by the indexing thread, which is not being interrupted, since it is not processing servlet calls.\nCorrect me if I'm wrong: Since using IndexSearcher alone does not involve any write operations, I am safe against ClosedChannelException.\nIn the long run, I'll try to find a way to prevent using RAFDirectory, i.e. prevent the container interrupting querying threads. "
        }
    ]
}