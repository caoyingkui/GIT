{
    "id": "SOLR-4733",
    "title": "Rollback does not work correctly with tlog and optimistic concurrency updates",
    "details": {
        "affect_versions": "4.2.1,                                            4.3",
        "status": "Open",
        "fix_versions": [],
        "components": [],
        "type": "Bug",
        "priority": "Major",
        "labels": "",
        "resolution": "Unresolved"
    },
    "description": "When using the updateLog, attempting to rollback atomic updates still causes post-rollback atomic updates to still report a conflict with the version assigned to the update posted prior to the rollback",
    "attachments": {
        "SOLR-4733.patch": "https://issues.apache.org/jira/secure/attachment/12579468/SOLR-4733.patch"
    },
    "issue_links": {},
    "comments": [
        {
            "author": "Hoss Man",
            "id": "comment-13635962",
            "date": "2013-04-19T02:21:12+0000",
            "content": "Mark: thank you very much for your detailed bug report and test case, a few comments for your future reference:\n\n1) please try to keep the description short, as it is included in all emails sent (to all devs!) any time someone posts a comment. It's best to post a comment with long details after creating your issue, or use attachments.  I've moved your initial description into a comment below.\n\n2) when posting test cases, please try to make your test case entirely self contained \u2013 ideally as a patch that can be applied to the existing solr code base, but if you do provide a completely new standalone test case we at least need all of the configs you use in the solr server you run your test against in order to be able to reproduce.  Specifically in regards to this issue and SOLR-4605 (where you provided what appears to be the same test before), had you provided a fully reproducible test case in SOLR-4605  along with your configs, mark miller might have noticed at the time that beyond re-opening the IndexWriter, there is an additional problem involved when using the updateLog \u2013 the test mark added as part of SOLR-4605 demonstrated the same error as your initial bug report, but if it had been easy for him to try/apply your exact testcase with configs the second problem would have been obvious.\n\n\n\nThe crux of the issue seems to be when mixing optimistic concurrency with both the transaction log and rollback.  I've updated the description accordingly and i have a patch with test cases i'll attach shortly (FWIW: i have no idea what the cause is)\n\nOriginal Bug Report\nI wrote a simple test that seems to reproduce the unexpected behaviour. See the below test case \"addBeanThenRollbackThenAddBeanThenRollbackTest()\".\n\nIt seems on rollback the bean is not written to Solr system, though I think the client remembers the bean which then creates a version conflict SolrException.\n\n\n\n\tThe test case:\n\n@Test\npublic void addBeanThenRollbackThenAddBeanThenRollbackTest() throws Exception {\n\n\tMyTestBean myTestBean = createTestBean(\"addBeanTest\");\n\tUpdateResponse updateResponseOne = server.addBean(myTestBean);\n\tAssert.assertEquals(0, updateResponseOne.getStatus());\n\n\trollback();\n\tThread.sleep(1000);\n\n\t// No Bean Found\n\t{\n\t\tMyTestBean myTestBeanStored = getTestBean(myTestBean.getId());\n\t\tAssert.assertNull(myTestBeanStored);\n\t}\n\n\tUpdateResponse updateResponseTwo = server.addBean(myTestBean);\n\tAssert.assertEquals(0, updateResponseTwo.getStatus());\n\n\trollback();\n\tThread.sleep(1000);\n\n\t// No Bean Found\n\t{\n\t\tMyTestBean myTestBeanStored = getTestBean(myTestBean.getId());\n\t\tAssert.assertNull(myTestBeanStored);\n\t}\n\n}\n\n\n\n\n\n\n\tThe stack trace:\n\norg.apache.solr.common.SolrException: version conflict for 154ff2e0-621b-4eb0-a1d3-4bbe7ea01573 expected=-1 actual=1432619355523252224\n\tat org.apache.solr.client.solrj.impl.HttpSolrServer.request(HttpSolrServer.java:404)\n\tat org.apache.solr.client.solrj.impl.HttpSolrServer.request(HttpSolrServer.java:181)\n\tat org.apache.solr.client.solrj.request.AbstractUpdateRequest.process(AbstractUpdateRequest.java:117)\n\tat org.apache.solr.client.solrj.SolrServer.add(SolrServer.java:116)\n\tat org.apache.solr.client.solrj.SolrServer.addBean(SolrServer.java:136)\n\tat org.apache.solr.client.solrj.SolrServer.addBean(SolrServer.java:125)\n\tat test.SolrJBeanTest.addBeanThenRollbackThenAddBeanThenRollbackTest(SolrJBeanTest.java:157)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)\n\tat java.lang.reflect.Method.invoke(Method.java:597)\n\tat org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:45)\n\tat org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:15)\n\tat org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:42)\n\tat org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:20)\n\tat org.junit.internal.runners.statements.RunBefores.evaluate(RunBefores.java:28)\n\tat org.junit.internal.runners.statements.RunAfters.evaluate(RunAfters.java:30)\n\tat org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:263)\n\tat org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:68)\n\tat org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:47)\n\tat org.junit.runners.ParentRunner$3.run(ParentRunner.java:231)\n\tat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:60)\n\tat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:229)\n\tat org.junit.runners.ParentRunner.access$000(ParentRunner.java:50)\n\tat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:222)\n\tat org.junit.runners.ParentRunner.run(ParentRunner.java:300)\n\tat org.eclipse.jdt.internal.junit4.runner.JUnit4TestReference.run(JUnit4TestReference.java:50)\n\tat org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:467)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:683)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:390)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:197)\n\n\n\n\n\n\n\n\tThe test class:\n\npackage test;\n\nimport java.io.Serializable;\nimport java.util.Date;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.UUID;\n\nimport junit.framework.Assert;\n\nimport org.apache.solr.client.solrj.SolrQuery;\nimport org.apache.solr.client.solrj.beans.Field;\nimport org.apache.solr.client.solrj.impl.BinaryRequestWriter;\nimport org.apache.solr.client.solrj.impl.HttpSolrServer;\nimport org.apache.solr.client.solrj.response.QueryResponse;\nimport org.apache.solr.client.solrj.response.UpdateResponse;\nimport org.junit.After;\nimport org.junit.Before;\nimport org.junit.Test;\n\n\npublic class SolrJBeanTest {\n\n    private static HttpSolrServer server;\n\n    static {\n\n        String url = \"http://localhost:8080/solr/collection1\";\n\n        server = new HttpSolrServer(url);\n\n         server.setRequestWriter(new BinaryRequestWriter());\n//         server.setParser(new XMLResponseParser()); // binary parser is used by default\n\n        server.setSoTimeout(5000); // socket read timeout\n        server.setConnectionTimeout(30000);\n        server.setDefaultMaxConnectionsPerHost(100);\n        server.setMaxTotalConnections(100);\n        server.setFollowRedirects(false); // defaults to false\n        // allowCompression defaults to false.\n        // Server side must support gzip or deflate for this to have any effect.\n        server.setAllowCompression(true);\n        server.setMaxRetries(1); // defaults to 0.  > 1 not recommended.\n\n    }\n\n    @Before\n    public void setUp() throws Exception {\n\n        UpdateResponse updateResponse = server.deleteByQuery(\"type_s:\" + \"MyTestBean\");\n        Assert.assertEquals(0, updateResponse.getStatus());\n\n        commit();\n\n    }\n\n\n    @After\n    public void tearDown() throws Exception {\n\n        UpdateResponse updateResponse = server.deleteByQuery(\"type_s:\" + \"MyTestBean\");\n        Assert.assertEquals(0, updateResponse.getStatus());\n\n        commit();\n\n        List<MyTestBean> beans = getTestBeans();\n        Assert.assertEquals(0, beans.size());\n\n    }\n\n    private static void commit() throws Exception {\n        UpdateResponse updateResponseForCommit = server.commit();\n        Assert.assertEquals(0, updateResponseForCommit.getStatus());\n    }\n\n    private static void rollback() throws Exception {\n        UpdateResponse updateResponseForCommit = server.rollback();\n        Assert.assertEquals(0, updateResponseForCommit.getStatus());\n    }\n\n    @Test\n    public void addBeanTest() throws Exception {\n\n        MyTestBean myTestBean = createTestBean(\"addBeanTest\");\n        UpdateResponse updateResponse = server.addBean(myTestBean);\n        Assert.assertEquals(0, updateResponse.getStatus());\n\n        Thread.sleep(1000);\n\n        // No Bean Found\n        {\n            MyTestBean myTestBeanStored = getTestBean(myTestBean.getId());\n            Assert.assertNull(myTestBeanStored);\n        }\n\n        UpdateResponse updateResponseForCommit = server.commit();\n        Assert.assertEquals(0, updateResponseForCommit.getStatus());\n\n        // Bean Found\n        {\n            MyTestBean myTestBeanStored = getTestBean(myTestBean.getId());\n            Assert.assertNotNull(myTestBeanStored);\n\n            Assert.assertEquals(myTestBean.getId(), myTestBeanStored.getId());\n            Assert.assertEquals(myTestBean.getType(), myTestBeanStored.getType());\n            Assert.assertEquals(myTestBean.getValue(), myTestBeanStored.getValue());\n            Assert.assertEquals(myTestBean.getCreatedDate(), myTestBeanStored.getCreatedDate());\n\n            Assert.assertEquals(-1L, myTestBean.get_version_().longValue());\n            Assert.assertTrue(myTestBeanStored.get_version_() > 0);\n        }\n\n    }\n\n    @Test\n    public void addBeanThenRollbackTest() throws Exception {\n\n        MyTestBean myTestBean = createTestBean(\"addBeanTest\");\n        UpdateResponse updateResponse = server.addBean(myTestBean);\n        Assert.assertEquals(0, updateResponse.getStatus());\n\n        Thread.sleep(1000);\n\n        // No Bean Found\n        {\n            MyTestBean myTestBeanStored = getTestBean(myTestBean.getId());\n            Assert.assertNull(myTestBeanStored);\n        }\n\n        UpdateResponse updateResponseForCommit = server.rollback();\n        Assert.assertEquals(0, updateResponseForCommit.getStatus());\n\n        // No Bean Found\n        {\n            MyTestBean myTestBeanStored = getTestBean(myTestBean.getId());\n            Assert.assertNull(myTestBeanStored);\n        }\n\n    }\n\n    @Test\n    public void addBeanThenRollbackThenAddBeanThenRollbackTest() throws Exception {\n\n        MyTestBean myTestBean = createTestBean(\"addBeanTest\");\n        UpdateResponse updateResponseOne = server.addBean(myTestBean);\n        Assert.assertEquals(0, updateResponseOne.getStatus());\n\n        rollback();\n        Thread.sleep(1000);\n\n        // No Bean Found\n        {\n            MyTestBean myTestBeanStored = getTestBean(myTestBean.getId());\n            Assert.assertNull(myTestBeanStored);\n        }\n\n        UpdateResponse updateResponseTwo = server.addBean(myTestBean);\n        Assert.assertEquals(0, updateResponseTwo.getStatus());\n\n        rollback();\n        Thread.sleep(1000);\n\n        // No Bean Found\n        {\n            MyTestBean myTestBeanStored = getTestBean(myTestBean.getId());\n            Assert.assertNull(myTestBeanStored);\n        }\n\n    }\n\n    private MyTestBean createTestBean(String value) {\n        MyTestBean myTestBean = new MyTestBean();\n        myTestBean.setId(UUID.randomUUID().toString().toLowerCase(Locale.ENGLISH));\n        myTestBean.setType(\"MyTestBean\");\n        myTestBean.setCreatedDate(new Date());\n        myTestBean.setValue(value);\n        myTestBean.set_version_(-1L);\n        return myTestBean;\n    }\n\n    private static List<MyTestBean> getTestBeans() throws Exception {\n        return getTestBeans(null, null);\n    }\n\n    private static MyTestBean getTestBean(String id) throws Exception {\n        List<MyTestBean> beans = getTestBeans(id, null);\n\n        if (beans == null || beans.size() == 0) {\n            return null;\n        }\n\n        return beans.get(0);\n    }\n\n    private static List<MyTestBean> getTestBeans(String id, String value) throws Exception {\n\n        SolrQuery solrQuery = new SolrQuery();\n        solrQuery.setQuery(\"*:*\");\n        if (id != null) {\n            solrQuery.addFilterQuery(\"id:\" + id);\n        }\n        solrQuery.addFilterQuery(\"type_s:\" + \"MyTestBean\");\n        if (value != null) {\n            solrQuery.addFilterQuery(\"value:\" + value);\n        }\n\n        QueryResponse queryResponse = server.query(solrQuery);\n\n        List<MyTestBean> beans = queryResponse.getBeans(MyTestBean.class);\n\n        return beans;\n\n    }\n\n\n    public static class MyTestBean implements Serializable {\n\n        private static final long serialVersionUID = 1L;\n\n        @Field(\"id\")\n        private String id;\n\n        @Field(\"type_s\")\n        private String type;\n\n        @Field(\"value_s\")\n        private String value;\n\n        @Field(\"created_dt\")\n        private Date createdDate;\n\n        @Field(\"_version_\")\n        private Long _version_;\n\n        public MyTestBean() {\n\n        }\n\n        public String getId() {\n            return id;\n        }\n\n        public void setId(String id) {\n            this.id = id;\n        }\n\n        public String getType() {\n            return type;\n        }\n\n        public void setType(String type) {\n            this.type = type;\n        }\n\n        public String getValue() {\n            return value;\n        }\n\n        public void setValue(String value) {\n            this.value = value;\n        }\n\n        public Date getCreatedDate() {\n            return createdDate;\n        }\n\n        public void setCreatedDate(Date createdDate) {\n            this.createdDate = createdDate;\n        }\n\n        public Long get_version_() {\n            return _version_;\n        }\n\n        public void set_version_(Long _version_) {\n            this._version_ = _version_;\n        }\n\n        @Override\n        public String toString() {\n            return \"MyTestBean [id=\" + id + \", type=\" + type + \", value=\" + value + \", createdDate=\" + createdDate\n                    + \", _version_=\" + _version_ + \"]\";\n        }\n\n    }\n\n}\n\n\n\n "
        },
        {
            "author": "Hoss Man",
            "id": "comment-13635970",
            "date": "2013-04-19T02:31:33+0000",
            "content": "patch demonstrating the crux of Mark's reported failure as an extension of existing tests....\n\n\n\tgeneral improvement to BasicFunctionalityTest setup to randomize use of tlog for the whole class\n\tnew BasicFunctionalityTest.testRollbackWithOptimisticConcurrency that covers the basics of this issue (leveraging the randomized use of tlog)\n\tnew TestUpdate.testRollbackWithOptimisticConcurrency that always uses tlog and goes more in depth into verifying that the optimistic concurrency update logic is rolled back properly.\n\n\n\nAs things stand, the new BasicFunctionalityTest test fails 50% of the time (if and only if tlog is used) and the new TestUpdate test fails consistently. "
        },
        {
            "author": "Mark S",
            "id": "comment-13635974",
            "date": "2013-04-19T02:47:42+0000",
            "content": "Thanks for the comments, I definitely appreciate you taking the time.\n\nMy test case should be very self contained, and all that is required is the url of your Solr instance (Default value:  http://localhost:8080/solr/collection1) and JUnit on the classpath.  I should have mentioned that I am using a vanilla Solr deployment running inside of tomcat instance on Ubuntu.  As far as I recall, no schema changes or anything.\n\nI try to keep my test bare bones to reduce confusion.  The test class I provided here is different from the test class I provided SOLR-4605.   The SolrJBeanTest here has only three test methods: \"addBeanTest()\", \"addBeanThenRollbackTest()\" and \"addBeanThenRollbackThenAddBeanThenRollbackTest()\".  I included the first two method tests as a system and configuration check, with the 3rd test method \"addBeanThenRollbackThenAddBeanThenRollbackTest()\" as a means to highlight the problem. "
        },
        {
            "author": "Mark Miller",
            "id": "comment-13673700",
            "date": "2013-06-03T22:34:03+0000",
            "content": "I think there are a variety of things that rollback does not quite work with with SolrCloud - when I talked about it in the past with Yonik, he had little to no interest in trying to support rollback with SolrCloud - I've been meaning to change it to throw an exception in SolrCloud mode. "
        },
        {
            "author": "Hoss Man",
            "id": "comment-13673709",
            "date": "2013-06-03T22:38:34+0000",
            "content": "I think there are a variety of things that rollback does not quite work with with SolrCloud\n\nMark: if that's the case, then yes it should throw an exception that it's unsupported \u2013 but that sounds like a distinct issue.\n\nthere is no mention of SolrCloud in this bug report \u2013 this is purely a problem of using rollback with tlog, even on single node instances. "
        },
        {
            "author": "Mark Miller",
            "id": "comment-13673716",
            "date": "2013-06-03T22:43:28+0000",
            "content": "Yeah, fair enough - when I see stuff around tlog and optimistic concurrency, I think SolrCloud. And I think some of the reasons SolrCloud does not support rollback involves the transaction log and optimistic concurrency and these types of things - so the challanges may extend to single node instances when using these features.\n\nYonik Seeley ? "
        },
        {
            "author": "Yonik Seeley",
            "id": "comment-13673741",
            "date": "2013-06-03T22:59:19+0000",
            "content": "Rollback is never going to be a \"first class\" feature... there's no transaction isolation, so it only going to make sense for people that have complete control / coordination over all indexing clients.  If that's the case, optimistic concurrency isn't needed.\n\nI think we can improve rollback support by dropping all the internal tlog state and forcing open a new realtime reader (basically, what the delete-by-query code does), but that's probably the extent of it.  The vast majority of people should not use \"rollback\". "
        },
        {
            "author": "Mark Miller",
            "id": "comment-13673764",
            "date": "2013-06-03T23:20:39+0000",
            "content": "we can improve rollback support by dropping all the internal tlog state and forcing open a new realtime reader \n\nOkay - I can open a JIRA issue for that then. Because as it is, it seems we have to say anything that uses the update log does not support rollback - SolrCloud or not.\n\nRollback is never going to be a \"first class\" feature... there's no transaction isolation\n\nI don't really follow that - commit is the same way, so it seems rollback is just as first class in that regard - it's something you have to understand, but rollback is still simply the same as commit to me - you have one global transaction to work with.  "
        },
        {
            "author": "Mark Miller",
            "id": "comment-13673767",
            "date": "2013-06-03T23:22:12+0000",
            "content": "but that's probably the extent of it\n\nI think that's actually all people would hope for - I thought there where actually some other more esoteric reasons you might have problems (w/ SolrCloud and rollbacks). "
        },
        {
            "author": "Mark Miller",
            "id": "comment-13673779",
            "date": "2013-06-03T23:32:03+0000",
            "content": "I created SOLR-4895.\n\nThere are other issues - for one, I dont think we distribute rollback requests at all like we do commits - its likely to one node. Also, since using the tlog kind of begs for auto hard commit, thats not really a happy friend to rollback. "
        },
        {
            "author": "Yonik Seeley",
            "id": "comment-13673804",
            "date": "2013-06-03T23:48:07+0000",
            "content": "wrt transaction isolation & commit, one client can always make another client's changes visible, and that's usually never been a big deal.  Throw rollbacks into the equation and those clients had better be working together since one client undoing another clients updates (at the last arbitrary commit point) seems much more problematic.\n\nwrt cloud mode, there's probably a lot of edge cases we haven't considered when rollbacks come into play... peer sync stuff, recovery using whole index replication and then getting a rollback in the middle of buffering updates, etc.   "
        },
        {
            "author": "Mark Miller",
            "id": "comment-13673817",
            "date": "2013-06-03T23:54:09+0000",
            "content": "\nwrt transaction isolation & commit, one client can always make another client's changes visible, and that's usually never been a big deal. Throw rollbacks into the equation and those clients had better be working together since one client undoing another clients updates (at the last arbitrary commit point) seems much more problematic.\n\nEh ... it's not the end of the world if you commit on someone else, but when you consider the idea of commit is generally that your docs dont go in unless you do it, I really see it as the same issue as rollback. You simply have to understand Lucene/Solr has one global transaction in both cases.\n\nwrt cloud mode,\n\nYeah, I kind of caught the idea that you may only have been clearing the updatelog for rollback and not cloud - which is why I created 2 new issues.\n\nI still think the auto hard commit that the updatelog wants makes supporting rollback even in the single node case a large problem though.\n\nI'm halfway back to wanting to boot it for all modes  "
        },
        {
            "author": "Arcadius Ahouansou",
            "id": "comment-14577088",
            "date": "2015-06-08T12:04:14+0000",
            "content": "Any progress on this issue?\nHaving rollback() in SolrCloud would be a very usefuly feature.\nIMHO, a rolling back all uncommited changes from other clients is OK as it is consistent with the way commit() works at the moment. "
        }
    ]
}