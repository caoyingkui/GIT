{
    "id": "LUCENE-4396",
    "title": "BooleanScorer should sometimes be used for MUST clauses",
    "details": {
        "components": [],
        "fix_versions": [],
        "affect_versions": "None",
        "priority": "Major",
        "labels": "",
        "type": "Improvement",
        "resolution": "Unresolved",
        "status": "Open"
    },
    "description": "Today we only use BooleanScorer if the query consists of SHOULD and MUST_NOT.\n\nIf there is one or more MUST clauses we always use BooleanScorer2.\n\nBut I suspect that unless the MUST clauses have very low hit count compared to the other clauses, that BooleanScorer would perform better than BooleanScorer2.  BooleanScorer still has some vestiges from when it used to handle MUST so it shouldn't be hard to bring back this capability ... I think the challenging part might be the heuristics on when to use which (likely we would have to use firstDocID as proxy for total hit count).\n\nLikely we should also have BooleanScorer sometimes use .advance() on the subs in this case, eg if suddenly the MUST clause skips 1000000 docs then you want to .advance() all the SHOULD clauses.\n\nI won't have near term time to work on this so feel free to take it if you are inspired!",
    "attachments": {
        "LUCENE-4396.patch": "https://issues.apache.org/jira/secure/attachment/12640212/LUCENE-4396.patch",
        "all.perf": "https://issues.apache.org/jira/secure/attachment/12657029/all.perf",
        "perf.png": "https://issues.apache.org/jira/secure/attachment/12660629/perf.png",
        "AndOr.tasks": "https://issues.apache.org/jira/secure/attachment/12644311/AndOr.tasks",
        "stat.cpp": "https://issues.apache.org/jira/secure/attachment/12655537/stat.cpp",
        "SIZE.perf": "https://issues.apache.org/jira/secure/attachment/12655538/SIZE.perf",
        "luceneutil-score-equal.patch": "https://issues.apache.org/jira/secure/attachment/12644312/luceneutil-score-equal.patch",
        "merge-simple.png": "https://issues.apache.org/jira/secure/attachment/12662047/merge-simple.png",
        "merge.perf": "https://issues.apache.org/jira/secure/attachment/12660790/merge.perf",
        "merge.png": "https://issues.apache.org/jira/secure/attachment/12660791/merge.png",
        "And.tasks": "https://issues.apache.org/jira/secure/attachment/12648146/And.tasks",
        "tasks.cpp": "https://issues.apache.org/jira/secure/attachment/12659620/tasks.cpp",
        "LUCENE-4396-simple.patch": "https://issues.apache.org/jira/secure/attachment/12662046/LUCENE-4396-simple.patch",
        "merge-simple.perf": "https://issues.apache.org/jira/secure/attachment/12662045/merge-simple.perf"
    },
    "issue_links": {},
    "comments": [
        {
            "date": "2014-03-14T16:20:47+0000",
            "content": "There's a GSoC proposal for this: http://www.google-melange.com/gsoc/proposal/review/org/google/gsoc2014/dhuang/5629499534213120\n\nI'm happy to be a mentor for this project. ",
            "author": "Michael McCandless",
            "id": "comment-13935203"
        },
        {
            "date": "2014-03-15T01:50:01+0000",
            "content": "I have just set the GSoC proposal's visibility as Public, and the public URL is this: http://www.google-melange.com/gsoc/proposal/public/google/gsoc2014/dhuang/5629499534213120 ",
            "author": "Da Huang",
            "id": "comment-13935929"
        },
        {
            "date": "2014-03-17T02:14:14+0000",
            "content": "I'm revising and polishing my proposal these days, and I have discovered an interesting thing. That is: if BooleanScorer supports required scorers in the way I have proposed, docIDs would be in acsending order in the bucket table. I think this can make BooleanScorer be a Not-Top Scorer, as .advance() .docID() .nextDoc() etc. can be implemented. However, I'm not sure how it would affect the performance when it acts as a Not-Top Scorer. This is because when .nextDoc() or .advance() is called, BooleanScorer may calculate a 2K window whose data may not be all useful.\n\nI hope I have made my idea clear. ",
            "author": "Da Huang",
            "id": "comment-13937412"
        },
        {
            "date": "2014-03-17T11:11:59+0000",
            "content": "Da, that's a great discovery.\n\nSo, in the case where at least one MUST clause is present, BS will in fact collect in-order, and then BS could be embedded in other queries that want a sub-scorer.\n\nThis may force us to more strongly separate the notion of \"force doc-at-a-time scoring\" (LUCENE-2684), since today the \"sneaky\" way to do this is return false from your Collector.acceptsDocsOutOfOrder.\n\nI think you should be careful in your proposal to keep this issue well-scoped.  I.e., the overall goal is to let BS handle MUST clauses in certain causes (heuristic needs to decide this), and then a nice-to-have is to enable BS too also be a sub-scorer in some cases. ",
            "author": "Michael McCandless",
            "id": "comment-13937683"
        },
        {
            "date": "2014-03-19T09:33:02+0000",
            "content": "Hi, Mike. \n\nI have just finished revising my proposal. I'm not so sure about the decription on this page \"unless the MUST clauses have very low hit count compared to the other clauses, that BooleanScorer would perform better than BooleanScorer2.\".\n\nIn my opinion, even when MUST clauses have very low hit count compared to the other clauses, BooleanScorer is likely to perform better than BooleanScorer2, because the calling on .advance() when dealing with SHOULD clauses can skip documents as many as BooleanScorer2 does.\n\nRelevant ideas is described in the session \"Improve the Rule for Choosing Scorer\". As it's not very consistent with the description on this page, I'm not sure whether my idea makes sense. ",
            "author": "Da Huang",
            "id": "comment-13940342"
        },
        {
            "date": "2014-03-19T10:07:19+0000",
            "content": "Thanks Da, the new iteration on the proposal looks awesome; I left a comment there!\n\nYou're right: if we do use .advance on the sub-scorers, then even in the case where a conjunction clause has very low cost, BS should still be competitive. ",
            "author": "Michael McCandless",
            "id": "comment-13940357"
        },
        {
            "date": "2014-03-20T14:38:27+0000",
            "content": "Sorry for my late reply. I have been thinking about the new code/design on the trunk these days. \n\nThe new code breaks out BulkScorer from Scorer, and it is necessary to create a new BooleanScorer (a Scorer), just as you said. I'm afraid that we do have to take Scorer instead as subScorer in the new BooleanScorer. And yes: BooleanBulkScorer should not be embeded as its docIDs are out of order. My idea is to keep BooleanBulkScorer just supporting no-MUST-clause case, and let the new BooleanScorer to deal with the case where there is at least one MUST clause. I think this is one of the best ways to be compatible with the current design.\n\nBesides, I'm afraid that the name of BulkScorer may be confusing. The new BooleanScorer is also implemented by scoring a range of documents at once, but it actually can act as Sub-Scorer. ",
            "author": "Da Huang",
            "id": "comment-13941775"
        },
        {
            "date": "2014-03-20T23:05:32+0000",
            "content": "Using BooleanScorer (a Scorer) when there is one or more MUST makes sense I think, but we need to test perf.  It could be letting BooleanBulkScorer also handle MUST gives a good performance gain, in which case we could let both handle it ...\n\nBesides, I'm afraid that the name of BulkScorer may be confusing. \n\nThat's a good point ... for a while on that issue we had the name TopScorer ... maybe we need to revisit that  ",
            "author": "Michael McCandless",
            "id": "comment-13942481"
        },
        {
            "date": "2014-03-21T00:27:28+0000",
            "content": "I'm afraid that if BooleanBulkScorer also handle MUST, it couldn't make use of .advance(), as its subScorers are BulkScorer which could not call .advance(). ",
            "author": "Da Huang",
            "id": "comment-13942577"
        },
        {
            "date": "2014-03-21T02:23:38+0000",
            "content": "A new iteration on the proposal has just been submitted. The new iteration has added a part \"Supplementary Notes\" to describe how to fit my design to the new design on the current lucene trunk, such as renaming BooleanScorer to BooleanBulkScorer, creating a new BooleanScorer extended from Scorer. ",
            "author": "Da Huang",
            "id": "comment-13942684"
        },
        {
            "date": "2014-03-21T09:55:55+0000",
            "content": "I'm afraid that if BooleanBulkScorer also handle MUST, it couldn't make use of .advance(), as its subScorers are BulkScorer which could not call .advance().\n\nThat's true ... but then in some cases I think using advance will hurt, e.g. MUST of a very common term with SHOULD of rare term(s).  And if the bulk scorer really is the top scorer, advance isn't needed.  Tricky \n\nThe supplemental section in the proposal looks good!  I put a small comment on the proposal... ",
            "author": "Michael McCandless",
            "id": "comment-13942924"
        },
        {
            "date": "2014-03-21T11:17:54+0000",
            "content": "Oh, that's very true. According to the current design, using advance will hurt in such case.\n\nHowever, I think such case may be able to be solved by building a skipping list on MUST-all-hit bulks and skipping MUST-all-hit bulks when scanning SHOULD, but I haven't made this idea very clear in my mind. So making BooleanBulkScorer is still necessary now. ",
            "author": "Da Huang",
            "id": "comment-13942978"
        },
        {
            "date": "2014-04-15T06:40:12+0000",
            "content": "BooleanScorer can support MUST clause (ie. requiredScorers) now.\nThe patch is based on commit 9e87821edeb3e24ca8dedaecf856f6510d61d0d3 on github. ",
            "author": "Da Huang",
            "id": "comment-13969267"
        },
        {
            "date": "2014-04-15T10:36:49+0000",
            "content": "Currently, I pass \"List<Scorer> requiredScorers\" to BooleanScorer, and merge them as ConjunctionScorer.\n\nFor consistency, I should probably change the argument from \"List<Scorer> requiredScorers\" to \"List<BulkScorer> requiredScorers\", but, as a result, getScorer method should be added to BulkScorer.\nBesides, I removed the static statement on BooleanScorerCollector and BucketTable, because I have to refer the member \"requiredNrMatchers\" of BooleanScorer. But, I'm so sure whether removing the static statement is a proper option. ",
            "author": "Da Huang",
            "id": "comment-13969418"
        },
        {
            "date": "2014-04-15T21:42:26+0000",
            "content": "This looks great!  Tests pass for me.\n\nChanging from static so you can access requiredNrMatchers seems fine;\nwe could also pass that into the class & save it.  Either way ...\n\nThe comment for REQUIRED_MASK needs fixing.\n\nMaybe add a comment where we return null if requiredSubScorer is null\nexplaining why?\n\nHmm that pre-existing comment \"// Check if we can and should return a\nBooleanScorer\" is wrong ... I'll fix.\n\nSmall styling issue: we don't put whitespace after ( and before ),\ne.g.:\n\n\n    if ( this.requiredNrMatchers > 0 ) {\n\n\n\nshould be this instead:\n\n\n    if (this.requiredNrMatchers > 0) {\n\n\n\nMaybe change:\n\n     if (current.coord >= minNrShouldMatch + requiredNrMatchers) {\n\n\n\nto:\n\n\n     if (current.coord - requiredNrMatchers >= minNrShouldMatch) {\n\n\n\nAnd add a comment saying \"minNrShouldMatch only applies to SHOULD\nclauses\", or something?  Just to make the math more obvious \n\n\nFor consistency, I should probably change the argument from \"List<Scorer> requiredScorers\" to \"List<BulkScorer> requiredScorers\", but, as a result, getScorer method should be added to BulkScorer.\n\nHmm in general a BulkScorer need not implement a Scorer under the hood\n(DefaultBulkScorer does, because it wraps, but e.g. BooleanScorer\ndoesn't).\n\nOr alternatively if you pass List<BulkScorer> you could handle all the\nconjunctions yourself in BooleanScorer, e.g. make different collectors\nfor them that add up a \"mustClauseCountMatches\" counter (instead of\nsetting the 1 bit mask), and then check if that counts is >=\nrequiredScorers.size() before counting it as a hit...\n ",
            "author": "Michael McCandless",
            "id": "comment-13970091"
        },
        {
            "date": "2014-04-15T23:29:16+0000",
            "content": "These suggestions are very helpful. Thank you.\n\nAdding up a \"mustClauseCountMatches\" counter would be low-efficient, as it can not make use of list skippings.\nHow about implementing getScorer returning null for BulkScorer, while returning the scorer for DefaultBulkScorer.\nI'm not very sure whether passing List<BulkScorer> instead of List<Scorer> is really necessary.\nSo I think this issue should probably be just set aside for now. ",
            "author": "Da Huang",
            "id": "comment-13970193"
        },
        {
            "date": "2014-04-28T01:30:58+0000",
            "content": "I create a new class named BooleanNovelScorer in this iteration.\nThis scorer is based on the techinque of BooleanScorer, but can make use of the skipping list while collecting documents.\nMoreover, it is a subclass of Scorer which can act as a non-top scorer.\nHowever, the performance is low now, because I have not implemented its .advance() in a efficent way. ",
            "author": "Da Huang",
            "id": "comment-13982697"
        },
        {
            "date": "2014-04-29T16:25:27+0000",
            "content": "Thanks Da, this looks neat!\n\nHmm, the patch didn't cleanly apply, but I was able to work through\nit.  I think your dev area is not up to date with trunk?\n\nSmall code style things: can you try to add { .. } around the\ntrue/else body of if statements, even if they are only one line?\nAnd also no whitespace around the condition.  E.g. instead of:\n\n\n      if ( required.size() > 0 )\n        return new BooleanNovelScorer(this, disableCoord, minNrShouldMatch, required, optional, prohibited, maxCoord);\n\n\n\ndo this:\n\n\n      if (required.size() > 0) {\n        return new BooleanNovelScorer(this, disableCoord, minNrShouldMatch, required, optional, prohibited, maxCoord);\n      }\n\n\n\nSo it looks like BooleanNovelScorer is able to be a Scorer because the\nlinked-list of visited buckets in one window are guaranteed to be in\ndocID order, because we first visit the requiredConjunctionScorer's\ndocs in that window.\n\nHave you tested performance when the .advance method here isn't called?\nIe, just boolean queries w/ one MUST and one or more SHOULD?  I think\nthe important question here is whether/in what cases the\nBooleanNovelScorer approach beats BooleanScorer2 performance?\n\nI realized LUCENE-4872 is related here, i.e. we should also sometimes\nuse BooleanScorer for the minShouldMatch>1 case. ",
            "author": "Michael McCandless",
            "id": "comment-13984459"
        },
        {
            "date": "2014-04-30T07:59:29+0000",
            "content": "Thanks for your suggestions, Mike. And sorry for my late reply.\n\nHmm, the patch didn't cleanly apply, but I was able to work through\nit. I think your dev area is not up to date with trunk?\nI haven't merged my branch to the newest trunk version, because my network account at school for April has been run out and I couldn't pull the code from github untill 1 May. Sorry for that.\n\nSmall code style things\nI'm very sorry for the code style. That's my fault. Very sorry for that.\n\nSo it looks like BooleanNovelScorer is able to be a Scorer because the\nlinked-list of visited buckets in one window are guaranteed to be in\ndocID order, because we first visit the requiredConjunctionScorer's\ndocs in that window.\nYes, you're right.\n\nHave you tested performance when the .advance method here isn't called?\nIe, just boolean queries w/ one MUST and one or more SHOULD? \nNo, I haven't. Do you mean the .advance method of subScorers in BooleanNovelScorer?\nIf so, I will do that. \nIf you mean the .advance method of BooleanNovelScorer itself, I think it would be confusing, \nbecause BooleanNovelScorer now is used when there's at least one MUST clause, \nno matter whether it acts as a top scorer or not. Therefore, .advance() of BooleanNovelScorer \nmust be called when BooleanNovelScorer acts as a non-top scorer. \n\n I think the important question here is whether/in what cases the\nBooleanNovelScorer approach beats BooleanScorer2 performance?\nYes, you're right. But BooleanNovelScorer has not been totally finished, and the performance itself \nremans to be improved especially its .advance method.\n\nI realized LUCENE-4872 is related here, i.e. we should also sometimes\nuse BooleanScorer for the minShouldMatch>1 case.\nYes, I also notice that.  I think this issue should be dealed with together. ",
            "author": "Da Huang",
            "id": "comment-13985254"
        },
        {
            "date": "2014-04-30T15:26:10+0000",
            "content": "I haven't merged my branch to the newest trunk version, because my network account at school for April has been run out and I couldn't pull the code from github untill 1 May. Sorry for that.\n\nGood grief, that's awful you have to \"budget\" your allowed network\naccess month by month ... don't worry about it, it's easy to apply\nthe patch.  Alternatively, just add a pointer here to your github fork\nand we can clone from there to review?\n\nI'm very sorry for the code style. That's my fault. Very sorry for that.\n\nNo need to apologize; it's just code style ... everyone has their own,\nbut we have a standard one in Lucene so we don't spend all our time\nfighting over whose style is best \n\n\nIf you mean the .advance method of BooleanNovelScorer itself, I think it would be confusing, \nbecause BooleanNovelScorer now is used when there's at least one MUST clause, \nno matter whether it acts as a top scorer or not. Therefore, .advance() of BooleanNovelScorer \nmust be called when BooleanNovelScorer acts as a non-top scorer.\n\nYeah I meant BNS.advance, when it's a top scorer.  Ie, can BNS beat\nBS2 in this case.  It seems like you could test this case now since as\na topScorer nobody would call the unfinished BNS.advance method.  This\nway, if BNS can beat BS2 in this case we know it's worth pursuing.\n\nI think this issue should be dealed with together.\n\n+1, but only if time this summer permits (i.e. top priority is this\nissue, allowing BS to accept MUST clauses). ",
            "author": "Michael McCandless",
            "id": "comment-13985615"
        },
        {
            "date": "2014-05-11T00:51:10+0000",
            "content": "The patch is based on the github mirror commit c1e423e45e6fa9f846ab2c382c0100fd515b4cb1.\n\nThe following things are done in this patch:\n\n1. Fix the bug on last patch. The bug is due to not setting prev and next to null before add an element to a linked list.\n\n2. Refine the code style.\n\n3. Make a small improvement on .advance(). The performance is a little better than the last patch, but still worse than the trunk, when testing on luceneutil.\n\nP.S. The bug on last patch can not be detected by ant-test, but can be found by running query like \"+a b\" on luceneutil. I'm getting to add a junit test case which can detect the bug, but it may take me some days. ",
            "author": "Da Huang",
            "id": "comment-13994362"
        },
        {
            "date": "2014-05-11T00:53:48+0000",
            "content": "luceneutil tasks file to test queries like \"+a b c d e ...\"\n\nThe performance shows as follows.\n\n\n\n    TaskQPS \n baseline \n     StdDevQPS \n my_modified_version \n     StdDev \n               Pct diff \n\n\n HighAndManyLowOr    \n     8.50    \n   (3.3%)    \n     1.72    \n   (0.3%) \n  -79.8% ( -80% -  -78%) \n\n\n           PKLookup    \n   239.75   \n    (0.9%)  \n     239.99    \n   (0.9%)  \n   0.1% (  -1% -    1%) \n\n\n    LowAndManyHighOr    \n     7.11    \n   (1.4%)   \n      7.76    \n   (1.4%)  \n   9.1% (   6% -   12%) \n\n\n        LowAndManyLowOr    \n    33.83    \n   (0.7%)   \n     41.03    \n   (2.7%)  \n  21.3% (  17% -   24%) \n\n\n    HighAndManyHighOr    \n     0.12   \n    (0.7%)      \n   0.29   \n    (7.8%) \n  148.0% ( 138% -  157%) \n\n\n\n ",
            "author": "Da Huang",
            "id": "comment-13994363"
        },
        {
            "date": "2014-05-11T00:59:36+0000",
            "content": "A patch for luceneutil, which allows scores is different within a tolerance range. ",
            "author": "Da Huang",
            "id": "comment-13994366"
        },
        {
            "date": "2014-05-12T11:40:01+0000",
            "content": "Add TestBooleanNovelScorer.java to detect the bug on the second patch. ",
            "author": "Da Huang",
            "id": "comment-13995009"
        },
        {
            "date": "2014-05-14T14:49:55+0000",
            "content": "I like this tasks file!\n\nBut, maybe we could test on fewer terms, for the\nLow/HighAndManyLow/High tasks?  I think it's more common to have a\nhandful (3-5 maybe) of terms.  But maybe keep your current category\nand rename it to Tons instead of Many?\n\nThank you for adding the test case; it's always disturbing when\nluceneutil finds a bug that \"ant test\" doesn't!  Maybe we can improve\nthe test so that it exercises BS and NBS?  E.g., toggle the \"require\ndocs in order\" via a custom collector?  We could commit this test today\nto trunk/4x right?\n\nA patch for luceneutil, which allows scores is different within a tolerance range.\n\nHmm do we know why the scores changed?  Are we comparing BS2 to\nNovelBS?  (I think BS and BS2 already have different scores today?).\n\nSo, with these changes, BS (a BulkScorer) can handle required clauses\n(but you commented this out in your patch in order to test NBS I\nguess?), and NBS (a Scorer) can handle required too.\n\nDo you have any perf results of BS w/ required clauses (as a\nBulkScorer) vs BS2 (what trunk does today)? ",
            "author": "Michael McCandless",
            "id": "comment-13997609"
        },
        {
            "date": "2014-05-15T12:52:40+0000",
            "content": "Thanks for your suggestions!\n\n\nmaybe we could test on fewer terms, for the\nLow/HighAndManyLow/High tasks? I think it's more common to have a\nhandful (3-5 maybe) of terms.\nWhen terms are few, BooleanNovelScorer performs slower than BS (about -10%).\nHowever, I have to generate tasks with fewer terms and rerun the tasks to reconfirm\nthe specific perf. difference.\n\n\n But maybe keep your current category\nand rename it to Tons instead of Many?\nOK, I will do so.\n\n\nMaybe we can improve\nthe test so that it exercises BS and NBS? E.g., toggle the \"require\ndocs in order\" via a custom collector?\nYes, I think that's a good idea.\n\n\nHmm do we know why the scores changed?\nYes, it's because the calculating orders are different. \nBS adds up scores of all SHOULD clauses, and then add their sum to the final score.\nBNS adds score of each SHOULD clause to final score one by one.\n\n\nAre we comparing BS2 to NovelBS?\nYes.\n\n\nI think BS and BS2 already have different scores today?\nYes. Actually, the score calculating order of BS is the same as BNS.\n\n\nbut you commented this out in your patch in order to test NBS I\nguess?\nyes, I did that in order to test BNS. Otherwise, luceneutil would throw exception.\n\n\nDo you have any perf results of BS w/ required clauses (as a\nBulkScorer) vs BS2 (what trunk does today)?\nHmm, I haven't carried out such experiment yet. Checking the perf. results of BS vs BS2 \nis a good idea. I will do that.   \n ",
            "author": "Da Huang",
            "id": "comment-13998736"
        },
        {
            "date": "2014-05-19T08:25:45+0000",
            "content": "\nWhen terms are few, BooleanNovelScorer performs slower than BS (about -10%).\nHowever, I have to generate tasks with fewer terms and rerun the tasks to reconfirm\nthe specific perf. difference.\n\nOK, interesting.  It may be BooleanNovelScorer doesn't work out, and we \"just\" focus on BooleanScorer handling MUST.\n\n\nbut you commented this out in your patch in order to test NBS I guess?\n\nyes, I did that in order to test BNS. Otherwise, luceneutil would throw exception.\n\nOK, maybe add a comment just saying something \"temporarily commented out so NovelBS is invoked instead of BS\"?  And what exception did luceneutil throw...?\n\nHmm, I haven't carried out such experiment yet. Checking the perf. results of BS vs BS2 \nis a good idea. I will do that.\n\nThank you! ",
            "author": "Michael McCandless",
            "id": "comment-14001487"
        },
        {
            "date": "2014-05-19T11:30:09+0000",
            "content": "Thanks for your reply.\nOK, maybe add a comment just saying something \"temporarily commented out so NovelBS is invoked instead of BS\"?\nI will comment that.\n And what exception did luceneutil throw...?\nIt just says that \"hit %s has wrong field/score value %s vs %s\", and the perf. test abort. And the score value diff. is about 0.000001 . ",
            "author": "Da Huang",
            "id": "comment-14001595"
        },
        {
            "date": "2014-05-19T13:47:43+0000",
            "content": "It just says that \"hit %s has wrong field/score value %s vs %s\", and the perf. test abort. And the score value diff. is about 0.000001 .\n\nAhh, OK \"just\" the score diff between BS and BS2.\n\nI'm nervous about the luceneutil change, just because I don't want to \"encourage\" complacency on scores being different in general. ",
            "author": "Michael McCandless",
            "id": "comment-14001694"
        },
        {
            "date": "2014-05-19T14:01:34+0000",
            "content": " I'm nervous about the luceneutil change, just because I don't want to \"encourage\" complacency on scores being different in general. \nI agree. but it seems that the original perf. tasks file has too few items on each case to discover scores' difference, when the scorer's calculating orders are different. \nActually, if I decrease the items in my tasks file on each case to 3, the scores are the same with the trunk. ",
            "author": "Da Huang",
            "id": "comment-14001706"
        },
        {
            "date": "2014-05-19T17:06:53+0000",
            "content": "About the scoring differences: I think it might be enough to fix the TODO in ConjunctionScorer.score() ? ",
            "author": "Robert Muir",
            "id": "comment-14001992"
        },
        {
            "date": "2014-05-19T23:54:29+0000",
            "content": "Thanks for your advice, Robert.\nDo you mean just changing\n\nfloat sum = 0.0f;\n\n\nto \n\ndouble sum = 0.0f;\n\n\n ?\n\nHowever, I'm not sure doing this will really be enough for scoring differences, as the differences are due to different calculating order. ",
            "author": "Da Huang",
            "id": "comment-14002604"
        },
        {
            "date": "2014-05-20T00:03:46+0000",
            "content": "I think its enough in practice: its not expensive and it reduces the problem significantly. This is already the \"hack\" in use so that BooleanScorer and BooleanScorer2 have comparable scores: LUCENE-4327 ",
            "author": "Robert Muir",
            "id": "comment-14002611"
        },
        {
            "date": "2014-05-20T00:13:00+0000",
            "content": "Oh, thanks. I think it\u2018s worth a try. ",
            "author": "Da Huang",
            "id": "comment-14002620"
        },
        {
            "date": "2014-05-25T08:41:07+0000",
            "content": "The patch is based on lucene github mirror commit cfb408ff6788e6fea8215098a785d72fb4e95c5b.\n\nThe following things have been done:\n\n1. Rename TestBooleanNovelScorer to TestBooleanUnevenly, and this test suit test both BNS and BS when hit documents' distribution is unevenly.\n\n2. Following Robert's advice, I sum scores into a double and cast to float in ConjunctionScorer. However, it seems to take little effect. Scores difference problem still remain.\n\n3. Add a comment to scores difference within tolerance on luceneutil.\n\n4. Make a new tasks file, which can test \"AndSomeOR\" cases.\n\n5. Run luceneutil for \"BNS vs BS2\" and \"BS vs BS2\". The result is showed as follows.\n\nP.S. BS has the same problem with score difference as BNS.\nAlthrough there's no BS2 now as the architecture has changed, here I still call it BS2 for convenience.\n\n\nBNS vs BS2\n\n                    TaskQPS baseline      StdDevQPS my_modified_version      StdDev                Pct diff\n        HighAndTonsLowOr       10.95      (3.5%)        1.52      (0.3%)  -86.1% ( -86% -  -85%)\n        HighAndSomeLowOr       29.98      (6.7%)       11.84      (2.9%)  -60.5% ( -65% -  -54%)\n         LowAndSomeLowOr      756.81      (1.4%)      503.21      (2.8%)  -33.5% ( -37% -  -29%)\n        LowAndSomeHighOr       54.25      (2.1%)       53.26      (2.1%)   -1.8% (  -5% -    2%)\n                PKLookup      241.74      (2.8%)      241.96      (2.3%)    0.1% (  -4% -    5%)\n         LowAndTonsLowOr       40.23      (1.2%)       43.19      (7.2%)    7.4% (   0% -   15%)\n        LowAndTonsHighOr        2.63      (2.1%)        2.99      (2.3%)   13.8% (   9% -   18%)\n       HighAndSomeHighOr        4.99      (1.8%)        5.86      (4.7%)   17.4% (  10% -   24%)\n       HighAndTonsHighOr        0.09      (1.5%)        0.22      (8.1%)  145.4% ( 133% -  157%)\n\n\nBS vs BS2\n\n                    TaskQPS baseline      StdDevQPS my_modified_version      StdDev                Pct diff\n        HighAndTonsLowOr       16.54      (2.4%)        3.70      (0.2%)  -77.6% ( -78% -  -76%)\n        HighAndSomeLowOr       11.95      (8.5%)        4.29      (0.8%)  -64.1% ( -67% -  -59%)\n         LowAndSomeLowOr      839.11      (1.9%)      540.83      (2.5%)  -35.5% ( -39% -  -31%)\n        LowAndSomeHighOr      149.50      (2.6%)      136.71      (3.4%)   -8.6% ( -14% -   -2%)\n       HighAndSomeHighOr        3.72      (1.7%)        3.51      (1.7%)   -5.6% (  -8% -   -2%)\n                PKLookup      240.32      (2.8%)      238.87      (2.8%)   -0.6% (  -6% -    5%)\n        LowAndTonsHighOr        4.96      (2.3%)        5.35      (3.8%)    7.8% (   1% -   14%)\n         LowAndTonsLowOr       35.28      (1.2%)       39.00      (5.2%)   10.6% (   4% -   17%)\n       HighAndTonsHighOr        0.16      (1.1%)        0.36      (4.0%)  122.6% ( 116% -  129%)\n\n ",
            "author": "Da Huang",
            "id": "comment-14008299"
        },
        {
            "date": "2014-06-03T13:23:54+0000",
            "content": "A patch based on lucene github mirror commit cf10341825ff6bd1662dd48c51926bc51d751ce5.\n\nI use a bitset to skip required docs when scaning optional and prohibited docs. The perf. comparison is at the bottom.\n\nBesides, I build a new tasks file the test the perf. and I discover that BNS optimize the \"+a -b -c -d ...\" case a lot, when \"b c d ...\" hits many docs.\n\n\nBNS (without bitset) vs. BS2\n                    TaskQPS baseline      StdDevQPS my_version      StdDev                Pct diff\n       HighAndTonsLowNot        4.29      (2.9%)        1.08      (0.6%)  -74.8% ( -76% -  -73%)\n        HighAndTonsLowOr        4.87      (6.4%)        1.24      (1.0%)  -74.4% ( -76% -  -71%)\n       HighAndSomeLowNot        9.03      (5.2%)        4.11      (4.1%)  -54.4% ( -60% -  -47%)\n        HighAndSomeLowOr       16.21      (9.6%)        7.75      (4.1%)  -52.2% ( -60% -  -42%)\n         LowAndSomeLowOr      303.28      (2.4%)      183.14      (6.6%)  -39.6% ( -47% -  -31%)\n        LowAndSomeLowNot      257.24      (1.8%)      157.07      (6.5%)  -38.9% ( -46% -  -31%)\n        LowAndSomeHighOr       36.78      (1.9%)       33.74      (3.0%)   -8.3% ( -12% -   -3%)\n        LowAndTonsLowNot       21.28      (2.0%)       19.69      (6.9%)   -7.5% ( -16% -    1%)\n       LowAndSomeHighNot       34.40      (1.6%)       33.69      (3.2%)   -2.1% (  -6% -    2%)\n                PKLookup      100.63      (4.8%)      103.46      (4.7%)    2.8% (  -6% -   12%)\n        LowAndTonsHighOr        1.26      (1.6%)        1.41      (1.7%)   11.8% (   8% -   15%)\n         LowAndTonsLowOr       13.66      (0.9%)       15.50      (6.0%)   13.5% (   6% -   20%)\n      HighAndSomeHighNot        2.65      (1.4%)        3.12      (6.5%)   17.6% (   9% -   25%)\n       HighAndSomeHighOr        2.21      (2.4%)        2.62      (5.8%)   18.6% (  10% -   27%)\n       HighAndTonsHighOr        0.07      (0.8%)        0.19     (10.5%)  160.3% ( 147% -  172%)\n       LowAndTonsHighNot        2.86      (1.6%)       10.24     (18.1%)  257.7% ( 234% -  281%)\n      HighAndTonsHighNot        0.05      (0.8%)        0.40     (28.2%)  641.8% ( 607% -  676%)\n      \n\nBS vs. BS2\n                    TaskQPS baseline      StdDevQPS my_version      StdDev                Pct diff\n        HighAndTonsLowOr        4.02      (6.8%)        0.87      (0.5%)  -78.2% ( -80% -  -76%)\n       HighAndTonsLowNot        4.95      (3.4%)        1.29      (0.9%)  -73.9% ( -75% -  -72%)\n        HighAndSomeLowOr       14.45      (9.5%)        6.68      (3.7%)  -53.8% ( -61% -  -44%)\n       HighAndSomeLowNot       14.78      (5.1%)        7.48      (3.9%)  -49.4% ( -55% -  -42%)\n         LowAndSomeLowOr      316.55      (2.2%)      170.14      (5.6%)  -46.3% ( -52% -  -39%)\n        LowAndSomeLowNot      283.47      (1.7%)      157.35      (6.0%)  -44.5% ( -51% -  -37%)\n        LowAndSomeHighOr       39.39      (2.0%)       35.07      (3.1%)  -11.0% ( -15% -   -6%)\n       LowAndSomeHighNot       53.96      (2.0%)       48.57      (3.8%)  -10.0% ( -15% -   -4%)\n        LowAndTonsLowNot       17.97      (1.5%)       17.04      (6.0%)   -5.2% ( -12% -    2%)\n                PKLookup       97.57      (2.7%)      100.21      (5.2%)    2.7% (  -5% -   10%)\n        LowAndTonsHighOr        3.59      (1.7%)        3.74      (2.4%)    4.1% (   0% -    8%)\n         LowAndTonsLowOr       14.71      (1.3%)       15.63      (5.7%)    6.3% (   0% -   13%)\n      HighAndSomeHighNot        1.84      (1.3%)        2.05      (5.6%)   11.2% (   4% -   18%)\n       HighAndSomeHighOr        1.93      (2.1%)        2.16      (5.6%)   11.9% (   4% -   20%)\n       HighAndTonsHighOr        0.05      (1.0%)        0.13     (14.1%)  144.8% ( 128% -  161%)\n       LowAndTonsHighNot        1.63      (1.9%)        4.95      (7.2%)  204.0% ( 191% -  217%)\n      HighAndTonsHighNot        0.06      (1.0%)        0.34     (18.2%)  459.6% ( 435% -  483%)\n\n\nBNS (with bitset) vs. BS2\n                    TaskQPS baseline      StdDevQPS my_version      StdDev                Pct diff\n        HighAndSomeLowOr        7.45     (12.0%)        3.49      (6.6%)  -53.1% ( -64% -  -39%)\n       HighAndSomeLowNot       10.45      (8.0%)        5.25      (6.8%)  -49.7% ( -59% -  -37%)\n         LowAndSomeLowOr      310.53      (2.3%)      168.56      (5.8%)  -45.7% ( -52% -  -38%)\n        LowAndSomeLowNot      292.05      (2.3%)      165.88      (5.7%)  -43.2% ( -50% -  -36%)\n       HighAndTonsLowNot        5.94      (3.5%)        4.33      (6.8%)  -27.0% ( -36% -  -17%)\n        HighAndTonsLowOr        5.92      (4.4%)        4.39      (6.0%)  -25.9% ( -34% -  -16%)\n       LowAndSomeHighNot       53.79      (2.4%)       47.71      (2.8%)  -11.3% ( -16% -   -6%)\n        LowAndSomeHighOr       31.03      (2.6%)       28.20      (2.4%)   -9.1% ( -13% -   -4%)\n         LowAndTonsLowOr       18.58      (1.1%)       17.60      (6.2%)   -5.3% ( -12% -    2%)\n      HighAndSomeHighNot        1.49      (1.8%)        1.44      (8.9%)   -3.5% ( -13% -    7%)\n                PKLookup       96.96      (3.4%)      100.03      (5.1%)    3.2% (  -5% -   12%)\n        LowAndTonsHighOr        2.06      (2.2%)        2.18      (2.3%)    5.9% (   1% -   10%)\n        LowAndTonsLowNot       13.63      (1.3%)       14.57      (6.3%)    6.9% (   0% -   14%)\n       HighAndSomeHighOr        2.03      (2.4%)        2.33      (8.1%)   14.5% (   3% -   25%)\n       HighAndTonsHighOr        0.07      (0.8%)        0.17     (13.6%)  158.2% ( 142% -  174%)\n       LowAndTonsHighNot        1.40      (2.2%)        6.21     (11.3%)  344.2% ( 323% -  365%)\n      HighAndTonsHighNot        0.07      (1.1%)        0.46     (24.2%)  572.1% ( 540% -  604%)\n      \n      \n\n\n\n ",
            "author": "Da Huang",
            "id": "comment-14016491"
        },
        {
            "date": "2014-06-04T10:33:22+0000",
            "content": "Thanks Da!\n\nWhen you say \"BNS (without bitset) vs. BS2\" that means baseline=BS2\nand my_version=BNS (without bitset)?  I just want to make sure I have\nthe direction right!\n\nWith the added bitset, couldn't you not use a linked list anymore?\nIe, just use prev/nextSetBit.  I wonder if the bitset (instead of the\nlinked list) could also help BooleanScorer?  Maybe test this change\nseparately (e.g. just modify BS we have today on trunk) to see if it\nhelps or hurts... if it does help, it seems like BNS could be\nused (or BS could be a Scorer not a BulkScorer) even when there are no\nMUST clauses?  Ie, the bitset lets us easily keep the order.  Then we\ncan merge BS/BNS into one?\n\nCould you attach all new tasks as a single file in general?  Note that\nwhen you set up a luceneutil test, you can add a task filter using\naddTaskPattern, so you run just a subset of the tasks for that one\ntest.\n\nStrange that the scores are still different between BS/BS2 and BNS/BS2\nwhen using double.\n\nIf there's only 1 required clause sent to BS/BNS can't we use its scorer\ninstead?\n\nHave you explored having BS interact directly with all the MUST\nclauses, rather than using ConjunctionScorer?\n\nBecause we have wildly divergent results (sometimes one is much\nfaster, other times it's much slower) we will somehow need to add\nlogic to pick the right scorer for each query.  But we can defer this\nuntil we're \"doneish\" iterating the changes to each scorer... it can\ncome later on. ",
            "author": "Michael McCandless",
            "id": "comment-14017605"
        },
        {
            "date": "2014-06-04T13:54:50+0000",
            "content": "Thanks for your suggestions, Mike!\n\n\nWhen you say \"BNS (without bitset) vs. BS2\" that means baseline=BS2\nand my_version=BNS (without bitset)?\nYes, this is just what I mean.\n\n\nWith the added bitset, couldn't you not use a linked list anymore?\nIe, just use prev/nextSetBit. I wonder if the bitset (instead of the\nlinked list) could also help BooleanScorer? Maybe test this change\nseparately (e.g. just modify BS we have today on trunk) to see if it\nhelps or hurts... if it does help, it seems like BNS could be\nused (or BS could be a Scorer not a BulkScorer) even when there are no\nMUST clauses? Ie, the bitset lets us easily keep the order. Then we\ncan merge BS/BNS into one?\nOh, that's a good idea! I will try that. However, linked list can be helpful \nwhen required docs is extremly sparse.\n\n\nCould you attach all new tasks as a single file in general? Note that\nwhen you set up a luceneutil test, you can add a task filter using\naddTaskPattern, so you run just a subset of the tasks for that one\ntest.\nDo you mean merging And.tasks and AndOr.tasks ? If so, there's no need to\ndo that, because And.tasks contains all tasks in AndOr.tasks, although tasks'\nnames are changed.\nAll the way, thanks for the advice on using addTaskPattern. I haven't noticed that.\n\n\nStrange that the scores are still different between BS/BS2 and BNS/BS2\nwhen using double.\nI don't think it strange. Because the difference is due to the score calculating order.\nSupposed that a doc hits \"+a b c\", \nSCORE_BS = (float)((float)(double)score_a + (float)score_b) + (float)score_c, while \nSCORE_BS2 = (float)(double)score_a + ((float)score_b + (float)score_c). \nHere, (float) means that we can only get the score by .score() whose return type is float.\nThe modification on this patch can only make score_a has a temp double value.\n\n\nIf there's only 1 required clause sent to BS/BNS can't we use its scorer\ninstead?\nHave you explored having BS interact directly with all the MUST\nclauses, rather than using ConjunctionScorer?\nHmm. I don't think that would be helpful. The reason is just the same as above.\n\n\nBecause we have wildly divergent results (sometimes one is much\nfaster, other times it's much slower) we will somehow need to add\nlogic to pick the right scorer for each query. But we can defer this\nuntil we're \"doneish\" iterating the changes to each scorer... it can\ncome later on.\nYes, I agree. ",
            "author": "Da Huang",
            "id": "comment-14017708"
        },
        {
            "date": "2014-06-05T02:04:53+0000",
            "content": "About scores diff. on BS/BS2 (the same as BNS/BS2)\n\nNow, there's scores diff. on BS/BS2, when excuting query like \"+a b c d ...\".\n\nI have been told that the reason is indicate by \nthe TODO on ReqOptSumScorer.score() which says that\n\n// TODO: sum into a double and cast to float if we ever send required clauses to BS1\n\n\n\nHowever, I don't think so, as the score bias is due to\ndifferent score calculating orders.\n\nSupposed that a doc hits the query \"+a b c d\", the score calculated by BS is \n\nBS.score(doc) = ((a.score() + b.score()) + c.score()) + d.score()\n\n\nwhile the score calculated by BS2 is \n\nBS2.score(doc) = a.score() + (float)(b.score() + c.score() + d.score())\n\n\n\nNotice that, in BS2, we can only get the float value of (b.score() + c.score() + d.score())\nby reqScorer.score().\n\nFurthermore, I have noticed that actually we can control the BS's \nscore calulating order, so that \n\nBS.score(doc) = a.score() + ((b.score() + c.score()) + d.score())\n\n\nHowever, for BS2, we do not know the calculating order of \n(b.score() + c.score() + d.score()), as the order is determined by \nscorer's position in a heap. I still think this matters little.\n\nI will rearrange the calculating order of BS.score() at next patch, \nto see whether it works. ",
            "author": "Da Huang",
            "id": "comment-14018417"
        },
        {
            "date": "2014-06-08T22:53:35+0000",
            "content": "Thanks for the detailed explanation on the score differences Da.  I think you are right that order-of-operations (with float casts in between) explains the score differences.\n\n\nDo you mean merging And.tasks and AndOr.tasks ? If so, there's no need to\ndo that, because And.tasks contains all tasks in AndOr.tasks, although tasks'\nnames are changed.\n\nAhh, OK nevermind.\n\nHowever, linked list can be helpful when required docs is extremly sparse.\n\nTrue, but maybe in such cases (low freqs for the clauses) we should just use BS2.  I think BS/BNS do better for high-freq clauses?\n\n\nIf there's only 1 required clause sent to BS/BNS can't we use its scorer instead? Have you explored having BS interact directly with all the MUST clauses, rather than using ConjunctionScorer?\n\nHmm. I don't think that would be helpful. The reason is just the same as above.\n\nI think we may get better performance when the MUST clauses are high freq, if we just use BooleanScorer to enumerate all the matching docs for each MUST instead of going through ConjunctionScorer? ",
            "author": "Michael McCandless",
            "id": "comment-14021471"
        },
        {
            "date": "2014-06-09T01:04:03+0000",
            "content": "True, but maybe in such cases (low freqs for the clauses) we should just use BS2. I think BS/BNS do better for high-freq clauses?\nI'm sorry that I could not be sure whether it's ture now, as I haven't made a closer analysis on the perf results. \nThe perf of BS/BNS depends on many factors, such as freq of each clause and the number of SHOULD(and MUST_NOT) clauses.\n\nI think we may get better performance when the MUST clauses are high freq, if we just use BooleanScorer to enumerate all the matching docs for each MUST instead of going through ConjunctionScorer?\nI afraid that enumerating all the matching docs would not get better perf. \nIn fact, BS2 and ConjunctionScorer collect docs by the method called \"document-at-a-time\"(DAAT), \nwhile BS/BNS is something like a combination of DAAT and \"term-at-a-time\"(TAAT). \nFor conjunctive clauses, it's more efficient to use DAAT than TAAT, as DAAT scans fewer docs than TAAT. ",
            "author": "Da Huang",
            "id": "comment-14021505"
        },
        {
            "date": "2014-06-09T15:11:12+0000",
            "content": "In theory, yes, DAAT that BS2 does will visit fewer docs than BS/BNS, but in practice I think the cost of the PQ and .advance when the number of matching docs is high, might be higher. ",
            "author": "Michael McCandless",
            "id": "comment-14025265"
        },
        {
            "date": "2014-06-09T23:55:29+0000",
            "content": "Hmm. I mean ConjunctionScorer does not use PQ, and it can be faster to use it rather than enumerating all the matching docs for each MUST.\nAs for .advance, I'm not sure whether its cost can exceed .next much enough, so that using .advance will be slower than using .next in this case. ",
            "author": "Da Huang",
            "id": "comment-14025945"
        },
        {
            "date": "2014-06-10T14:35:54+0000",
            "content": "Hmm. I mean ConjunctionScorer does not use PQ\n\nAhhhh right.  Only Disjunctions.... OK.\n\nAs for .advance, I'm not sure whether its cost can exceed .next much enough, so that using .advance will be slower than using .next in this case.\n\nOK, let's not explore this ... ",
            "author": "Michael McCandless",
            "id": "comment-14026508"
        },
        {
            "date": "2014-06-21T01:26:08+0000",
            "content": "This is a patch based on git mirror commit 8f9b823db1d6fba2cc7ec61b0596970f3c8bbe85.\nThe following things are done in this patch.\n\n1. Solve the problem of score diff. between pure DAAT(ie. BS2, as BS2 does not exist now, I think it may be better to call it pure DAAT) and BS completely.\n\n2. Add a new Scorer named BooleanScorerInOrder which uses only bitset but not linked list to collect docs.\nI create this new Scorer but not change the old BS, because I think BS may be more useful in some cases.\nFor now, BSIO does not support the cases where there is no any MUST clause, because the procedure for such cases is totally different from cases with MUST clause.\n\nThe perf. of BSIO is as follows.\n\n                    TaskQPS baseline      StdDevQPS my_version      StdDev                Pct diff\n         LowAndSomeLowOr      259.82      (2.3%)      102.70      (2.8%)  -60.5% ( -64% -  -56%)\n        LowAndSomeLowNot      184.38      (2.8%)       80.26      (2.3%)  -56.5% ( -59% -  -52%)\n       HighAndSomeLowNot       10.44      (7.2%)        4.70      (4.3%)  -55.0% ( -61% -  -46%)\n        HighAndSomeLowOr       18.11      (8.0%)        8.83      (4.0%)  -51.2% ( -58% -  -42%)\n       HighAndTonsLowNot        3.03      (5.4%)        1.62      (4.7%)  -46.8% ( -53% -  -38%)\n        LowAndTonsLowNot       14.59      (1.2%)        8.86      (2.0%)  -39.3% ( -41% -  -36%)\n         LowAndTonsLowOr       14.11      (1.1%)        8.74      (3.0%)  -38.1% ( -41% -  -34%)\n        HighAndTonsLowOr        5.52      (4.3%)        3.85      (5.2%)  -30.2% ( -38% -  -21%)\n        LowAndSomeHighOr       24.97      (3.5%)       21.10      (3.2%)  -15.5% ( -21% -   -9%)\n       LowAndSomeHighNot       25.51      (3.3%)       23.22      (3.4%)   -9.0% ( -15% -   -2%)\n        LowAndTonsHighOr        1.66      (2.6%)        1.64      (2.8%)   -1.1% (  -6% -    4%) \n                PKLookup       95.22      (5.5%)       96.64      (6.1%)    1.5% (  -9% -   13%)\n      HighAndSomeHighNot        2.37      (2.0%)        2.55      (6.9%)    7.4% (  -1% -   16%)\n       HighAndSomeHighOr        2.25      (2.7%)        2.43      (6.0%)    7.8% (   0% -   16%)\n       LowAndTonsHighNot        2.72      (2.3%)        5.94      (5.8%)  118.4% ( 107% -  129%)\n       HighAndTonsHighOr        0.05      (0.8%)        0.12     (17.0%)  162.4% ( 143% -  181%)\n      HighAndTonsHighNot        0.08      (1.3%)        0.48     (23.4%)  507.0% ( 476% -  538%)\n\n ",
            "author": "Da Huang",
            "id": "comment-14039626"
        },
        {
            "date": "2014-06-21T09:12:03+0000",
            "content": "Solve the problem of score diff. between pure DAAT(ie. BS2, as BS2 does not exist now, I think it may be better to call it pure DAAT) and BS completely.\n\nThat's great news!  Looks like you separated required & optional\nscores in the non-DAAT impls and then carefully cast to float at the\nright times?  Also, you can remove that TODO in ConjunctionScorer on\nswitching sum to double?\n\nAdd a new Scorer named BooleanScorerInOrder which uses only bitset but not linked list to collect docs.\n\nSo BooleanScorerIO is just like BooleanNovelScorer, except it uses a\nbitset instead of linked list to track the set buckets?  Between BNS\nand BSIO which one is faster?\n\nWhy does BSIO/NS see massive gains on the tasks that have so many NOT\nclauses?  I think in trunk/4.x today, we are not scoring the NOT\nclauses, right?  While these gains are sizable, I think it's not a\ncommon use case...\n\nI think you've explored a number of options here and now we need to\nsee if we can make this committable, e.g. figure out how to have\nBooleanQuery pick the right scorer for the situation?  Somehow we need\nlogic that looks at how many / cost of the sub-clauses and picks the\nright scorer? ",
            "author": "Michael McCandless",
            "id": "comment-14039743"
        },
        {
            "date": "2014-06-21T09:59:35+0000",
            "content": "\n Looks like you separated required & optional\nscores in the non-DAAT impls and then carefully cast to float at the\nright times?\nYes, you get what I mean.\n\nyou can remove that TODO in ConjunctionScorer on\nswitching sum to double?\nOK, I will do that on next patch.\n\nSo BooleanScorerIO is just like BooleanNovelScorer, except it uses a\nbitset instead of linked list to track the set buckets? Between BNS\nand BSIO which one is faster?\nYes. exactly. According to perf. tests, it seems that\nBNS do better for those tasks faster than the trunk, \nwhile do better for those tasks slower than the trunk.\n\nWhy does BSIO/NS see massive gains on the tasks that have so many NOT\nclauses? I think in trunk/4.x today, we are not scoring the NOT\nclauses, right? While these gains are sizable, I think it's not a\ncommon use case...\nThe reason is that when we search for \"+a -b -c -d\", \nlucene actually do \"+a -(b c d)\" and the cost of getting disjunction of (b c d) is huge.\nIndeed, such case may not be a common case.\n\nI think you've explored a number of options here and now we need to\nsee if we can make this committable, e.g. figure out how to have\nBooleanQuery pick the right scorer for the situation? Somehow we need\nlogic that looks at how many / cost of the sub-clauses and picks the\nright scorer?\nYeah, you're right. \n\nBesides, a new idea has come up to me. For BNS, we actually does not\nmake use of the hash feature of BucketTable. Thus, I think we should not \ntake BucketTable as a hash table (ie. do not place doc to the absolute place buckets[doc & MASK]).\nFirstly, we get 2K required docs to BucketTable. Then, we do TAAT on these 2K docs. ",
            "author": "Da Huang",
            "id": "comment-14039754"
        },
        {
            "date": "2014-07-05T03:27:36+0000",
            "content": "This is a patch based on the git mirror commit 7f66461aea7bc2cb6f31a993cba77734e5e0f9d9.\n\nIn this patch, I take the bucketTable as an array but not a hash table.\nIt seems that its perf. is better than former patches' on most cases.\n\nAs you know, after putting required docs into bucketTable, I have to scan both the table and optional docs. Here, I have tried skipping to scan the bucketTable to improve the perf. The results is as follows.\n\n\n\nNo skip\n                    TaskQPS baseline      StdDevQPS my_version      StdDev                Pct diff\n       HighAndTonsLowNot        6.56      (3.1%)        2.59      (1.0%)  -60.5% ( -62% -  -58%)\n        HighAndTonsLowOr        6.43      (3.3%)        2.58      (0.8%)  -59.9% ( -61% -  -57%)\n        HighAndSomeLowOr        8.49      (8.5%)        4.05      (1.8%)  -52.3% ( -57% -  -45%)\n       HighAndSomeLowNot        6.17      (8.6%)        3.16      (2.1%)  -48.8% ( -54% -  -41%)\n         LowAndSomeLowOr      250.58      (2.0%)      194.86      (1.6%)  -22.2% ( -25% -  -18%)\n        LowAndSomeLowNot      178.66      (1.6%)      147.67      (2.2%)  -17.3% ( -20% -  -13%)\n        LowAndSomeHighOr       40.71      (2.8%)       41.50      (1.8%)    2.0% (  -2% -    6%)\n                PKLookup       97.59      (3.0%)       99.52      (4.6%)    2.0% (  -5% -    9%)\n       LowAndSomeHighNot       20.76      (3.0%)       21.54      (2.3%)    3.7% (  -1% -    9%)\n      HighAndSomeHighNot        2.22      (1.7%)        2.67      (4.4%)   20.3% (  13% -   26%)\n       LowAndTonsHighNot        3.81      (2.3%)        4.60      (2.1%)   20.8% (  15% -   25%)\n        LowAndTonsHighOr        2.87      (2.3%)        3.48      (2.6%)   21.2% (  15% -   26%)\n       HighAndSomeHighOr        1.74      (2.1%)        2.16      (3.5%)   24.0% (  18% -   30%)\n         LowAndTonsLowOr       18.66      (1.3%)       23.68      (1.9%)   26.9% (  23% -   30%)\n        LowAndTonsLowNot       16.01      (1.4%)       22.16      (2.8%)   38.4% (  33% -   43%)\n       HighAndTonsHighOr        0.04      (0.9%)        0.11      (9.8%)  158.2% ( 146% -  170%)\n      HighAndTonsHighNot        0.06      (1.1%)        0.15     (13.5%)  166.2% ( 149% -  182%)\n      \n---------------------------------------------------\nBinary search skip\n                    TaskQPS baseline      StdDevQPS my_version      StdDev                Pct diff\n       HighAndTonsLowNot        6.22      (3.8%)        2.45      (0.9%)  -60.6% ( -62% -  -58%)\n        HighAndSomeLowOr        8.29     (11.2%)        4.40      (3.0%)  -46.9% ( -54% -  -36%)\n       HighAndSomeLowNot       12.34      (7.1%)        6.65      (2.6%)  -46.1% ( -52% -  -39%)\n         LowAndSomeLowOr      232.38      (2.9%)      165.05      (1.8%)  -29.0% ( -32% -  -24%)\n        HighAndTonsLowOr        5.17      (6.2%)        3.75      (3.0%)  -27.4% ( -34% -  -19%)\n        LowAndSomeLowNot      227.71      (2.6%)      171.13      (3.2%)  -24.8% ( -29% -  -19%)\n       HighAndSomeHighOr        1.35      (3.9%)        1.14      (3.5%)  -16.1% ( -22% -   -9%)\n        LowAndSomeHighOr       50.17      (3.6%)       48.84      (3.7%)   -2.7% (  -9% -    4%)\n       LowAndSomeHighNot       52.71      (3.0%)       51.55      (3.8%)   -2.2% (  -8% -    4%)\n                PKLookup       90.17      (3.5%)       91.38      (3.3%)    1.3% (  -5% -    8%)\n      HighAndSomeHighNot        1.69      (2.9%)        2.00      (6.3%)   18.5% (   8% -   28%)\n         LowAndTonsLowOr       15.61      (1.9%)       18.59      (2.8%)   19.0% (  14% -   24%)\n        LowAndTonsHighOr        1.82      (2.7%)        2.20      (4.6%)   20.7% (  13% -   28%)\n        LowAndTonsLowNot       15.51      (1.7%)       20.14      (3.8%)   29.8% (  23% -   35%)\n       LowAndTonsHighNot        1.01      (2.9%)        1.34      (6.5%)   31.7% (  21% -   42%)\n       HighAndTonsHighOr        0.07      (0.9%)        0.12      (6.9%)   77.7% (  69% -   86%)\n      HighAndTonsHighNot        0.07      (1.4%)        0.19     (11.9%)  162.4% ( 146% -  178%)\n      \n---------------------------------------------------\n8 steps skip\n                    TaskQPS baseline      StdDevQPS my_version      StdDev                Pct diff\n       HighAndTonsLowNot        5.45      (3.3%)        1.69      (1.3%)  -69.0% ( -71% -  -66%)\n        HighAndSomeLowOr        5.46     (11.0%)        2.76      (4.4%)  -49.5% ( -58% -  -38%)\n       HighAndSomeLowNot       17.94      (5.7%)       10.40      (3.8%)  -42.1% ( -48% -  -34%)\n         LowAndSomeLowOr      306.62      (1.7%)      231.45      (1.5%)  -24.5% ( -27% -  -21%)\n        LowAndSomeLowNot      286.30      (1.7%)      218.13      (2.0%)  -23.8% ( -27% -  -20%)\n        HighAndTonsLowOr        6.34      (3.5%)        5.31      (4.5%)  -16.3% ( -23% -   -8%)\n        LowAndSomeHighOr       33.53      (2.1%)       33.85      (2.2%)    1.0% (  -3% -    5%)\n                PKLookup       97.39      (1.9%)       98.40      (3.9%)    1.0% (  -4% -    6%)\n       LowAndSomeHighNot       42.16      (2.0%)       42.73      (2.1%)    1.4% (  -2% -    5%)\n       HighAndSomeHighOr        2.43      (2.4%)        2.76      (4.8%)   13.4% (   6% -   21%)\n      HighAndSomeHighNot        2.74      (1.4%)        3.17      (4.6%)   15.7% (   9% -   21%)\n        LowAndTonsHighOr        3.45      (1.8%)        4.21      (3.2%)   22.0% (  16% -   27%)\n       LowAndTonsHighNot        2.37      (1.8%)        2.95      (3.0%)   24.6% (  19% -   30%)\n         LowAndTonsLowOr       17.21      (1.1%)       22.50      (2.6%)   30.7% (  26% -   34%)\n        LowAndTonsLowNot       13.60      (1.4%)       19.97      (2.4%)   46.8% (  42% -   51%)\n       HighAndTonsHighOr        0.08      (0.5%)        0.19      (9.9%)  140.3% ( 129% -  151%)\n      HighAndTonsHighNot        0.06      (1.7%)        0.15     (12.0%)  163.9% ( 147% -  180%)\n\n---------------------------------------------------\n16 steps skip\n                    TaskQPS baseline      StdDevQPS my_version      StdDev                Pct diff\n       HighAndTonsLowNot        6.69      (2.0%)        2.71      (0.8%)  -59.5% ( -61% -  -57%)\n        HighAndTonsLowOr        1.69     (10.1%)        0.89      (2.1%)  -47.1% ( -53% -  -38%)\n        HighAndSomeLowOr        7.28     (11.5%)        3.96      (1.9%)  -45.6% ( -52% -  -36%)\n       HighAndSomeLowNot       14.38      (5.2%)        8.09      (1.5%)  -43.7% ( -47% -  -39%)\n         LowAndSomeLowOr      295.60      (2.3%)      223.80      (2.0%)  -24.3% ( -27% -  -20%)\n        LowAndSomeLowNot      171.52      (1.7%)      140.82      (1.5%)  -17.9% ( -20% -  -14%)\n        LowAndSomeHighOr       40.12      (2.1%)       41.32      (3.2%)    3.0% (  -2% -    8%)\n                PKLookup       96.15      (2.4%)       99.15      (6.0%)    3.1% (  -5% -   11%)\n       LowAndSomeHighNot       31.53      (2.3%)       32.64      (2.9%)    3.5% (  -1% -    8%)\n      HighAndSomeHighNot        2.67      (1.3%)        3.04      (3.4%)   13.9% (   9% -   18%)\n       HighAndSomeHighOr        2.11      (2.1%)        2.58      (3.3%)   22.5% (  16% -   28%)\n        LowAndTonsHighOr        2.17      (1.8%)        2.67      (3.2%)   23.1% (  17% -   28%)\n       LowAndTonsHighNot        2.53      (1.6%)        3.16      (3.3%)   25.2% (  20% -   30%)\n        LowAndTonsLowNot       14.68      (0.9%)       20.97      (3.6%)   42.8% (  38% -   47%)\n         LowAndTonsLowOr       14.04      (1.1%)       20.09      (2.6%)   43.0% (  38% -   47%)\n       HighAndTonsHighOr        0.06      (0.7%)        0.15      (9.4%)  152.0% ( 141% -  163%)\n      HighAndTonsHighNot        0.05      (0.8%)        0.14     (12.1%)  167.3% ( 153% -  181%)\n      \n---------------------------------------------------\n32 steps skip\n                    TaskQPS baseline      StdDevQPS my_version      StdDev                Pct diff\n       HighAndTonsLowNot        6.50      (2.6%)        3.24      (1.1%)  -50.1% ( -52% -  -47%)\n       HighAndSomeLowNot        9.51      (6.4%)        4.87      (3.2%)  -48.8% ( -54% -  -41%)\n        HighAndSomeLowOr       14.87     (11.6%)        8.81      (3.6%)  -40.8% ( -50% -  -28%)\n         LowAndSomeLowOr      311.27      (2.6%)      241.43      (1.6%)  -22.4% ( -25% -  -18%)\n        LowAndSomeLowNot      231.96      (2.4%)      181.95      (2.0%)  -21.6% ( -25% -  -17%)\n        HighAndTonsLowOr        5.60      (5.7%)        4.45      (3.7%)  -20.5% ( -28% -  -11%)\n       LowAndSomeHighNot       62.10      (2.6%)       60.59      (2.5%)   -2.4% (  -7% -    2%)\n        LowAndSomeHighOr       49.36      (3.0%)       48.87      (3.1%)   -1.0% (  -6% -    5%)\n                PKLookup       96.38      (2.0%)       95.91      (2.5%)   -0.5% (  -4% -    4%)\n      HighAndSomeHighNot        2.08      (1.6%)        2.34      (5.2%)   12.7% (   5% -   19%)\n       HighAndSomeHighOr        2.30      (2.6%)        2.63      (5.7%)   14.2% (   5% -   23%)\n        LowAndTonsHighOr        1.88      (2.5%)        2.35      (4.2%)   25.5% (  18% -   33%)\n       LowAndTonsHighNot        1.10      (2.5%)        1.45      (5.0%)   31.1% (  23% -   39%)\n         LowAndTonsLowOr       14.38      (1.0%)       20.24      (3.2%)   40.8% (  36% -   45%)\n        LowAndTonsLowNot       12.98      (1.0%)       18.82      (2.9%)   45.0% (  40% -   49%)\n       HighAndTonsHighOr        0.08      (0.8%)        0.18     (12.3%)  138.0% ( 123% -  152%)\n      HighAndTonsHighNot        0.08      (1.1%)        0.21     (12.5%)  157.6% ( 142% -  172%)\n\n ",
            "author": "Da Huang",
            "id": "comment-14052765"
        },
        {
            "date": "2014-07-08T19:01:00+0000",
            "content": "This is neat!  So now it's just a simple array holding all buckets\nseen, which we can only do if there's at least one MUST clause.\n\nMaybe try testing different values of SIZE?\n\nWhen you fold in the MUST_NOT clauses you could just compact the array\nas you go, instead of having a separate valid bool?\n\nI think we should start moving this towards something committable?\nI.e., of all the approaches you've explored, let's take the most\npromising and fold them into a new scorer, and then work on the\nlogic/heuristics for when this scorer should and shouldn't apply? ",
            "author": "Michael McCandless",
            "id": "comment-14055322"
        },
        {
            "date": "2014-07-08T23:19:03+0000",
            "content": "Thanks for you suggestions, mike.\n\nMaybe try testing different values of SIZE?\nHmm, that's a good idea.\n\n\nWhen you fold in the MUST_NOT clauses you could just compact the array\nas you go, instead of having a separate valid bool?\nOh, that's is a great idae! I will do that on next patch.\n\n\nI think we should start moving this towards something committable?\nI.e., of all the approaches you've explored, let's take the most\npromising and fold them into a new scorer, and then work on the\nlogic/heuristics for when this scorer should and shouldn't apply?\nYeah, I agree. I am working on that. ",
            "author": "Da Huang",
            "id": "comment-14055653"
        },
        {
            "date": "2014-07-14T13:03:24+0000",
            "content": "I have done tests for different SIZE of bucketTable.\nThe file 'SIZE.perf' is the original test result data.\n\n'stat.cpp' is a C++ program used to do statistic on *.perf files.\nYou can compile it with 'g++ stat.cpp -std=c++0x -o stat'\nand run by './stat < SIZE.perf'\n\nThe statistic result for SIZE.perf is supposed to be as follows.\n\n                Task          size10          size11           size5           size6           size7           size8           size9\n  HighAndSomeHighNot           -14.5             4.0             6.6            -3.0             5.2            10.0*            3.4\n   HighAndSomeHighOr             2.4            10.9            17.3            17.4            12.9            18.3            21.3*\n   HighAndSomeLowNot           -36.8           -37.3           -47.8           -47.8           -40.2           -42.2           -41.5\n    HighAndSomeLowOr           -45.1           -46.4           -47.9           -46.2           -38.7           -39.7           -44.9\n  HighAndTonsHighNot           162.4*          145.1           149.1           130.1           142.9           144.7           143.7\n   HighAndTonsHighOr           154.8*          146.5           154.0           137.8           144.9           150.0           149.1\n   HighAndTonsLowNot           -27.0           -17.4           -73.7           -49.6           -40.1           -28.6           -15.6\n    HighAndTonsLowOr           -28.7           -14.3           -63.8           -44.8           -33.0           -24.4           -13.9\n   LowAndSomeHighNot             3.0             0.2             4.5             6.2*            5.7             6.2*            4.7\n    LowAndSomeHighOr             5.3             1.4             6.8*            6.7             7.7             5.8             6.6\n    LowAndSomeLowNot            -6.3           -24.4             3.7*            0.8             1.7            -2.3            -4.0\n     LowAndSomeLowOr           -10.3           -22.7             2.2*            2.0             1.7            -2.3            -8.8\n   LowAndTonsHighNot            27.3*           21.4            22.5            21.5            21.0            23.8            26.5\n    LowAndTonsHighOr            23.1            28.2            24.2            23.9            29.1*           27.5            28.2\n    LowAndTonsLowNot            33.0            46.5            39.1            33.4            30.0            47.2*           44.3\n     LowAndTonsLowOr            45.7*           34.6            29.9            36.8            45.3            40.9            38.1\n\n\n\nsize7 means the bucketTable's size is 1 << 7.\nthe character '*', which is added manually, marks the best value.\n\nIt seems that we can get a better result on *Some* tasks if we combine size9 with size5. ",
            "author": "Da Huang",
            "id": "comment-14060615"
        },
        {
            "date": "2014-07-15T06:02:13+0000",
            "content": "This patch is based on git mirror commit ce7d0578b30981d15687bf76aec595274efccbad\n\nIn this patch, I just compact the array as I go through the MUST_NOT docs.\n\n                    TaskQPS baseline      StdDevQPS my_version      StdDev                Pct diff\n       HighAndTonsLowNot        4.88      (3.5%)        2.44      (4.4%)  -49.9% ( -55% -  -43%)\n       HighAndSomeLowNot        6.55      (6.1%)        3.60      (4.7%)  -45.1% ( -52% -  -36%)\n        HighAndSomeLowOr        9.93     (12.9%)        5.49      (4.7%)  -44.7% ( -55% -  -31%)\n        LowAndSomeLowNot      293.78      (2.3%)      216.29      (1.7%)  -26.4% ( -29% -  -22%)\n         LowAndSomeLowOr      347.60      (1.8%)      266.94      (1.2%)  -23.2% ( -25% -  -20%)\n        HighAndTonsLowOr        5.59      (5.7%)        4.34      (4.4%)  -22.4% ( -30% -  -13%)\n                PKLookup       97.38      (2.1%)       95.54      (2.9%)   -1.9% (  -6% -    3%) \n      HighAndSomeHighNot        1.88      (2.2%)        1.89      (6.6%)    0.7% (  -7% -    9%) \n        LowAndSomeHighOr       41.32      (2.9%)       41.92      (2.8%)    1.5% (  -4% -    7%) \n       LowAndSomeHighNot       54.74      (2.4%)       56.73      (2.7%)    3.7% (  -1% -    8%) \n       HighAndSomeHighOr        2.26      (2.7%)        2.56      (6.8%)   13.3% (   3% -   23%)\n        LowAndTonsLowNot       17.18      (1.2%)       22.14      (2.4%)   28.9% (  24% -   32%)\n        LowAndTonsHighOr        1.21      (2.7%)        1.57      (4.4%)   29.8% (  22% -   37%)\n         LowAndTonsLowOr       17.22      (1.3%)       22.53      (2.4%)   30.9% (  26% -   35%)\n       HighAndTonsHighOr        0.07      (1.2%)        0.16     (13.1%)  141.0% ( 125% -  157%)\n       LowAndTonsHighNot        2.02      (2.4%)        9.70      (9.7%)  380.6% ( 360% -  402%)\n      HighAndTonsHighNot        0.09      (1.2%)        0.50     (23.1%)  475.7% ( 446% -  505%)\n\n\n\nBesides, I am working combine all explored method to get a better perf now. \nIn order to get more accurate perf of each method, I'm retesting some previous methods now. \nIt may take several days to make a combined method work. ",
            "author": "Da Huang",
            "id": "comment-14061719"
        },
        {
            "date": "2014-07-15T14:19:51+0000",
            "content": "This is good progress, thanks Da!\n\nIn this patch, I just compact the array as I go through the MUST_NOT docs.\n\nIt looks like this gave some nice gains with the many-not cases\n\nIt seems that we can get a better result on Some tasks if we combine size9 with size5.\n\nCuriously some of the tasks are really hurt by the larger sizes ... maybe 1<<9 is a good compromise? ",
            "author": "Michael McCandless",
            "id": "comment-14062106"
        },
        {
            "date": "2014-07-16T03:52:12+0000",
            "content": "Thank you, Mike!\n\nIt looks like this gave some nice gains with the many-not cases\nYes, but many-not cases might not be a usual case. Therefore, this method might not be used in the final method.\n\n\nCuriously some of the tasks are really hurt by the larger sizes ... maybe 1<<9 is a good compromise?\nYeah. Finally, I will just focus on those *Some* cases. \n\"size9\" is better for HighAndSomeHighOr case, while \"size5\" is better for LowAndSomeHighOr, LowAndSomeLowNot  and LowAndSomeLowOr cases.\nI think it would be better to detect the case type and adjust the SIZE of bucketTable in BNS's constructor. ",
            "author": "Da Huang",
            "id": "comment-14063089"
        },
        {
            "date": "2014-07-22T01:49:16+0000",
            "content": "I have retested previous explored methods, and do an statistic on their performance.\n\nThe file all.perf is the original perf. data.\nstat.cpp is used to do an statistic on all.perf.\n\ng++ -std=c++0x stat.cpp -o stat\n./stat < all.perf\n\n\n\nThe perf. statistic results are showed as follows.\n\n                Task  ArrayNotDel           BS       BitSet           ll         llbs        size5        size8        size9\n  HighAndSomeHighNot         0.7         15.3*         7.4          8.9          2.0          6.6         10.0          3.4 \n   HighAndSomeHighOr        13.3         24.5*         7.8          9.1         10.9         17.3+        18.3+        21.3+\n   HighAndSomeLowNot       -45.1        -53.9        -55.0        -57.3        -45.5        -47.8        -42.2        -41.5 \n    HighAndSomeLowOr       -44.7        -55.4        -51.2        -58.1        -54.5        -47.9        -39.7        -44.9 \n  HighAndTonsHighNot       475.7+       472.7+       507.0+       552.9+       627.9*       149.1        144.7        143.7 \n   HighAndTonsHighOr       141.0+       135.4+       162.4+       153.4+       169.7*       154.0+       150.0+       149.1+\n   HighAndTonsLowNot       -49.9        -66.2        -46.8        -76.9        -30.3        -73.7        -28.6        -15.6 \n    HighAndTonsLowOr       -22.4        -69.4        -30.2        -67.5        -41.9        -63.8        -24.4        -13.9 \n   LowAndSomeHighNot         3.7         -2.6         -9.0         -7.3         -6.2          4.5+         6.2*         4.7+\n    LowAndSomeHighOr         1.5        -14.0        -15.5        -10.8        -12.0          6.8*         5.8+         6.6+\n    LowAndSomeLowNot       -26.4        -43.7        -56.5        -47.3        -43.7          3.7*        -2.3         -4.0 \n     LowAndSomeLowOr       -23.2        -41.8        -60.5        -46.2        -43.4          2.2*        -2.3         -8.8 \n   LowAndTonsHighNot       380.6+       171.5        118.4        248.3        381.8*        22.5         23.8         26.5 \n    LowAndTonsHighOr        29.8*         5.2         -1.1         10.7          5.4         24.2+        27.5+        28.2+\n    LowAndTonsLowNot        28.9          9.1        -39.3          5.3          1.3         39.1+        47.2*        44.3+\n     LowAndTonsLowOr        30.9+         7.2        -38.1          0.5          9.0         29.9+        40.9*        38.1+\n\n                Task         Good Method\n  HighAndSomeHighNot       BS, \n   HighAndSomeHighOr       BS, size9, size8, size5, \n   HighAndSomeLowNot       \n    HighAndSomeLowOr       \n  HighAndTonsHighNot       llbs, ll, BitSet, ArrayNotDel, BS, \n   HighAndTonsHighOr       llbs, BitSet, size5, ll, size8, size9, ArrayNotDel, BS, \n   HighAndTonsLowNot       \n    HighAndTonsLowOr       \n   LowAndSomeHighNot       size8, size9, size5, \n    LowAndSomeHighOr       size5, size9, size8, \n    LowAndSomeLowNot       size5, \n     LowAndSomeLowOr       size5, \n   LowAndTonsHighNot       llbs, ArrayNotDel, \n    LowAndTonsHighOr       ArrayNotDel, size9, size8, size5, \n    LowAndTonsLowNot       size8, size9, size5, \n     LowAndTonsLowOr       size8, size9, ArrayNotDel, size5, \n\n\nAmong them, 'll' is the linkedlist docs method, while 'llbs' is the linkedlist with bitset.\nCharacter '*' marks the best perf, while '+' marks ones some kind of as good as the best perf.\nI have been merging these methods. I decided to move the scorer choosing logic into a new class, but a bug come to me.\nI'm working on it. ",
            "author": "Da Huang",
            "id": "comment-14069689"
        },
        {
            "date": "2014-07-24T01:53:39+0000",
            "content": "This patch is based on the git mirror commit ce7d0578b30981d15687bf76aec595274efccbad .\nThis is the first try to merge scorers, so that we can get a better perf of boolean retrieval.\n\nI create a new class named \"BooleanMixedScorerDecider\" to choose the best scorer.\nRules for choosing remains to be improved. I have been working on it to find an elegant way to define rules.\n\n                    TaskQPS baseline      StdDevQPS my_version      StdDev                Pct diff\n       HighAndSomeLowNot       11.53      (7.3%)       10.75     (10.1%)   -6.8% ( -22% -   11%)\n       HighAndTonsLowNot        4.87      (4.0%)        4.64      (6.0%)   -4.9% ( -14% -    5%)\n         LowAndSomeLowOr      306.20      (2.2%)      299.06      (2.8%)   -2.3% (  -7% -    2%)\n        HighAndSomeLowOr       13.67      (9.4%)       13.38      (2.7%)   -2.1% ( -13% -   11%)\n        HighAndTonsLowOr        4.04      (6.4%)        3.96      (1.9%)   -1.9% (  -9% -    6%)\n        LowAndSomeLowNot      215.18      (1.9%)      211.14      (2.2%)   -1.9% (  -5% -    2%)\n                PKLookup       96.26      (2.3%)       94.56      (2.8%)   -1.8% (  -6% -    3%)\n      HighAndTonsHighNot        0.06      (2.3%)        0.06      (2.6%)   -1.0% (  -5% -    4%)\n       HighAndTonsHighOr        0.06      (0.6%)        0.06      (1.3%)    0.9% (   0% -    2%)\n      HighAndSomeHighNot        1.59      (2.2%)        1.62      (2.9%)    1.7% (  -3% -    6%)\n       LowAndSomeHighNot       66.33      (2.1%)       68.77      (2.1%)    3.7% (   0% -    8%)\n        LowAndSomeHighOr       53.75      (1.6%)       56.86      (2.1%)    5.8% (   1% -    9%)\n        LowAndTonsLowNot       14.00      (1.7%)       14.84      (1.5%)    6.1% (   2% -    9%)\n       HighAndSomeHighOr        2.39      (2.2%)        2.68      (3.5%)   12.4% (   6% -   18%)\n         LowAndTonsLowOr       17.69      (0.9%)       21.64      (1.7%)   22.3% (  19% -   25%)\n        LowAndTonsHighOr        1.83      (1.3%)        2.33      (2.4%)   27.2% (  23% -   31%)\n       LowAndTonsHighNot        1.15      (1.5%)        1.51      (3.1%)   30.9% (  25% -   36%)\n\n ",
            "author": "Da Huang",
            "id": "comment-14072693"
        },
        {
            "date": "2014-07-24T21:16:08+0000",
            "content": "Do we really need a separate class to make the decision about which scorer to use?  Seems like the added logic for when to use BNS is fairly small so we could just add it into BQ's scorer method instead?\n\nFor bulkScorer, should we ever return BooleanScorer even when there are required clauses?  Or was that just commented out for temporary benchmarking so we'd wrap BNS?  When there is a required clause, if BNS is never slower than BS, then instead of falling back to super.bulkScorer we could do the wrapping ourselves there?  Just to make it clearer we are using BNS ... or maybe just put a comment saying so (replacing that TODO).\n\nFor the rules on when to use which scorer, it seems like we should take the .cost() of the sub-clauses into account somehow... ",
            "author": "Michael McCandless",
            "id": "comment-14073669"
        },
        {
            "date": "2014-07-25T05:20:23+0000",
            "content": "\nDo we really need a separate class to make the decision about which scorer to use? Seems like the added logic for when to use BNS is fairly small so we could just add it into BQ's scorer method instead?\nOK, I will move the decision logic back to BQ.\n\n\nFor bulkScorer, should we ever return BooleanScorer even when there are required clauses? Or was that just commented out for temporary benchmarking so we'd wrap BNS? When there is a required clause, if BNS is never slower than BS, then instead of falling back to super.bulkScorer we could do the wrapping ourselves there? Just to make it clearer we are using BNS ... or maybe just put a comment saying so (replacing that TODO).\nBooleanScorer should be applied for bulkScorer under some cases. Now I turn to super.bulkScorer when there are required clauses is just a temporary strategy.\nSee the following tables.\n\n                Task  ArrayNotDel           BS       BitSet           ll         llbs        size5        size8        size9\n  HighAndSomeHighNot         0.7         15.3*         7.4          8.9          2.0          6.6         10.0          3.4 \n   HighAndSomeHighOr        13.3         24.5*         7.8          9.1         10.9         17.3+        18.3+        21.3+\n   HighAndSomeLowNot       -45.1        -53.9        -55.0        -57.3        -45.5        -47.8        -42.2        -41.5 \n    HighAndSomeLowOr       -44.7        -55.4        -51.2        -58.1        -54.5        -47.9        -39.7        -44.9 \n  HighAndTonsHighNot       475.7+       472.7+       507.0+       552.9+       627.9*       149.1        144.7        143.7 \n   HighAndTonsHighOr       141.0+       135.4+       162.4+       153.4+       169.7*       154.0+       150.0+       149.1+\n   HighAndTonsLowNot       -49.9        -66.2        -46.8        -76.9        -30.3        -73.7        -28.6        -15.6 \n    HighAndTonsLowOr       -22.4        -69.4        -30.2        -67.5        -41.9        -63.8        -24.4        -13.9 \n   LowAndSomeHighNot         3.7         -2.6         -9.0         -7.3         -6.2          4.5+         6.2*         4.7+\n    LowAndSomeHighOr         1.5        -14.0        -15.5        -10.8        -12.0          6.8*         5.8+         6.6+\n    LowAndSomeLowNot       -26.4        -43.7        -56.5        -47.3        -43.7          3.7*        -2.3         -4.0 \n     LowAndSomeLowOr       -23.2        -41.8        -60.5        -46.2        -43.4          2.2*        -2.3         -8.8 \n   LowAndTonsHighNot       380.6+       171.5        118.4        248.3        381.8*        22.5         23.8         26.5 \n    LowAndTonsHighOr        29.8*         5.2         -1.1         10.7          5.4         24.2+        27.5+        28.2+\n    LowAndTonsLowNot        28.9          9.1        -39.3          5.3          1.3         39.1+        47.2*        44.3+\n     LowAndTonsLowOr        30.9+         7.2        -38.1          0.5          9.0         29.9+        40.9*        38.1+\n\n                Task         Good Method\n  HighAndSomeHighNot       BS, \n   HighAndSomeHighOr       BS, size9, size8, size5, \n   HighAndSomeLowNot       \n    HighAndSomeLowOr       \n  HighAndTonsHighNot       llbs, ll, BitSet, ArrayNotDel, BS, \n   HighAndTonsHighOr       llbs, BitSet, size5, ll, size8, size9, ArrayNotDel, BS, \n   HighAndTonsLowNot       \n    HighAndTonsLowOr       \n   LowAndSomeHighNot       size8, size9, size5, \n    LowAndSomeHighOr       size5, size9, size8, \n    LowAndSomeLowNot       size5, \n     LowAndSomeLowOr       size5, \n   LowAndTonsHighNot       llbs, ArrayNotDel, \n    LowAndTonsHighOr       ArrayNotDel, size9, size8, size5, \n    LowAndTonsLowNot       size8, size9, size5, \n     LowAndTonsLowOr       size8, size9, ArrayNotDel, size5, \n\n\nBS perferms the best for HighAndSomeHigh* cases.\n\n\nFor the rules on when to use which scorer, it seems like we should take the .cost() of the sub-clauses into account somehow...\nI have already take .cost() into account see the rules in the decider.\n\n    if (!required.isEmpty() && optional.size() > 3) {\n      float times = (float) required.get(0).cost() / optional.get(0).cost();\n      if (times < 1) return new BooleanNovelScorer(weight, disableCoord, minShouldMatch, required, optional, prohibited, maxCoord);\n    }   \n    if (!required.isEmpty() && prohibited.size() > 3) {\n      float times = (float) required.get(0).cost() / prohibited.get(0).cost();\n      if (times < 1) return new BooleanNovelScorer(weight, disableCoord, minShouldMatch, required, optional, prohibited, maxCoord);\n    }   \n\n\nHere, I just take the first scorer's cost into account, as it may cost a lot to iterate all scorers. ",
            "author": "Da Huang",
            "id": "comment-14074083"
        },
        {
            "date": "2014-07-29T05:30:01+0000",
            "content": "This is a patch based on git mirror commit ce7d0578b30981d15687bf76aec595274efccbad\nI've tried to merge all explored methods to get a better performance for boolean retrieval.\n\nIn this patch, I just mix methods in BooleanQuery.BooleanWeight.scorer()\nI have tried to mix methods in .bulkScorer(), but it fails to pass the ant-test.\n\nIt took me lots of time to figure out the cause.\nIt turned out that I'm not supposed to call w.bulkScorer() to get optional scorer,\nas well as prohibited scorer, in BooleanQuery.BooleanWeight.bulkScorer(), \nor the TestBooleanScorer.testEmbeddedBooleanScorer will throws an UnsupportedOperationException\nbecause it calls an unimplemented .scorer() method.\n\nIt makes me embarrassed that I'm not able to get the cost of a scorer \nwithout an instance of Scorer.\n\nTherefore, my next step is to check whether I can get optional scorer in .bulkScorer().\nIf yes, do the similar things as .scorer(). If no, just call BooleanScorer();\n\nBesides, I'm very sorry that the code in this patch may looks ugly, \nas I haven't spared enough time to rearrange the code.\n\n\n                    TaskQPS baseline      StdDevQPS my_version      StdDev                Pct diff\n       HighAndTonsLowNot        4.06      (4.0%)        3.44      (5.1%)  -15.5% ( -23% -   -6%)\n       HighAndSomeLowNot       17.02      (5.3%)       15.61      (9.2%)   -8.3% ( -21% -    6%)\n        HighAndTonsLowOr        5.82      (5.0%)        5.67      (1.5%)   -2.6% (  -8% -    4%)\n        LowAndSomeHighOr       55.03      (3.0%)       54.39      (2.2%)   -1.2% (  -6% -    4%)\n      HighAndSomeHighNot        1.24      (2.3%)        1.23      (2.3%)   -1.0% (  -5% -    3%)\n         LowAndSomeLowOr      231.48      (1.8%)      229.47      (2.1%)   -0.9% (  -4% -    3%)\n                PKLookup       97.60      (2.1%)       97.63      (2.2%)    0.0% (  -4% -    4%)\n        LowAndSomeLowNot      312.07      (2.0%)      312.28      (2.1%)    0.1% (  -3% -    4%)\n       HighAndSomeHighOr        1.69      (2.6%)        1.69      (1.2%)    0.4% (  -3% -    4%)\n        HighAndSomeLowOr       14.28     (11.7%)       14.81      (4.7%)    3.7% ( -11% -   22%)\n       LowAndSomeHighNot       34.74      (2.9%)       36.83      (2.6%)    6.0% (   0% -   11%)\n        LowAndTonsHighOr        2.34      (2.7%)        2.90      (3.2%)   24.3% (  17% -   30%)\n         LowAndTonsLowOr       18.88      (1.0%)       25.14      (3.0%)   33.2% (  28% -   37%)\n        LowAndTonsLowNot       15.78      (1.4%)       22.29      (2.0%)   41.2% (  37% -   45%)\n       HighAndTonsHighOr        0.06      (0.6%)        0.17      (5.8%)  179.9% ( 172% -  187%)\n       LowAndTonsHighNot        1.33      (2.4%)        4.29      (8.1%)  223.5% ( 207% -  239%)\n      HighAndTonsHighNot        0.06      (1.8%)        0.34     (17.3%)  495.0% ( 467% -  523%)\n\n    ",
            "author": "Da Huang",
            "id": "comment-14077402"
        },
        {
            "date": "2014-07-30T09:49:02+0000",
            "content": "\nIt makes me embarrassed that I'm not able to get the cost of a scorer without an instance of Scorer.\n\nHmm, maybe BulkScorer should also have a cost method?\n\nBesides, I'm very sorry that the code in this patch may looks ugly, as I haven't spared enough time to rearrange the code.\n\nNo worries, this is perfectly normal and healthy in iterative open-source development!  This is just how the iterations work...\n\nor the TestBooleanScorer.testEmbeddedBooleanScorer will throws an UnsupportedOperationException because it calls an unimplemented .scorer() method.\n\nThis test may simply be too ridiculous!  It's just trying to ensure that we can do the boolean bulk scoring embedded inside another bulk scorer. ",
            "author": "Michael McCandless",
            "id": "comment-14079117"
        },
        {
            "date": "2014-08-02T12:10:58+0000",
            "content": "This is a patch based on git mirror commit 67d17eb81b754fa242bb91e1b91070fd8b38ecd9\n\nIn this patch, I go further based on the last patch.\n\nFirstly, I move all scorer choosing logics to .bulkScorer(), so that there's no need to wrap scorer in .bulkScorer().\n\nSecondly, I have tried to use BooleanScorer for some cases with MUST.\nHowever, it seems that there's something wrong with my test on BS before.\nThe perf. of BS can just beat DAAT on 2 cases, and BS perfs worse than other explored scorers on these 2 cases.\n\nTher perf of BQ(the merged scorer) and BS is showed as follows.\n\n\nBQ\n                    TaskQPS baseline      StdDevQPS my_version      StdDev                Pct diff\n       HighAndTonsLowNot        5.01      (3.5%)        4.29      (2.7%)  -14.3% ( -19% -   -8%)\n       HighAndSomeLowNot       15.33      (5.1%)       13.71      (5.4%)  -10.6% ( -20% -    0%)\n         LowAndSomeLowOr      240.72      (2.5%)      217.73      (2.5%)   -9.6% ( -14% -   -4%)\n        LowAndSomeLowNot      269.51      (1.4%)      244.76      (2.3%)   -9.2% ( -12% -   -5%)\n        HighAndTonsLowOr        5.19      (5.3%)        4.94      (2.0%)   -4.8% ( -11% -    2%)\n      HighAndSomeHighNot        1.60      (2.0%)        1.57      (2.6%)   -1.9% (  -6% -    2%)\n        HighAndSomeLowOr        6.65     (11.5%)        6.77      (4.1%)    1.8% ( -12% -   19%)\n                PKLookup       96.93      (2.3%)       99.72      (4.1%)    2.9% (  -3% -    9%)\n       LowAndSomeHighNot       59.45      (1.5%)       61.63      (2.4%)    3.7% (   0% -    7%)\n        LowAndSomeHighOr       40.78      (2.0%)       42.75      (3.0%)    4.8% (   0% -   10%)\n       HighAndSomeHighOr        2.11      (2.8%)        2.44      (3.0%)   16.1% (  10% -   22%)\n        LowAndTonsLowNot       17.45      (1.3%)       20.88      (2.5%)   19.6% (  15% -   23%)\n        LowAndTonsHighOr        2.76      (1.6%)        3.34      (3.1%)   21.0% (  16% -   26%)\n         LowAndTonsLowOr       15.36      (1.2%)       19.83      (3.1%)   29.2% (  24% -   33%)\n       HighAndTonsHighOr        0.08      (0.7%)        0.21      (5.1%)  159.8% ( 152% -  166%)\n       LowAndTonsHighNot        1.69      (1.5%)        5.14      (5.9%)  204.0% ( 193% -  214%)\n      HighAndTonsHighNot        0.09      (0.7%)        0.41     (11.0%)  359.9% ( 345% -  374%)\n\n\nBooleanScorer\n                    TaskQPS baseline      StdDevQPS my_version      StdDev                Pct diff\n        LowAndSomeHighOr       51.38      (1.7%)        1.47      (0.4%)  -97.1% ( -97% -  -96%)\n        LowAndTonsHighOr        2.79      (1.5%)        0.10      (0.5%)  -96.5% ( -97% -  -95%)\n       LowAndTonsHighNot        1.71      (2.0%)        0.17      (0.7%)  -90.3% ( -91% -  -89%)\n       LowAndSomeHighNot       32.69      (2.2%)        3.18      (0.6%)  -90.3% ( -91% -  -89%)\n         LowAndSomeLowOr      258.50      (1.7%)       91.84      (1.6%)  -64.5% ( -66% -  -62%)\n        HighAndSomeLowOr       12.66      (9.1%)        5.89      (2.3%)  -53.5% ( -59% -  -46%)\n        LowAndSomeLowNot      252.33      (2.1%)      124.57      (1.1%)  -50.6% ( -52% -  -48%)\n        HighAndTonsLowOr        3.13      (7.5%)        1.57      (2.3%)  -49.7% ( -55% -  -43%)\n         LowAndTonsLowOr       14.17      (0.8%)        7.32      (2.6%)  -48.4% ( -51% -  -45%)\n       HighAndSomeLowNot       18.01      (5.6%)       10.03      (2.8%)  -44.3% ( -49% -  -37%)\n        LowAndTonsLowNot       17.17      (1.1%)       11.33      (1.5%)  -34.0% ( -36% -  -31%)\n       HighAndTonsLowNot        6.29      (2.5%)        4.73      (2.4%)  -24.9% ( -29% -  -20%)\n       HighAndSomeHighOr        1.66      (3.1%)        1.28      (7.5%)  -22.7% ( -32% -  -12%)\n      HighAndSomeHighNot        2.11      (1.4%)        1.83      (3.4%)  -13.5% ( -18% -   -8%)\n                PKLookup       96.92      (4.0%)       94.94      (2.5%)   -2.0% (  -8% -    4%)\n       HighAndTonsHighOr        0.07      (0.5%)        0.09     (18.2%)   38.3% (  19% -   57%)\n      HighAndTonsHighNot        0.04      (1.9%)        0.16     (24.4%)  263.0% ( 232% -  294%)\n\n\n\n\nBy the perf. table of BQ, it looks that BQ perfs low on the first 4 cases.\nHowever, when I run these cases one by one, they're just worse than the trunk within 2%.\nI'm not sure what makes this happen? ",
            "author": "Da Huang",
            "id": "comment-14083536"
        },
        {
            "date": "2014-08-03T18:38:48+0000",
            "content": "I cannot quickly find recent java code discussed here, in spite of the github commits mentioned.\n\nWould it be possible to provide an easier reference to the recent code, e.g. a pull request or the name of a github repo containing this? ",
            "author": "Paul Elschot",
            "id": "comment-14084081"
        },
        {
            "date": "2014-08-03T22:41:57+0000",
            "content": "Da attached the latest patch here ... I'm not sure where the github commit is ... ",
            "author": "Michael McCandless",
            "id": "comment-14084152"
        },
        {
            "date": "2014-08-04T05:38:57+0000",
            "content": "The patch based on git mirror commit 67d17eb81b754fa242bb91e1b91070fd8b38ecd9 .\n\nIn this patch, I remove those unused classes, encapsulate some functions and fix some bugs.\n\nBesides, the tasks file used before has heavy relevance between cases.\nI think it's not good. Therefore, I generate a new tasks file.\n\nThe file And.tasks is the new tasks file, while 'tasks.cpp' is the program to generate this tasks file.\nYou can generate tasks file by running\n\ng++ tasks.cpp -std=c++0x -o tasks\n./tasks < wikimedium.10M.nostopwords.tasks > And.tasks\n\n\n\nThe perf. on the new tasks file is as follows.\n\n                    TaskQPS baseline      StdDevQPS my_version      StdDev                Pct diff\n          HighAnd5LowNot        5.40      (5.1%)        4.88      (4.2%)   -9.6% ( -18% -    0%)\n           HighAnd5LowOr        7.05     (10.2%)        6.87      (3.8%)   -2.6% ( -15% -   12%)\n           LowAnd5LowNot       27.17      (2.1%)       26.47      (2.6%)   -2.6% (  -7% -    2%)\n          HighAnd5HighOr        1.13      (3.8%)        1.11      (2.2%)   -1.8% (  -7% -    4%)\n            LowAnd5LowOr       31.82      (2.6%)       31.35      (2.3%)   -1.5% (  -6% -    3%)\n                PKLookup       98.80      (5.2%)      102.02      (6.3%)    3.3% (  -7% -   15%)\n         HighAnd5HighNot        1.95      (1.0%)        2.04      (2.1%)    4.7% (   1% -    7%)\n          LowAnd5HighNot        9.46      (2.9%)       10.32      (2.7%)    9.0% (   3% -   15%)\n           LowAnd5HighOr        7.56      (2.8%)        8.42      (2.8%)   11.4% (   5% -   17%)\n          LowAnd60HighOr        0.51      (2.5%)        0.82      (4.8%)   58.7% (  50% -   67%)\n          LowAnd60LowNot        2.61      (1.0%)        4.64      (3.4%)   78.0% (  72% -   83%)\n         HighAnd60LowNot        1.30      (1.2%)        2.36      (3.7%)   81.1% (  75% -   87%)\n          HighAnd60LowOr        1.18      (1.3%)        2.15      (3.7%)   82.0% (  76% -   88%)\n           LowAnd60LowOr        2.25      (0.6%)        4.61      (4.2%)  104.7% (  99% -  110%)\n         HighAnd60HighOr        0.10      (0.7%)        0.26      (4.8%)  151.2% ( 144% -  157%)\n         LowAnd60HighNot        0.53      (2.5%)        1.62      (8.0%)  204.0% ( 188% -  220%)\n        HighAnd60HighNot        0.14      (0.9%)        0.59      (8.9%)  328.4% ( 315% -  341%)\n\n\n\nMy next step is to do more tests to get better rules and make sure the correctness. I think it can be finished by this Friday.\n\nAs the suggested pencil down date is comming, I will begin to scrub the code, improve the comments, and write document in conclusion. ",
            "author": "Da Huang",
            "id": "comment-14084323"
        },
        {
            "date": "2014-08-04T05:57:59+0000",
            "content": "Hi, Paul Elschot.\n\nThe commit hash code mentioned here just indicates which commit the patch should apply on.\n\nIf you want to get the java latest code discussed here for example, you can do these\n\ngit clone https://github.com/apache/lucene-solr\ncd lucene-solr\ngit checkout 67d17eb81b754fa242bb91e1b91070fd8b38ecd9\ngit apply LUCENE-4396.patch\n\n\n\nLUCENE-4396.patch is attached on this page, you can download it first.\n\nHope this can help you.\n\nbtw, there is a repo where I'm maintaining the code, but the repo is on the server in my lab.\nYou're not able to clone from that repo without password.\nSorry for that. ",
            "author": "Da Huang",
            "id": "comment-14084332"
        },
        {
            "date": "2014-08-04T14:18:11+0000",
            "content": "Thanks Da, this looks like great progress.\n\nJust to sum things up a bit here:\n\n\n\tBoth BooleanArrayScorer and BooleanLinkedScorer (which are Scorers\n    not BulkScorers) can only be used when there's at least one MUST\n    clause in the BooleanQuery.\n\n\n\n\n\tBooleanArrayScorer grabs the next SIZE (256 now) hits from the\n    MUST clauses, and then folds in the MUST_NOT and SHOULD.\n\n\n\n\n\tBooleanLinkedScorer, like BooleanScorer, matches/cores in windows\n    of 2048 docIDs at once, but it uses a bitSet (and also the linked\n    list) to track filled bucket slots.\n\n\n\n\n\tBooleanScorer now can also handle MUST clauses\n\n\n\nIt's nice that you're careful to do the math and double/float casting\nin the same order as BS2 so the scores match.\n\nIt's a bit spooky that collectMore recurses on itself; in theory\nthere's an adversary that could consume quite a bit of stack right?\nCan we refactor that to the equivalent while loop (it's \"just\" tail\nrecursion).\n\nUnfortunately the logic for picking which scorer to use looks really\ncomplex; hopefully we can simplify it.\n\nAlso, do we really need 3 scorer classes (BS, BAS, BLS) for the\nnon-DAAT case?  Ie, does each really provide a compelling situation\nwhere it's better than the others?  It's not great adding so much\ncomplexity for performance gains of unusual (so many clauses) boolean\nqueries... ",
            "author": "Michael McCandless",
            "id": "comment-14084692"
        },
        {
            "date": "2014-08-04T20:29:42+0000",
            "content": "The commit hash code mentioned here just indicates which commit the patch should apply on.\n\nI missed that. Also I mistook the date order of the patches posted here, so I thought there were only old patches.\nAnd I did not think of looking for the commit in my own repo, I thought the commit was a commit for the patch.\n\nbtw, there is a repo where I'm maintaining the code, but the repo is on the server in my lab.\n\nMy situation is very similar.\nThe latest patch applies nicely to the indicated commit with the commands given above, thanks. ",
            "author": "Paul Elschot",
            "id": "comment-14085242"
        },
        {
            "date": "2014-08-04T21:00:32+0000",
            "content": "By the perf. table of BQ, it looks that BQ perfs low on the first 4 cases. However, when I run these cases one by one, they're just worse than the trunk within 2%.\n\nThe only reason I can think of that might cause this is that in the mixed case there is less effective use of caches (L1, L2, L3) during the test. When this is the case the max difference of 20% should go down when running for example twice as many of the same queries in one go during the mixed test.\n\nBtw. BooleanScorer2 is now almost ten years old, see LUCENE-294. Lots of improvements were made since then and I'm happy to see some further possible performance improvements here. ",
            "author": "Paul Elschot",
            "id": "comment-14085276"
        },
        {
            "date": "2014-08-05T14:11:54+0000",
            "content": "Thanks for Mike and Paul's suggestions.\n\n\nIt's a bit spooky that collectMore recurses on itself; in theory\nthere's an adversary that could consume quite a bit of stack right?\nCan we refactor that to the equivalent while loop (it's \"just\" tail\nrecursion).\nOk. Doing collectMore without recursion is easy.\n\n\nUnfortunately the logic for picking which scorer to use looks really\ncomplex; hopefully we can simplify it.\nAlso, do we really need 3 scorer classes (BS, BAS, BLS) for the\nnon-DAAT case? Ie, does each really provide a compelling situation\nwhere it's better than the others? \nActually, these scorers are still very competitive when clauses are much fewer.\nI have done some tests today. Results are as follows.\n\n\n                Task        array           bs           ll\n    HighAnd10HighNot        34.7         31.7         53.7*\n     HighAnd10HighOr        27.0+        -0.9         32.6*\n     HighAnd10LowNot       -33.5         -6.5        -17.5 \n      HighAnd10LowOr       -36.7         -2.1        -43.4 \n     HighAnd5HighNot         3.0        -10.0         16.8*\n      HighAnd5HighOr       -11.5         -2.0         -4.2 \n      HighAnd5LowNot       -44.5         -9.4        -36.6 \n       HighAnd5LowOr       -56.2         -3.4        -61.9 \n     LowAnd10HighNot        18.2+        18.7+        20.0*\n      LowAnd10HighOr        21.2+        26.1*         6.0 \n      LowAnd10LowNot        19.6*        -2.4          5.7 \n       LowAnd10LowOr        13.3*        -2.7        -11.1 \n      LowAnd5HighNot         9.1*         6.9+        -2.7 \n       LowAnd5HighOr         7.6         12.5*        -9.3 \n       LowAnd5LowNot        -0.9         -4.0        -11.0 \n        LowAnd5LowOr        -7.5         -3.6        -27.2 \n\n                Task         Good Method\n    HighAnd10HighNot       ll, \n     HighAnd10HighOr       ll, array, \n     HighAnd10LowNot       \n      HighAnd10LowOr       \n     HighAnd5HighNot       ll, \n      HighAnd5HighOr       \n      HighAnd5LowNot       \n       HighAnd5LowOr       \n     LowAnd10HighNot       ll, bs, array, \n      LowAnd10HighOr       bs, array, \n      LowAnd10LowNot       array, \n       LowAnd10LowOr       array, \n      LowAnd5HighNot       array, bs, \n       LowAnd5HighOr       bs, \n       LowAnd5LowNot       \n        LowAnd5LowOr       \n================================================\n                Task        array           bs           ll\n    HighAnd25HighNot        75.3         79.1        131.5*\n     HighAnd25HighOr        69.8+        74.2+        80.8*\n     HighAnd25LowNot        -1.0          3.8         15.7*\n      HighAnd25LowOr        -3.8        -34.7         -9.1 \n     HighAnd5HighNot         8.1*        -2.9          7.8+\n      HighAnd5HighOr        -1.6         -4.1        -12.9 \n      HighAnd5LowNot       -37.3        -33.3        -39.1 \n       HighAnd5LowOr       -60.8        -42.5        -60.7 \n     LowAnd25HighNot        38.9         40.1         79.4*\n      LowAnd25HighOr        44.8*        40.2+        23.5 \n      LowAnd25LowNot        52.7+        55.7*        39.2+\n       LowAnd25LowOr        51.1*        50.8+        23.7 \n      LowAnd5HighNot        10.0+        12.0*        -2.7 \n       LowAnd5HighOr         5.0          8.0*        -9.9 \n       LowAnd5LowNot         2.6          4.1*       -10.1 \n        LowAnd5LowOr        -8.8         -5.1        -29.1 \n\n                Task         Good Method\n    HighAnd25HighNot       ll, \n     HighAnd25HighOr       ll, bs, array, \n     HighAnd25LowNot       ll, \n      HighAnd25LowOr       \n     HighAnd5HighNot       array, ll, \n      HighAnd5HighOr       \n      HighAnd5LowNot       \n       HighAnd5LowOr       \n     LowAnd25HighNot       ll, \n      LowAnd25HighOr       array, bs, \n      LowAnd25LowNot       bs, array, ll, \n       LowAnd25LowOr       array, bs, \n      LowAnd5HighNot       bs, array, \n       LowAnd5HighOr       bs, \n       LowAnd5LowNot       bs, \n        LowAnd5LowOr       \n\n\n\n\nNow, I'm just using BAS and BLS for cases with MUST, as BS's perfermance is not very competitive.\nEven though BS seems to be a compelling choice for the case LowAnd5HighOr, its superiority to BAS is not huge.\nBesides, BS can make the logics even more complicate, as BS is BulkScorer while others are Scorer.\n\nIf we still need to give up one scorer, I think it would be better to give up BLS,\nas it looks that BAS to have more positive value than BLS.\n\n\n\nIt's not great adding so much\ncomplexity for performance gains of unusual (so many clauses) boolean\nqueries...\nI'm going to just focus the *And5* & *And10* cases to optimize the perf.\nIf 10 clauses are still too many, I will just focus on the *And5* cases.\n\n\nBesides, today when I did tests to check the correctness, I discovered that \nBS, BAS, as well as BLS, are not supposed to deal with pure conjunction.\n\nTestBooleanQueryVisitSubscorers.testConjunction will fail, when these scorers have only MUST clauses.\nThis is because these three scorers do not have .getChildren() implemented.\n\nI think we should throw exception when people try to take them as ConjunctionScorer. Do you agree? ",
            "author": "Da Huang",
            "id": "comment-14086295"
        },
        {
            "date": "2014-08-08T22:18:51+0000",
            "content": "Thanks Da!\n\nNow, I'm just using BAS and BLS for cases with MUST, as BS's perfermance is not very competitive.\n\nOK, that's nice to see.\n\nIf we still need to give up one scorer, I think it would be better to give up BLS, as it looks that BAS to have more positive value than BLS.\n\nI think it makes sense to drop BLS?  Looking at your performance charts (thanks!) it looks like BAS is typically ahead of BLS.\n\nTestBooleanQueryVisitSubscorers.testConjunction will fail, when these scorers have only MUST clauses.  This is because these three scorers do not have .getChildren() implemented.\n\nOK.  Today, the caller can force DAAT scoring by returning false from Collector.acceptDocsOutOfOrder; I think it's important we keep that capability, for expert apps that want .getChildren to work.\n\nI think we should throw exception when people try to take them as ConjunctionScorer. Do you agree?\n\nI agree.  In this case it's not so different from BS2 right?  They will both just use the same ConjunctionScorer? ",
            "author": "Michael McCandless",
            "id": "comment-14091376"
        },
        {
            "date": "2014-08-09T03:19:17+0000",
            "content": "This is a patch based on git mirror commit a5a2e716ebcba1a201c4934f336ae9c0fcb551bf .\n\nIn this patch, I have fixed a bug of wrong coord counting.\n\nBesides, I have come up with an awesome idea on choosing scorer and implemented this idea in this patch.\n\nThe following is the story of this idea.\n\nAfter I have completed performance tests for each scorer, I plotted figures for the results, \nso that I can have an intuitive view on natures of each scorers.\nThe figures are showed as follows.\n\n\nThen, I discovered that the performance of each scorer can probably be fitted by a straight line.\nIt may be confusing that there're several points which look distinctive, such as (8, -20) on BAS, in LowAndNLowOr case.\nHowever, when I retested BAS again, its performance went to 10 with N = 8.\nTherefore, I just consider these 'distinctive' points as noisy points.\n\nSo, the following things to do is to get those performance curves' expressions.\nFirstly, just have a look at the perf. figures again.\nWe can find that BAS can get the best performance on average, so we just discuss BAS here.\n\nThe expressions of each performance curve' fitting line are showed as follows.  \n(Suppose that the horizontal axis is 'x', while the vertical axis is 'y')\n\n\n\n LowAndNLowOr  \n LowAndNHighOr  \n HighAndNLowOr  \n HighAndNHighOr  \n\n\n y = 5.33x - 31 \n y = 3.83x - 8.5 \n y = 1.67x - 55  \n y = 7.5x - 32.5  \n\n\n LowAndNLowNot \n LowAndNHighNot \n HighAndNLowNot \n HighAndNHighNot \n\n\n y = 4.5x - 18.5 \n y = 3x - 7   \n y = -0.83x - 22.5 \n y = 7x - 31      \n\n\n\n\n\nI got these expressions just by visual estimation.\nYou can also get similiar expressions by drawing a straight line between the first and last point on each firgure.\n\nNow suppose that the general performance expression is y = A * x + B .\nIn lucene/BooleanQuery, the only information we have is requiredCost and optionalCost(or prohibitedCost).\nFor convenience, Let's just symbolize these two values as 'a' and 'b' respectively.\n\nIf we can find two functions, f and g, which have A = f(a, b), B = g(a, b), \nwe can get the performance curve in the program.\n\nFor convenience, we just discuss A = f(a, b) here, and the case of B is just similiar to A.\nThe same, we just discuss *Or cases here, and *Not cases are just similiar ones.\n\nHere, we know the values of a and b for each case.\n\n\n\n LowAndNLowOr  \n LowAndNHighOr  \n HighAndNLowOr  \n HighAndNHighOr  \n\n\n a = L, b = L   \n a = L, b = H    \n a = H, b = L    \n a = H, b = H     \n\n\n\n\n\nAmong, L represents a low cost, while H represents a high cost.\nWe can evaluate these two value by doing a statistics on wikimedium.10M.nostopwords.tasks in luceneutil.\nHere, their evaluated values are:\n\nH = 747310, L = 34750\n\n\n\nAs, you can see, the values of H and L are too high.\nHere, we get their log value; that is\n\nh = log(H), l = log(L)\n\n\n\nSuppose that f is formatted as \n\nf(a,b) = k1 * u1(a, b) + k2 * u2(a, b) + k3 * u3(a, b) + k4 * u4(a, b)\n\n\n\nThus, we have\n\nk1 * u1(l, l) + k2 * u2(l, l) + k3 * u3(l, l) + k4 * u4(l, l) = 5.33\nk1 * u1(l, h) + k2 * u2(l, h) + k3 * u3(l, h) + k4 * u4(l, h) = 3.84\nk1 * u1(h, l) + k2 * u2(h, l) + k3 * u3(h, l) + k4 * u4(h, l) = 1.67\nk1 * u1(h, h) + k2 * u2(h, h) + k3 * u3(h, h) + k4 * u4(h, h) = 7.5\n\n\n\nThe following question is how to choose ui(a, b).\nActually, I have tried many formulations, and I found the following is the best.\n\n\n\n\nu1(a,b)\nu2(a,b)\nu3(a,b)\nu4(a,b)\n\n\n    a   \n    b   \n  a*b \n a*b/(a+b)\n\n\n\n\n\nI think such setup has its physical meanings.\nu1 and u2 are the influence factors of a and b respectively.\nu3 represents the higher dimentional factor.\nu4 is half of the harmonic mean. \n\nThus, we have\n\n[ l  l  l*l     l      ]   [ k1 ]   [5.33]\n[ l  h  l*h  l*h/(l+h) ] * [ k2 ] = [3.84]\n[ h  l  h*l  l*h/(l+h) ]   [ k3 ]   [1.67]\n[ h  h  h*h     h      ]   [ k4 ]   [7.5 ]\n\nthat is\n[  10.4559   10.4559  109.3266  5.2280 ]  \n[  10.4559   13.5242  141.4085  5.8969 ] * [k] = [A]\n[  13.5242   10.4559  141.4085  5.8969 ]\n[  13.5242   13.5242  182.9049  6.7621 ]\n\nor symbolized\n[U] * [k] = [A]\n\n\n\nLuckily, [U] is a good matrix, which means that its inverse matrix is 'calculable'.\n\n           [ -1.4365    1.1106    1.4365   -1.1106 ]\ninv([U]) = [ -1.4365    1.4365    1.1106   -1.1106 ]\n           [ -0.0312    0.0000    0.0000    0.0241 ]\n           [  6.5893   -5.0943   -5.0943    3.9386 ]\n           \n[k] = inv([U]) * [A] = [-9.3396  -8.6334  0.0145  36.6630]'\n\n\n\nNow, in the program, we can get A by,\n\nA = f(a,b) = k1 * a + k2 * b + k3 * a * b + k4 * a * b / (a + b)\n\n\nand get B in a similiar way.\n\nFinally, we get the evaluated fitting straight line of BAS in a specific case.\ny = A * x + B\n\nx is the number of optional(or prohibited) scorers.\nThus, we can use BAS, when A * N + B > THERHOLD.\n\nHere, I set the THERHOLD as 5.\n\nI have tested this idea with medium cost cases included.\nAnd it turns out that all cases performs well.\nSee the original performance file [merge.perf] and the following figures.\n ",
            "author": "Da Huang",
            "id": "comment-14091617"
        },
        {
            "date": "2014-08-11T01:14:11+0000",
            "content": "This is a patch based on git mirror commit d707f783ab068b70752a3f9cfdc0dabb7f4fbadf .\n\nIn this patch, I tried to fix the .getChildren() problem in BAS and BLS.\n\nI have tried to make .bulkScorer() choose DAAT, when scoreDocsInOrder is true.\nHowever, I discovered that I have to copy the scorer choosing logics to .scoreDocsOutOfOrder() \nto make things right.\n\nI have also tried to implement the .getChildren() method for BAS and BLS,\nbut the TAAT strategy will make scorers exhausted at the beginning.\n\nFinally, I just throw UnsupportedOperationException in BAS.getChildren() and BLS.getChildren().\n\n\nBesides, I have run more tests to make sure everything is right.\nAs you can see, the performance of HighAnd.*Low.* cases showed in merge.png is not good.\nTherefore, I ran HighAnd.*Low.* cases with luceneutil's pattern filter, and the result is as follows.\n\n                    TaskQPS baseline      StdDevQPS my_version      StdDev                Pct diff\n           HighAnd6LowOr        9.44      (6.4%)        9.19      (4.8%)   -2.6% ( -12% -    9%)\n           HighAnd5LowOr        9.00      (8.8%)        8.85      (7.4%)   -1.6% ( -16% -   16%)\n           HighAnd3LowOr       11.89      (8.9%)       11.71      (7.8%)   -1.6% ( -16% -   16%)\n           HighAnd4LowOr       10.78      (7.4%)       10.61      (6.3%)   -1.5% ( -14% -   13%)\n           HighAnd7LowOr        9.08      (7.2%)        8.94      (5.8%)   -1.5% ( -13% -   12%)\n           HighAnd8LowOr        6.32      (8.6%)        6.23      (6.9%)   -1.4% ( -15% -   15%)\n           HighAnd9LowOr        5.71      (5.7%)        5.65      (4.5%)   -1.1% ( -10% -    9%)\n                PKLookup       98.95      (4.5%)       98.38      (2.4%)   -0.6% (  -7% -    6%)\n          HighAnd9LowNot        7.49      (3.7%)        7.46      (3.2%)   -0.4% (  -7% -    6%)\n          HighAnd4LowNot       10.33      (6.4%)       10.31      (6.1%)   -0.2% ( -11% -   13%)\n          HighAnd8LowNot        6.69      (5.3%)        6.70      (4.9%)    0.1% (  -9% -   10%)\n          HighAnd7LowNot        6.82      (5.1%)        6.84      (5.0%)    0.3% (  -9% -   10%)\n          HighAnd6LowNot        9.45      (5.5%)        9.48      (4.7%)    0.3% (  -9% -   11%)\n          HighAnd3LowNot       10.80      (6.7%)       10.87      (6.1%)    0.6% ( -11% -   14%)\n          HighAnd5LowNot        4.28      (7.4%)        4.32      (7.1%)    1.0% ( -12% -   16%)\n\n\nEverything looks right.\n\nI have also run tests for more complicate tasks.\n\n                    TaskQPS baseline      StdDevQPS my_version      StdDev                Pct diff\n     LowAnd6LowOr6LowNot       31.59      (1.0%)       28.52      (2.4%)   -9.7% ( -12% -   -6%)\n    HighAnd6LowOr6LowNot        6.10      (2.7%)        5.76      (4.0%)   -5.6% ( -11% -    1%)\n     MedAnd6LowOr6LowNot        7.33      (2.3%)        7.03      (3.1%)   -4.0% (  -9% -    1%)\n    HighAnd6MedOr6LowNot        3.51      (1.5%)        3.49      (2.6%)   -0.6% (  -4% -    3%)\n                PKLookup       95.99      (5.1%)       95.48      (4.9%)   -0.5% ( -10% -    9%)\n    HighAnd6MedOr6MedNot        1.96      (1.3%)        1.97      (2.5%)    0.4% (  -3% -    4%)\n     MedAnd6MedOr6MedNot        2.34      (1.2%)        2.35      (2.3%)    0.5% (  -2% -    4%)\n   HighAnd6LowOr6HighNot        1.31      (1.1%)        1.33      (2.4%)    0.9% (  -2% -    4%)\n    HighAnd6LowOr6MedNot        3.08      (1.5%)        3.12      (2.7%)    1.2% (  -2% -    5%)\n     MedAnd6LowOr6MedNot        3.72      (1.4%)        3.89      (2.6%)    4.8% (   0% -    8%)\n   HighAnd6MedOr6HighNot        1.40      (1.0%)        1.53      (2.4%)    9.3% (   5% -   12%)\n     LowAnd6LowOr6MedNot        9.23      (2.1%)       10.19      (2.7%)   10.4% (   5% -   15%)\n    LowAnd6LowOr6HighNot        6.04      (2.5%)        6.74      (2.9%)   11.6% (   6% -   17%)\n   LowAnd6HighOr6HighNot        4.15      (3.4%)        4.72      (4.2%)   13.8% (   5% -   22%)\n    MedAnd6MedOr6HighNot        1.65      (1.2%)        1.91      (2.2%)   15.7% (  12% -   19%)\n    MedAnd6LowOr6HighNot        2.42      (1.7%)        2.80      (2.7%)   16.0% (  11% -   20%)\n    LowAnd6HighOr6LowNot        4.69      (2.9%)        5.45      (3.7%)   16.1% (   9% -   23%)\n     MedAnd6MedOr6LowNot        3.45      (1.2%)        4.04      (2.1%)   17.1% (  13% -   20%)\n     LowAnd6MedOr6LowNot        8.77      (1.6%)       10.38      (2.4%)   18.4% (  14% -   22%)\n     LowAnd6MedOr6MedNot        6.36      (2.6%)        7.55      (3.5%)   18.6% (  12% -   25%)\n    LowAnd6MedOr6HighNot        5.48      (3.1%)        6.51      (3.9%)   18.8% (  11% -   26%)\n    LowAnd6HighOr6MedNot        5.77      (3.1%)        6.86      (4.3%)   18.9% (  11% -   27%)\n   MedAnd6HighOr6HighNot        1.22      (1.0%)        1.46      (2.0%)   19.8% (  16% -   23%)\n   HighAnd6HighOr6MedNot        1.32      (1.1%)        1.59      (2.0%)   20.7% (  17% -   24%)\n    MedAnd6HighOr6MedNot        1.72      (1.5%)        2.09      (2.2%)   21.3% (  17% -   25%)\n  HighAnd6HighOr6HighNot        1.26      (1.2%)        1.56      (2.1%)   24.0% (  20% -   27%)\n   HighAnd6HighOr6LowNot        1.54      (1.3%)        1.92      (2.0%)   24.7% (  21% -   28%)\n    MedAnd6HighOr6LowNot        2.26      (1.5%)        2.85      (1.9%)   26.3% (  22% -   30%)\n\n\nAll look good.\n\nIf no other problems, I will begin to clean up those unused logics in the code such as BLS, \nand refine the javadoc. ",
            "author": "Da Huang",
            "id": "comment-14092314"
        },
        {
            "date": "2014-08-11T09:40:34+0000",
            "content": "Thanks Da, this looks like great progress.\n\nIn this patch, I have fixed a bug of wrong coord counting.\n\nIs it possible to make a test case showing what the bug was, and\nthat's fixed (and stays fixed)?\n\nAlso, do we have a test case that fails if DAAT and TAAT scoring\ndiffers (as it does on trunk today)?  I know you worked hard /\niterated to get these two to produce precisely the same score, which\nis awesome!  I want to make sure we don't regress in the future...\n\nI'm a little worried about the \"heavy math\" (the matrix) used to\ndetermine which scorer to apply, i.e. it's a little too magical when\nyou just come across it in the sources.  Can you add a comment to that\npart in the code, linking to this issue and explaining the motivation\nbehind it?  It may also be over-tuned to Wikipedia... but then each of\nthese boolean scorers should do OK.\n\n+1 to work on the javadocs / comments.  Make sure any now-done TODOs\nare removed!\n\nCan I commit TestBooleanUnevenly to trunk today?  Seems like there's\nno reason to wait...\n\nI'll run some perf tests on this patch too... ",
            "author": "Michael McCandless",
            "id": "comment-14092619"
        },
        {
            "date": "2014-08-11T11:13:08+0000",
            "content": "Thanks for your sugggestions, Mike !\n\n\nIs it possible to make a test case showing what the bug was, and\nthat's fixed (and stays fixed)?\nThe current test cases can show the bug, if you uncomment this line:\n\n//      scorerOrClass = BooleanArrayScorer.class;\n\n\n\n\nAlso, do we have a test case that fails if DAAT and TAAT scoring\ndiffers (as it does on trunk today)? \nNegative. I'll add the test case to the next patch.\n\n\nCan you add a comment to that\npart in the code, linking to this issue and explaining the motivation\nbehind it?\nSure.\n\n\nCan I commit TestBooleanUnevenly to trunk today? Seems like there's\nno reason to wait...\nYes, sure. ",
            "author": "Da Huang",
            "id": "comment-14092678"
        },
        {
            "date": "2014-08-11T13:40:14+0000",
            "content": "Commit 1617284 from Michael McCandless in branch 'dev/trunk'\n[ https://svn.apache.org/r1617284 ]\n\nLUCENE-4396: add test case ",
            "author": "ASF subversion and git services",
            "id": "comment-14092763"
        },
        {
            "date": "2014-08-11T13:40:48+0000",
            "content": "Commit 1617285 from Michael McCandless in branch 'dev/branches/branch_4x'\n[ https://svn.apache.org/r1617285 ]\n\nLUCENE-4396: add test case ",
            "author": "ASF subversion and git services",
            "id": "comment-14092764"
        },
        {
            "date": "2014-08-13T23:26:48+0000",
            "content": "This is a patch based on git mirror commit 67d17eb81b754fa242bb91e1b91070fd8b38ecd9 .\n\nIn this patch, I added test cases to make sure score calculated by BS, BAS and DAAT are same.\n\nBesides, I have deleted the unused logics and added comments. ",
            "author": "Da Huang",
            "id": "comment-14096299"
        },
        {
            "date": "2014-08-14T09:38:49+0000",
            "content": "Oh, it looks like we are down to one new added scorer,\nBooleanArrayScorer (that's a nice simplification!)?  It's a normal\nScorer (not BulkScorer), and it's only invoked if there's at least one\nMUST clause.\n\nThe matrix math is still spooky: I think it could easily be over-tuned\nto Wikipedia corpus, and I think it's hard for others to maintain\ngoing forward.  I wonder if we can somehow simplify that decision\nprocess?  I know it's tricky because we now have 3 scorer classes that\ncan handle MUST cases... ",
            "author": "Michael McCandless",
            "id": "comment-14096794"
        },
        {
            "date": "2014-08-14T11:00:30+0000",
            "content": "\nit looks like we are down to one new added scorer\nYes, we just have only one added scorer now.\n\n\n I wonder if we can somehow simplify that decision\nprocess?\nYea, I agree. The current choosing logics is indeed too tricky.\nI'm going to find a more simple and intuitive way.\nI think the perf. figures showed in perf.png is still the most important reference. ",
            "author": "Da Huang",
            "id": "comment-14096845"
        },
        {
            "date": "2014-08-14T12:45:40+0000",
            "content": "I ran the default luceneutil tasks, on full Wikipedia (en) index, with\nJava 1.8.0_05.  I use these JVM options to reduce hotspot noise:\n\n\n  -server -XX:-UseTieredCompilation -Xbatch\n\n\n\nAnd run with 4 GB heap:\n\n\nReport after iter 19:\n                    Task    QPS base      StdDev    QPS comp      StdDev                Pct diff\n               OrHighLow       22.04     (13.0%)       20.95      (7.8%)   -5.0% ( -22% -   18%)\n              OrHighHigh       32.92     (12.5%)       31.63      (7.8%)   -3.9% ( -21% -   18%)\n            OrHighNotMed       27.17      (7.3%)       26.41      (7.7%)   -2.8% ( -16% -   13%)\n               OrHighMed       27.43     (14.1%)       26.72      (7.8%)   -2.6% ( -21% -   22%)\n           OrHighNotHigh        7.14      (9.5%)        7.02      (8.1%)   -1.7% ( -17% -   17%)\n             AndHighHigh       24.87      (3.9%)       24.67      (4.7%)   -0.8% (  -9% -    8%)\n               MedPhrase       37.06      (7.8%)       36.78     (11.1%)   -0.8% ( -18% -   19%)\n            OrHighNotLow       48.28     (13.2%)       48.21      (8.1%)   -0.1% ( -18% -   24%)\n        HighSloppyPhrase       10.50      (3.2%)       10.48      (3.9%)   -0.1% (  -7% -    7%)\n         MedSloppyPhrase       46.47      (4.3%)       46.49      (4.0%)    0.0% (  -7% -    8%)\n             MedSpanNear        7.41      (5.2%)        7.43      (5.4%)    0.2% (  -9% -   11%)\n                 LowTerm      347.65      (1.7%)      351.48      (1.7%)    1.1% (  -2% -    4%)\n                  Fuzzy1       65.17     (13.9%)       65.96      (9.0%)    1.2% ( -18% -   27%)\n                  IntNRQ        3.02      (7.9%)        3.06      (2.7%)    1.3% (  -8% -   12%)\n              HighPhrase       41.20      (5.4%)       41.82      (2.5%)    1.5% (  -6% -    9%)\n                  Fuzzy2       35.60     (11.8%)       36.23      (8.5%)    1.8% ( -16% -   25%)\n                PKLookup      202.07      (3.0%)      205.78      (3.6%)    1.8% (  -4% -    8%)\n              AndHighMed       64.22      (8.5%)       65.54      (1.6%)    2.1% (  -7% -   13%)\n                Wildcard       27.13     (11.1%)       27.75      (5.9%)    2.3% ( -13% -   21%)\n                 Respell       38.65     (10.3%)       39.58      (9.1%)    2.4% ( -15% -   24%)\n               LowPhrase       14.73     (10.1%)       15.09      (6.6%)    2.5% ( -12% -   21%)\n            HighSpanNear        3.02      (9.4%)        3.10      (3.9%)    2.9% (  -9% -   17%)\n                 Prefix3       51.57     (11.0%)       53.19      (4.9%)    3.1% ( -11% -   21%)\n                 MedTerm      148.60      (5.1%)      153.51      (2.1%)    3.3% (  -3% -   11%)\n         LowSloppyPhrase       13.82      (7.7%)       14.29      (1.6%)    3.4% (  -5% -   13%)\n             LowSpanNear       14.27      (8.9%)       14.78      (5.8%)    3.6% ( -10% -   20%)\n                HighTerm       23.15      (9.1%)       24.05      (3.8%)    3.9% (  -8% -   18%)\n              AndHighLow      466.12     (16.4%)      501.68     (13.8%)    7.6% ( -19% -   45%)\n           OrNotHighHigh       14.83      (9.1%)       16.04      (5.8%)    8.1% (  -6% -   25%)\n            OrNotHighMed        8.47      (9.7%)       10.20      (4.8%)   20.4% (   5% -   38%)\n            OrNotHighLow       24.83      (9.5%)       30.66      (4.6%)   23.5% (   8% -   41%)\n\n\n\nLooks like OrNot* got faster, but other Or* are maybe a bit slower... ",
            "author": "Michael McCandless",
            "id": "comment-14096924"
        },
        {
            "date": "2014-08-15T11:52:31+0000",
            "content": "This is a patch based on git mirror commit 67d17eb81b754fa242bb91e1b91070fd8b38ecd9 .\n\nIn this patch, I simplify the logics of choosing scorers.\nI think the logic is quite simple and intuitive now.\n\nmerge-simple.perf is its original performance data.\nYou can also refer to the following figures.\n ",
            "author": "Da Huang",
            "id": "comment-14098485"
        },
        {
            "date": "2014-08-15T13:21:02+0000",
            "content": "Thanks Da, this is simpler.\n\nI'm worried about how BooleanWeight.bulkScorer first pulls BulkScorer\nfor the clauses, and then sometimes also pulls Scorer; pulling a\nScorer is not that cheap an operation in general.  Maybe if we added\ncost() to bulk scorer we could avoid that?  Or maybe we could look at\nthe BulkScorer, and if it's a DefaultBulkScorer, just ask it for the\nScorer it wrapped?\n\nThe small perf hit in BooleanScorer might just be that hotspot is less\nhappy because we converted the static classes to non-static ones\n... just speculation though. ",
            "author": "Michael McCandless",
            "id": "comment-14098534"
        },
        {
            "date": "2014-08-15T14:12:20+0000",
            "content": "Thanks for your suggestions, Mike!\n\nI'm worried about how BooleanWeight.bulkScorer first pulls BulkScorer\nfor the clauses, and then sometimes also pulls Scorer; pulling a\nScorer is not that cheap an operation in general. \nMy current plan is to break from the first weights iteration when it comes to a required scorer.\nIn this way, I'm sure that the times it pulls scorers is exactly the same as the trunk does. \n\n\nMaybe if we added .cost() to bulk scorer we could avoid that? \nI don't think so. When the logics choose DAAT but not BS, \nit has to wrap up to super.bulkScorer() and pulls all scorers again.\n\n\nOr maybe we could look at the BulkScorer, and if it's a DefaultBulkScorer, \njust ask it for the Scorer it wrapped?\nThis way may make it embarrassed when it's not a DefaultBulkScorer. but not sure.\nI will have a try. ",
            "author": "Da Huang",
            "id": "comment-14098565"
        },
        {
            "date": "2014-08-16T04:50:42+0000",
            "content": "In this patch, I make BS's classes to be static, and adjust the scorers choosing logics so that the times it pull scorers is exactly the same as the trunk does. ",
            "author": "Da Huang",
            "id": "comment-14099501"
        },
        {
            "date": "2014-08-16T11:15:33+0000",
            "content": "I have rebase the patch to the recent git mirror commit 9069570eba29b3270bf5232f4fc8f6a156ff66d1 .\n\nBesides, I've optimized the BooleanScorerCollector to make the coord calculated in the constructor. ",
            "author": "Da Huang",
            "id": "comment-14099597"
        },
        {
            "date": "2014-08-17T17:14:27+0000",
            "content": "Thanks Da, new patch applies cleanly!\n\nBut I still see some perf hit to pure OR queries:\n\n\n                    Task    QPS base      StdDev    QPS comp      StdDev                Pct diff\n               OrHighMed       29.64      (7.1%)       25.78     (11.6%)  -13.0% ( -29% -    6%)\n               OrHighLow       23.40      (7.5%)       20.74      (9.4%)  -11.4% ( -26% -    5%)\n              OrHighHigh       35.16      (7.2%)       31.26      (9.3%)  -11.1% ( -25% -    5%)\n            OrHighNotLow       52.50      (7.2%)       47.38      (9.4%)   -9.7% ( -24% -    7%)\n            OrHighNotMed       27.99      (7.2%)       26.08      (9.3%)   -6.8% ( -21% -   10%)\n                  Fuzzy2       38.75      (8.7%)       36.26      (7.6%)   -6.4% ( -20% -   10%)\n           OrHighNotHigh        7.44      (6.7%)        7.01      (8.7%)   -5.8% ( -19% -   10%)\n                  Fuzzy1       69.64      (4.9%)       67.24      (5.3%)   -3.4% ( -12% -    7%)\n                 LowTerm      357.08      (2.9%)      347.21      (5.9%)   -2.8% ( -11% -    6%)\n            HighSpanNear        3.11      (2.4%)        3.04      (9.0%)   -2.3% ( -13% -    9%)\n                 Respell       40.87      (4.4%)       39.96      (6.2%)   -2.2% ( -12% -    8%)\n               LowPhrase       15.36      (2.2%)       15.02      (8.5%)   -2.2% ( -12% -    8%)\n                 MedTerm      154.50      (2.8%)      153.13      (1.5%)   -0.9% (  -5% -    3%)\n              AndHighLow      536.51      (6.3%)      532.65     (10.5%)   -0.7% ( -16% -   17%)\n                HighTerm       24.23      (3.4%)       24.06      (1.7%)   -0.7% (  -5% -    4%)\n             AndHighHigh       25.25      (1.0%)       25.15      (1.0%)   -0.4% (  -2% -    1%)\n             MedSpanNear        7.36      (3.9%)        7.33      (4.1%)   -0.4% (  -8% -    7%)\n               MedPhrase       38.32      (1.9%)       38.17      (2.2%)   -0.4% (  -4% -    3%)\n              HighPhrase       42.07      (2.3%)       41.98      (2.4%)   -0.2% (  -4% -    4%)\n              AndHighMed       66.56      (1.7%)       66.44      (1.8%)   -0.2% (  -3% -    3%)\n                  IntNRQ        3.09      (2.1%)        3.09      (2.4%)   -0.1% (  -4% -    4%)\n                Wildcard       28.08      (2.2%)       28.06      (1.8%)   -0.1% (  -4% -    4%)\n             LowSpanNear       14.61      (4.4%)       14.61      (4.6%)    0.0% (  -8% -    9%)\n         LowSloppyPhrase       14.17      (2.0%)       14.19      (1.7%)    0.1% (  -3% -    3%)\n        HighSloppyPhrase       10.47      (3.0%)       10.49      (3.0%)    0.2% (  -5% -    6%)\n                 Prefix3       53.87      (4.3%)       54.21      (3.2%)    0.6% (  -6% -    8%)\n         MedSloppyPhrase       45.63      (9.0%)       46.57      (4.6%)    2.1% ( -10% -   17%)\n           OrNotHighHigh       15.44      (6.3%)       16.02      (6.9%)    3.8% (  -8% -   18%)\n            OrNotHighLow       25.75      (6.1%)       29.99     (10.2%)   16.5% (   0% -   34%)\n            OrNotHighMed        8.73      (8.9%)       10.20      (5.1%)   16.9% (   2% -   33%)\n\n\n\nUnfortunately, I've found hotspot to be very finicky about changes to BooleanScorer in the past; I'm not sure why.  Maybe, we have to not touch BooleanScorer here (meaning it can't accept MUST clauses) and just direct all appropriate (according to the switching criteria) queries with MUST clauses to BAS? ",
            "author": "Michael McCandless",
            "id": "comment-14099990"
        },
        {
            "date": "2014-08-17T23:55:10+0000",
            "content": "Oh, that's very unfortunate. It seems that the only choice is to recover the BS.\n\nIn this patch, I've recovered the BS. Hope to have better perf. ",
            "author": "Da Huang",
            "id": "comment-14100180"
        },
        {
            "date": "2014-08-18T03:52:13+0000",
            "content": "I've tested again with the setup exactly same as mike's.\nHere's the performance.\n\n                    TaskQPS baseline      StdDevQPS my_version      StdDev                Pct diff\n            HighSpanNear        1.05      (2.1%)        1.04      (2.1%)   -1.6% (  -5% -    2%)\n        HighSloppyPhrase        3.83      (5.3%)        3.78      (4.9%)   -1.3% ( -10% -    9%)\n                 LowTerm       78.04      (4.5%)       77.13      (4.5%)   -1.2% (  -9% -    8%)\n             MedSpanNear        2.89      (3.9%)        2.86      (3.3%)   -1.1% (  -8% -    6%)\n             LowSpanNear        5.91      (4.9%)        5.84      (4.2%)   -1.1% (  -9% -    8%)\n                HighTerm        8.02     (12.1%)        7.94     (11.4%)   -1.0% ( -21% -   25%)\n             AndHighHigh        9.84      (1.9%)        9.74      (2.4%)   -1.0% (  -5% -    3%)\n                 MedTerm       30.63      (4.7%)       30.35      (5.1%)   -0.9% ( -10% -    9%)\n         LowSloppyPhrase        5.83      (4.4%)        5.79      (4.5%)   -0.7% (  -9% -    8%)\n         MedSloppyPhrase       16.86      (4.5%)       16.75      (4.3%)   -0.6% (  -9% -    8%)\n               OrHighMed        7.57      (4.5%)        7.55      (4.1%)   -0.3% (  -8% -    8%)\n            OrNotHighLow        7.87      (5.3%)        7.84      (5.3%)   -0.3% ( -10% -   10%)\n              AndHighMed       25.10      (3.1%)       25.05      (3.7%)   -0.2% (  -6% -    6%)\n                  Fuzzy2       10.80      (2.7%)       10.78      (2.9%)   -0.1% (  -5% -    5%)\n              OrHighHigh        8.75      (4.4%)        8.74      (4.1%)   -0.1% (  -8% -    8%)\n            OrHighNotMed        7.33      (4.4%)        7.33      (4.0%)   -0.1% (  -8% -    8%)\n           OrNotHighHigh        4.84      (5.1%)        4.84      (5.0%)   -0.1% (  -9% -   10%)\n               OrHighLow        6.67      (4.6%)        6.66      (4.5%)   -0.1% (  -8% -    9%)\n            OrNotHighMed        2.90      (5.2%)        2.89      (5.2%)   -0.1% ( -10% -   10%)\n           OrHighNotHigh        2.32      (4.9%)        2.32      (4.6%)   -0.0% (  -9% -    9%)\n                  Fuzzy1       20.35      (3.1%)       20.38      (3.4%)    0.1% (  -6% -    6%)\n            OrHighNotLow       13.54      (4.5%)       13.56      (4.2%)    0.2% (  -8% -    9%)\n               MedPhrase       11.75      (3.2%)       11.78      (2.4%)    0.2% (  -5% -    5%)\n               LowPhrase        6.08      (2.9%)        6.09      (2.7%)    0.2% (  -5% -    6%)\n              HighPhrase       13.25      (3.8%)       13.29      (3.4%)    0.3% (  -6% -    7%)\n                 Prefix3       19.78      (3.2%)       19.85      (3.9%)    0.4% (  -6% -    7%)\n                 Respell       15.13      (3.1%)       15.19      (3.7%)    0.4% (  -6% -    7%)\n                Wildcard        8.82      (3.3%)        8.89      (4.9%)    0.8% (  -7% -    9%)\n                  IntNRQ        0.85      (4.2%)        0.86      (6.0%)    1.3% (  -8% -   12%)\n              AndHighLow      172.85      (4.9%)      175.57      (4.7%)    1.6% (  -7% -   11%)\n\n ",
            "author": "Da Huang",
            "id": "comment-14100255"
        },
        {
            "date": "2014-08-18T09:49:59+0000",
            "content": "OK indeed I see effectively no perf diffs for the default tasks:\n\n\nReport after iter 19:\n                    Task    QPS base      StdDev    QPS comp      StdDev                Pct diff\n                 LowTerm      159.50     (18.8%)      157.56     (17.0%)   -1.2% ( -31% -   42%)\n               LowPhrase        9.13      (2.3%)        9.10      (3.0%)   -0.3% (  -5% -    5%)\n              HighPhrase       22.96      (3.2%)       22.89      (4.0%)   -0.3% (  -7% -    7%)\n               MedPhrase       20.96      (2.6%)       20.91      (3.5%)   -0.2% (  -6% -    6%)\n         LowSloppyPhrase        9.01      (4.2%)        9.02      (4.3%)    0.1% (  -8% -    8%)\n                  Fuzzy1       34.93      (4.3%)       34.96      (5.2%)    0.1% (  -9% -   10%)\n                 Respell       23.59      (2.9%)       23.64      (2.9%)    0.2% (  -5% -    6%)\n         MedSloppyPhrase       27.69      (5.1%)       27.76      (4.8%)    0.3% (  -9% -   10%)\n        HighSloppyPhrase        6.39      (6.3%)        6.41      (6.4%)    0.3% ( -11% -   13%)\n              AndHighMed       39.17      (1.9%)       39.30      (2.1%)    0.4% (  -3% -    4%)\n                 MedTerm       76.73      (9.0%)       77.02      (8.6%)    0.4% ( -15% -   19%)\n             AndHighHigh       15.19      (1.6%)       15.26      (2.4%)    0.4% (  -3% -    4%)\n             MedSpanNear        4.14      (4.7%)        4.16      (5.7%)    0.4% (  -9% -   11%)\n            HighSpanNear        1.49      (3.3%)        1.50      (4.6%)    0.5% (  -7% -    8%)\n             LowSpanNear        8.60      (6.0%)        8.67      (7.5%)    0.8% ( -11% -   15%)\n                HighTerm       13.12      (8.6%)       13.24     (10.1%)    0.9% ( -16% -   21%)\n               OrHighMed       15.47      (6.3%)       15.62      (6.0%)    0.9% ( -10% -   14%)\n           OrNotHighHigh        8.61      (7.2%)        8.70      (6.9%)    1.1% ( -12% -   16%)\n            OrHighNotLow       26.60      (5.8%)       26.95      (5.9%)    1.3% (  -9% -   13%)\n            OrHighNotMed       14.53      (6.6%)       14.72      (6.1%)    1.3% ( -10% -   15%)\n               OrHighLow       12.25      (6.5%)       12.42      (6.9%)    1.4% ( -11% -   15%)\n           OrHighNotHigh        4.06      (7.3%)        4.12      (6.5%)    1.4% ( -11% -   16%)\n                 Prefix3       30.14      (3.5%)       30.58      (4.2%)    1.4% (  -6% -    9%)\n              OrHighHigh       18.13      (6.1%)       18.40      (6.1%)    1.5% ( -10% -   14%)\n            OrNotHighLow       14.43      (7.6%)       14.65      (7.6%)    1.5% ( -12% -   18%)\n                Wildcard       15.10      (4.2%)       15.34      (6.2%)    1.6% (  -8% -   12%)\n                  Fuzzy2       20.01      (4.0%)       20.39      (3.7%)    1.9% (  -5% -   10%)\n              AndHighLow      278.92      (3.2%)      284.79      (3.7%)    2.1% (  -4% -    9%)\n            OrNotHighMed        5.10      (7.8%)        5.22      (7.6%)    2.2% ( -12% -   19%)\n                  IntNRQ        1.63      (5.7%)        1.69     (10.3%)    3.7% ( -11% -   20%)\n\n\n\nI'll run with And.tasks next... ",
            "author": "Michael McCandless",
            "id": "comment-14100492"
        },
        {
            "date": "2014-08-18T12:46:53+0000",
            "content": "And.tasks perf:\n\n\nReport after iter 19:\n                    Task    QPS base      StdDev    QPS comp      StdDev                Pct diff\n          HighAnd5LowNot       15.44      (5.9%)       14.86      (1.8%)   -3.8% ( -10% -    4%)\n         HighAnd5HighNot        2.95      (2.0%)        2.93      (1.1%)   -0.8% (  -3% -    2%)\n         HighAnd60LowNot        2.18      (1.9%)        2.17      (1.5%)   -0.5% (  -3% -    2%)\n          LowAnd5HighNot       11.21      (2.0%)       11.17      (1.8%)   -0.3% (  -4% -    3%)\n           LowAnd5HighOr       16.29      (2.5%)       16.27      (2.1%)   -0.1% (  -4% -    4%)\n           LowAnd5LowNot       46.98      (3.1%)       47.02      (2.3%)    0.1% (  -5% -    5%)\n          HighAnd60LowOr        2.00      (2.1%)        2.01      (1.6%)    0.3% (  -3% -    3%)\n          HighAnd5HighOr        2.71      (2.9%)        2.73      (1.4%)    1.0% (  -3% -    5%)\n           HighAnd5LowOr       16.17     (10.5%)       16.49      (2.6%)    2.0% ( -10% -   16%)\n            LowAnd5LowOr       45.06      (4.2%)       46.11      (3.2%)    2.3% (  -4% -   10%)\n         LowAnd60HighNot        1.03      (1.8%)        1.59      (3.4%)   53.4% (  47% -   59%)\n          LowAnd60HighOr        0.87      (1.7%)        1.44      (3.7%)   64.7% (  58% -   71%)\n          LowAnd60LowNot        3.55      (2.1%)        6.68      (3.3%)   88.2% (  81% -   95%)\n           LowAnd60LowOr        3.66      (1.6%)        7.05      (3.6%)   92.5% (  85% -   99%)\n        HighAnd60HighNot        0.19      (2.1%)        0.39      (3.8%)  106.4% (  98% -  114%)\n         HighAnd60HighOr        0.15      (1.6%)        0.34      (3.2%)  119.0% ( 112% -  125%)\n\n ",
            "author": "Michael McCandless",
            "id": "comment-14100596"
        },
        {
            "date": "2014-08-18T13:12:54+0000",
            "content": "A new tasks file, and the program which can generate it.\n\nIn order to generate the tasks file with the program, you can run:\n\ng++ tasks.cpp -std=c++0x -o tasks\n./tasks <  wikimedium.10M.nostopwords.tasks > And.tasks\n\n ",
            "author": "Da Huang",
            "id": "comment-14100612"
        },
        {
            "date": "2014-08-18T21:05:09+0000",
            "content": "OK I tested on the larger And.tasks:\n\n\nReport after iter 19:\n                    Task    QPS base      StdDev    QPS comp      StdDev                Pct diff\n          HighAnd3LowNot       12.63      (5.9%)       11.26      (2.0%)  -10.8% ( -17% -   -3%)\n          HighAnd4LowNot       11.41      (5.8%)       10.24      (2.0%)  -10.3% ( -17% -   -2%)\n          HighAnd7LowNot        7.69      (5.4%)        6.95      (1.8%)   -9.7% ( -15% -   -2%)\n          HighAnd9LowNot        7.75      (4.8%)        7.06      (1.6%)   -8.8% ( -14% -   -2%)\n           MedAnd3LowNot       26.09      (4.9%)       23.79      (1.8%)   -8.8% ( -14% -   -2%)\n          HighAnd5LowNot       17.15      (4.4%)       15.81      (1.6%)   -7.8% ( -13% -   -1%)\n          HighAnd6LowNot       16.26      (4.1%)       15.13      (1.4%)   -6.9% ( -11% -   -1%)\n           MedAnd4LowNot       26.69      (3.7%)       25.14      (1.4%)   -5.8% ( -10% -    0%)\n          HighAnd8LowNot       14.88      (3.2%)       14.13      (1.1%)   -5.0% (  -9% -    0%)\n           MedAnd7LowNot       18.29      (3.0%)       17.38      (1.1%)   -5.0% (  -8% -    0%)\n           MedAnd8LowNot       15.96      (3.1%)       15.21      (1.0%)   -4.7% (  -8% -    0%)\n          HighAnd4MedNot        6.63      (3.0%)        6.32      (1.2%)   -4.7% (  -8% -    0%)\n           MedAnd5LowNot       23.66      (2.7%)       22.69      (1.1%)   -4.1% (  -7% -    0%)\n          HighAnd6MedNot        5.16      (2.5%)        4.95      (1.0%)   -3.9% (  -7% -    0%)\n          HighAnd5MedNot        5.95      (2.3%)        5.73      (1.0%)   -3.7% (  -6% -    0%)\n           MedAnd9LowNot       16.50      (2.6%)       15.91      (0.9%)   -3.6% (  -6% -    0%)\n          HighAnd3MedNot       11.60      (2.3%)       11.20      (1.4%)   -3.4% (  -6% -    0%)\n           MedAnd6LowNot       25.79      (2.6%)       24.91      (1.1%)   -3.4% (  -6% -    0%)\n          HighAnd7MedNot        4.51      (2.1%)        4.37      (1.0%)   -3.2% (  -6% -    0%)\n           LowAnd3LowNot       72.70      (2.4%)       70.53      (1.1%)   -3.0% (  -6% -    0%)\n           MedAnd3MedNot       15.50      (1.9%)       15.04      (1.1%)   -3.0% (  -5% -    0%)\n         HighAnd3HighNot        3.71      (1.9%)        3.61      (1.4%)   -2.8% (  -5% -    0%)\n           MedAnd4MedNot       12.83      (1.9%)       12.47      (1.0%)   -2.8% (  -5% -    0%)\n           LowAnd3MedNot       38.64      (1.8%)       37.79      (1.6%)   -2.2% (  -5% -    1%)\n          HighAnd8MedNot        4.42      (1.6%)        4.32      (1.0%)   -2.2% (  -4% -    0%)\n         HighAnd5HighNot        3.44      (1.5%)        3.36      (1.0%)   -2.2% (  -4% -    0%)\n          MedAnd3HighNot        7.56      (1.4%)        7.42      (1.3%)   -1.9% (  -4% -    0%)\n           LowAnd5LowNot       47.22      (1.9%)       46.38      (1.7%)   -1.8% (  -5% -    1%)\n          MedAnd4HighNot        8.43      (1.4%)        8.29      (1.1%)   -1.7% (  -4% -    0%)\n           LowAnd4LowNot       58.26      (2.3%)       57.28      (1.4%)   -1.7% (  -5% -    2%)\n           MedAnd5MedNot       14.06      (1.4%)       13.83      (1.1%)   -1.6% (  -4% -    0%)\n          LowAnd3HighNot       28.74      (2.4%)       28.36      (2.4%)   -1.3% (  -5% -    3%)\n           LowAnd5MedNot       23.30      (1.5%)       23.01      (1.8%)   -1.3% (  -4% -    2%)\n         HighAnd4HighNot        4.14      (1.2%)        4.09      (1.1%)   -1.1% (  -3% -    1%)\n          MedAnd5HighNot        4.83      (1.3%)        4.78      (1.2%)   -1.0% (  -3% -    1%)\n          LowAnd4HighNot       81.42      (1.8%)       80.63      (2.3%)   -1.0% (  -4% -    3%)\n           LowAnd4MedNot       33.59      (1.2%)       33.27      (1.2%)   -0.9% (  -3% -    1%)\n          LowAnd5HighNot       10.79      (2.2%)       10.72      (2.2%)   -0.6% (  -4% -    3%)\n           LowAnd4HighOr       14.62      (2.6%)       14.61      (2.5%)   -0.1% (  -5% -    5%)\n           LowAnd3HighOr       17.87      (2.8%)       17.87      (2.4%)    0.0% (  -4% -    5%)\n           LowAnd5HighOr       15.44      (2.3%)       15.46      (2.5%)    0.1% (  -4% -    5%)\n            LowAnd4MedOr       27.91      (1.8%)       27.95      (1.8%)    0.1% (  -3% -    3%)\n            LowAnd5MedOr       19.76      (2.0%)       19.79      (1.6%)    0.1% (  -3% -    3%)\n            LowAnd3MedOr       35.41      (2.5%)       35.56      (1.9%)    0.4% (  -3% -    4%)\n            LowAnd3LowOr       72.38      (3.2%)       72.95      (1.2%)    0.8% (  -3% -    5%)\n           MedAnd3HighOr        5.77      (2.6%)        5.82      (1.5%)    0.8% (  -3% -    5%)\n            LowAnd5LowOr       44.94      (3.3%)       45.33      (1.4%)    0.9% (  -3% -    5%)\n           MedAnd5HighOr        6.88      (2.0%)        6.94      (0.9%)    0.9% (  -2% -    3%)\n           MedAnd4HighOr        7.48      (2.2%)        7.55      (1.1%)    0.9% (  -2% -    4%)\n           HighAnd7LowOr        5.63     (12.5%)        5.69      (1.2%)    1.0% ( -11% -   16%)\n            MedAnd6LowOr       27.56      (4.0%)       27.84      (1.2%)    1.0% (  -4% -    6%)\n           HighAnd3LowOr        9.96     (13.4%)       10.06      (1.3%)    1.0% ( -12% -   18%)\n            MedAnd8LowOr       19.01      (3.3%)       19.21      (0.9%)    1.1% (  -3% -    5%)\n            MedAnd9LowOr       17.51      (2.9%)       17.73      (0.8%)    1.3% (  -2% -    5%)\n            MedAnd5LowOr       22.88      (7.5%)       23.19      (1.1%)    1.3% (  -6% -   10%)\n           HighAnd8LowOr       12.29      (8.6%)       12.45      (1.1%)    1.3% (  -7% -   12%)\n            MedAnd7LowOr       20.30      (4.4%)       20.58      (1.0%)    1.4% (  -3% -    7%)\n           HighAnd9LowOr       10.82      (8.7%)       10.98      (1.1%)    1.4% (  -7% -   12%)\n           HighAnd6MedOr        6.06      (4.0%)        6.15      (0.9%)    1.4% (  -3% -    6%)\n            MedAnd3LowOr       26.52     (10.5%)       26.91      (1.2%)    1.5% (  -9% -   14%)\n            LowAnd4LowOr       53.92      (3.5%)       54.71      (1.6%)    1.5% (  -3% -    6%)\n           HighAnd6LowOr       15.37      (9.0%)       15.60      (1.1%)    1.5% (  -7% -   12%)\n            MedAnd4LowOr       27.39      (8.7%)       27.80      (1.3%)    1.5% (  -7% -   12%)\n           HighAnd5LowOr       17.05      (9.5%)       17.31      (1.3%)    1.5% (  -8% -   13%)\n           HighAnd4LowOr       25.42      (9.2%)       25.83      (1.1%)    1.6% (  -8% -   13%)\n            MedAnd4MedOr       10.42      (3.3%)       10.59      (0.8%)    1.6% (  -2% -    5%)\n           HighAnd9MedOr        3.29      (3.7%)        3.34      (0.8%)    1.6% (  -2% -    6%)\n           HighAnd4MedOr        7.91      (5.6%)        8.04      (1.0%)    1.7% (  -4% -    8%)\n            MedAnd5MedOr        8.01      (3.6%)        8.15      (0.8%)    1.7% (  -2% -    6%)\n           HighAnd5MedOr        5.92      (4.2%)        6.02      (0.9%)    1.7% (  -3% -    7%)\n           HighAnd8MedOr        3.09      (3.4%)        3.14      (0.8%)    1.7% (  -2% -    6%)\n            MedAnd3MedOr       13.67      (5.1%)       13.91      (1.1%)    1.8% (  -4% -    8%)\n          HighAnd4HighOr        2.71      (4.1%)        2.76      (0.9%)    1.9% (  -3% -    7%)\n          HighAnd5HighOr        2.91      (3.2%)        2.96      (0.8%)    1.9% (  -2% -    6%)\n           HighAnd3MedOr        8.92      (5.5%)        9.10      (0.9%)    2.0% (  -4% -    8%)\n          HighAnd3HighOr        4.80      (5.2%)        4.89      (0.9%)    2.0% (  -3% -    8%)\n            MedAnd6MedOr        4.38      (4.3%)        4.52      (0.7%)    3.2% (  -1% -    8%)\n           MedAnd6MedNot        7.22      (1.5%)        7.60      (2.4%)    5.3% (   1% -    9%)\n          HighAnd6HighOr        1.54      (3.7%)        1.63      (0.9%)    6.2% (   1% -   11%)\n         HighAnd6HighNot        3.26      (1.2%)        3.49      (2.2%)    6.8% (   3% -   10%)\n           LowAnd6LowNot       44.49      (1.3%)       48.71      (2.4%)    9.5% (   5% -   13%)\n           LowAnd7LowNot       33.91      (1.6%)       37.82      (2.6%)   11.5% (   7% -   15%)\n          LowAnd6HighNot       10.75      (2.1%)       12.21      (2.5%)   13.5% (   8% -   18%)\n           LowAnd6MedNot       22.24      (1.5%)       25.81      (2.1%)   16.0% (  12% -   19%)\n          MedAnd6HighNot        4.99      (1.2%)        5.81      (1.6%)   16.4% (  13% -   19%)\n           MedAnd7MedNot        7.99      (0.9%)        9.35      (2.3%)   16.9% (  13% -   20%)\n          LowAnd7HighNot       12.14      (2.1%)       14.24      (2.3%)   17.3% (  12% -   22%)\n           LowAnd8LowNot       30.14      (1.3%)       35.43      (2.0%)   17.5% (  14% -   21%)\n         HighAnd8HighNot        2.16      (1.0%)        2.55      (2.2%)   18.0% (  14% -   21%)\n           LowAnd9LowNot       31.23      (1.6%)       36.93      (2.6%)   18.3% (  13% -   22%)\n          HighAnd9MedNot        4.28      (1.2%)        5.07      (2.4%)   18.5% (  14% -   22%)\n            LowAnd6LowOr       44.85      (2.9%)       53.16      (6.0%)   18.5% (   9% -   28%)\n          LowAnd8HighNot        8.27      (2.1%)        9.82      (2.8%)   18.7% (  13% -   24%)\n           LowAnd7MedNot       18.14      (1.4%)       21.67      (1.6%)   19.4% (  16% -   22%)\n         HighAnd9HighNot        1.84      (1.2%)        2.20      (2.3%)   20.0% (  16% -   23%)\n           HighAnd7MedOr        4.77      (2.5%)        5.73      (2.2%)   20.1% (  15% -   25%)\n           LowAnd7HighOr        8.47      (2.3%)       10.19      (3.0%)   20.3% (  14% -   26%)\n           LowAnd6HighOr       10.98      (2.3%)       13.25      (3.0%)   20.7% (  14% -   26%)\n         HighAnd7HighNot        3.11      (1.0%)        3.77      (1.8%)   21.1% (  18% -   24%)\n           MedAnd8MedNot        6.94      (1.1%)        8.48      (2.3%)   22.2% (  18% -   25%)\n           LowAnd9HighOr        7.52      (2.5%)        9.23      (3.1%)   22.7% (  16% -   29%)\n            MedAnd7MedOr        4.89      (2.5%)        6.00      (2.9%)   22.8% (  16% -   28%)\n          LowAnd9HighNot        7.70      (1.8%)        9.46      (2.5%)   22.9% (  18% -   27%)\n           LowAnd8MedNot       16.93      (1.3%)       20.81      (2.3%)   23.0% (  19% -   26%)\n          MedAnd7HighNot        4.89      (1.1%)        6.07      (1.8%)   24.0% (  20% -   27%)\n           LowAnd8HighOr        8.70      (2.2%)       10.82      (3.4%)   24.4% (  18% -   30%)\n            LowAnd7MedOr       16.85      (2.0%)       20.99      (3.2%)   24.5% (  18% -   30%)\n           MedAnd9MedNot        7.06      (1.1%)        8.85      (1.9%)   25.3% (  22% -   28%)\n            LowAnd7LowOr       36.86      (2.2%)       46.19      (5.2%)   25.3% (  17% -   33%)\n            LowAnd6MedOr       21.10      (1.7%)       26.47      (3.2%)   25.4% (  20% -   30%)\n            LowAnd8LowOr       29.79      (1.9%)       37.49      (4.6%)   25.8% (  18% -   32%)\n           LowAnd9MedNot       13.51      (1.5%)       17.31      (2.6%)   28.1% (  23% -   32%)\n          MedAnd9HighNot        3.75      (1.1%)        4.84      (1.7%)   29.1% (  26% -   32%)\n          MedAnd8HighNot        3.39      (1.1%)        4.40      (1.7%)   29.8% (  26% -   32%)\n           MedAnd6HighOr        4.54      (1.9%)        5.90      (2.4%)   29.9% (  25% -   34%)\n            MedAnd8MedOr       10.56      (1.8%)       13.76      (2.7%)   30.3% (  25% -   35%)\n          HighAnd7HighOr        2.06      (2.3%)        2.69      (3.2%)   30.3% (  24% -   36%)\n           MedAnd7HighOr        4.86      (1.8%)        6.44      (2.3%)   32.5% (  28% -   37%)\n            LowAnd8MedOr       15.35      (1.8%)       20.45      (3.1%)   33.2% (  27% -   38%)\n            MedAnd9MedOr        3.77      (2.0%)        5.03      (3.0%)   33.4% (  27% -   39%)\n          HighAnd8HighOr        1.67      (2.0%)        2.25      (3.2%)   34.3% (  28% -   40%)\n           MedAnd8HighOr        4.07      (1.8%)        5.49      (2.7%)   34.8% (  29% -   39%)\n          HighAnd9HighOr        1.40      (2.2%)        1.89      (3.4%)   35.1% (  28% -   41%)\n            LowAnd9MedOr       11.78      (1.9%)       16.23      (3.3%)   37.8% (  31% -   43%)\n           MedAnd9HighOr        2.82      (1.6%)        3.92      (2.3%)   39.1% (  34% -   43%)\n            LowAnd9LowOr       25.34      (1.6%)       37.25      (5.9%)   47.0% (  38% -   55%)\n\n ",
            "author": "Michael McCandless",
            "id": "comment-14101296"
        }
    ]
}