{
    "id": "LUCENE-84",
    "title": "Enhanced FSDirectory that allow lock disable via API",
    "details": {
        "labels": "",
        "priority": "Minor",
        "components": [
            "core/store"
        ],
        "type": "Improvement",
        "fix_versions": [
            "1.9"
        ],
        "affect_versions": "None",
        "resolution": "Fixed",
        "status": "Closed"
    },
    "description": "Below is a new version of FSDirectory.java.  It is based on 1/30/2003 source.\n\nI have added one new version each of getDirectory(File) and getDirectory\n(String). They take a new third argument 'boolean useLocks'.\n\nThe previous 'private static final boolean DISABLE_LOCKS' has been changed \nto 'private static boolean _disableLocks' and is initialized to false. I also \nadded a new method 'private boolean locksDisabledByProp' that checks \nthe 'disableLuceneLocks' system property.\n\nMethod makeLock now checks the static _disableLocks as the first term in an OR \nclause, the second of which is a call to locksDisabledByProp. This allows use \nin an applet that does not have write access to the local filesystem, and when \nthe API is used in that way prevents the query of the system property that is \nalso disallowed in an applet by default (at least in Mozilla/Netscape).\n\nFrom my applet, I can now invoke:\n\nSearcher searcher = new IndexSearcher(\n      IndexReader.open(FSDirectory.getDirectory(indexFile, false, false)));\n\nand I get an IndexSearcher that will work in the applet with no special \npermissions other than applet JAR signing.\n\nObviously, email me (jmethot@bea.com) if you have any questions.\n\n\n\t\n\t\n\t\t\n\t\t\n\t\t\t\n\t\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\t\t\n\t\t\t\t\t\t\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tFSDirectory.java *******************************\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\n\t\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t\n\t\t\t\n\t\t\n\t\t\n\t\n\t\n\n\n\npackage org.apache.lucene.store;\n\n/* ====================================================================\n\n\tThe Apache Software License, Version 1.1\n *\n\tCopyright (c) 2001 The Apache Software Foundation.  All rights\n\treserved.\n *\n\tRedistribution and use in source and binary forms, with or without\n\tmodification, are permitted provided that the following conditions\n\tare met:\n *\n\t1. Redistributions of source code must retain the above copyright\n\tnotice, this list of conditions and the following disclaimer.\n *\n\t2. Redistributions in binary form must reproduce the above copyright\n\tnotice, this list of conditions and the following disclaimer in\n\tthe documentation and/or other materials provided with the\n\tdistribution.\n *\n\t3. The end-user documentation included with the redistribution,\n\tif any, must include the following acknowledgment:\n\t\"This product includes software developed by the\n\tApache Software Foundation (http://www.apache.org/).\"\n\tAlternately, this acknowledgment may appear in the software itself,\n\tif and wherever such third-party acknowledgments normally appear.\n *\n\t4. The names \"Apache\" and \"Apache Software Foundation\" and\n\t\"Apache Lucene\" must not be used to endorse or promote products\n\tderived from this software without prior written permission. For\n\twritten permission, please contact apache@apache.org.\n *\n\t5. Products derived from this software may not be called \"Apache\",\n\t\"Apache Lucene\", nor may \"Apache\" appear in their name, without\n\tprior written permission of the Apache Software Foundation.\n *\n\tTHIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n\tWARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n\tOF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n\tDISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n\tITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n\tSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n\tLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n\tUSE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n\tON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n\tOR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n\tOF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n\tSUCH DAMAGE.\n\t====================================================================\n *\n\tThis software consists of voluntary contributions made by many\n\tindividuals on behalf of the Apache Software Foundation.  For more\n\tinformation on the Apache Software Foundation, please see\n\t<http://www.apache.org/>.\n */\n\n\n\nimport java.io.IOException;\nimport java.io.File;\nimport java.io.RandomAccessFile;\nimport java.util.Hashtable;\n\nimport org.apache.lucene.util.Constants;\n\n/**\n\n\tStraightforward implementation of \n{@link Directory}\n as a directory of files.\n\t<p>If the system property 'disableLuceneLocks' has the String value of\n\t\"true\", lock creation will be disabled.\n *\n\t@see Directory\n\t@author Doug Cutting\n */\n\n\n\npublic final class FSDirectory extends Directory {\n  /** This cache of directories ensures that there is a unique Directory\n\n\tinstance per path, so that synchronization on the Directory can be used to\n\tsynchronize access between readers and writers.\n   *\n\tThis should be a WeakHashMap, so that entries can be GC'd, but that would\n\trequire Java 1.2.  Instead we use refcounts...  */\n  private static final Hashtable DIRECTORIES = new Hashtable();\n\n\n\n  private static boolean _disableLocks = false;\n\n  private boolean locksDisabledByProp()\n  {\n      return Boolean.getBoolean(\"disableLuceneLocks\") || Constants.JAVA_1_1;\n  }\n\n  /** Returns the directory instance for the named location, with option of\n\n\tdisabled locking.\n   *\n\t<p>Directories are cached, so that, for a given canonical path, the same\n\tFSDirectory instance will always be returned.  This permits\n\tsynchronization on directories.\n   *\n\t@param path the path to the directory.\n\t@param create if true, create, or erase any existing contents.\n\t@param useLocks if false, don't use locks during index reads. Useful in\n\tread-only filesystems or from applets.\n\t@return the FSDirectory for the named file.  */\n  public static FSDirectory getDirectory(String path, boolean create, boolean \nuseLocks)\n      throws IOException \n{\n    _disableLocks = !useLocks;\n    return getDirectory(new File(path), create);\n  }\n\n\n\n  /** Returns the directory instance for the named location.\n   *\n\n\t<p>Directories are cached, so that, for a given canonical path, the same\n\tFSDirectory instance will always be returned.  This permits\n\tsynchronization on directories.\n   *\n\t@param path the path to the directory.\n\t@param create if true, create, or erase any existing contents.\n\t@return the FSDirectory for the named file.  */\n  public static FSDirectory getDirectory(String path, boolean create)\n      throws IOException \n{\n    return getDirectory(new File(path), create);\n  }\n\n\n\n  /** Returns the directory instance for the named location, with option of\n\n\tdisabled locking.\n   *\n\t<p>Directories are cached, so that, for a given canonical path, the same\n\tFSDirectory instance will always be returned.  This permits\n\tsynchronization on directories.\n   *\n\t@param file the path to the directory.\n\t@param create if true, create, or erase any existing contents.\n\t@param useLocks if false, don't use locks during index reads. Useful in\n\tread-only filesystems or from applets.\n\t@return the FSDirectory for the named file.  */\n  public static FSDirectory getDirectory(File file, boolean create, boolean \nuseLocks)\n    throws IOException \n{\n    _disableLocks = !useLocks;\n    return getDirectory(file, create);\n  }\n\n\n\n  /** Returns the directory instance for the named location.\n   *\n\n\t<p>Directories are cached, so that, for a given canonical path, the same\n\tFSDirectory instance will always be returned.  This permits\n\tsynchronization on directories.\n   *\n\t@param file the path to the directory.\n\t@param create if true, create, or erase any existing contents.\n\t@return the FSDirectory for the named file.  */\n  public static FSDirectory getDirectory(File file, boolean create)\n    throws IOException {\n    file = new File(file.getCanonicalPath());\n    FSDirectory dir;\n    synchronized (DIRECTORIES) \nUnknown macro: {      dir = (FSDirectory)DIRECTORIES.get(file);      if (dir == null) {\n\tdir = new FSDirectory(file, create);\n\tDIRECTORIES.put(file, dir);\n      } else if (create) {\n        dir.create();\n      }    } \n    synchronized (dir) \n{\n      dir.refCount++;\n    }\n    return dir;\n  }\n\n\n\n  private File directory = null;\n  private int refCount;\n\n  private FSDirectory(File path, boolean create) throws IOException \n{\n    directory = path;\n\n    if (create)\n      create();\n\n    if (!directory.isDirectory())\n      throw new IOException(path + \" not a directory\");\n  }\n\n  private synchronized void create() throws IOException {\n    if (!directory.exists())\n\tif (!directory.mkdir())\n\t    throw new IOException(\"Cannot create directory: \" + directory);\n\n    String[] files = directory.list();            // clear old files\n    for (int i = 0; i < files.length; i++) \n{\n      File file = new File(directory, files[i]);\n      if (!file.delete())\n        throw new IOException(\"couldn't delete \" + files[i]);\n    }\n  }\n\n  /** Returns an array of strings, one for each file in the directory. */\n  public final String[] list() throws IOException \n{\n    return directory.list();\n  }\n\n  /** Returns true iff a file with the given name exists. */\n  public final boolean fileExists(String name) throws IOException \n{\n    File file = new File(directory, name);\n    return file.exists();\n  }\n\n  /** Returns the time the named file was last modified. */\n  public final long fileModified(String name) throws IOException \n{\n    File file = new File(directory, name);\n    return file.lastModified();\n  }\n\n  /** Returns the time the named file was last modified. */\n  public static final long fileModified(File directory, String name)\n       throws IOException {    File file = new File(directory, name);    return file.lastModified();  }\n\n  /** Set the modified time of an existing file to now. */\n  public void touchFile(String name) throws IOException \n{\n    File file = new File(directory, name);\n    file.setLastModified(System.currentTimeMillis());\n  }\n\n  /** Returns the length in bytes of a file in the directory. */\n  public final long fileLength(String name) throws IOException \n{\n    File file = new File(directory, name);\n    return file.length();\n  }\n\n  /** Removes an existing file in the directory. */\n  public final void deleteFile(String name) throws IOException \n{\n    File file = new File(directory, name);\n    if (!file.delete())\n      throw new IOException(\"couldn't delete \" + name);\n  }\n\n  /** Renames an existing file in the directory. */\n  public final synchronized void renameFile(String from, String to)\n      throws IOException \n{\n    File old = new File(directory, from);\n    File nu = new File(directory, to);\n\n    /* This is not atomic.  If the program crashes between the call to\n       delete() and the call to renameTo() then we're screwed, but I've\n       been unable to figure out how else to do this... */\n\n    if (nu.exists())\n      if (!nu.delete())\n\tthrow new IOException(\"couldn't delete \" + to);\n\n    if (!old.renameTo(nu))\n      throw new IOException(\"couldn't rename \" + from + \" to \" + to);\n  }\n\n  /** Creates a new, empty file in the directory with the given name.\n      Returns a stream writing this file. */\n  public final OutputStream createFile(String name) throws IOException \n{\n    return new FSOutputStream(new File(directory, name));\n  }\n\n  /** Returns a stream reading an existing file. */\n  public final InputStream openFile(String name) throws IOException \n{\n    return new FSInputStream(new File(directory, name));\n  }\n\n  /** Constructs a \n{@link Lock}\n with the specified name.  Locks are implemented\n\n\twith \n{@link File#createNewFile() }\n.\n   *\n\t<p>In JDK 1.1 or if system property <I>disableLuceneLocks</I> is the\n\tstring \"true\", locks are disabled.  Assigning this property any other\n\tstring will <B>not</B> prevent creation of lock files. Locks are also\n\tdisabled if getDirectory was invoked with the optional third argument\n\tuseLocks set to false.\n\tDisabling locks is useful when using Lucene on read-only medium, such\n\tas CD-ROM, or from an applet that does not have filesystem write\n\tpermission.\n   *\n\t@param name the name of the lock file\n\t@return an instance of <code>Lock</code> holding the lock\n   */\n  public final Lock makeLock(String name) {\n    final File lockFile = new File(directory, name);\n    if (_disableLocks || locksDisabledByProp())\n    {\n      return new Lock() \nUnknown macro: {\tpublic boolean obtain() throws IOException {\n\t  return true;\n\t}\tpublic void release() {\n\t  return;\n\t}\tpublic String toString() {\n\t  return \"Lock@locksDisabled\";\n\t}      } \n;\n    }\n    else\n    {\n      return new Lock() \nUnknown macro: {\tpublic boolean obtain() throws IOException {\n          return lockFile.createNewFile();\n\t}\tpublic void release() {\n\t  lockFile.delete();\n\t}\tpublic String toString() {\n\t  return \"Lock@\" + lockFile;\n\t}      } \n;\n    }\n  }\n\n\n\n  /** Closes the store to future operations. */\n  public final synchronized void close() throws IOException {\n    if (--refCount <= 0) {\n      synchronized (DIRECTORIES) \n{\n\tDIRECTORIES.remove(directory);\n      }\n    }\n  }\n\n  /** For debug output. */\n  public String toString() \n{\n    return \"FSDirectory@\" + directory;\n  }\n}\n\n\nfinal class FSInputStream extends InputStream {\n  private class Descriptor extends RandomAccessFile {\n    public long position;\n    public Descriptor(File file, String mode) throws IOException \n{\n      super(file, mode);\n    }\n  }\n\n  Descriptor file = null;\n  boolean isClone;\n\n  public FSInputStream(File path) throws IOException \n{\n    file = new Descriptor(path, \"r\");\n    length = file.length();\n  }\n\n  /** InputStream methods */\n  protected final void readInternal(byte[] b, int offset, int len)\n       throws IOException {\n    synchronized (file) {\n      long position = getFilePointer();\n      if (position != file.position) \n{\n\tfile.seek(position);\n\tfile.position = position;\n      }\n      int total = 0;\n      do \n{\n\tint i = file.read(b, offset+total, len-total);\n\tif (i == -1)\n\t  throw new IOException(\"read past EOF\");\n\tfile.position += i;\n\ttotal += i;\n      }\n while (total < len);\n    }\n  }\n\n  public final void close() throws IOException \n{\n    if (!isClone)\n      file.close();\n  }\n\n  /** Random-access methods */\n  protected final void seekInternal(long position) throws IOException {\n  }\n\n  protected final void finalize() throws IOException \n{\n    close();\t\t\t\t\t  // close the file\n  }\n\n  public Object clone() \n{\n    FSInputStream clone = (FSInputStream)super.clone();\n    clone.isClone = true;\n    return clone;\n  }\n}\n\n\nfinal class FSOutputStream extends OutputStream {\n  RandomAccessFile file = null;\n\n  public FSOutputStream(File path) throws IOException \n{\n    file = new RandomAccessFile(path, \"rw\");\n  }\n\n  /** output methods: */\n  public final void flushBuffer(byte[] b, int size) throws IOException \n{\n    file.write(b, 0, size);\n  }\n  public final void close() throws IOException \n{\n    super.close();\n    file.close();\n  }\n\n  /** Random-access methods */\n  public final void seek(long pos) throws IOException \n{\n    super.seek(pos);\n    file.seek(pos);\n  }\n  public final long length() throws IOException \n{\n    return file.length();\n  }\n\n  protected final void finalize() throws IOException \n{\n    file.close();\t\t\t\t  // close the file\n  }\n\n}",
    "attachments": {
        "ASF.LICENSE.NOT.GRANTED--FSDirectory.java": "https://issues.apache.org/jira/secure/attachment/12312209/ASF.LICENSE.NOT.GRANTED--FSDirectory.java"
    },
    "issue_links": {},
    "comments": [
        {
            "date": "2003-02-06T03:55:35+0000",
            "content": "Created an attachment (id=4743)\nProposed new code FSDirectory.java ",
            "author": "John Methot",
            "id": "comment-12321191"
        },
        {
            "date": "2003-02-23T15:51:38+0000",
            "content": "John - just so I understand - your change does not add any new functionality, it\nsimply allows you to disable locks by using one of your 2 new methods.\nIs this because you cannot set the system properly when writing an applet?\nCouldn't you just call System.setProperty(String key, String value) to set\ndisableLuceneLocks property to true before calling FSDirectory and achieve the\nsame thing? ",
            "author": "Otis Gospodnetic",
            "id": "comment-12321192"
        },
        {
            "date": "2003-04-16T11:50:23+0000",
            "content": "The diff is a bit hard to read, contains some formatting changes in addition to\nchanges to the way locking is disabled, but I think it looks good, it compiles,\nand it doesn't break any unit tests.\nThis is also a modification made to one of the older versions of FSDirectory,\nbut that should be easy to handle.\n\nAnyhow, I'm checking this in, unless somebody complains by tomorrow. ",
            "author": "Otis Gospodnetic",
            "id": "comment-12321193"
        },
        {
            "date": "2003-09-19T04:33:39+0000",
            "content": "I do not remember if the attached code was ever committed, but I believe we've\nhad  the have support to disable locking for a while now.\nI'm closing this issue for now.\n ",
            "author": "Otis Gospodnetic",
            "id": "comment-12321194"
        },
        {
            "date": "2003-09-19T04:47:01+0000",
            "content": "Otis, I never saw your comments in the bug, thus my failure to reply. I'm not \nclear whether your comment in the bug today means you're removing my changes \nfrom the codebase (your previous comment says you checked it in).\n\nVis a vis your prior comment:\n\n\"John - just so I understand - your change does not add any new \nfunctionality...\"\n\nOne can't call System.setProperty() from an applet unless the applet has \nspecific permission to do so, as configured on the end-user's machine.  The \nonly way to disable locking wihtout special permission, to my knowledge, is \nvia the API. ",
            "author": "John Methot",
            "id": "comment-12321195"
        },
        {
            "date": "2004-02-26T08:40:26+0000",
            "content": "Created an attachment (id=10558)\nNew version based on 1.3-final source - easier diffs ",
            "author": "John Methot",
            "id": "comment-12321196"
        },
        {
            "date": "2004-02-26T08:53:21+0000",
            "content": "Well, I completely misunderstood Otis' comments that meant he hadn't checked \nin the change.  I didn't realize it hadn't been checked in until I updated to \n1.3 and the fix wasn't there.\n\nSo here it is again.  I've rewritten the changes against 1.3-final source, so \nthe diffs should be a lot more intelligible. ",
            "author": "John Methot",
            "id": "comment-12321197"
        },
        {
            "date": "2005-09-27T01:57:20+0000",
            "content": "It looks like this old issue was fixed at some point, as FSDirectory now has the following method:\n\n  public static void setDisableLocks(boolean doDisableLocks) {\n... ",
            "author": "Otis Gospodnetic",
            "id": "comment-12330487"
        }
    ]
}