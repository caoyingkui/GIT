{
    "id": "SOLR-5743",
    "title": "Faceting with BlockJoin support",
    "details": {
        "affect_versions": "None",
        "status": "Closed",
        "fix_versions": [
            "5.5",
            "6.0"
        ],
        "components": [
            "faceting"
        ],
        "type": "New Feature",
        "priority": "Major",
        "labels": "",
        "resolution": "Fixed"
    },
    "description": "For a sample inventory(note - nested documents) like this -   \n <doc>\n<field name=\"id\">10</field>\n<field name=\"type_s\">parent</field>\n<field name=\"BRAND_s\">Nike</field>\n<doc>\n<field name=\"id\">11</field>\n<field name=\"COLOR_s\">Red</field>\n<field name=\"SIZE_s\">XL</field>\n</doc>\n<doc>\n<field name=\"id\">12</field>\n<field name=\"COLOR_s\">Blue</field>\n<field name=\"SIZE_s\">XL</field>\n</doc>\n</doc>\n\nFaceting results must contain - \nRed(1)\nXL(1) \nBlue(1) \n\nfor a \"q=*\" query. \n\nPS : The inventory example has been taken from this blog - http://blog.griddynamics.com/2013/09/solr-block-join-support.html",
    "attachments": {
        "service_baseline.png": "https://issues.apache.org/jira/secure/attachment/12785835/service_baseline.png",
        "solr_new_baseline.jpg": "https://issues.apache.org/jira/secure/attachment/12785838/solr_new_baseline.jpg",
        "service_new_baseline.jpg": "https://issues.apache.org/jira/secure/attachment/12785837/service_new_baseline.jpg",
        "solr_baseline.jpg": "https://issues.apache.org/jira/secure/attachment/12785836/solr_baseline.jpg",
        "cluster.jpg": "https://issues.apache.org/jira/secure/attachment/12785839/cluster.jpg",
        "SOLR-5743.patch": "https://issues.apache.org/jira/secure/attachment/12674782/SOLR-5743.patch"
    },
    "issue_links": {},
    "comments": [
        {
            "author": "Dr Oleg Savrasov",
            "id": "comment-14016391",
            "date": "2014-06-03T11:25:09+0000",
            "content": "I'm preparing Lucene Revolution talk http://lucenerevolution.uservoice.com/forums/254256-internals-track/suggestions/5995621-faceting-with-lucene-blockjoinquery which addresses the feature. Your votes would be much appreciated. "
        },
        {
            "author": "Dr Oleg Savrasov",
            "id": "comment-14171064",
            "date": "2014-10-14T15:22:38+0000",
            "content": "Initial implementation which meets functionality requirements. There is new BlockJoinFacetComponent which expects ToParentBlockJoinQuery in search request. Facets are calculated for fields defined by child.facet.field parameter. Only DocValues fields are supported. "
        },
        {
            "author": "ash fo",
            "id": "comment-14292938",
            "date": "2015-01-27T04:03:35+0000",
            "content": "There are two xml files you are tweaking in this patch that do not even exist in the source:\n\nsolr/core/src/test-files/solr/collection1/conf/schema-blockjoinfacetcomponent.xml\nsolr/core/src/test-files/solr/collection1/conf/solrconfig-blockjoinfacetcomponent.xml\n\nCould you please explain where I find those files? Patch is modifying them not adding the whole file. When I apply the patch it skips those files basically.\n\nThank you  "
        },
        {
            "author": "Dr Oleg Savrasov",
            "id": "comment-14293587",
            "date": "2015-01-27T14:24:24+0000",
            "content": "I created the files by copying and modifying existing configurations. It looks like my IDE processed changes incorrectly. Sorry about that. Please find updated patch attached. Should you have any issues, please notice me. "
        },
        {
            "author": "ash fo",
            "id": "comment-14296429",
            "date": "2015-01-29T06:05:21+0000",
            "content": "Thanks, I applied the patch but still passing \"child.facet.field=xxxxxxx\" doesn't do anything. Here is my query:\n\nhttp://localhost:8080/solr/nested_collecion2/select?q=*%3A*&fq=content_type%3AparentDocument&fl=id&wt=json&indent=true&facet=true&child.facet.field=retid\n\nAnd this is what I get back, basically Solr doesn't know the 'child.facet.field' parameter:\n\n{\n  \"responseHeader\":{\n    \"status\":0,\n    \"QTime\":1,\n    \"params\":{\n      \"facet\":\"true\",\n      \"fl\":\"id\",\n      \"indent\":\"true\",\n      \"q\":\":\",\n      \"child.facet.field\":\"retid\",\n      \"wt\":\"json\",\n      \"fq\":\"content_type:parentDocument\"}},\n  \"response\":{\"numFound\":998,\"start\":0,\"docs\":[\n      \n{\n        \"id\":\"1554855923\"}\n,\n      \n{\n        \"id\":\"1556730933\"}\n,\n      \n{\n        \"id\":\"1437257890\"}\n,\n      \n{\n        \"id\":\"1463296684\"}\n,\n      \n{\n        \"id\":\"1143793641\"}\n,\n      \n{\n        \"id\":\"1168208507\"}\n,\n      \n{\n        \"id\":\"1201399772\"}\n,\n      \n{\n        \"id\":\"1162769709\"}\n,\n      \n{\n        \"id\":\"1199906811\"}\n,\n      \n{\n        \"id\":\"1296203203\"}\n]\n  },\n  \"facet_counts\":{\n    \"facet_queries\":{},\n    \"facet_fields\":{},\n    \"facet_dates\":{},\n    \"facet_ranges\":{},\n    \"facet_intervals\":{}}}\n\nthe retid field has the docValues=\"true\" too.\n\n<field name=\"retid\" type=\"int\" indexed=\"true\" stored=\"true\" docValues=\"true\"/>\n\nIs there anything else needs to be done? \n\nThanks "
        },
        {
            "author": "Dr Oleg Savrasov",
            "id": "comment-14298423",
            "date": "2015-01-30T09:53:44+0000",
            "content": "In order to utilize proposed component, you need to configure it in solrconfig.xml and introduce some search handler which uses it, for example\n\n  <searchComponent name=\"blockJoinFacet\" class=\"org.apache.solr.handler.component.BlockJoinFacetComponent\">\n\n  </searchComponent>\n\n  <requestHandler name=\"/blockJoinFacetRH\" class=\"org.apache.solr.handler.component.SearchHandler\">\n    <arr name=\"last-components\">\n      <str>blockJoinFacet</str>\n    </arr>\n  </requestHandler>\n\nPlease notice that only string docValues fields could be used for faceting, int type can be covered later, so you need to update appropriate fields configuration in schema.xml file, for example\n\n <field name=\"COLOR_s\" type=\"string\" indexed=\"true\" stored=\"true\" docValues=\"true\"/>\n <field name=\"SIZE_s\" type=\"string\" indexed=\"true\" stored=\"true\" docValues=\"true\"/>\n\n\nThen after indexing some set of hierarchical documents like\n\n <doc>\n    <field name=\"id\">10</field>\n    <field name=\"type_s\">parent</field>\n    <field name=\"BRAND_s\">Nike</field>\n    <doc>\n      <field name=\"id\">11</field>\n      <field name=\"type_s\">child</field>\n      <field name=\"COLOR_s\">Red</field>\n      <field name=\"SIZE_s\">XL</field>\n    </doc>\n    <doc>\n      <field name=\"id\">12</field>\n      <field name=\"type_s\">child</field>\n      <field name=\"COLOR_s\">Blue</field>\n      <field name=\"SIZE_s\">XL</field>\n    </doc>\n </doc>\n\nyou need to pass required ToParentBlockJoinQuery to the configured request handler, for example\n\n http://localhost:8983/solr/collection1/blockJoinFacetRH?q=\n{!parent+which%3D%22type_s%3Aparent%22}\ntype_s%3Achild&wt=json&indent=true&facet=true&child.facet.field=COLOR_s&child.facet.field=SIZE_s\n\nand it yields you the desired result\n\n {\n  \"responseHeader\":\n{\n    \"status\":0,\n    \"QTime\":1}\n,\n  \"response\":{\"numFound\":1,\"start\":0,\"docs\":[\n      \n{\n        \"id\":\"10\",\n        \"type_s\":\"parent\",\n        \"BRAND_s\":\"Nike\",\n        \"_version_\":1491642108914696192}\n]\n  },\n  \"facet_counts\":{\n    \"facet_queries\":{},\n    \"facet_fields\":{},\n    \"facet_dates\":{},\n    \"facet_ranges\":{},\n    \"facet_intervals\":{},\n    \"facet_fields\":[\n      \"COLOR_s\",[\n        \"Blue\",1,\n        \"Red\",1],\n      \"SIZE_s\",[\n        \"XL\",1]]}}\n\nPlease take the latest patch, it contains fix related to just found caching issue. "
        },
        {
            "author": "ash fo",
            "id": "comment-14300951",
            "date": "2015-02-02T07:08:16+0000",
            "content": "Thank you, finally I got it working. Is it possible to include the integer and float fields in this patch as well? Two of my child fields are integer and float (retailer id and price) and I need to facet on them too.  "
        },
        {
            "author": "Dr Oleg Savrasov",
            "id": "comment-14312419",
            "date": "2015-02-09T16:31:07+0000",
            "content": "After investigating it, I've found that float and int types work fine for multivalued fields, i.e. they should be configured like\n\n<field name=\"RETAILER_ID\" type=\"int\" indexed=\"true\" stored=\"true\" docValues=\"true\" multiValued=\"true\"/>\n<field name=\"PRICE\" type=\"float\" indexed=\"true\" stored=\"true\" docValues=\"true\" multiValued=\"true\"/>\n\nUnit test in the patch is extended to cover int and float types.\nI'll try to find out if it's possible to make it working for multiValued=\"false\". "
        },
        {
            "author": "ash fo",
            "id": "comment-14313627",
            "date": "2015-02-10T05:45:48+0000",
            "content": "Thank you. \n\nCould you please also include the 'child.facet.query'? A lot of times people want to know how many offers for example are in a specific price range, something like this:\n\n&child.facet.query=price :[1 TO 100]\n "
        },
        {
            "author": "ash fo",
            "id": "comment-14327039",
            "date": "2015-02-19T06:31:48+0000",
            "content": "It seems that the patch isn't working with Solr cloud. When I have a single instance it works, but in cloud with multiple nodes and shards it just doesn't work. Is there a way to have this working with multiple nodes/shards? Thank you. "
        },
        {
            "author": "Dr Oleg Savrasov",
            "id": "comment-14343133",
            "date": "2015-03-02T12:57:10+0000",
            "content": "Solr Cloud support has been implemented "
        },
        {
            "author": "Dr Oleg Savrasov",
            "id": "comment-14343137",
            "date": "2015-03-02T13:06:50+0000",
            "content": "Please checkout the latest patch. Solr Cloud support has been implemented here. Please notice that in order to make it working you should make some configuration changes.\n\n1. If you have /select SearchHandler definition, you should add blockJoinFacet as a last component here, like\n\n  <requestHandler name=\"/select\" class=\"solr.SearchHandler\">\n    .....\n    <arr name=\"last-components\">\n      <str>blockJoinFacet</str>\n    </arr>\n  </requestHandler>\n\n2. If you don't have /select SearchHandler definition, you should configure your custom BlockJoinFacet search handler with shards.qt parameter, which should reference on search handler name. For example: \n\n  <requestHandler name=\"/blockJoinFacetRH\" class=\"org.apache.solr.handler.component.SearchHandler\">\n    <lst name=\"defaults\">\n      <str name=\"shards.qt\">blockJoinFacetRH</str>\n    </lst>\n    <arr name=\"last-components\">\n      <str>blockJoinFacet</str>\n    </arr>\n  </requestHandler> "
        },
        {
            "author": "Dr Oleg Savrasov",
            "id": "comment-14343189",
            "date": "2015-03-02T14:31:33+0000",
            "content": "Video from the Lucene Revolution talk is available here http://www.youtube.com/watch?v=Su5SHc_uJw8 "
        },
        {
            "author": "Jacob Carter",
            "id": "comment-14359562",
            "date": "2015-03-12T22:41:20+0000",
            "content": "I've applied this patch to the Solr 5.0.0 and with a index containing around 400k parent documents and 1.5 million child documents it's taking over a minute to return the values of a child facet and their counts.  Is this performance to be expected at the present time or have I potentially misconfigured my instance? "
        },
        {
            "author": "Dr Oleg Savrasov",
            "id": "comment-14360055",
            "date": "2015-03-13T07:37:41+0000",
            "content": "Performance improvements are still under investigation at the moment. I don't have too much time these days so I cannot promise that I'll come up with some solution soon. But we keep working on it. "
        },
        {
            "author": "Dr Oleg Savrasov",
            "id": "comment-14376129",
            "date": "2015-03-23T16:25:02+0000",
            "content": "I don't think that we need to introduce one more new special child.facet.query parameter here.\nIt looks like that it's possible to achieve the same result by specifying appropriate ToParentQuery in facet.query parameter.\nFor example, facet.query=\n{!parent which=type_s:parent}\nprice:[1 TO 100].\nBut please notice that in this case facet.query result could count child documents which are not matched by search query.\nFor example, there could be a parent document with two children. One child has COLOR_s:Red and price:200, while another one COLOR_s:Blue and price:50.\nIf you request q=\n{!parent which=type_s:parent}\nCOLOR_s:Red\nand facet.query=\n{!parent which=type_s:parent}\nprice:[1 TO 100], this document is going go be counted.\nSometimes it's OK, but if you want to eliminate this effect, you need to add child documents filter from q to facet.query.\nThe best way to do it is introducing new http parameter, say qq=COLOR_s:Red and referencing it both from q and facet.query, i.e.\nq=\n{!parent which=type_s:parent v=$qq}\n&facet.query=\n{!parent which=type_s:parent}\n+price:[1 TO 100] +\n{!v=$qq}\n&qq=type_s:child&facet=true "
        },
        {
            "author": "Jim Musil",
            "id": "comment-14559660",
            "date": "2015-05-26T19:16:59+0000",
            "content": "Curious, how would you handle this if a user searches for \"pink shoes\" or \"large gloves\"?\n "
        },
        {
            "author": "Dr Oleg Savrasov",
            "id": "comment-14564400",
            "date": "2015-05-29T08:20:16+0000",
            "content": "We call this kind of requests which mix and match fields from different related entities a \"deep search\". To handle such requests we need to create a composition of Boolean query which will provide linguistic matching and Block Join query which will allow to return top level document when match happened on nested document. This topic worth its own JIRA (or few of them). Here, we are focusing on faceting rather than matching.  "
        },
        {
            "author": "Dr Oleg Savrasov",
            "id": "comment-14978159",
            "date": "2015-10-28T10:26:42+0000",
            "content": "Performance improvement patch, which is prepared for lucene_solr_5_2 branch. On my local test data it makes proposed component faster in about 25 times. Please notice that it's recommended to apply patch SOLR-7730 as well, since it yields significant performance benefits too. "
        },
        {
            "author": "Dr Oleg Savrasov",
            "id": "comment-15005966",
            "date": "2015-11-15T16:42:26+0000",
            "content": "Proposed component has been reworked to utilize algorithm described here https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-bucket-reverse-nested-aggregation.html. As a result code became more elegant and faster in about 2 times in comparison with the previous version. "
        },
        {
            "author": "Dr Oleg Savrasov",
            "id": "comment-15021060",
            "date": "2015-11-22T16:11:22+0000",
            "content": "Unit test is extended to cover single value flow "
        },
        {
            "author": "Ishan Chattopadhyaya",
            "id": "comment-15021091",
            "date": "2015-11-22T17:28:37+0000",
            "content": "IMHO this is an important issue to fix, and the patch looks good to me (based on initial look, and due to the tests included in the patch). It would be very good to have some committer attention here. "
        },
        {
            "author": "Mikhail Khludnev",
            "id": "comment-15021155",
            "date": "2015-11-22T19:41:45+0000",
            "content": "Ishan Chattopadhyaya I'd like to commit it. I just want to confirm that there is no veto from anyone. \nI also appreciate if colleagues leave feedbacks for the recent patch, especially about its' performance. Jacob Carter would you comment on that?\n\nTo summarize, If we decide to go on, I'll add it into defaultComponents, after that user will be able to get aggregated facets for children fields along side with the usual one:\n\nq={!parent ...}...&facet=true&child.facet.field=COLOR\n\n \n\nHere is the brief use case description https://www.mail-archive.com/solr-user@lucene.apache.org/msg115732.html "
        },
        {
            "author": "Mikhail Khludnev",
            "id": "comment-15049432",
            "date": "2015-12-09T21:50:54+0000",
            "content": "Colleagues! I need your advice. \nThis patch disables query result caching (that requires to make NO_CHECK_QCACHE public), enforce execution query every time (of course only if params are present).\nIt calculates facets ongoing with search via DelegatingCollector. It's quite different to what Solr usually does. And it requires to relax encapsulation to access ToParentBlockJoinQuery.BlockJoinScorer.swapChildDocs(int[]). To accommodate this keeping encapsulation, we can add some public accessor class to o.a.l.search.join or made it default and add a class with o.a.l.search.join package into solr codebase (%100 ugly). \nAs an alternative, we can migrate closer to regular a Solr approach, calculate childDocset and run faceting over it. Please put your opinion, otherwise I'll go to IRC and repeat the question.    "
        },
        {
            "author": "Mikhail Khludnev",
            "id": "comment-15053524",
            "date": "2015-12-11T20:40:29+0000",
            "content": "Revamped the patch SOLR-5743.patch. Caveat, bitwise ticks! Now it provides both approaches:\n\n\tBlockJoinFacetComponent - enforces searching by NO_CHECK_QCACHE obtains child matches via BlockJoinScorer.swapChildDocs(int[]) see ChildTrackingCollector in the patch.\n\tBlockJoinFacetDocSetComponent - it works more like Solr with toplevel doc sets\nI think to include both components into 5.5 disabled by default to let users to experiment. \nremaining TODOs:\n\texclude parent docs from faceting\n\tnow it's hardcoded to mincount=1, either set to 0 or copypaste mincount params logic and will be\n\timprove simple test to handle edge cases with fields and hits.\n\n\n\nAny concerns?  "
        },
        {
            "author": "Mikhail Khludnev",
            "id": "comment-15055091",
            "date": "2015-12-13T19:10:15+0000",
            "content": "tweaked SOLR-5743.patch. \nBlockJoinFacetDistribTest found discrepancy in shards response with facet=false.\nsingle node or shards with facet=true\n\n{responseHeader={status=0,QTime=133},response={numFound=11,start=0,docs=[]},\nfacet_counts={facet_fields={COLOR_s={black=6,fuchsia=8,magenta=2},SIZE_s={3=4,4=3,5=2,6=1,l=1,m=3,maxi=3,xl=3,xml=3,xxl=1,xxxl=1}}}}\n\n\nshards without facet=true\n\n{responseHeader={status=0,QTime=64},child_facet_fields={COLOR_s={black=6,fuchsia=8,magenta=2},SIZE_s={3=4,4=3,m=3,maxi=3,xl=3,xml=3,5=2,6=1,l=1,xxl=1,xxxl=1}},response={numFound=11,start=0,maxScore=0.0,docs=[]}}\n\n\njunit\n\njunit.framework.AssertionFailedError: .child_facet_fields!=response (unordered or missing)\n\tat \n...\norg.apache.solr.BaseDistributedSearchTestCase.compareSolrResponses(BaseDistributedSearchTestCase.java:893)\n\tat \n...\norg.apache.solr.BaseDistributedSearchTestCase.query(BaseDistributedSearchTestCase.java:571)\n\tat org.apache.solr.search.join.BlockJoinFacetDistribTest.testBJQFacetComponent(BlockJoinFacetDistribTest.java:127)\n\n "
        },
        {
            "author": "Dr Oleg Savrasov",
            "id": "comment-15065844",
            "date": "2015-12-20T17:36:19+0000",
            "content": "Fix for the distributed test failure "
        },
        {
            "author": "Mikhail Khludnev",
            "id": "comment-15070210",
            "date": "2015-12-23T21:30:11+0000",
            "content": "I'm going to commit SOLR-5743.patch if there is no Christmas freeze.   "
        },
        {
            "author": "Mikhail Khludnev",
            "id": "comment-15071064",
            "date": "2015-12-24T14:37:41+0000",
            "content": "introducing ToParentBlockJoinQuery.ChildrenMatchesScorer to make javadoc happier  "
        },
        {
            "author": "Mikhail Khludnev",
            "id": "comment-15071118",
            "date": "2015-12-24T16:38:11+0000",
            "content": "now javadoc is perfect "
        },
        {
            "author": "ASF subversion and git services",
            "id": "comment-15071134",
            "date": "2015-12-24T17:04:58+0000",
            "content": "Commit 1721644 from mkhl@apache.org in branch 'dev/trunk'\n[ https://svn.apache.org/r1721644 ]\n\nSOLR-5743: introducing BlockJoinFacet*Component which are acting on child.facet.field request parameters "
        },
        {
            "author": "ASF subversion and git services",
            "id": "comment-15071221",
            "date": "2015-12-24T20:15:16+0000",
            "content": "Commit 1721652 from mkhl@apache.org in branch 'dev/branches/branch_5x'\n[ https://svn.apache.org/r1721652 ]\n\nSOLR-5743: merging: introducing BlockJoinFacet*Component which are acting on child.facet.field request parameters "
        },
        {
            "author": "Vijay Sekhri",
            "id": "comment-15098859",
            "date": "2016-01-14T21:06:54+0000",
            "content": "Hi Mikhail, Dr. Oleg\nThe requirement to use this feature is to have ToParentBlockJoinQuery like \n\n q={!parent which=<allParents>}<someChildren> \n\nTo use the ParentBlockJoinQuery it needs to search on fields present in child document. In real world your parent document would have most of the common fields and child document would have only the different fields. For example just like BRAND_s, there will be fields like description_s, name_s, title_s, partnumber_s, etc. in the parent document only. As they are same for all the child documents , one would not repeat them in the child document, rather only keep them in the parent document only. In the child document , we would have attributes like COLOR_s, SIZE_s as the differ. \n\nNow for any real searches , one would search for fields like BRAND_s, description_s, name_s, title_s, partnumber_s, etc to return appropriate documents.  However , those fields are only present in parent docs. \n\nSo searching them like\n\n q={!parent which=type_s:parent}BRAND_s:Nike&facet=true&child.facet.field=COLOR_s \n \n\ndoes not work because search on BRAND_s:Nike is present in parent document .  It gives this error also\nchild query must only match non-parent docs, but parent docID=2 matched childScorer=class org.apache.lucene.search.TermScorer\n\nOne could search on fields from child like this without any problem.\n\n q={!parent%20which=type_s:parent}COLOR_s:Blue&facet=true&child.facet.field=COLOR_s \n\n\nTo use this feature do we have to copy all the common fields ( and thousands of such fields alike ) back into the child (repeating them for every child) and search on those fields ? For example copying brand_s field like this \n\n[{\n \"id\": 10,\n \"type_s\": \"parent\",\n \"BRAND_s\": \"Nike\",\n \"_childDocuments_\": [{\n   \"id\": 11,\n   \"COLOR_s\": \"Red\",\n   \"SIZE_s\": \"XL\",\n   \"BRAND_s\": \"Nike\",\n }, \n {\n \"id\": 12,\n \"COLOR_s\": \"Blue\",\n \"SIZE_s\": \"XL\",\n \"BRAND_s\": \"Nike\",\n }]\n}]\n\n\n\nThis way the query works \n\nq={!parent which=type_s:parent}BRAND_s:Nike&facet=true&child.facet.field=COLOR_s\n\n\n\nOr there is some other way where we can still use the facets on the child fields (SIZE_s) ,  aggregate the counts on the parent docs (id:10) and still search on the common fields from parent docs (BRAND_s) ? "
        },
        {
            "author": "Mikhail Khludnev",
            "id": "comment-15101185",
            "date": "2016-01-15T04:45:01+0000",
            "content": "hold on.. \nI wonder why you can't intersect it with parent level filer  \n\nq={!parent%20which=type_s:parent}COLOR_s:Blue&facet=true&child.facet.field=COLOR_s&fq=BRAND_s:Nike\n\n\nin this case no copying is necessary. Make sure you checked examples from the blog "
        },
        {
            "author": "Vijay Sekhri",
            "id": "comment-15101931",
            "date": "2016-01-15T15:35:36+0000",
            "content": " I saw the blog few times before already. Thank you for writing it Mikhail .  I am not sure it cover the searching uses cases. Searching and filtering are two different use cases. \n For example say you have these in your solrconfig as one of the requesthandler . As you can see it would search in a lot fields and boost based on which fields matches. Plus if you declare  pf field for proximity and mm field for must match , relevancy kicks in . All of this I am not sure how can be still used just by mere filter. Searching return relevant docs with accounting for boosts. Filter remove docs that matches criteria. \n\n\t\n         <str name=\"qf\">\n                 primaryLnames^5.0 partnumber^11.0 itemnumber^11.0 description^0.5  fullmfpartno^5.0 mfpartno^5.0 xref^10.0 storeOriginSearchable^3.0 nameSearchable^10.0 brandSearchable^5.0  searchPhrase^1.0 searchableAttributesSearchable^1.0\n            </str>\n            <str name=\"pf\">\n\t\t\t\tprimaryLnames^0.5 nameSearchable^1.0 description^0.1 storeOriginSearchable^0.3 brandSearchable^0.5  xref^1.1 searchableAttributesSearchable^0.1\n\t\t\t </str>\n            <str name=\"fl\">*</str>\n            <str name=\"mm\">\n                2<-1 5<-2 6<-50%\n            </str>\n\t\t\t\n\t\t\n\n\nLet me know if there is a way to still search, not filter and still use ToParentBlockJoinQuery . Real world scenarios would return parent docs based on some order of relevancy and boost criteria.  "
        },
        {
            "author": "Mikhail Khludnev",
            "id": "comment-15101980",
            "date": "2016-01-15T16:08:03+0000",
            "content": "Let me know if there is a way to still search, not filter and still use ToParentBlockJoinQuery .\n\n\nq=+BRAND_s:Nike +_query_:\"{!parent which=type_s:parent}+COLOR_s:Red +SIZE_s:XL\"\n\n "
        },
        {
            "author": "Vijay Sekhri",
            "id": "comment-15102468",
            "date": "2016-01-15T21:09:06+0000",
            "content": "Thank you Mikhail. I already tried that before already and it did not work. Now I found out why it was not working earlier. Apparently if you have  defType=dismax in the requestHandler, then that type of sibling clause query does not work.   Removing it works as expected. Thank you again. "
        },
        {
            "author": "Erick Erickson",
            "id": "comment-15102516",
            "date": "2016-01-15T21:46:33+0000",
            "content": "Should we close this and add trunk to the fixed versions? "
        },
        {
            "author": "Mikhail Khludnev",
            "id": "comment-15107272",
            "date": "2016-01-19T19:35:09+0000",
            "content": "Cassandra Targett would mind to have a look at the wiki? I appreciate feedback about content and format as well. Thanks!  "
        },
        {
            "author": "Cassandra Targett",
            "id": "comment-15108614",
            "date": "2016-01-20T14:23:16+0000",
            "content": "Hey Mikhail Khludnev, I'll take a look today - thanks! "
        },
        {
            "author": "Cassandra Targett",
            "id": "comment-15109464",
            "date": "2016-01-20T21:29:16+0000",
            "content": "Please check out the changes I made and let me know if my edits made any information incorrect. I tried to study this issue a bit for the background, but might have misunderstood something. "
        },
        {
            "author": "Vijay Sekhri",
            "id": "comment-15128887",
            "date": "2016-02-02T19:48:56+0000",
            "content": "Hi Mikhail,\nI did benchmark testing of this feature to determine the efficiency and performance .\nIn our stress environment I have roughly 57 Mil documents in solr index. 10 shards and each shard hosting around 5.7 Mil documents . Each shard has one replica and one leader .\nLike in this figure.\n\n\nThere is solrj service that connects to solr cluster hosted on 8 hosts and each having 3 JVM instances. So in total 24 round robin instances of solrj service running and issuing queries to solr cluster. \nSolr version is 5.3.1\n\nHere is the baseline \nWith a load of 50 requests per seconds to the solrj service the average response times in service is 290 milliseconds. Same translated into solr cluster results in average response Qtimes of 22 milliseconds.\nHere is the picture of average response times at service \n\n\n\nHere is the picture of average response Qtime of the solr\n\n\n\nNow I converted most of the documents with parent child relationship . In total there were 27 Mil new child documents  . So the total count of the documents increased from 57 Mil to 83 Mil documents.  I converted all the queries into the format of parent child in the solrj service layer .   Now with the same load the average response times in service increased to 1.3 seconds and average response Qtimes increased to 500 milliseconds. \nThe solr version is 5.4. trunk with your code in it . \n\nHere is the picture of average response times at service with parent child\n\n\nHere is the picture of average response Qtime of the solr with parent child \n\n\nThe overall performance was 10 times slower in solr layer and 3 times slower in solrj service layer with the same load . \n\nBTW I only tested with org.apache.solr.search.join.BlockJoinFacetComponent . Do you think that org.apache.solr.search.join.BlockJoinDocSetFacetComponent would be faster? \n\nVijay "
        },
        {
            "author": "Mikhail Khludnev",
            "id": "comment-15146681",
            "date": "2016-02-14T18:35:08+0000",
            "content": "Vijay, here are a few notes:\n\n\t290 milli vs Qtimes of 22 millis, here either I'm missing something or here is the room for performance engineering even not search specific ones. Although, it's an off-top.\n\tI wonder how you compare performance on different indexes, and how to interpret the results: it's either might say about inefficient algorithm, or about high model expenses. To evaluate the former, you can compare the block join facet performance with child only queries and child field facet counting. ie it's worth to compare performance of :\n\nq={!parent%20which=type_s:parent}COLOR_s:Blue&facet=true&child.facet.field=COLOR_s\n\n\nwith\n\nq=COLOR_s:Blue&facet=true&facet.field=COLOR_s\n\n\nComparing these numbers can evidence about aggregation efficiency (almost, see below).\n\tBlockJoinDocSetFacetComponent should be faster for rarely changed indexes. Notice: BlockJoinFacetComponent disables query result cache and this also might impact benchmarking results.\n\n\n\n\n\n "
        },
        {
            "author": "Vijay Sekhri",
            "id": "comment-15147562",
            "date": "2016-02-15T16:43:19+0000",
            "content": "Hi Mikhail,\nThere were 2 reasons why the performance was bad I realized. \na) For a whole lot of queries (internally generated by solr to different shards ) you code was giving a NPE. That made our service layer get the exception and do another query that added up to the overall response times (QTime). The NPE was not happening on all queries though. However, whenever it would happen it would degrade the performance because of multiple queries. This is the code where it was happening \n\n\n14:00:20,751 ERROR [org.apache.solr.servlet.HttpSolrCall] (http-/10.235.43.43:8580-82) null:java.lang.NullPointerException\n        at org.apache.solr.search.join.BlockJoinFacetCollector.incrementFacets(BlockJoinFacetCollector.java:100)\n        at org.apache.solr.search.join.BlockJoinFacetCollector.collect(BlockJoinFacetCollector.java:87)\n\n\n\nat this line \n\n\n final int[] docNums = blockJoinScorer.swapChildDocs(childDocs);\n\n\t\t\n\nbecause sometime the blockJoinScorer object would be null.  Again this would happen half of the time but other half it would be fine. \n\nSo I changed the code \n\n\t\t\n    if(blockJoinScorer == null) {\n        //System.out.println(\"blockJoinScorer is NULL\");\n        return;\n    }\n\n\t\t\n\nand reran my load and it brought down performance back to 60 millisecond from 200 milliseconds.\n\nb) All my queries were doing a wild card match like this \n\n\t\t\nq={!parent%20which=type_s:parent}id:*_child\n\n\t\t\n\n\nand I changed that to \n\n\t\t\nq={!parent%20which=type_s:parent}type_s:child\n\n\t\t\n\nThis further brought down the qTimes to 30 milliseconds. Granted it is a bit higher than baseline but it is acceptable. Please let me know what to do about that NPE in the code. I am not sure if what I did is functionally  correct or not. \n\n-regards "
        },
        {
            "author": "Mikhail Khludnev",
            "id": "comment-15147752",
            "date": "2016-02-15T20:10:41+0000",
            "content": "Vijay,\nthis NPE is a twin of SOLR-8643, SOLR-8644 (I'll comment them soon too). Though it's might be caused by specific form of queries in SolrCloud. Could you please expose a few following line to catch which queries particularly cause a NPE?  \nAnd, yes - BlockJoinFacetDocSetComponent shouldn't be impacted by this scorer routine "
        },
        {
            "author": "Vijay Sekhri",
            "id": "comment-15157222",
            "date": "2016-02-22T16:18:25+0000",
            "content": "Hi Mikhail, \nIt could be related to stats query that does not even have any ToParentBlockJoin syntax  . Here is one example \n\n\n15:07:56,736 INFO  [org.apache.solr.core.SolrCore.Request] (http-/10.235.43.43:8580-143) [core1]  webapp=/solr path=/select \nparams={shards.qt=searchStandard&tie=0.01&stats=true&distrib=false&q.alt=*:*&originIP=10.235.52.131&collection=search1&shards.tolerant=true&version=2&NOW=1454360876733&shard.url=http://solrx331p.qa.ch3.s.com:8580/solr/core1/|http://solrx351p.qa.ch3.s.com:8580/solr/core1/&fl=id&fl=score&bf=%0a++++++++++++&timeAllowed=10000&qt=searchStandard&fsv=true&fq=catalogs:((\"10104\"))&fq=searchableAttributes:((\"Metal%3DTri+color\"))&fq=brand:(\"Black+Hills+Gold\")&fq=discount:(\"70\")&fq=primaryCategory:(\"10104_3_Jewelry_Diamonds_Rings\")&mm=%0a++++++++++++++++2<-1+5<-2+6<-50%25%0a++++++++++++&hasOrigCategories=1&qf=%0a+++++++++++++++++primaryLnames^5.0+partnumber^11.0+itemnumber^11.0+fullmfpartno^5.0+mfpartno^5.0+xref^10.0+storeOriginSearchable^3.0+nameSearchable^10.0+brandSearchable^5.0++searchPhrase^1.0++searchableAttributesSearchable^1.0++++%0a++++++++++++&wt=javabin&rows=0&pf=%0a+++++++++++++++primaryLnames^0.5+nameSearchable^1.0+storeOriginSearchable^0.3+brandSearchable^0.5++xref^1.1+searchableAttributesSearchable^0.1%0a++++++++++++&shards.purpose=516&start=0&q=white+diamonds+diamonds+elizabeth+taylor+body+lotion&bot=true&stats.field=price_10151_f&isShard=true&ps=100} hits=0 status=0 QTime=0\n\n\n15:07:56,758 ERROR [org.apache.solr.handler.RequestHandlerBase] (http-/10.235.43.43:8580-26) java.lang.NullPointerException\n        at org.apache.solr.search.join.BlockJoinFacetCollector.incrementFacets(BlockJoinFacetCollector.java:100)\n        at org.apache.solr.search.join.BlockJoinFacetCollector.collect(BlockJoinFacetCollector.java:87)\n        at org.apache.solr.search.SolrIndexSearcher.getDocSet(SolrIndexSearcher.java:1153)\n        at org.apache.solr.handler.component.QueryComponent.process(QueryComponent.java:350)\n        at org.apache.solr.handler.component.SearchHandler.handleRequestBody(SearchHandler.java:273)\n        at org.apache.solr.handler.RequestHandlerBase.handleRequest(RequestHandlerBase.java:156)\n\n\n\n\n\n\nIf you want I could revert back the code and run some load again to get more of these queries. \nVijay  "
        },
        {
            "author": "Mikhail Khludnev",
            "id": "comment-15159247",
            "date": "2016-02-23T17:31:34+0000",
            "content": "This, NPE is pretty strange, it's a gap in error handling functionality, but request log has status=0 it couldn't happen if an exception occurs. These query parameters can't enable BlockJoinFacet component. Actual query parameters causing this NPE should follow stacktrace.  "
        },
        {
            "author": "Vijay Sekhri",
            "id": "comment-15167890",
            "date": "2016-02-25T21:16:48+0000",
            "content": "Mikhail, \nFor issues like these and some others should I open a separate Jira  for manageability ?  I also observed that facet.prefix is not being honored on child.facet.field . Let me know and I can open a Jira .\nThanks  "
        },
        {
            "author": "Mikhail Khludnev",
            "id": "comment-15183563",
            "date": "2016-03-07T19:48:37+0000",
            "content": "Vijay,\nSure you can open, but personally I prefer to postpone any such extensions until we merge child.facet engine into json facets.  "
        },
        {
            "author": "Vijay Sekhri",
            "id": "comment-15191254",
            "date": "2016-03-11T17:24:56+0000",
            "content": "I created a new JIRA and also attached a rudimentary patch that takes care of NPE and honors facet.prefix. \nhttps://issues.apache.org/jira/secure/attachment/12792872/SOLR-8834.patch\nhttps://issues.apache.org/jira/browse/SOLR-8834\n\nVijay "
        },
        {
            "author": "Alisa Zhila",
            "id": "comment-15214986",
            "date": "2016-03-28T22:08:32+0000",
            "content": "Hi Mikhail and Oleg, \nThank you for introducing this new feature and describing it your blog (http://blog.griddynamics.com/search/label/~Mikhail%20Khludnev). \n\nI am wondering  whether BlockJoin faceting supports the parameters for output \"limit\" and \"mincount\"? Unfortunately, I could not find any mentions in the wiki (https://cwiki.apache.org/confluence/display/solr/BlockJoin+Faceting). \n\nMy experiments with trying to use the common facet.limit and facet.mincount syntax failed: \n/bjqfacet?q=\n{!parent%20which=type_s:doc}\ntype_s:doc.enriched.text.keywords&facet=true&child.facet.field=text_t&child.facet.limit=10&child.facet.mincount=5&rows=0&fq=\n{!parent%20which=type_s:doc}\ntype_s:doc.userData%20%2BSubject_t:california&wt=json&indent=true\n\n{\n  \"responseHeader\":\n{\n    \"status\":0,\n    \"QTime\":1}\n,\n  \"response\":\n{\"numFound\":19,\"start\":0,\"docs\":[]\n  }\n,\n  \"facet_counts\":{\n    \"facet_queries\":{},\n    \"facet_fields\":{\n      \"text_t\":[\n        \"128x\",1,\n        \"18xx\",1,\n        ...\n        \"ab\",2,\n        \"access\",5,\n        \"account\",1,\n        \"accounts\",1,\n        \"action\",2,\n        \"address\",1,\n        \"addressee\",1,\n        \"afternoon\",3,\n        \"agreement\",2,\n...\n         \"wsj\",1,\n        \"year\",2,\n        \"yoder\",2,\n        \"york\",1]}}\n\nAs you see, the buckets are sorted in alphabetical order and the response yields all of them. \n\nIs limit and mincount implemented  for BlockJoin faceting?  If yes, can its usage be described in the wiki? \n\nThank you!\n\n\n "
        },
        {
            "author": "Mikhail Khludnev",
            "id": "comment-15215553",
            "date": "2016-03-29T06:44:00+0000",
            "content": "Alisa,\n\nMy personal preference is to don't implement limit and mincount here, but merge this logic into JSON Facets. But I don't know how, yet.   "
        },
        {
            "author": "Nikita Pchelintsev",
            "id": "comment-15612287",
            "date": "2016-10-27T15:48:05+0000",
            "content": "Mikhail, the solution is great, but it seems that it doesn't allow to facet on such queries, error returned:\n\n\"Block join faceting is allowed with ToParentBlockJoinQuery only\"\n\nIs there a way to search on both parent and child doc fields and facet? "
        },
        {
            "author": "Nikita Pchelintsev",
            "id": "comment-15612412",
            "date": "2016-10-27T16:26:47+0000",
            "content": "Sorry for the confusion. I was using custom query parser which affected the outer query type. Changed to lucene and it works fine. "
        },
        {
            "author": "Mikhail Khludnev",
            "id": "comment-15612698",
            "date": "2016-10-27T18:22:21+0000",
            "content": "Oh, c'mon! "
        }
    ]
}