{
    "id": "LUCENE-139",
    "title": "[PATCH] Bigram based CJK tokenizer(modified from StopTokenizer)",
    "details": {
        "labels": "",
        "priority": "Minor",
        "components": [
            "modules/analysis"
        ],
        "type": "Improvement",
        "fix_versions": [],
        "affect_versions": "None",
        "resolution": "Fixed",
        "status": "Closed"
    },
    "description": "/* ====================================================================\n\n\tThe Apache Software License, Version 1.1\n *\n\tCopyright (c) 2001 The Apache Software Foundation.  All rights\n\treserved.\n *\n\tRedistribution and use in source and binary forms, with or without\n\tmodification, are permitted provided that the following conditions\n\tare met:\n *\n\t1. Redistributions of source code must retain the above copyright\n\tnotice, this list of conditions and the following disclaimer.\n *\n\t2. Redistributions in binary form must reproduce the above copyright\n\tnotice, this list of conditions and the following disclaimer in\n\tthe documentation and/or other materials provided with the\n\tdistribution.\n *\n\t3. The end-user documentation included with the redistribution,\n\tif any, must include the following acknowledgment:\n\t\"This product includes software developed by the\n\tApache Software Foundation (http://www.apache.org/).\"\n\tAlternately, this acknowledgment may appear in the software itself,\n\tif and wherever such third-party acknowledgments normally appear.\n *\n\t4. The names \"Apache\" and \"Apache Software Foundation\" and\n\t\"Apache Lucene\" must not be used to endorse or promote products\n\tderived from this software without prior written permission. For\n\twritten permission, please contact apache@apache.org.\n *\n\t5. Products derived from this software may not be called \"Apache\",\n\t\"Apache Lucene\", nor may \"Apache\" appear in their name, without\n\tprior written permission of the Apache Software Foundation.\n *\n\tTHIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n\tWARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n\tOF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n\tDISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n\tITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n\tSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n\tLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n\tUSE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n\tON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n\tOR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n\tOF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n\tSUCH DAMAGE.\n\t====================================================================\n *\n\tThis software consists of voluntary contributions made by many\n\tindividuals on behalf of the Apache Software Foundation.  For more\n\tinformation on the Apache Software Foundation, please see\n\t<http://www.apache.org/>.\n *\n\t$Id: CJKTokenizer.java,v 1.7 2003/05/26 07:14:03 chedong Exp $\n */\n\n\n\npackage org.apache.lucene.analysis.cjk;\n\nimport org.apache.lucene.analysis.Token;\nimport org.apache.lucene.analysis.Tokenizer;\n\nimport java.io.Reader;\n\n\n/**\n\n\t<p>\n\tCJKTokenizer was modified from StopTokenizer which does a decent job for\n\tmost European languages. and it perferm other token method for double-byte\n\tCharacters: the token will return at each two charactors with overlap\nmatch.<br>\n\tExample: \"java C1C2C3C4\" will be segment to: \"java\" \"C1C2\" \"C2C3\" \"C3C4\" it\n\talso need filter filter zero length token \"\"<br>\n\tfor Digit: digit, '+', '#' will token as letter<br>\n\tfor more info on Asia language(Chinese Japanese Korean) text segmentation:\n\tplease search  <a\n\thref=\"http://www.google.com/search?q=word+chinese+segment\">google</a>\n\t</p>\n *\n\t@author Che, Dong\n */\npublic final class CJKTokenizer extends Tokenizer {\n    //~ Static fields/initializers ---------------------------------------------\n\n\n\n    /** Max word length */\n    private static final int MAX_WORD_LEN = 255;\n\n    /** buffer size: */\n    private static final int IO_BUFFER_SIZE = 256;\n\n    //~ Instance fields --------------------------------------------------------\n\n    /** word offset, used to imply which character(in ) is parsed */\n    private int offset = 0;\n\n    /** the index used only for ioBuffer */\n    private int bufferIndex = 0;\n\n    /** data length */\n    private int dataLen = 0;\n\n    /**\n\n\tcharacter buffer, store the characters which are used to compose <br>\n\tthe returned Token\n     */\n    private final char[] buffer = new char[MAX_WORD_LEN];\n\n\n\n    /**\n\n\tI/O buffer, used to store the content of the input(one of the <br>\n\tmembers of Tokenizer)\n     */\n    private final char[] ioBuffer = new char[IO_BUFFER_SIZE];\n\n\n\n    /** word type: single=>ASCII  double=>non-ASCII word=>default */\n    private String tokenType = \"word\";\n\n    /**\n\n\ttag: previous character is a cached double-byte character  \"C1C2C3C4\"\n\t----(set the C1 isTokened) C1C2 \"C2C3C4\" ----(set the C2 isTokened)\n\tC1C2 C2C3 \"C3C4\" ----(set the C3 isTokened) \"C1C2 C2C3 C3C4\"\n     */\n    private boolean preIsTokened = false;\n\n\n\n    //~ Constructors -----------------------------------------------------------\n\n    /**\n\n\tConstruct a token stream processing the given input.\n     *\n\t@param in I/O reader\n     */\n    public CJKTokenizer(Reader in) \n{\n        input = in;\n    }\n\n\n\n    //~ Methods ----------------------------------------------------------------\n\n    /**\n\n\tReturns the next token in the stream, or null at EOS.\n     *\n\t@return Token\n     *\n\t@throws java.io.IOException - throw IOException when read error <br>\n\thanppened in the InputStream\n     *\n\t@see \"http://java.sun.com/j2se/1.3/docs/api/java/lang/Character.UnicodeBlock.htm\nl\"\n\tfor detail\n     */\n    public final Token next() throws java.io.IOException {\n        /** how many character(s) has been stored in buffer */\n        int length = 0;\n\n\n\n        /** the position used to create Token */\n        int start = offset;\n\n        while (true) {\n            /** current charactor */\n            char c;\n\n            /** unicode block of current charactor for detail */\n            Character.UnicodeBlock ub;\n\n            offset++;\n\n            if (bufferIndex >= dataLen) \n{\n                dataLen = input.read(ioBuffer);\n                bufferIndex = 0;\n            }\n\n            if (dataLen == -1) {\n                if (length > 0) {\n                    if (preIsTokened == true) \n{\n                        length = 0;\n                        preIsTokened = false;\n                    }\n\n                    break;\n                } else {\n                    return null;\n                }\n            } else {\n                //get current character\n                c = (char) ioBuffer[bufferIndex++];\n\n                //get the UnicodeBlock of the current character\n                ub = Character.UnicodeBlock.of(c);\n            }\n\n            //if the current character is ASCII or Extend ASCII\n            if ((ub == Character.UnicodeBlock.BASIC_LATIN)\n                    || (ub == \nCharacter.UnicodeBlock.HALFWIDTH_AND_FULLWIDTH_FORMS)\n               ) {\n                if (ub == Character.UnicodeBlock.HALFWIDTH_AND_FULLWIDTH_FORMS) \n{\n                    /** convert  HALFWIDTH_AND_FULLWIDTH_FORMS to BASIC_LATIN */\n                    int i = (int) c;\n                    i = i - 65248;\n                    c = (char) i;\n                }\n\n                // if the current character is a letter or \"_\" \"+\" \"#\"\n                if (Character.isLetterOrDigit(c)\n                        || ((c == '_') || (c == '+') || (c == '#'))\n                   ) {\n                    if (length == 0) {\n                        // \"javaC1C2C3C4linux\" <br>\n                        //      ^--: the current character begin to token the \nASCII\n                        // letter\n                        start = offset - 1;\n                    } else if (tokenType == \"double\") {\n                        // \"javaC1C2C3C4linux\" <br>\n                        //              ^--: the previous non-ASCII\n                        // : the current character\n                        offset--;\n                        bufferIndex--;\n                        tokenType = \"single\";\n\n                        if (preIsTokened == true) {\n                            // there is only one non-ASCII has been stored\n                            length = 0;\n                            preIsTokened = false;\n\n                            break;\n                        } else {\n                            break;\n                        }\n                    }\n\n                    // store the LowerCase(c) in the buffer\n                    buffer[length++] = Character.toLowerCase(c);\n                    tokenType = \"single\";\n\n                    // break the procedure if buffer overflowed!\n                    if (length == MAX_WORD_LEN) {\n                        break;\n                    }\n                } else if (length > 0) {\n                    if (preIsTokened == true) {                        length = 0;                        preIsTokened = false;                    }\n else \n{\n                        break;\n                    }\n                }\n            } else {\n                // non-ASCII letter, eg.\"C1C2C3C4\"\n                if (Character.isLetter(c)) {\n                    if (length == 0) {\n                        start = offset - 1;\n                        buffer[length++] = c;\n                        tokenType = \"double\";\n                    } else {\n                        if (tokenType == \"single\") {\n                            offset--;\n                            bufferIndex--;\n\n                            //return the previous ASCII characters\n                            break;\n                        } else {\n                            buffer[length++] = c;\n                            tokenType = \"double\";\n\n                            if (length == 2) {\n                                offset--;\n                                bufferIndex--;\n                                preIsTokened = true;\n\n                                break;\n                            }\n                        }\n                    }\n                } else if (length > 0) {\n                    if (preIsTokened == true) {\n                        // empty the buffer\n                        length = 0;\n                        preIsTokened = false;\n                    } else {                        break;                    }\n                }\n            }\n        }\n\n        return new Token(new String(buffer, 0, length), start, start + length,\n                         tokenType\n                        );\n    }\n}\n\n\n/* ====================================================================\n\n\tThe Apache Software License, Version 1.1\n *\n\tCopyright (c) 2001 The Apache Software Foundation.  All rights\n\treserved.\n *\n\tRedistribution and use in source and binary forms, with or without\n\tmodification, are permitted provided that the following conditions\n\tare met:\n *\n\t1. Redistributions of source code must retain the above copyright\n\tnotice, this list of conditions and the following disclaimer.\n *\n\t2. Redistributions in binary form must reproduce the above copyright\n\tnotice, this list of conditions and the following disclaimer in\n\tthe documentation and/or other materials provided with the\n\tdistribution.\n *\n\t3. The end-user documentation included with the redistribution,\n\tif any, must include the following acknowledgment:\n\t\"This product includes software developed by the\n\tApache Software Foundation (http://www.apache.org/).\"\n\tAlternately, this acknowledgment may appear in the software itself,\n\tif and wherever such third-party acknowledgments normally appear.\n *\n\t4. The names \"Apache\" and \"Apache Software Foundation\" and\n\t\"Apache Lucene\" must not be used to endorse or promote products\n\tderived from this software without prior written permission. For\n\twritten permission, please contact apache@apache.org.\n *\n\t5. Products derived from this software may not be called \"Apache\",\n\t\"Apache Lucene\", nor may \"Apache\" appear in their name, without\n\tprior written permission of the Apache Software Foundation.\n *\n\tTHIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n\tWARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n\tOF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n\tDISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n\tITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n\tSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n\tLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n\tUSE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n\tON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n\tOR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n\tOF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n\tSUCH DAMAGE.\n\t====================================================================\n *\n\tThis software consists of voluntary contributions made by many\n\tindividuals on behalf of the Apache Software Foundation.  For more\n\tinformation on the Apache Software Foundation, please see\n\t<http://www.apache.org/>.\n *\n\t$Id: jalopy.xml,v 1.1 2003/04/30 14:36:56 chedong Exp $\n */\n\n\n\npackage org.apache.lucene.analysis.cjk;\n\nimport org.apache.lucene.analysis.Analyzer;\nimport org.apache.lucene.analysis.StopFilter;\nimport org.apache.lucene.analysis.TokenStream;\n\nimport java.io.Reader;\n\nimport java.util.Hashtable;\n\n\n/**\n\n\tFilters CJKTokenizer with StopFilter.\n *\n\t@author Che, Dong\n */\npublic class CJKAnalyzer extends Analyzer {\n    //~ Static fields/initializers ---------------------------------------------\n\n\n\n    /**\n\n\tAn array containing some common English words that are not usually\n\tuseful for searching. and some double-byte interpunctions.....\n     */\n    private static String[] stopWords = \n{\n                                            \"a\", \"and\", \"are\", \"as\", \"at\", \"be\",\n                                            \"but\", \"by\", \"for\", \"if\", \"in\",\n                                            \"into\", \"is\", \"it\", \"no\", \"not\",\n                                            \"of\", \"on\", \"or\", \"s\", \"such\", \"t\",\n                                            \"that\", \"the\", \"their\", \"then\",\n                                            \"there\", \"these\", \"they\", \"this\",\n                                            \"to\", \"was\", \"will\", \"with\", \"\",\n                                            \"www\"\n                                        }\n;\n\n\n\n    //~ Instance fields --------------------------------------------------------\n\n    /** stop word list */\n    private Hashtable stopTable;\n\n    //~ Constructors -----------------------------------------------------------\n\n    /**\n\n\tBuilds an analyzer which removes words in STOP_WORDS.\n     */\n    public CJKAnalyzer() \n{\n        stopTable = StopFilter.makeStopTable(stopWords);\n    }\n\n    /**\n     * Builds an analyzer which removes words in the provided array.\n     *\n     * @param stopWords stop word array\n     */\n    public CJKAnalyzer(String[] stopWords) {        stopTable = StopFilter.makeStopTable(stopWords);    }\n\n\n\n    //~ Methods ----------------------------------------------------------------\n\n    /**\n\n\tget token stream from input\n     *\n\t@param fieldName lucene field name\n\t@param reader input reader\n     *\n\t@return TokenStream\n     */\n    public final TokenStream tokenStream(String fieldName, Reader reader) \n{\n        return new StopFilter(new CJKTokenizer(reader), stopTable);\n    }\n}",
    "attachments": {
        "ASF.LICENSE.NOT.GRANTED--CJKTokenizer.java": "https://issues.apache.org/jira/secure/attachment/12312255/ASF.LICENSE.NOT.GRANTED--CJKTokenizer.java",
        "ASF.LICENSE.NOT.GRANTED--CJKAnalyzer.java": "https://issues.apache.org/jira/secure/attachment/12312256/ASF.LICENSE.NOT.GRANTED--CJKAnalyzer.java"
    },
    "issue_links": {},
    "comments": [
        {
            "date": "2003-10-01T20:37:44+0000",
            "content": "Created an attachment (id=8418)\nCJKTokenizer ",
            "author": "Che Dong",
            "id": "comment-12321384"
        },
        {
            "date": "2003-10-01T20:39:32+0000",
            "content": "Created an attachment (id=8419)\nCJKAnalyser: need remove empty token created by CJKTokenizer ",
            "author": "Che Dong",
            "id": "comment-12321385"
        },
        {
            "date": "2003-12-24T02:49:12+0000",
            "content": "Thank you for the contribution, Che.\nI have finally added your 2 CJK classes to Lucene's Sandbox.\nI used the attached versions of your classes, not the inlined ones. ",
            "author": "Otis Gospodnetic",
            "id": "comment-12321386"
        }
    ]
}