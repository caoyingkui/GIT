{
    "id": "SOLR-2716",
    "title": "QueryResultKey hashCode() and equals() is dependent on filter order",
    "details": {
        "affect_versions": "3.3",
        "status": "Resolved",
        "fix_versions": [],
        "components": [
            "search"
        ],
        "type": "Improvement",
        "priority": "Minor",
        "labels": "",
        "resolution": "Duplicate"
    },
    "description": "The hashCode() and equals() methods of a QueryResultKey are dependent on the order of the filters meaning that potentially identical result sets are missed when cached.\n\nQuery query = new TermQuery(new Term(\"field1\", \"value1\"));\nQuery filter1 = new TermQuery(new Term(\"field2\", \"value2\"));\nQuery filter2 = new TermQuery(new Term(\"field3\", \"value3\"));\n\nList<Query> filters1 = new ArrayList<Query>();\nfilters1.add(filter1);\nfilters1.add(filter2);\n\nList<Query> filters2 = new ArrayList<Query>();\nfilters2.add(filter2);\nfilters2.add(filter1);\n\nQueryResultKey key1 = new QueryResultKey(query, filters1, null, 0);\nQueryResultKey key2 = new QueryResultKey(query, filters2, null, 0);\n\n// Both the following assertions fail\nassert key1.equals(key2);\nassert key1.hashCode() == key2.hashCode();",
    "attachments": {
        "SOLR-2716.patch": "https://issues.apache.org/jira/secure/attachment/12491611/SOLR-2716.patch"
    },
    "issue_links": {},
    "comments": [
        {
            "author": "Neil Prosser",
            "id": "comment-13090876",
            "date": "2011-08-25T08:59:49+0000",
            "content": "Half-baked and my first Solr patch so hopefully I've done what's needed. The above example is included as a unit test and I've tried to keep my changes as local as possible to the QueryResultKey class.\n\nI understand that there's some creation of HashSets/ArrayLists which can hopefully be removed. But I wanted to get people's opinion on the change before I went too far down the rabbit-hole and changed a load of files. "
        },
        {
            "author": "Simon Willnauer",
            "id": "comment-13090892",
            "date": "2011-08-25T09:45:57+0000",
            "content": "at a first glance this makes totally sense to me. I just wonder if we should take a Set<Filter> instead of List<Filter> from the beginning and maybe make the member final and use EmptySet() instead of null? Somehow I recall that we had a different issue where the order matters and I recall that there where reasons to keep it like it is but I can't find it right now. Maybe somebody else can find the issue if there is one. "
        },
        {
            "author": "Yonik Seeley",
            "id": "comment-13091069",
            "date": "2011-08-25T15:34:09+0000",
            "content": "Although it does make sense, I wonder if the increased cost in equals() would be worth it... the complete solr request (including filters) are normally generated by another system, not a user, so one will normally see filters in the same order anyway.\n\nFixing hashCode for no performance impact is easy, and for equals() perhaps we can put the comparison of filters last so it's often only executed when other components already match, and optimize a number of cases (check length first, if lengths==1 then comparison is simple).  The problem is when lengths!=1 - I don't see a simple way to quickly compare w/o adding more state to the QueryCacheKey or doing a fair bit more CPU work. "
        },
        {
            "author": "Hoss Man",
            "id": "comment-13091569",
            "date": "2011-08-26T04:24:46+0000",
            "content": "I wonder if the increased cost in equals() would be worth it... the complete solr request (including filters) are normally generated by another system, not a user, so one will normally see filters in the same order anyway.\n\nyeah ... that was the concern i had when this came up on the list.  initially i was thinking of it as a \"sort\" cost, but the same general perf concern still applies: if Set.equals is generally slower then List.equals, then it's better to tell the client \"to maximum cache hit rates, send your filters in a deterministic order\"\n\nif perf tests say that the Set equality is just as fast as List equality - go with the set "
        },
        {
            "author": "Mike Sokolov",
            "id": "comment-13091948",
            "date": "2011-08-26T18:53:43+0000",
            "content": "Also, if Set.equals() is slower than List.equals() and it seems worth the trouble, one could use maybe a SortedMap with keys being the filter hashCode.  This would have the effect of eliminating dups though, which could be bad in some weird case.  So maybe a Bag? "
        }
    ]
}