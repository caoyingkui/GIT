{
    "id": "LUCENE-4690",
    "title": "Optimize NumericUtils.*ToPrefixCoded(), add versions that don't hash",
    "details": {
        "components": [],
        "fix_versions": [
            "4.2",
            "6.0"
        ],
        "affect_versions": "None",
        "priority": "Minor",
        "labels": "",
        "type": "Improvement",
        "resolution": "Fixed",
        "status": "Closed"
    },
    "description": "As far as I can tell nothing actually uses the hash codes generated by these methods (not even any tests).  If someone did want to generate a hash, it would be just as fast to do it on the BytesRef after the fact (or even faster from the input number itself).\n\nedit: Uwe pointed out they were used in one place.  Other places still don't need it.",
    "attachments": {
        "LUCENE-4690.patch": "https://issues.apache.org/jira/secure/attachment/12566206/LUCENE-4690.patch"
    },
    "issue_links": {},
    "comments": [
        {
            "date": "2013-01-16T23:12:25+0000",
            "content": "Current code:\n\n  public static int longToPrefixCoded(final long val, final int shift, final BytesRef bytes) {\n    if (shift>63 || shift<0)\n      throw new IllegalArgumentException(\"Illegal shift value, must be 0..63\");\n    int hash, nChars = (63-shift)/7 + 1;\n    bytes.offset = 0;\n    bytes.length = nChars+1;\n    if (bytes.bytes.length < bytes.length) {\n      bytes.grow(NumericUtils.BUF_SIZE_LONG);\n    }\n    bytes.bytes[0] = (byte) (hash = (SHIFT_START_LONG + shift));\n    long sortableBits = val ^ 0x8000000000000000L;\n    sortableBits >>>= shift;\n    while (nChars > 0) {\n      // Store 7 bits per byte for compatibility\n      // with UTF-8 encoding of terms\n      bytes.bytes[nChars--] = (byte)(sortableBits & 0x7f);\n      sortableBits >>>= 7;\n    }\n    // calculate hash\n    for (int i = 1; i < bytes.length; i++) {\n      hash = 31*hash + bytes.bytes[i];\n    }\n    return hash;\n  }\n\n\n\nProposed code template (i.e. for all of the *ToPrefixCoded methods):\n\n  public void longToPrefixCodedBytes(final long val, final int shift, final BytesRef bytes) {\n    assert (shift & ~0x3f) == 0;  // ensure shift is 0..63\n    int nChars = (63-shift)/7 + 1;\n    bytes.offset = 0;\n    bytes.length = nChars+1;   // one extra for the byte that contains the shift info\n    if (bytes.bytes.length < bytes.length) {\n      bytes.bytes = new byte[NumericUtils.BUF_SIZE_LONG];  // use the max\n    }\n    bytes.bytes[0] = (byte)(SHIFT_START_LONG + shift);\n    long sortableBits = val ^ 0x8000000000000000L;\n    sortableBits >>>= shift;\n    while (nChars > 0) {\n      // Store 7 bits per byte for compatibility\n      // with UTF-8 encoding of terms\n      bytes.bytes[nChars--] = (byte)(sortableBits & 0x7f);\n      sortableBits >>>= 7;\n    }\n  }\n\n\n\nSome of the changes:\n\n\tSetting bytes.length to be larger than the current contained array temporarily puts BytesRef into an invalid state.  Calling any BytesRef methods (like grow) while it is in that invalid state is suspect.\n\treplace grow with simple allocation.\n   1. grow over-allocates all the time.  Most of the time (like here) it's wasted space.\n   2. grow copies the previous buffer when allocating a bigger buffer.  This is wasted/unneeded here.\n\tremoves hash code calculation\n\n ",
            "author": "Yonik Seeley",
            "id": "comment-13555589"
        },
        {
            "date": "2013-01-17T01:47:24+0000",
            "content": "An additional cool little hack... even though it's much improved, IDIV still has a latency of 18-42 cycles on a core2 processor.  One equivalent of i/7 is (i*37)>>8 for i in 0..63.  This only takes 4 cycles. ",
            "author": "Yonik Seeley",
            "id": "comment-13555746"
        },
        {
            "date": "2013-01-17T15:46:51+0000",
            "content": "Curious, how do you know that and/or measure that? ",
            "author": "David Smiley",
            "id": "comment-13556326"
        },
        {
            "date": "2013-01-17T15:59:32+0000",
            "content": "Curious, how do you know that and/or measure that?\n\nThe number of cycles?  It's all documented in various places.  Of course one needs a good sense of what assembly a compiler/hotspot will emit.\nInteger multiply has been 3 cycles for quite a while for both Intel and AMD, and shifts have been a single cycle (after the ill-fated P4).\n\nhttp://gmplib.org/~tege/x86-timing.pdf\nhttp://www.agner.org/optimize/instruction_tables.pdf ",
            "author": "Yonik Seeley",
            "id": "comment-13556333"
        },
        {
            "date": "2013-01-17T16:19:35+0000",
            "content": "As far as I can tell nothing actually uses the hash codes generated by these methods (not even any tests).\n\nThe return value (the hash) is used by NumericTokenStreeam#NumericTermAttribute.fillBytesRef():\n\n\n    @Override\n    public int fillBytesRef() {\n      try {\n        assert valueSize == 64 || valueSize == 32;\n        return (valueSize == 64) ? \n          NumericUtils.longToPrefixCoded(value, shift, bytes) :\n          NumericUtils.intToPrefixCoded((int) value, shift, bytes);\n      } catch (IllegalArgumentException iae) {\n        // return empty token before first or after last\n        bytes.length = 0;\n        return 0;\n      }\n    }\n\n\n\nOther comments:\n\n\tThe masking away of invalid shifts is a no-go to me. This leads to unexpected behaviour.\n\tA agree grow() does not need to be used for this stuff. We can simply reallocate, as we know size exactly.\n\n ",
            "author": "Uwe Schindler",
            "id": "comment-13556348"
        },
        {
            "date": "2013-01-17T16:20:49+0000",
            "content": "By the way, your patch above would corrumpt the IAE case in fillBytesRef used by indexer. ",
            "author": "Uwe Schindler",
            "id": "comment-13556350"
        },
        {
            "date": "2013-01-17T16:33:07+0000",
            "content": "The return value (the hash) is used by NumericTokenStreeam#NumericTermAttribute.fillBytesRef():\n\nAhh, I didn't see it because the use of the value is on a separate line from the method call.  Makes it hard to find. ",
            "author": "Yonik Seeley",
            "id": "comment-13556358"
        },
        {
            "date": "2013-01-23T22:42:18+0000",
            "content": "Here's a patch that doubles the performance of NumericUtils.*ToPrefixCoded ",
            "author": "Yonik Seeley",
            "id": "comment-13561184"
        },
        {
            "date": "2013-01-24T17:09:09+0000",
            "content": "Seems good to me to have non-hashing versions (these versions exist for unicodeutil for terms already for similar purposes) ",
            "author": "Robert Muir",
            "id": "comment-13561768"
        },
        {
            "date": "2013-01-24T22:44:26+0000",
            "content": "[trunk commit] Yonik Seeley\nhttp://svn.apache.org/viewvc?view=revision&revision=1438242\n\nLUCENE-4690: Performance improvements and non-hashing versions of NumericUtils.*ToPrefixCoded ",
            "author": "Commit Tag Bot",
            "id": "comment-13562078"
        },
        {
            "date": "2013-01-24T23:04:12+0000",
            "content": "[branch_4x commit] Yonik Seeley\nhttp://svn.apache.org/viewvc?view=revision&revision=1438253\n\nLUCENE-4690: Performance improvements a non-hashing versions of NumericUtils.*ToPrefixCoded ",
            "author": "Commit Tag Bot",
            "id": "comment-13562106"
        },
        {
            "date": "2013-01-24T23:24:27+0000",
            "content": "Thanks, Yonik! ",
            "author": "Uwe Schindler",
            "id": "comment-13562125"
        },
        {
            "date": "2013-05-10T10:34:33+0000",
            "content": "Closed after release. ",
            "author": "Uwe Schindler",
            "id": "comment-13654255"
        }
    ]
}