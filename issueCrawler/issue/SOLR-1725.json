{
    "id": "SOLR-1725",
    "title": "Script based UpdateRequestProcessorFactory",
    "details": {
        "affect_versions": "1.4",
        "status": "Closed",
        "fix_versions": [
            "4.0-BETA",
            "6.0"
        ],
        "components": [
            "update"
        ],
        "type": "New Feature",
        "priority": "Critical",
        "labels": "",
        "resolution": "Fixed"
    },
    "description": "A script based UpdateRequestProcessorFactory (Uses JDK6 script engine support). The main goal of this plugin is to be able to configure/write update processors without the need to write and package Java code.\n\nThe update request processor factory enables writing update processors in scripts located in solr.solr.home directory. The functory accepts one (mandatory) configuration parameter named scripts which accepts a comma-separated list of file names. It will look for these files under the conf directory in solr home. When multiple scripts are defined, their execution order is defined by the lexicographical order of the script file name (so scriptA.js will be executed before scriptB.js).\n\nThe script language is resolved based on the script file extension (that is, a *.js files will be treated as a JavaScript script), therefore an extension is mandatory.\n\nEach script file is expected to have one or more methods with the same signature as the methods in the UpdateRequestProcessor interface. It is not required to define all methods, only those hat are required by the processing logic.\n\nThe following variables are define as global variables for each script:\n\n\treq - The SolrQueryRequest\n\trsp- The SolrQueryResponse\n\tlogger - A logger that can be used for logging purposes in the script",
    "attachments": {
        "SOLR-1725.patch": "https://issues.apache.org/jira/secure/attachment/12430671/SOLR-1725.patch",
        "SOLR-1725-rev1.patch": "https://issues.apache.org/jira/secure/attachment/12491563/SOLR-1725-rev1.patch"
    },
    "issue_links": {},
    "comments": [
        {
            "author": "Uri Boness",
            "id": "comment-12801942",
            "date": "2010-01-18T20:37:02+0000",
            "content": "Initial implementation. Includes a simple test (probably more tests are required). Builds a script engine per script file - each file has its own scope.\n\nThis patch also introduces a new Interface - SolrResourceLoaderAware which can be used by any plugin loaded by SolrCore. (Any plugin implementing this interface will be injected by the resource loader of the SolrCore). The ScriptUpdateRequestProcessorFactory uses the resource loader to load the scripts from solr home conf directory. "
        },
        {
            "author": "Mark Miller",
            "id": "comment-12801971",
            "date": "2010-01-18T21:54:14+0000",
            "content": "This is a great idea.\n\nThis patch also introduces a new Interface - SolrResourceLoaderAware\n\nWhat about the existing ResourceLoaderAware? "
        },
        {
            "author": "Uri Boness",
            "id": "comment-12801983",
            "date": "2010-01-18T22:58:08+0000",
            "content": "What about the existing ResourceLoaderAware?\n\nWoops... missed that one out ... I'll check it out and update the patch "
        },
        {
            "author": "Uri Boness",
            "id": "comment-12801988",
            "date": "2010-01-18T23:19:05+0000",
            "content": "Is there any reason for currently limiting the classes that can be ResourceLoaderAware? This limitation is explicit in SolrResourceLoader (line: 584):\n\n\nawareCompatibility.put(\n      ResourceLoaderAware.class, new Class[] {\n        CharFilterFactory.class,\n        TokenFilterFactory.class,\n        TokenizerFactory.class,\n        FieldType.class\n      }\n    );\n\n\n\nIf the type is not one of this classes an exception is thrown "
        },
        {
            "author": "Mark Miller",
            "id": "comment-12801991",
            "date": "2010-01-18T23:28:58+0000",
            "content": "I believe its somewhat arbitrary based on what makes sense - so adding something to it shouldn't be a problem. "
        },
        {
            "author": "Uri Boness",
            "id": "comment-12801994",
            "date": "2010-01-18T23:50:21+0000",
            "content": "Right... ok... I'll add another class to this list (I just don't understand why would you want to limit the types that can be *Aware - in a way it defeats the whole idea of the *Aware abstraction). "
        },
        {
            "author": "Uri Boness",
            "id": "comment-12801996",
            "date": "2010-01-19T00:04:18+0000",
            "content": "A new patch, this time leverages the already existing ResourceLoaderAware interface "
        },
        {
            "author": "Mark Miller",
            "id": "comment-12801998",
            "date": "2010-01-19T00:05:41+0000",
            "content": "I believe the history was, on development of *aware - hey, here is a patch that restricts this to certain classes if we want? Anyone object? - and no one did.\n\nedit\n\nActually there was some further discussion - \n\nhttps://issues.apache.org/jira/browse/SOLR-414 "
        },
        {
            "author": "Uri Boness",
            "id": "comment-12802001",
            "date": "2010-01-19T00:28:48+0000",
            "content": "Thanks for the reference "
        },
        {
            "author": "Koji Sekiguchi",
            "id": "comment-12802014",
            "date": "2010-01-19T01:01:49+0000",
            "content": "I like the idea, Uri. I've not looked into the patch yet, it depends on Java 6? I think Solr support Java 5. There is ScriptTransformer in DIH which uses javax.script but it looks like ScriptEngineManager is loaded at runtime. "
        },
        {
            "author": "Uri Boness",
            "id": "comment-12802022",
            "date": "2010-01-19T01:32:18+0000",
            "content": "Yes, it depends on Java 6. I guess the concern is mainly for the unit tests? (at runtime the it shouldn't really matter) "
        },
        {
            "author": "Uri Boness",
            "id": "comment-12802024",
            "date": "2010-01-19T01:35:45+0000",
            "content": "Sorry... of course it matters for the build  "
        },
        {
            "author": "Uri Boness",
            "id": "comment-12802073",
            "date": "2010-01-19T03:45:08+0000",
            "content": "Third try , this time Java 5 compatible "
        },
        {
            "author": "Uri Boness",
            "id": "comment-12802495",
            "date": "2010-01-19T22:02:17+0000",
            "content": "This new patch cleans things up a bit. The main change here is the addition of the script engine abstraction. Supporting JDK 6 script engine at the moment is a bit tricky as Solr is built on JDK 5. So this support must be done using reflection at runtime which makes the code a bit of a mess. The abstraction helps to keep the code clean. "
        },
        {
            "author": "Uri Boness",
            "id": "comment-12802496",
            "date": "2010-01-19T22:03:44+0000",
            "content": "The DIH ScriptTransformer can really be cleaned up using this patch as well. I didn't add it to this patch as I didn't know whether it was a good idea to put too much into one patch.  "
        },
        {
            "author": "Mark Miller",
            "id": "comment-12802607",
            "date": "2010-01-20T01:34:43+0000",
            "content": "We might want to think about making this a contrib?\n\nHow do people feel about putting in core Solr code/functionality that requires Java 6?\n\nSo far you have been able to run all of Solr with just Java 5. Do we want to go down the road of some non contrib features only working with something higher than 5?\n\nShould that only be allowed as a contrib?\n\nWe certainly want the functionality I think, but as far as I can tell this would break new ground in terms of Solr's jvm version requirements (noting that Uri has made it so that everything still builds and runs with 5, you just can't use this functionality unless you are on 6) \n\nAny opinions? "
        },
        {
            "author": "Uri Boness",
            "id": "comment-12804092",
            "date": "2010-01-23T15:20:58+0000",
            "content": "If we move this to the contrib. we'll need to extract the script engine abstraction of a separate contrib. utils library (so the DIH will be able to utilize it). I believe this can create a bit of a mess just for this small (though useful) functionality. Is there are real reason for not keeping it in the core? \n\nI think either way, if people will want to use it they'll need to read somewhere how... I think it'd be nice to save them the extra effort of putting an extra jar file in the lib directory - the configuration (writing the script and configuring the update processors) they'll need to adjust anyway. The only thing that we must stress in the documentation (both in the schema and in the wiki) is that they can only use this feature in Java 6.\n\nTwo additional things to note:\n1. JDK 5 has reached the end of service life (EOSL) already and is not actively supported by Sun (/Oracle).\n2. The general recommendation is to run Solr on Java 6 anyways (due to some threading issues in Java 5). "
        },
        {
            "author": "Jan H\u00f8ydahl",
            "id": "comment-12804093",
            "date": "2010-01-23T15:22:27+0000",
            "content": "This is very much wanted!\n\nWould it make more sense to execute the scripts in the order they are named in the scripts param? If I have two pipelines/chains, that need to use the same scripts but in different orders, I'm in trouble.\n\nIsn't solr/lib/scripts a more natural location of code than solr/conf?\n\nHow to pass parameters to each script, to facilitate reusable scripts instead of hardcoded ones?\n\nTo overcome some of these limitations, why not reuse the existing pipeline mechanism to define even the chain, i.e. allow only one script at a time? Then the order of scripts are then dictated by the order of <processor > tags in the ProcessorChain and we reuse the parameter passing logic. A positive side effect is that you can compose a ProcessorChain with a mix and match of Java and Script based Processors. Class/script instantiation needs to be optimized of course.\n\nExample use case: Say you have an XML input with structured data where one of the fields is the file name of a PDF. You want to convert the PDF usigng a Tika processor (hopefully to come) and then sanitize Author metadata from the parsed PDF. This could then look like this in solrconfig.xml:\n\n<updateRequestProcessorChain name=\"xmlwithpdf\">\n    <processor class=\"solr.FileReaderProcessorFactory\">\n      <str name=\"filenameField\">filename</str>\n      <str name=\"outputField\">binarydata</str>\n    </processor>\n    <processor class=\"solr.TikaProcessorFactory\">\n      <str name=\"inputField\">binarydata</str>\n      <str name=\"fmap.author\">tikaauthor</str>\n      <str name=\"fmap.content\">text</str>\n    </processor>\n    <processor class=\"solr.ScriptUpdateProcessorFactory\">\n      <str name=\"script\">author_samitizer.js</str>\n      <str name=\"inputField\">tikaauthor</str>\n      <str name=\"outputField\">author</str>\n      <str name=\"discardRegex\">Microsoft Word.|Adobe Distiller.|PDF995.*|Unknown</str>\n      <bool name=\"overwriteExisting\">false</str>\n    </processor>\n    <processor class=\"solr.LogUpdateProcessorFactory\" />\n    <processor class=\"solr.RunUpdateProcessorFactory\" />\n  </updateRequestProcessorChain> "
        },
        {
            "author": "Uri Boness",
            "id": "comment-12804094",
            "date": "2010-01-23T15:29:44+0000",
            "content": "Would it make more sense to execute the scripts in the order they are named in the scripts param? If I have two pipelines/chains, that need to use the same scripts but in different orders, I'm in trouble.\n\nAbsolutely! The reason why it is currently lexicographically ordered is due to an initial (different) implementation that i had. I'll change it and add a patch for it. "
        },
        {
            "author": "Uri Boness",
            "id": "comment-12804097",
            "date": "2010-01-23T15:32:58+0000",
            "content": "How to pass parameters to each script, to facilitate reusable scripts instead of hardcoded ones?\n\nAnother great idea... I'll put it in the same patch. \n\n\nTo overcome some of these limitations, why not reuse the existing pipeline mechanism to define even the chain, i.e. allow only one script at a time? Then the order of scripts are then dictated by the order of <processor > tags in the ProcessorChain and we reuse the parameter passing logic. A positive side effect is that you can compose a ProcessorChain with a mix and match of Java and Script based Processors. Class/script instantiation needs to be optimized of course.\n\nWell, once you'll have the parameters support than you'll be able to do it even if the processor supports multiple scripts. "
        },
        {
            "author": "Chris A. Mattmann",
            "id": "comment-12804105",
            "date": "2010-01-23T16:44:51+0000",
            "content": "Is there any reason for SOLR not to move to JDK 1.6? "
        },
        {
            "author": "Chris A. Mattmann",
            "id": "comment-12804106",
            "date": "2010-01-23T16:46:03+0000",
            "content": "oh and one other thing \u2013 I really like this patch, Uri! I'm looking to integrate it into a data processing project here at JPL. Great idea! "
        },
        {
            "author": "Uri Boness",
            "id": "comment-12804112",
            "date": "2010-01-23T17:23:47+0000",
            "content": "A new patch which incorporates some of the ideas suggested above, in particular:\n\n1. The order of script execution is based on the order in which they are configured in solrconfig.xml\n2. It is now possible to configure global scope variables which will be available for scripts. for example:\n\n<processor class=\"solr.ScriptUpdateProcessorFactory\">\n    <str name=\"scripts\">updateProcessor.js</str>\n    <lst name=\"params\">\n        <bool name=\"boolValue\">true</bool>\n        <int name=\"intValue\">3</int>\n    </lst>\n</processor>\n\n "
        },
        {
            "author": "Uri Boness",
            "id": "comment-12804114",
            "date": "2010-01-23T17:26:01+0000",
            "content": "oh and one other thing - I really like this patch, Uri! I'm looking to integrate it into a data processing project here at JPL. Great idea!\nThanks  "
        },
        {
            "author": "Lance Norskog",
            "id": "comment-12804725",
            "date": "2010-01-25T21:25:48+0000",
            "content": "This is growing into the DataImportHandler  \nIs it possible to just create a super-simple configuration language that turns into the DIH language? That way you get the benefit of this simplified format without having to support another execution engine. \n\n<updateRequestProcessorChain name=\"xmlwithpdf\"></bq> \n<processor class=\"solr.FileReaderProcessorFactory\"> \n<str name=\"filenameField\">filename</str> \n<str name=\"outputField\">binarydata</str> "
        },
        {
            "author": "Jan H\u00f8ydahl",
            "id": "comment-12805051",
            "date": "2010-01-26T14:51:23+0000",
            "content": "Lance, what do you mean by \"DIH language\"?\n\nIn my example xml that you quoted, the two first processors, FileReaderProcessorFactory and TikaProcessorFactory, were supposed to be (imagined) ordinary Java processors, not scripting ones.\n\nUri, I'd prefer if the manner of configuration was as similar as possible, i.e. if we could get rid of the <lst name=\"params\"> part, and instead pass all top-level params directly to the script (except the \"scripts\" param itself).\n\nEven better if the definition of a processor was in a separate xml section and then refer by name only in each chain, but that is a bigger change outside scope of this patch. "
        },
        {
            "author": "Uri Boness",
            "id": "comment-12805235",
            "date": "2010-01-26T22:06:43+0000",
            "content": "Lance, I lost you a bit as well.\n\nUri, I'd prefer if the manner of configuration was as similar as possible, i.e. if we could get rid of the <lst name=\"params\"> part, and instead pass all top-level params directly to the script (except the \"scripts\" param itself).\n\nHmm... personally I prefer configurations that clearly indicate their purpose. leaving out the params list will make things a bit confusing - some parameters are available for the scripts, others are not... it's not really clear.\n\nmanner of configuration was as similar as possible\n\nThe configuration are similar. All elements in solrconfig.xml have one standard way of configuration which can be anything from a lst, bool, str, etc.... Tomorrow a new processor will popup which will also require a lst configuration... and that's fine. \n\nEven better if the definition of a processor was in a separate xml section and then refer by name only in each chain, but that is a bigger change outside scope of this patch.\n\nWell, indeed that's a bigger change. Like everything, this kind of configuration has it's pros&cons.\n\nI guess it's best if people will just state their preferences regarding how they would like to see this processor configured and based on that I'll adjust the patch. "
        },
        {
            "author": "Hoss Man",
            "id": "comment-12805247",
            "date": "2010-01-26T22:31:11+0000",
            "content": "Some random comments/questions from the peanut gallery...\n\n1) what is the value add in making ScriptUpdateProcessorFactory support multiple \"scripts\" ? ... wouldn't it be simpler to require that users declare multiple instances of ScriptUpdateProcessorFactory (that hte processor chain already executes in sequence) then to add sequential processing to the ScriptUpdateProcessor?\n\n2) The NamedList init args can be as deep of a data structure as you want, so something like this would be totally feasible (if desired) ...\n\n\n<processor class=\"solr.ScriptUpdateProcessorFactory\">\n  <lst name=\"scripts\">\n    <lst name=\"updateProcessor1.js\">\n      <bool name=\"someParamName\">true</bool>\n      <int name=\"someOtherParamName\">3</int>\n    </lst>\n    <lst name=\"updateProcessor2.js\">\n      <bool name=\"fooParam\">true</bool>\n      <str name=\"barParam\">3</str>\n    </lst>\n  </lst>\n  <lst name=\"otherProcessorOPtionsIfNeeded\">\n    ...\n  </lst>\n</processor>\n\n "
        },
        {
            "author": "Uri Boness",
            "id": "comment-12805254",
            "date": "2010-01-26T22:44:01+0000",
            "content": "1) what is the value add in making ScriptUpdateProcessorFactory support multiple \"scripts\" ? ... wouldn't it be simpler to require that users declare multiple instances of ScriptUpdateProcessorFactory (that hte processor chain already executes in sequence) then to add sequential processing to the ScriptUpdateProcessor?\n\nWell... to my taste it makes the configuration cleaner (no need to define several script processors). The thing is, you have the choice here - either specify several scripts (comma separated) or split them to several processors.\n\n2) The NamedList init args can be as deep of a data structure as you want, so something like this would be totally feasible (if desired) ...\n\nThat's definitely another option.\n\nThe only thing is that you'd probably want some way to define shared parameters (shared between the scripts that is) and not be forced to specify them several times for each script. I guess you can do something like this:\n\n\n<processor class=\"solr.ScriptUpdateProcessorFactory\">\n  <lst name=\"sharedParams\">\n    <bool name=\"paramName\">true</bool>\n  </lst>\n  <lst name=\"scripts\">\n    <lst name=\"updateProcessor1.js\">\n      <bool name=\"someParamName\">true</bool>\n      <int name=\"someOtherParamName\">3</int>\n    </lst>\n    <lst name=\"updateProcessor2.js\">\n      <bool name=\"fooParam\">true</bool>\n      <str name=\"barParam\">3</str>\n    </lst>\n  </lst>\n  <lst name=\"otherProcessorOPtionsIfNeeded\">\n    ...\n  </lst>\n</processor>\n\n "
        },
        {
            "author": "Jan H\u00f8ydahl",
            "id": "comment-12805500",
            "date": "2010-01-27T13:01:36+0000",
            "content": "It looks logical and nice.\n\nHowever, I'm leaning towards keeping it very simple. The simplest is one script per processor, since that will always work.\n\nAs more and more update processors are written, in Java, JS, Jython and more, it would be a clear benefit if Administrators don't need to care about the underlying implementation, but can use same way of configuring each one - That's why I opt for the top-level param structure as default.\n\nI have years of experience with FAST document processing, which is really a killer feature, mainly because it's so dead simple. Drop in a python script with a deployment descriptor and start using it in your pipelines. You don't care if the implementation is pure Python, a C library wrapper or whatever, you just care about what parameters to give it. I see this patch as one big step towards the same simplicity with Solr! "
        },
        {
            "author": "Yonik Seeley",
            "id": "comment-12805532",
            "date": "2010-01-27T15:15:19+0000",
            "content": "Cool feature!\n\nPerformance:\n\n\tIt looks like scripts are read from the resource loader and parsed again (eval) for every update request. This can be pretty expensive, esp for those scripting languages that generate java class files instead of using an interpreter. One way to combat this would be to cache and reuse them.\n\n\n\nInterface:\n\n\tShould we have a way to specify a script in-line (in solrconfig.xml)?\n\tOr even cooler... allow passing of scripts as parameters in the update request! Think about the power of pointing Solr to a CSV file and also providing document transformers & field manipulators on the fly!\n\tThis seems to raise the visibility of the UpdateCommand classes, directly exposing them to users w/o plugins. We should perhaps consider interface cleanups on these classes at the same time as this issue.\n\tExamples! Using javascript (since it's both fast and included in JDK6), let's see what the scripts are for some common usecases. This both helps improve the design as well as lets other people give feedback w/o having to read through code.\n\n "
        },
        {
            "author": "Uri Boness",
            "id": "comment-12805612",
            "date": "2010-01-27T18:55:29+0000",
            "content": "\nPerformance:\n\nIt looks like scripts are read from the resource loader and parsed again (eval) for every update request. This can be pretty expensive, esp for those scripting languages that generate java class files instead of using an interpreter. One way to combat this would be to cache and reuse them.\nYes, indeed the scripts are evaluated per request but for a reason. One of the goals here is to keep the scripts as close as possible to the update processor interface, so the functions in the scripts has the same signature as the methods in the processor. But in order for the scripts to be flexible I decided to introduce some global scoped variables which are accessible in the functions. (currently the current solr request, response and a logger are there). The problem is that the API only defines 3 scopes where you can register variables and the lowest one is the engine itself. Since the evaluation of a script is done on the engine level as well, when using this API together with the global variables I don't think you can escape the need for creating an engine per request (thus, also evaluating the scripts).\n\nBut I agree with you that if there is a way around it, caching the evaluated/compiled scripts will definitely boost things up. I'll need to investigate this further and come up with alternatives (I already have some ideas using ThreadLocals).\n\nShould we have a way to specify a script in-line (in solrconfig.xml)?\n\nPersonally I prefer keeping the solrconfig.xml as clean as possible. I do however think that a standardization of Solr scripting support in general can be great. (for example, have a scripts folder under solr.solr.home were all the scripts are placed, or come up with a standard configuration structure for the scripts... perhaps something in the direction Hoss suggested above).\n\nThis seems to raise the visibility of the UpdateCommand classes, directly exposing them to users w/o plugins. We should perhaps consider interface cleanups on these classes at the same time as this issue.\n+1\n\nExamples! Using javascript (since it's both fast and included in JDK6), let's see what the scripts are for some common usecases. This both helps improve the design as well as lets other people give feedback w/o having to read through code.\nYep.. that would probably be very helpful. basically I think anyone who's ever written an update processor can perhaps try to convert it to a script and see how it works. The usual use case for me is to just add a few fields which are derived from the other fields, but perhaps there are some other more interesting use cases out there. I guess these examples should be put in the Wiki, right?\n\n\n "
        },
        {
            "author": "Uri Boness",
            "id": "comment-12805672",
            "date": "2010-01-27T22:18:19+0000",
            "content": "Been looking more into it and I think there's a nice way in which we can cache the evaluated scripts. But... (and there's always a but) to make it work cleanly we need to be able to extend the scripting support, which means we need to be able to compile the code in Java 6.\n\nAnd this brings us back to Mark's comment above on how do we want to do that. "
        },
        {
            "author": "Yonik Seeley",
            "id": "comment-12805678",
            "date": "2010-01-27T22:36:54+0000",
            "content": "As you pointed out, Java5 is EOL'd already and Sun/Oracle doesn't even let you download JDK5 anymore w/o registration.\nWouldn't hurt my feelings to move to Java6.  After all, the SolrCloud stuff we're working on uses zookeeper which requires 1.6. "
        },
        {
            "author": "Uri Boness",
            "id": "comment-12805691",
            "date": "2010-01-27T23:24:44+0000",
            "content": "Well then... I just hope others will not shed tears as well and we can make Solr 1.5 Java 6 compiled  "
        },
        {
            "author": "David Smiley",
            "id": "comment-13006284",
            "date": "2011-03-13T22:03:40+0000",
            "content": "This capability is awesome, just as it's DIH equivalent is.  It's been over a year since any activity here.  As time passes, the case for moving to Java 6 increases.  Short of that, I don't see a problem with this working like the DIH ScriptTransformer does by using the Java 6 features via reflection. "
        },
        {
            "author": "Grant Ingersoll",
            "id": "comment-13007627",
            "date": "2011-03-16T18:53:57+0000",
            "content": "As time passes, the case for moving to Java 6 increases.\n\nSolr trunk is on 1.6. "
        },
        {
            "author": "Bill Bell",
            "id": "comment-13061823",
            "date": "2011-07-08T07:44:13+0000",
            "content": "Is there a reason why this is not committed. It seems pretty awesome!!  "
        },
        {
            "author": "Simon Willnauer",
            "id": "comment-13061838",
            "date": "2011-07-08T08:24:50+0000",
            "content": "Is there a reason why this is not committed. It seems pretty awesome!!\nindeed this looks good... somebody should bring it uptodate I guess  "
        },
        {
            "author": "Simon Rosenthal",
            "id": "comment-13090591",
            "date": "2011-08-24T22:45:37+0000",
            "content": "With the hope that this can be committed to trunk soon, I updated the patch to work with reorganized sources in trunk, and a couple of other small changes so that the tests would compile\n.\nSome tests fail - I'm seeing\n    [junit] ERROR: SolrIndexSearcher opens=30 closes=28\n    [junit] junit.framework.AssertionFailedError: ERROR: SolrIndexSearcher opens=30 closes=28\n\nin the ScriptUpdateProcessorFactoryTest\t\n "
        },
        {
            "author": "Jan H\u00f8ydahl",
            "id": "comment-13188177",
            "date": "2012-01-18T01:29:50+0000",
            "content": "As a Solr4 (alpha) release is getting more realistic, perhaps we shall just aim this as a 4.0 only feature, and go with clean Java6 requirement, which makes everything simpler! "
        },
        {
            "author": "Erik Hatcher",
            "id": "comment-13278109",
            "date": "2012-05-17T19:10:50+0000",
            "content": "Here's a patch updated to current trunk. "
        },
        {
            "author": "Erik Hatcher",
            "id": "comment-13278118",
            "date": "2012-05-17T19:17:11+0000",
            "content": "I'm picking this much needed issue up.  I've updated Simon's last patch to trunk.  I even did a quick (commented out in ScriptEngineTest) test to see if JRuby worked and it did.   I haven't looked, yet, at what needs to be removed/refactored since we can assume Java 6 now, but that'll get cleaned up before committing.\n\nWhat else is needed here? "
        },
        {
            "author": "Andrzej Bialecki",
            "id": "comment-13278257",
            "date": "2012-05-17T20:58:53+0000",
            "content": "Erik, good stuff, very much needed!\n\nMy comments relate to a use case that would require extending this functionality to be able to re-configure the processor on the fly (without a core reload) and to support non-file based scripts (e.g. parsing scripts from SolrParams). Currently these classes are not extensible at all, but only small modifications would be required to make them much more powerful and reusable:\n\n\n\tI'd like to be able to re-configure SUPFactory programatically and not via init args. The implementation appears to handle this by not throwing an exception if <script></script> exists and is empty. That's fine, but if it wasn't intentional then please don't block it \n\n\n\n\n\tcould you please change initEngines(req,rsp) and associated private classes (and members in SUPFactory) to protected? I'd like to be able to customize these parts, too.\n\n\n\n\n\tactually, I don't like ScriptFile at all, and it's baked into EngineInfo so that I can't get rid of it - in my use case I wouldn't have a file, and anyway the whole idea of re-reading actual files on each request is doubtful, in terms of performance... I'd rather see something like this:\n\n\n\n\nprotected static class Script {\n private final String scriptName;\n private final String type;\n private final byte[] script;\n\n protected Script(String scriptName, String type, byte[] content) {\n  ...\n }\n...\n}\n\n\nI.e. to separate the actual content of the script from the way we obtain it, and do the reading as a part of init(args), so that it's customizable. The benefit of this is also that we would cache the script content so that no IO would be needed on each request. Then initEngines(..) could simply open a reader on the cached bytes to eval() the script. "
        },
        {
            "author": "Erik Hatcher",
            "id": "comment-13279001",
            "date": "2012-05-18T17:38:52+0000",
            "content": "Updated patch that removes the Java 5 support (removing a lot of now unnecessary code) and other fiddlings. "
        },
        {
            "author": "Erik Hatcher",
            "id": "comment-13279010",
            "date": "2012-05-18T17:45:32+0000",
            "content": "The latest patch also refactors the test case a bit, creating a common base class for useful stuff borrowed from the field mutating update processor tests.\n\nI'm having issues with the tests in the latest patches.  Running \"ant -Dtestcase=ScriptUpdateProcessorFactoryTest test\" I get, after it \"hangs\" for a couple of minutes:\n\n\n   [junit4] ERROR   0.00s | ScriptUpdateProcessorFactoryTest (suite)\n   [junit4]    > Throwable #1: java.lang.AssertionError: ERROR: SolrIndexSearcher opens=3 closes=1\n\n\n\nI've not yet figured out what is causing this, as the test class itself is fairly straightforward.\n\nAlso, testMultipleScripts test case is a bit odd... setting one of the factories to enabled=false (so it's not really testing multiple, though awkwardly it actually is anyway for some reason).  \n\nStill fiddling, but figured I'd post an updated patch in case anyone else has thoughts on these issues. "
        },
        {
            "author": "Erik Hatcher",
            "id": "comment-13279094",
            "date": "2012-05-18T19:07:23+0000",
            "content": "Updated patch, removing the \"enabled\" concept which wasn't working well for the tests only.  Also fixed up tests that were not decrementing searcher count causing the test monitor to raise a red flag. "
        },
        {
            "author": "Erik Hatcher",
            "id": "comment-13279543",
            "date": "2012-05-19T12:30:19+0000",
            "content": "New patch, which allows script files to not have to implement every method. "
        },
        {
            "author": "Erik Hatcher",
            "id": "comment-13279545",
            "date": "2012-05-19T12:42:34+0000",
            "content": "With the latest patch, you can implement an update processor more simply (not having to implement every process* and finish() methods) like this:\n\n\nfunction processAdd(cmd) {\n  doc = cmd.solrDoc;\n\n  doc.addField('foo_s', 'bar');\n}\n\n\n\nI think there needs to be a simpler mode such that a script can be assumed to be simply under processAdd (it's not going to be a common activity to need to implement a processAnythingElse) where the script is handed a SolrInputDocument cleanly and not (necessarily) having to see the AddUpdateCommand object at all.\n\nThoughts on how that should work?   (at the ScriptEngine level, it's cleaner to eval than it is to invoke a function).  Maybe something like:\n\n\n    <processor class=\"solr.ScriptUpdateProcessorFactory\">\n      <str name=\"add\">add_doc.js</str>\n    </processor>\n\n\n\nwhere add_doc.js is evaluated only during processAdd and handed a SolrInputDocument \"doc\" (along with the request and logger objects of course).  We can still keep it such that a full \"update processor\" can be implemented with script to have the full power of all update processor methods. "
        },
        {
            "author": "Erik Hatcher",
            "id": "comment-13279547",
            "date": "2012-05-19T12:45:28+0000",
            "content": "Is there really a need for multiple scripts specified for a single update processor?   We could simplify the implementation and testing if we kept it at one script per ScriptUpdateProcessorFactory. I appreciate the flexibility scripts plural offers, but practically speaking it's not really necessary as an implementer could combine all script activities into one script file, or specify multiple ScriptUpdateProcessorFactory's.   "
        },
        {
            "author": "Erik Hatcher",
            "id": "comment-13279549",
            "date": "2012-05-19T13:30:43+0000",
            "content": "Just FYI, with the current patch, I've gotten the following to work:\n\n\n  <updateRequestProcessorChain name=\"script\">\n    <processor class=\"solr.ScriptUpdateProcessorFactory\">\n      <str name=\"scripts\">updateProcessor.js</str>\n    </processor>\n    <processor class=\"solr.LogUpdateProcessorFactory\" />\n    <processor class=\"solr.RunUpdateProcessorFactory\" />\n  </updateRequestProcessorChain>\n\n\n  <updateRequestProcessorChain name=\"ruby\">\n    <processor class=\"solr.ScriptUpdateProcessorFactory\">\n      <str name=\"scripts\">updateProcessor.rb</str>\n    </processor>\n    <processor class=\"solr.LogUpdateProcessorFactory\" />\n    <processor class=\"solr.RunUpdateProcessorFactory\" />\n  </updateRequestProcessorChain>\n\n  <updateRequestProcessorChain name=\"python\">\n    <processor class=\"solr.ScriptUpdateProcessorFactory\">\n      <str name=\"scripts\">updateProcessor.py</str>\n    </processor>\n    <processor class=\"solr.LogUpdateProcessorFactory\" />\n    <processor class=\"solr.RunUpdateProcessorFactory\" />\n  </updateRequestProcessorChain>\n\n\n\nusing the following scripts:\n\nJavaScript\n\nfunction processAdd(cmd) {\n  doc = cmd.solrDoc;\n\n  doc.addField('foo_s', 'bar');\n}\n\n\n\nJRuby\n\ndef processAdd(cmd)\n  doc = cmd.solrDoc\n\n  doc.addField('foo_s', 'bar')\n\n  $logger.info(\"Added field to #{doc}\")\nend\n\n\n\nJython\n\ndef processAdd(cmd):\n  doc = cmd.solrDoc\n  doc.addField('foo_s', 'bar')\n\n\n\nI simply added jruby.jar and jython.jar to my local lucene/solr/lib directory and rebuilt the example.  Pretty cool! "
        },
        {
            "author": "Erik Hatcher",
            "id": "comment-13279551",
            "date": "2012-05-19T13:33:01+0000",
            "content": "Another TODO is to get this to work with a scripting language implementation JAR file being added as a \"plugin\" somehow.  I'm not yet sure what it'd take to be able to keep solr.war as-is, and have an external jruby.jar picked up.  Anyone with insight into how to make this work? "
        },
        {
            "author": "Lance Norskog",
            "id": "comment-13295512",
            "date": "2012-06-15T07:54:38+0000",
            "content": "I simply added jruby.jar and jython.jar to my local lucene/solr/lib directory and rebuilt the example. \nNext post, 3 minutes later:\nAnother TODO is to get this to work with a scripting language implementation JAR file being added as a \"plugin\" somehow. I'm not yet sure what it'd take to be able to keep solr.war as-is, and have an external jruby.jar picked up. \n\nDoesn't the first comment answer the second? What other deployment are you describing? "
        },
        {
            "author": "Erik Hatcher",
            "id": "comment-13295882",
            "date": "2012-06-15T19:40:22+0000",
            "content": "Doesn't the first comment answer the second? What other deployment are you describing?\n\nNo, it doesn't.  lucene/solr/lib (we're talking about a source checkout dir structure here) is a build time directory, not used at run-time.  Dropping those jars in there causes them to get built (\"and rebuilt the example\", i.e. ran \"ant example\") into solr.war. "
        },
        {
            "author": "Lance Norskog",
            "id": "comment-13295921",
            "date": "2012-06-15T21:05:19+0000",
            "content": "So, parking them into  solr.home/lib or solr.home/cores/collection/lib does not work? The scripting engine will not be dynamically loaded? "
        },
        {
            "author": "Erik Hatcher",
            "id": "comment-13295974",
            "date": "2012-06-15T22:43:09+0000",
            "content": "So, parking them into solr.home/lib or solr.home/cores/collection/lib does not work? The scripting engine will not be dynamically loaded?\n\nMy comment above still stands: \"Another TODO is to get this to work with a scripting language implementation JAR file being added as a \"plugin\" somehow. I'm not yet sure what it'd take to be able to keep solr.war as-is, and have an external jruby.jar picked up.\".\n\nIn other words, a TODO.  I didn't try it, but I'm fairly certain there's no way that'd work currently, as somehow we'd need to incorporate the SolrResourceLoader into the picture to see that \"classpath\" for anything we load.  Surely we'll need some SolrResourceLoader#newInstance action, or something.  I dunno yet.  Wanna iterate on this patch with me some, Lance?  Feel free to take some stabs at it. "
        },
        {
            "author": "Hoss Man",
            "id": "comment-13402743",
            "date": "2012-06-28T01:06:28+0000",
            "content": "My comment above still stands: \"Another TODO is to get this to work with a scripting language implementation JAR file being added as a \"plugin\" somehow.\n\nI played around with this on the train today and confirmed that we can do runtime loading of jars that included script engines if we changed the ScriptEngineManager instantiation so that we use the one arg constructor and pass in resourceLoader.getClassLoader().\n\nA few other notes based on reviewing the patch and playing arround with it.  Baring objections i'll probably take a stab at addressing these tomorow or friday...\n\n\n\ti don't see any mechanism for scripts to indicate that processing should \"stop\" \u2013 ie: the way a java UpdateProcessor would just return w/o calling super.foo. we should add/test/doc some functionality to look at the result of the invokeFunction call to support this\n\tthe tests seem to assert that the side effects of the scripts happen (ie: that the \"testcase\" records the function names) but i don't see any assertions that the expected modifications of the update commands is happening (ie: that documents are being modified in processAdd\n\twe need to test that request params are easily accessable (i'm not sure how well the SolrQueryRequest class works in various scripting langauges, so might need to pull out hte SolrParams and expose directly - either way we need to demonstrate doing it in a test)\n\twhitespace/comma/pipesplitting of the script names is a bad meme.  we should stop doing that, and require that multiple scripts be specified as multiple <str> params\n\t\n\t\twe can add convenience code to support <arr name=\"script\"><str><str></arr> style as well\n\t\n\t\n\t\"ScriptFile\" and it's extension parsing is very primitive and broken on any file with \".\" in it's name.  We should just use the helper method for parsing filename extensions that already exists in commons-io\n\tfrom what i can tell looking at the ScriptEngine javadocs, it's possible that a ScriptEngine might exist w/o a specific file extension, or that multiple engines could support the same extension(s)  we should offer an init param that lets the user specify a ScriptEngine by \"shortname\" to override whatever extension might be found\n\tcurrently, problems with scripts not being found, or engines for scripts not being found, aren't reported until first request tries to use them - we should error check all of this in init (or inform) and fail fast.\n\t\n\t\tditto for the assumption in invokeFunction that we can cast every ScriptEngine to Invocable \u2013 we should at check this on init/inform and fail fast\n\t\n\t\n\tthe way the various UpdateProcessor methods are implemented to be lenient about any scripts that don't explicitly implement a method seems kludgy \u2013 isn't there anyway we can introspect the engine to ask if a function exists?\n\t\n\t\tin particular, when i did some testing with jruby, i found that it didn't work at all - i guess jruby was throwing a ScriptException instead of NoSuchMethodException?\n\t\n\t\n\n\n\n\nundefined method `processCommit' for main:Object (NoMethodError)\norg.jruby.embed.InvokeFailedException: (NoMethodError) undefined method `processCommit' for main:Object\n\tat org.jruby.embed.internal.EmbedRubyObjectAdapterImpl.call(EmbedRubyObjectAdapterImpl.java:403)\n\tat org.jruby.embed.internal.EmbedRubyObjectAdapterImpl.callMethod(EmbedRubyObjectAdapterImpl.java:189)\n\tat org.jruby.embed.ScriptingContainer.callMethod(ScriptingContainer.java:1386)\n\tat org.jruby.embed.jsr223.JRubyEngine.invokeFunction(JRubyEngine.java:262)\n\tat org.apache.solr.update.processor.ScriptUpdateProcessorFactory$ScriptUpdateProcessor.invokeFunction(ScriptUpdateProcessorFactory.java:221)\n\tat org.apache.solr.update.processor.ScriptUpdateProcessorFactory$ScriptUpdateProcessor.processCommit(ScriptUpdateProcessorFactory.java:202)\n\n\n\n "
        },
        {
            "author": "Hoss Man",
            "id": "comment-13403663",
            "date": "2012-06-29T02:19:29+0000",
            "content": "Updated patch with lots of changes, here's the notes i kept as i went along...\n\n\n\tupdated patch to trunk\n\tadded classloader to ScriptEngineManager constructor\n\tfixed InputStreamReader to use UTF-8\n\tfixed Reader usage to ensure it's closed\n\tfixed file extension parsing using commons-io\n\trenamed some test files to make it more clear at a glance what they were for\n\tmore tests and asserts to verify that changes are working (including adding field values)\n\tadded logic to allow script functions to return \"false\" to end processing of this command\n\tfixed init to call super.init\n\tremoved splitting of string \"scripts\" init param, replaced with multivalued \"script\" init param\n\tgenerallize \"params\" to allow any init param type (not just NamedList)\n\tadd support for forcing engine name\n\tadd details about supported engines if we can't fine one by extension/name\n\tupdated javadocs\n\n\n\nThings i still want to deal with:\n\n\n\tmake test assume() javascript/js engine is available - from what i can tell JREs aren't required to support it\n\tcheck engine(s) & scripts exist in inform\n\tadd tests of bad configs (bad engine name, bad extension)\n\tpolish javadocs\n\tdeal with problem of processor functions that don't exist in script.\n\n\n\nThe last one is a biggee.  from what i can tell, the ScriptEngine api doesn't give us any sort of \"reflection\" and the more i think about it, the more silently ignoring when a function doesn't exist seems like a really bad idea \u2013 what if the script has a function name with a typo in it? what if a stray \"cat\" command causes someome to accidently truncate a script file to 0 bytes? (so it's still a legal script, but doesn't have any functions?)  ... i think we should fail hard if any method used isn't found \u2013 so people have to implement every method that they use (ie: if you never use \"rollback\" it's no big deal that you don't have a processRollback(...) method) "
        },
        {
            "author": "Robert Muir",
            "id": "comment-13403838",
            "date": "2012-06-29T11:28:14+0000",
            "content": "\nfixed InputStreamReader to use UTF-8\n\nI couldn't resist: I think instead of\n\nInputStream input = resourceLoader.openResource(fileName);\nreturn new InputStreamReader(input, \"UTF-8\");\n\n\n\nI would try something like\n\nInputStream input = resourceLoader.openResource(fileName);\nCharsetDecoder decoder = IOUtils.CHARSET_UTF_8.newDecoder()\n              .onMalformedInput(CodingErrorAction.REPORT)\n              .onUnmappableCharacter(CodingErrorAction.REPORT);\nreturn new InputStreamReader(input, decoder);\n\n\n\nwe could maybe add some sugar like this somewhere: I think\nwe should be throwing exceptions on invalid encoding when possible.\nI can't stand how java silently defaults to replacing errors with \\uFFFD "
        },
        {
            "author": "Robert Muir",
            "id": "comment-13403841",
            "date": "2012-06-29T11:34:31+0000",
            "content": "We do have sugar for this already actually: IOUtils.getDecodingReader(InputStream, Charset) "
        },
        {
            "author": "Hoss Man",
            "id": "comment-13404362",
            "date": "2012-06-30T01:51:05+0000",
            "content": "Updated patch, changes...\n\n\n\trefactor TestBadConfig and BadIndexSchemaTest to use common base class\n\tadd TestBadConfig tests that bad script processor configs should fail on init\n\tadd initEngine call to inform so errors are triggered at startup\n\ttweak SolrCore init error reporting to make the underlying msg more visible\n\ttweak script processor error reporting to have better error msgs\n\ttest wrapping of errors thrown by the script functions\n\texplicitly check that ScriptEngine is Invocable\n\tmake tests use assume() on existence of javascript engine since JVMs aren't garunteed to support it\n\tmake processor fail hard if a method is missing from a script\n\trevert unneccessary SolrResourceLoader change\n\tfixed rmuirs charset suggestions\n\n\n\n...the only thing from my previous list i didn't get to today was polishing up the javadocs (still some TODOs in there about scoping)\n\n\u2014\n\nFWIW: Erik and i had a (VERY) breif exchange on IRC last night about the \"NoSuchMethod\" problem in which he pointed me to his earlier comment about a simpler syntax for just dealing with \"processAdd\" as it's own script, which got me reading a lot of the older comments on this issue (i fully admit: i glossed over most of them when i first started looking at this issue a few days ago because when skimming it looked like they were mostly all about Java5 stuff) which got me thinking more about scoping and caching of ScriptEngine objects.\n\nIn general, i think what we have here is definitely usable (if nothing else then for rapid prototyping and experimentation), and provides a fairly direct representation of an \"UpdateProcessor implemented as a script - ie: isolated instances are constructed for each request (with no risk of multiple requests polluting each other) and individual functions/methods are called for each command in that request.  \n\nBut there are probably other approaches we could take, in slightly different directions, that deviate from the existing UpdateProcessor model to get other gains:\n\n\tConstruct ScriptEngine instances that are scoped to the processorfactory (and live for hte lifespan of hte solr core), and using eval or invokeFunction for the individual methods passing req,rsp,and cmd as args (requires the user to be more careful about variable usage in their script implementations)\n\tlet the user specify distinct script files for each method they want to implement and require that the ScriptEngines are \"Compilable\", so we can generate a CompiledScript during processorfactory initialization, such that the CompiledScript's lifespan is the same sa the solr core, and call CompiledScript.eval(Bindings) with Bindings containing the req/rsp/cmd in each process method \u2013 ie: the entire script file is a single function (should be much more efficient, but has a lot of preconditions, and like the above suggestion requires the user to be careful about the variables in their scripts)\n\tetc...\n\n\n\n...the bottom line being i think we should commit this, and iterate in other issues on other ways scripting could be exposed as update processors.\n\nwith that in mind, the one pro-active thing i would think we should still do here, is to change the name to something like \"StatelessScriptUpdateProcessorFactory\" since the scripts are re-evaluated from scratch on every request.  that will help us differnetiate it from any alternative future factory implementations where we try to support compiling/cache/reusing scripts.\n\nthoughts? "
        },
        {
            "author": "Hoss Man",
            "id": "comment-13405230",
            "date": "2012-07-02T18:45:41+0000",
            "content": "Updated patch renaming the factory to StatelessScriptUpdateProcessorFactoryTest and polishing the javadocs (mainly around explaining the scope for each script)\n\nplan to commit tomorrow  "
        },
        {
            "author": "Erik Hatcher",
            "id": "comment-13405331",
            "date": "2012-07-02T21:22:52+0000",
            "content": "Hoss - I've been following along.  Well done Hoss (and Robert) on the state of this now.  +1.   We can certainly iterate on the fine details, but this is a superb start.  Thanks again for all the polish and cleanup that has developed.  I'm going to be trying this out fully and reporting back.  Let's start some wiki documentation on this too. "
        },
        {
            "author": "Erik Hatcher",
            "id": "comment-13405337",
            "date": "2012-07-02T21:35:54+0000",
            "content": "Let's start some wiki documentation on this too.\n\nFor starters, I put a ScriptUpdateProcessor section here, but it'll deserve its own page and then some probably. - http://wiki.apache.org/solr/UpdateRequestProcessor "
        },
        {
            "author": "Erik Hatcher",
            "id": "comment-13405338",
            "date": "2012-07-02T21:38:58+0000",
            "content": "Hoss - in StatelessScriptUpdateProcessorFactory, there's this:\n\n\n      Reader scriptSrc = scriptFile.openReader(resourceLoader);\n\n      try {\n        engine.eval(scriptFile.openReader(resourceLoader)\n...\n\n\n\nAre those two consecutive openReader calls redundant or needed?\n\nAndrzej - does ScriptFile now address your needs with it being ResourceLoader savvy?   I'm not sure it does - I think you were asking for scripts to be loaded from the factory configuration directly?  Just checking if we're still missing a use case Andrzej had in mind. "
        },
        {
            "author": "Erik Hatcher",
            "id": "comment-13405416",
            "date": "2012-07-02T22:59:11+0000",
            "content": "I'm not fond of a script having to implement all the functions, which seems to be the way the latest patch works.  I tried a JRuby script that simply has this:\n\n\ndef processAdd(cmd)\n  doc = cmd.solrDoc\n\n  doc.addField('foo_s', 'bar')\n\n  $logger.info(\"Added field to #{doc}\")\nend\n\n\n\nWhich fails because \"finish\" isn't found.   \n\nIt's deceiving, because there is a test case to go along with conditional.updateprocessor.js, which just has processAdd, but the test case only calls processAdd, not a full document update from the outside.  So at the very least, the .js scripts should all be fully fleshed out to what would work for real.  But I really think we should default to no-op on all methods that don't exist when tried to invoke.   Is that so bad?  "
        },
        {
            "author": "Hoss Man",
            "id": "comment-13405480",
            "date": "2012-07-03T01:08:47+0000",
            "content": "Are those two consecutive openReader calls redundant or needed?\n\nthat was a very bad bug, thank you for catching that.\n\nAndrzej - does ScriptFile now address your needs with it being ResourceLoader savvy? I'm not sure it does - I think you were asking for scripts to be loaded from the factory configuration directly? Just checking if we're still missing a use case Andrzej had in mind.\n\nWe are most definitely missing what ab was asking about \u2013 i was alluding to his comments when i mentioned that we should probably iterate on other script based updateprocessors that scope things differently and have longer life cycles.  The fact that we do not attempt to cache the bytes of the file is one way this processor is \"stateless\" because you can actually edit the script files w/o needing a core reload and your changes automaticly get picked up.\n\nThe majority of what is in this factory is really around dealing with parsing init args and dealing with script files.  The amount of code needed to interact with teh ScriptEngineManager and ScriptEngines is so tiny it seems like what he's describing could be done just as easily with a completely distinct processor then worrying about extending this one \u2013 hence i didn't worry about making ScriptFile or EngineInfo public (but who knows, maybe if/when we iterate on other versions, we'll find that a lot of this can be refactored into a baseclass)\n\nSo at the very least, the .js scripts should all be fully fleshed out to what would work for real.\n\ngood catch .. i thought i already did that.\n\nBut I really think we should default to no-op on all methods that don't exist when tried to invoke. Is that so bad? \n\nI think it would be horrific.  Consider a small typo in your example...\n\n\ndef processadd(cmd)\n  doc = cmd.solrDoc\n\n  doc.addField('foo_s', 'bar')\n\n  $logger.info(\"Added field to #{doc}\")\nend\n\n\n\n...it will silently do nothing, which is terrible.\n\nI would rather people have to write a few no-op methods and get good errors then rip their hair out \u2013 or have data loss \u2013 because they have a subtle typo in a function name that they don't notice\n\n\u2014\n\nUpdated patch fixes the double reader open and adds the NOOP methods to all example scripts (except for \"missing.functions.updateprocessor.js\" because that's the entire point of the file) "
        },
        {
            "author": "Erik Hatcher",
            "id": "comment-13405934",
            "date": "2012-07-03T13:52:29+0000",
            "content": "I would rather people have to write a few no-op methods and get good errors then rip their hair out \u2013 or have data loss \u2013 because they have a subtle typo in a function name that they don't notice\n\nNo argument there.  I think this just demands that we implement an add-only type of capability such that the entire script is implicitly inside a processAdd call.  The most common use case here is for processAdd, and streamlining this to be easy and less-error-prone (why even have \"processAdd\" method wrapper at all if we're aiming for less hair pulling?) for the common needs.  We can iterate on that after a commit of what's there though.... having a full update processor via script is great too, for sure. "
        },
        {
            "author": "Erik Hatcher",
            "id": "comment-13405936",
            "date": "2012-07-03T13:54:08+0000",
            "content": "Do we really need to support multiple scripts inside a definition of a (Stateless)ScriptUpdateProcessorFactory?   It just seems added looping when why not just define two different StatelessScriptUpdateProcessorFactory's each with an individual script?   (or, combine the logic of the scripts into a single script if these were my scripts) "
        },
        {
            "author": "Lance Norskog",
            "id": "comment-13405962",
            "date": "2012-07-03T18:22:49+0000",
            "content": "What if I have a main file and a library file? How would that work? "
        },
        {
            "author": "David Smiley",
            "id": "comment-13405974",
            "date": "2012-07-03T18:31:35+0000",
            "content": "+1 to Erik's proposal of streamlining the common case of needing just processAdd() \u2013 I shouldn't be required to even define a processAdd() method in my script for this common case.  I'd rather not have subclasses for this.  Perhaps the configuration in solrconfig for this processor would have a processAddScript=\"myscript.rb\" and a processDeleteScript= ... etc.  as an alternative to script=\"script.rb\" \u2013 if you use the one-file script then you are required to define each method.  And, how about if scriptMethods=\"processAdd,processCommit\" then you just need to define the ones you list.\n\nLike Erik, I too have been following the awesome progress here as of late \u2013 thanks for your hard work Hoss (and Erik before him).  It has come far. "
        },
        {
            "author": "Hoss Man",
            "id": "comment-13406247",
            "date": "2012-07-04T02:32:35+0000",
            "content": "I think this just demands that we implement an add-only type of capability such that the entire script is implicitly inside a processAdd call.\n...\nPerhaps the configuration in solrconfig for this processor would have a processAddScript=\"myscript.rb\" and a processDeleteScript= ... etc. as an alternative to script=\"script.rb\"\n\nThat's all fine and good and i have no objection to any of it \u2013 but as i tried to explain before those aternative ideas still have a raft of questions related to what the lifecyle of the scripts should be, what the bindings should be for the relevant objects (SolrQueryRequest, AddDocCmd, etc...) and how they should be evaluated (CompiledScript vs script that is evaled on every processAdd, etc...).  \n\nHence my point that i think we should commit this as \"StatelessScriptUpdateProcessorFactory\", where the cript processing mirrors the lifecylce of a native java \"UpdateProcessor\" and iterate with other approaches, using other factories, in other jira issues \u2013 if we can refactor common stuff out then great, but we shouldn't try to over think generalizing the internals of this implementation in anticipation of a hypothetical future class that will likely be just as easy to write independently.\n\nDo we really need to support multiple scripts inside a definition of a (Stateless)ScriptUpdateProcessorFactory? It just seems added looping when why not just define two different StatelessScriptUpdateProcessorFactory's each with an individual script? (or, combine the logic of the scripts into a single script if these were my scripts)\n\ngood question.  That looping code was already there when i started looking at the patch \u2013 i left it in mainly because:\n\n\n\tit was already written and didn't overly complicate things\n\tit seemed like it would probably be easier/simpler for a lot of users to just add a <str name=\"script\">foo.js</str> when they wanted to add a script then to add an entire new <processor>...</processor>\n\twe use a single ScriptEngineManager per request, per UpdatePocessor instance.  In theory it will be more efficient for some languages the to generate ScriptEngines for each script from the same ScriptEngineManager then from distinct ScriptEngineManagers (ie: imagine if your scripting langauge was Java: configuring two scripts in a single <processor> means you spin up one JVM per request; if you put each script in it's own <processor> you spin up 2 JVMs per request)\n\taccording to the javax.script javadocs, because we use a single ScriptEngineManager per request then in theory any variable in \"global\" scope will be common across all the script files (for that request).  (In my JVM, this doesn't work for multiple javascript scripts that try to refer to the same global vars, no idea if other javac.script implementations support it)\n\n\n\nWhat if I have a main file and a library file? How would that work?\n\nNo freaking clue. .. \n\n\n\tThe javax.script APIs provide no mechanism for Java code to specify that modules should be loaded before evaluating a script, or any way to configure where the engine should look for modules if a script attempts to load them using it's own native syntax\n\tjavascript doesn't even have a language mechanism (that i know of) for a script file to specify that it wants to \"import\" another file/script so i don't even know of a decent way to test what happens if you try in a lanaguge that does ... (ie: will it try to use the ScriptEngineManager's classloader? will it try to read from the system default path for that language's libs?)\n\n\n\n\n "
        },
        {
            "author": "Hoss Man",
            "id": "comment-13412413",
            "date": "2012-07-12T00:30:08+0000",
            "content": "patch updated to trunk.\n\ni plan to cmmit & backport to 4x in the next 24 hours.\n\ni'll also create some other (related) jiras for tracking ideas discussed here that didn't make it into this \"StatelessScriptUpdateProcessorFactory\" but i don't promise i'll catch them all \u2013 folks should feel free to open & links issues on their own with the things they ar most concerned about. "
        },
        {
            "author": "Erik Hatcher",
            "id": "comment-13413081",
            "date": "2012-07-12T19:03:22+0000",
            "content": "i plan to cmmit & backport to 4x in the next 24 hours.\n\nHoss - you go!  Thank you for wrangling this one and polishing out the pedantic details needed to get it to this state.  Way +1.  "
        },
        {
            "author": "Hoss Man",
            "id": "comment-13413233",
            "date": "2012-07-12T21:17:15+0000",
            "content": "Committed revision 1360931. trunk\nCommitted revision 1360952. 4x "
        },
        {
            "author": "Mikhail Khludnev",
            "id": "comment-13413958",
            "date": "2012-07-13T19:00:07+0000",
            "content": "Hoss,\n\nCongrats! Btw, have you seen one more cool update processor factory SOLR-3585 ? "
        },
        {
            "author": "Erik Hatcher",
            "id": "comment-13424263",
            "date": "2012-07-28T03:41:59+0000",
            "content": "Committed an example script/configuration to trunk (r1366588) and 4_x (r1366589). "
        },
        {
            "author": "Steve Rowe",
            "id": "comment-13427840",
            "date": "2012-08-03T05:08:35+0000",
            "content": "The tests committed here 3 weeks ago have never succeeded under the Jenkins trunk and branch_4x maven builds.  (For some reason failure notification emails aren't making it to the dev list.)  E.g. https://builds.apache.org/job/Lucene-Solr-Maven-trunk/554/.  Javascript engine appears to not be found.  I don't understand why this would be the case, though, since the Ant tests succeed running under the same JVM. "
        },
        {
            "author": "Erik Hatcher",
            "id": "comment-13428018",
            "date": "2012-08-03T12:13:00+0000",
            "content": "The tests committed here 3 weeks ago have never succeeded under the Jenkins trunk and branch_4x maven builds.\n\nOdd.  Maybe something mentioned here http://stackoverflow.com/questions/6558055/is-osgi-fundamentally-incompatible-with-jsr-223-scripting-language-discovery is relevant?  I haven't found anything else seemingly relevant yet on this issue. "
        },
        {
            "author": "Steve Rowe",
            "id": "comment-13428675",
            "date": "2012-08-04T20:50:31+0000",
            "content": "Maybe something mentioned here http://stackoverflow.com/questions/6558055/is-osgi-fundamentally-incompatible-with-jsr-223-scripting-language-discovery is relevant?\n\nThanks for looking Erik, but I'm not sure if it's relevant.\n\nI get an NPE on lucene.zones.apache.org using this program with the OpenJDK VM at /usr/local/openjdk6/ (the default javac/java on that box).  Jenkins Java 6 jobs running Ant use this same VM (via /home/hudson/tools/java/latest1.6 -> openjdk6 -> /usr/local/openjdk6.\n\nI don't get it.  How do these tests pass under Ant?  I can't see any obviously named jars under solr/lib/ that would provide the javascript engine...\n "
        },
        {
            "author": "Erik Hatcher",
            "id": "comment-13429166",
            "date": "2012-08-06T14:42:30+0000",
            "content": "How do these tests pass under Ant?\n\nMaybe this is due to some libraries Ant itself is including in the classpath of the tests running?\n\nI'll go ahead and re-open this issue so it is red-flagged as something we should resolve before 4.0 final release.\n\nPerhaps we can include a scripting implementation in Solr, at least for testing purposes but maybe also to ship with to ensure this works out of the box on all JVMs.  jruby.jar would be nice to have handy always  "
        },
        {
            "author": "Erik Hatcher",
            "id": "comment-13429168",
            "date": "2012-08-06T14:43:43+0000",
            "content": "re-opening to have to have the tests (specifically the failing Maven run) looked at. "
        },
        {
            "author": "Erik Hatcher",
            "id": "comment-13429169",
            "date": "2012-08-06T14:44:33+0000",
            "content": "marking the re-opening as \"critical\" to fix, hopefully at least before 4.0 final. "
        },
        {
            "author": "Uwe Schindler",
            "id": "comment-13429176",
            "date": "2012-08-06T14:57:46+0000",
            "content": "Hi, this is not a problem at all. OpenJDK on FreeBSD contains no scripting engine. So it was added in ants lib path. This is why it works on ant in FreeBSD Jenkins. Rhino is the javascript engine, missing in openjdks for legal reasons. Rhino is shipped with official jdks and is mandatory, so thats a stupid freebsd issue. Steven should add it to maven builds, too.\n\nYou can resolve issue. "
        },
        {
            "author": "Steve Rowe",
            "id": "comment-13429178",
            "date": "2012-08-06T15:01:48+0000",
            "content": "Thanks Uwe, I'll add rhino to maven builds. "
        },
        {
            "author": "Steve Rowe",
            "id": "comment-13429214",
            "date": "2012-08-06T16:02:01+0000",
            "content": "OpenJDK on FreeBSD contains no scripting engine. So it was added in ants lib path.\n\nHow?  I've found the necessary jars, at /usr/home/hudson/tools/java/openjdk-missing-libs/, but I can't see how Ant's lib path includes them.  I looked at ~hudson/.profile, and lib/ and bin/ant under /usr/home/hudson/tools/ant/apache-ant-1.8.2 - none of these refer to the directory containing js.jar and script-js.jar.\n\nI'm asking because I'd like to set Maven up similarly to Ant. "
        },
        {
            "author": "Robert Muir",
            "id": "comment-13429218",
            "date": "2012-08-06T16:07:01+0000",
            "content": "I think they are added to ~hudson/.ant/lib ? "
        },
        {
            "author": "Robert Muir",
            "id": "comment-13429219",
            "date": "2012-08-06T16:07:49+0000",
            "content": "\n[rcmuir@lucene /home/hudson/.ant/lib]$ ls -la\ntotal 1843\ndrwxr-xr-x  2 hudson  hudson       5 Mar 30 15:46 .\ndrwxr-xr-x  3 hudson  hudson       8 May 13 12:41 ..\n-rw-r--r--  1 hudson  hudson  947592 Mar 30 15:45 ivy-2.2.0.jar\n-rw-r--r--  1 hudson  hudson  701049 Jul 27  2006 js.jar\n-rw-r--r--  1 hudson  hudson   34607 Oct 16  2006 script-js.jar\n\n "
        },
        {
            "author": "Steve Rowe",
            "id": "comment-13429222",
            "date": "2012-08-06T16:09:53+0000",
            "content": "Thanks Robert, I see them now. "
        },
        {
            "author": "Hoss Man",
            "id": "comment-13429240",
            "date": "2012-08-06T16:34:04+0000",
            "content": "I (think i) fixed the assumptions in these tests to actually skip properly if the engines aren't available...\n\nCommitted revision 1369874. - trunk\nCommitted revision 1369875. - 4x "
        },
        {
            "author": "Steve Rowe",
            "id": "comment-13429387",
            "date": "2012-08-06T20:11:22+0000",
            "content": "After Hoss's commits, both ASF Jenkins Maven jobs have run, and under both jobs, tests that previously were failing under Maven due to the lack of a javascript engine in the classpath are now being skipped.\n\nAfter those jobs started, I committed a change to dev/nightly/common-maven.sh that includes the two rhino jars in the Maven JVM boot class path: r1369936.\n\nI've enqueued the Maven jobs again on ASF Jenkins. "
        },
        {
            "author": "Uwe Schindler",
            "id": "comment-13429458",
            "date": "2012-08-06T21:33:41+0000",
            "content": "I think, this is all fine:\n\n\tJava 6 spec requires a JavaScript engine to be shipped with JDK, it is just missing at FreeBSD's package (there is an issue open upstream). If JavaScript is not there for Java 6 it is like missing UTF8 charset \n\tI strongly -1 shipping with additional scripting engines. No need for that. If user Foo wants to script Solr with engine Bar, he can add the SPI Jar to classpath. No need to ship. This is why SPI was invented!\n\n\n\nWe should maybe only fix Solr's classloader to be set as context classloader, too. SPIs cannot be loaded from $SOLR_HOME/lib, because context classloader does not see the jars. We fixed that for codecs and analyzer SPI JARs in Solr, but the most correct solution would be to enable Solr's threads to see the ResourceLoader as context classloader. Then you can add scripting engines, XML parsers, charset providers, locales,... just like plugins or codecs or analyzerfactories into the Solr home's lib folder without adding to WAR. "
        },
        {
            "author": "Hoss Man",
            "id": "comment-13429468",
            "date": "2012-08-06T21:52:15+0000",
            "content": "Java 6 spec requires a JavaScript engine to be shipped with JDK\n\ni didn't know that ... i couldn't find anything in the docs that suggested certain engines were mandatory, hence the assuptions i nthe test (the maven tests just indicated that those assumptions ere broken)\n\nI strongly -1 shipping with additional scripting engines\ni didn't see anyone suggesting that ... no argument there.\n\nWe should maybe only fix Solr's classloader to be set as context classloader, too.\n\nthat sounds like an ortoginal issue ... great idea, didn't know it was possible, please go ahead and do it, but let's track it in it's own issue "
        },
        {
            "author": "Hoss Man",
            "id": "comment-13429472",
            "date": "2012-08-06T21:54:24+0000",
            "content": "\nI strongly -1 shipping with additional scripting engines\n\ni didn't see anyone suggesting that ... no argument there.\n\nsorry .. i overlooked that part of erik's comment .. i'm with Uwe: let's let users add their own script engines as plugins "
        },
        {
            "author": "Uwe Schindler",
            "id": "comment-13429487",
            "date": "2012-08-06T22:10:41+0000",
            "content": "Hoss, you are right, it is not required that JS is available, the Java 6 specs says http://download.oracle.com/otndocs/jcp/j2se-1.6.0-pr-spec-oth-JSpec/:\n\n\nJSR 223: Scripting for the Java Platform  \nA large percentage of Java developers also use scripting languages. While the Java language is suitable for many tasks, and especially for writing robust, long-lived applications, scripting languages are useful for many other tasks.\n\nJSR 223 de\ufb01nes a framework for connecting interpreters of arbitrary scripting languages to Java programs. It includes facilities for locating the available scripting engines, invoking scripts from Java code and vice versa, and making Java application objects visible to scripts. The framework is divided into two parts, the Scripting API and an optional Web Scripting Framework. This feature will incorporate just the Scripting API into this version of the Java SE platform.\n\nThere will be no requirement that any particular scripting language be supported by the platform; implementors may choose to include support for the scripting language(s) of their choice as they see \ufb01t.\n\n[ JSR 223; javax.script ]\n\nBut all JDKs on all platforms except FreeBSD contain them. So we should have the \"error messages\" printed on failure to lookup engine and the assumption in test as you committed.\n\nBut as Hoss says, too: No need to ship engines. Its just bloat because there are millions of them  "
        },
        {
            "author": "Uwe Schindler",
            "id": "comment-13429528",
            "date": "2012-08-06T22:35:27+0000",
            "content": "I opened SOLR-3716. "
        },
        {
            "author": "Steve Rowe",
            "id": "comment-13429585",
            "date": "2012-08-06T23:43:52+0000",
            "content": "On IRC, Uwe suggested adding the Rhino jars to $JAVA_HOME/jre/lib/ext/ on the FreeBSD ASF Jenkins lucene slave (lucene.zones.apache.org) to allow both Ant and Maven build jobs to enable scripting tests.  I copied js.jar and script-js.jar from /usr/home/hudson/tools/java/openjdk-missing-libs/ to /usr/local/openjdk{6,7}/jre/lib/ext/, and the ScriptEngineTest tests under the Maven branch_4x job have succeeded, except for testJRuby(), which was skipped (as expected).\n\nI also removed js.jar and script-js.jar from ~hudson/.ant/lib/. "
        },
        {
            "author": "Robert Muir",
            "id": "comment-13429792",
            "date": "2012-08-07T03:43:05+0000",
            "content": "rmuir20120906-bulk-40-change "
        },
        {
            "author": "Hoss Man",
            "id": "comment-13435607",
            "date": "2012-08-15T23:16:44+0000",
            "content": "This feature (and the fixes to the tests that caused it to be re-opened) made it into 4.0-beta "
        }
    ]
}