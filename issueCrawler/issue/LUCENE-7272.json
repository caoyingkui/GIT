{
    "id": "LUCENE-7272",
    "title": "See if there's a way to cheapen geo3d's relationship calculations to make BKD Trees faster",
    "details": {
        "resolution": "Won't Fix",
        "affect_versions": "6.0",
        "components": [
            "modules/spatial3d"
        ],
        "labels": "",
        "fix_versions": [],
        "priority": "Major",
        "status": "Resolved",
        "type": "Improvement"
    },
    "description": "BKD Tree code does not make use of most of the fine relationship detail returned by getRelationship().  This means a lot of computation is going into figuring out fine details that gets simply wasted.  We should consider having a much simpler related relationship method that returns only what BKD trees need to proceed.\n\nHere's the current code:\n\n\n    // First, check bounds.  If the shape is entirely contained, return CELL_CROSSES_QUERY.\n    if (shapeBounds.getMinimumX() >= xMin && shapeBounds.getMaximumX() <= xMax &&\n      shapeBounds.getMinimumY() >= yMin && shapeBounds.getMaximumY() <= yMax &&\n      shapeBounds.getMinimumZ() >= zMin && shapeBounds.getMaximumZ() <= zMax) {\n      return Relation.CELL_CROSSES_QUERY;\n    }\n\n    // Quick test failed so do slower one...\n    GeoArea xyzSolid = GeoAreaFactory.makeGeoArea(PlanetModel.WGS84, xMin, xMax, yMin, yMax, zMin, zMax);\n\n    switch(xyzSolid.getRelationship(shape)) {\n    case GeoArea.CONTAINS:\n      // Shape fully contains the cell\n      //System.out.println(\"    inside\");\n      return Relation.CELL_INSIDE_QUERY;\n    case GeoArea.OVERLAPS:\n      // They do overlap but neither contains the other:\n      //System.out.println(\"    crosses1\");\n      return Relation.CELL_CROSSES_QUERY;\n    case GeoArea.WITHIN:\n      // Cell fully contains the shape:\n      //System.out.println(\"    crosses2\");\n      // return Relation.SHAPE_INSIDE_CELL;\n      return Relation.CELL_CROSSES_QUERY;\n    case GeoArea.DISJOINT:\n      // They do not overlap at all\n      //System.out.println(\"    outside\");\n      return Relation.CELL_OUTSIDE_QUERY;\n    default:\n      assert false;\n      return Relation.CELL_CROSSES_QUERY;\n    }\n\n\n\nIt looks like only CELL_CROSSES_QUERY, CELL_OUTSIDE_QUERY, and CELL_INSIDE_QUERY are ever returned.  This means we could (if computationally helpful) have a getRelationship() variant that only distinguishes between:\n\nGeoArea.DISJOINT\nGeoArea.CONTAINS\nGeoArea.OVERLAPS\n\n... with no GeoArea.WITHIN detection.  The question is, would this save significant computation?",
    "attachments": {},
    "issue_links": {},
    "comments": [
        {
            "id": "comment-15270566",
            "author": "Karl Wright",
            "date": "2016-05-04T12:48:51+0000",
            "content": "The code for computing the relationship is as follows:\n\n\n  public int getRelationship(final GeoShape path) {\n    if (isWholeWorld) {\n      if (path.getEdgePoints().length > 0)\n        return WITHIN;\n      return OVERLAPS;\n    }\n    \n    /*\n    for (GeoPoint p : getEdgePoints()) {\n      System.err.println(\" Edge point \"+p+\" path.isWithin()? \"+path.isWithin(p));\n    }\n    \n    for (GeoPoint p : path.getEdgePoints()) {\n      System.err.println(\" path edge point \"+p+\" isWithin()? \"+isWithin(p)+\" minx=\"+minXPlane.evaluate(p)+\" maxx=\"+maxXPlane.evaluate(p)+\" miny=\"+minYPlane.evaluate(p)+\" maxy=\"+maxYPlane.evaluate(p)+\" minz=\"+minZPlane.evaluate(p)+\" maxz=\"+maxZPlane.evaluate(p));\n    }\n    */\n    \n    //System.err.println(this+\" getrelationship with \"+path);\n    final int insideRectangle = isShapeInsideArea(path);\n    if (insideRectangle == SOME_INSIDE) {\n      //System.err.println(\" some shape points inside area\");\n      return OVERLAPS;\n    }\n\n    // Figure out if the entire XYZArea is contained by the shape.\n    final int insideShape = isAreaInsideShape(path);\n    if (insideShape == SOME_INSIDE) {\n      //System.err.println(\" some area points inside shape\");\n      return OVERLAPS;\n    }\n\n    if (insideRectangle == ALL_INSIDE && insideShape == ALL_INSIDE) {\n      //System.err.println(\" inside of each other\");\n      return OVERLAPS;\n    }\n\n    if ((minXPlaneIntersects && path.intersects(minXPlane, notableMinXPoints, maxXPlane, minYPlane, maxYPlane, minZPlane, maxZPlane)) ||\n        (maxXPlaneIntersects && path.intersects(maxXPlane, notableMaxXPoints, minXPlane, minYPlane, maxYPlane, minZPlane, maxZPlane)) ||\n        (minYPlaneIntersects && path.intersects(minYPlane, notableMinYPoints, maxYPlane, minXPlane, maxXPlane, minZPlane, maxZPlane)) ||\n        (maxYPlaneIntersects && path.intersects(maxYPlane, notableMaxYPoints, minYPlane, minXPlane, maxXPlane, minZPlane, maxZPlane)) ||\n        (minZPlaneIntersects && path.intersects(minZPlane, notableMinZPoints, maxZPlane, minXPlane, maxXPlane, minYPlane, maxYPlane)) ||\n        (maxZPlaneIntersects && path.intersects(maxZPlane, notableMaxZPoints, minZPlane, minXPlane, maxXPlane, minYPlane, maxYPlane))) {\n      //System.err.println(\" edges intersect\");\n      return OVERLAPS;\n    }\n\n    if (insideRectangle == ALL_INSIDE) {\n      //System.err.println(\" all shape points inside area\");\n      return WITHIN;\n    }\n\n    if (insideShape == ALL_INSIDE) {\n      //System.err.println(\" all area points inside shape\");\n      return CONTAINS;\n    }\n    //System.err.println(\" disjoint\");\n    return DISJOINT;\n  }\n\n\n\nNote that it cannot decide between DISJOINT and CONTAINS until the very end, after it has done the expensive step of looking for intersections between the six planes and the shape.  So unfortunately it doesn't look like any shortcut is possible here. "
        }
    ]
}