{
    "id": "LUCENE-7970",
    "title": "Add a Geo3d shape that models an exact circle, even when the planet model is not a sphere",
    "details": {
        "labels": "",
        "priority": "Major",
        "resolution": "Fixed",
        "affect_versions": "None",
        "status": "Closed",
        "type": "Improvement",
        "components": [
            "modules/spatial3d"
        ],
        "fix_versions": [
            "6.7",
            "7.1",
            "master (8.0)"
        ]
    },
    "description": "Hi [~Karl wright],\n\nHow circles are currently build do not behave very well when the planet model is not an sphere. when you are close to the border in WGS84 you might get false positves or false negatives when checking if a point is WITHIN. I think the reason is how the points to generate the circle plane are generated which assumes a sphere.\n\nMy proposal is the following:\n\nAdd a new method to PlanetModel:  \n\npublic GeoPoint pointOnBearing(GeoPoint from, double dist, double bearing);\n\nWhich uses and algorithm that takes into account that the planet might not be spherical. For example Vincenty's formulae (https://en.wikipedia.org/wiki/Vincenty%27s_formulae).\n\nUse this method to generate the points for the circle plane. My experiments shows that this approach removes false negatives in WGS84 meanwhile it works nicely in the Sphere.\n\nDoes it make sense?",
    "attachments": {
        "LUCENE-7970.patch": "https://issues.apache.org/jira/secure/attachment/12887088/LUCENE-7970.patch",
        "LUCENE-7970-generator.patch": "https://issues.apache.org/jira/secure/attachment/12889225/LUCENE-7970-generator.patch",
        "LUCENE-7970-exact.diff": "https://issues.apache.org/jira/secure/attachment/12888745/LUCENE-7970-exact.diff",
        "LUCENE-7970-proposed.patch": "https://issues.apache.org/jira/secure/attachment/12887093/LUCENE-7970-proposed.patch",
        "circle.jpg": "https://issues.apache.org/jira/secure/attachment/12888780/circle.jpg",
        "LUCENE_7970.patch": "https://issues.apache.org/jira/secure/attachment/12888232/LUCENE_7970.patch",
        "LUCENE-7970_testBearingPoint.patch": "https://issues.apache.org/jira/secure/attachment/12888501/LUCENE-7970_testBearingPoint.patch"
    },
    "issue_links": {},
    "comments": [
        {
            "id": "comment-16166061",
            "date": "2017-09-14T10:48:24+0000",
            "content": "Ignacio Vera: isWithin() for any plane on a non-spherical ellipsoid will generate \"true\" for an area that is an ellipse.  See:\n\nhttps://file.scirp.org/pdf/AM20121100009_89014420.pdf\n\nThis is almost certainly the cause for the claim that points around the edge of a GeoCircle are incorrectly described as in-set or out-of-set, when you apply the Vincenti formula to perform the surface distance computation.\n\nSince there are no \"generated\" points for a geo circle except maybe in the testing framework, I can't see how adding a point generation method helps this in any way.  Please clarify.\n ",
            "author": "Karl Wright"
        },
        {
            "id": "comment-16166119",
            "date": "2017-09-14T11:44:22+0000",
            "content": "Hi Karl Wright,\n\nI attached a test with my expections. The test perform the following operations:\n\n1) Generates a circle\n2) Generate a point\n3) calculates the surface distance between the center of the circle and the point\n4) if distance is bigger than radius the it is out-of-set else in-set.\n\nThis works for the Sphere but you get errors when doing it in WGS84. \n\nMy naive idea is that considering circle.center.latitud + radius and circle.center.latitud - radius as the upper and lower latitud for a circle is only correct for the SPHERE but it needs to be properly calculated for other planets, for example using Vincenti formula.\n\nmake sense? or there is a falw in my reasoning? \n\n\n\n ",
            "author": "Ignacio Vera"
        },
        {
            "id": "comment-16166133",
            "date": "2017-09-14T11:58:28+0000",
            "content": "Ignacio Vera, I'm sorry, but I still don't see that you've proposed any solution to the underlying issue.\nMaybe you can submit a patch for isWithin() that shows what you intend. ",
            "author": "Karl Wright"
        },
        {
            "id": "comment-16166158",
            "date": "2017-09-14T12:19:08+0000",
            "content": "Attached is the changes I have done. I changed the way the circle plane points are calculated to consider the planetModel.  ",
            "author": "Ignacio Vera"
        },
        {
            "id": "comment-16166303",
            "date": "2017-09-14T13:29:49+0000",
            "content": "Ignacio Vera, now I understand what you are trying to do.\n\nThere are several areas of concern:\n(1) For extremely small circles, e.g. those with radii Vector.MINIMUM_ANGULAR_RESOLUTION, does this reliably work?\n(2) For PlanetModel.SPHERE, can we \"shortcut\" to a faster implementation?  Or is the vincenti formula guaranteed to converge in one iteration in that case?  I do not want to make it exorbitantly expensive to construct circles in PlanetModel.SPHERE.\n(3) Paths also use circles.  The way those circles are constructed depends on whether the circles are intersection points, endpoints, or single circles. \n The latter I think should behave exactly like GeoCircles, however that works out.  It may be valuable, therefore, to provide a Plane static builder method that can be used for both GeoStandardCircle and GeoStandardPath.\n ",
            "author": "Karl Wright"
        },
        {
            "id": "comment-16167817",
            "date": "2017-09-15T12:50:14+0000",
            "content": "Ignacio Vera, I will have to put this on hold for about a week.  If you want to submit a complete patch that addresses the areas of concern described above, I might be able to look at it a little this weekend, but I'm pretty overcommitted even then. ",
            "author": "Karl Wright"
        },
        {
            "id": "comment-16167836",
            "date": "2017-09-15T13:04:07+0000",
            "content": "[~karl wright], that is ok. It seems a very hard problem and I only got partial results which are not so happy with. I will give myself a week and see how far I can get. I am very busy as well later so let see if we can improve cirlces in non-spherical planets. ",
            "author": "Ignacio Vera"
        },
        {
            "id": "comment-16174442",
            "date": "2017-09-21T08:38:37+0000",
            "content": "Hi [~karl wright],\n\nNot sure if we have something to do here as I think current implementation might be the best one to approximate the circle using one plane intersecting the spheroid. I don't think I can assure that any other implementation would be more precise.\n\nAnyway, I was thinking what is needed to support circles in a spheroid and of course it needs a totally different approach and eventually in some cases you need to use brute force. I want to share what I think it would be a viable solution if Geo3d ever needs to add precision to circles in spheriods like WGS84:\n\nThe new shape should have two planes:\n\n     innerEllipse: plane cutting the spheriod  producing the maximum ellipse within the circle. Anything within this plane is within the circle.\n     outerEllipse: plane cutting the spheriod  producing the minimum ellipse contaning the circle. Anything not within this plane is not within the circle.\n\nThere is only one gray area between the two planes (within outerEllipse, not within innerEllipse) where brute force will be needed. \n\nI attach my implementation for such a shape. It seems to work for WGS84, except for verly large and very small angles. I was unable to find the mathematical model to generate those planes (is that possible to solve mathematically?). \n\nThanks! ",
            "author": "Ignacio Vera"
        },
        {
            "id": "comment-16174675",
            "date": "2017-09-21T12:43:11+0000",
            "content": "Ignacio Vera I think this is a good addition to the stable of circle implementations, and I like how you solve the problem in a way that's as cheap as possible.\n\nI have a few things that we should discuss:\n\n(1) For the initial computation of the inner and outer planes, I would like more comments that explain exactly what the math is behind the construction of these planes.  It's currently unclear where that came from and I think we really need to know it.\n\n(2) The getBounds() method shouldn't bother being exact; it should just use the outer plane (if present), or the inner plane (if not present) to set the bounds.  Bounds are defined as possibly being larger than the shape they contain, so that is OK.  Also, we need to be sure xyz bounds work OK as well; just doing points doesn't work for XYZ bounds \u2013 you need the planes too.  Maybe you can just use both planes; that would be safest.\n\n(3) We shouldn't make the class public; it should be class scoped.  Instead, add a factory method to GeoCircleFactory.\n\nThanks!! ",
            "author": "Karl Wright"
        },
        {
            "id": "comment-16174740",
            "date": "2017-09-21T13:22:07+0000",
            "content": "(1) I was having problems with the maths so before going foward  in trying to solve/formalize it I wanted to see if the approach I was taken would be considered. First thing we need to do then, it is to formalize the way to compute the planes. I know there is something missing; there is a maximum cutoff angle which depends on the spheriod(ab,c) where the outerEllipse does not make sense and should be the whole planet. The same with the innerEllipse.  \n\n(2) Ok, I think we can use only the outer plane as it is bigger than the shape. If null then bounds should be the whole world.Using the inner plane can give bounds smaller than the shape and we might want to avoid that.\n\n(3) upps, my mistake ... shapes should not be public. \n\nI will try then to find the way to compute the planes that provides the desired inner and outer plane in a formal way. \n\nThanks!\n ",
            "author": "Ignacio Vera"
        },
        {
            "id": "comment-16175726",
            "date": "2017-09-22T00:30:26+0000",
            "content": "Ignacio Vera, with luck I'll be able to do more on this tomorrow, since things are slowing down now at work somewhat.\n\nMy thought is that it should be possible to pick the outer and inner planes based on (a) whether planetModel.c > planetModel.ab, and (b) a precise computation of the top and bottom latitude points of the circle.  I'll think about this further tomorrow morning and let's see what you come up with too. ",
            "author": "Karl Wright"
        },
        {
            "id": "comment-16175752",
            "date": "2017-09-22T00:43:59+0000",
            "content": "My initial observations:\n\n(1) The \"inner\" and \"outer\" planes are in fact parallel to one another \u2013 so we would want to compute first the one that goes through the upper latitude point and the lower latitude point, and then compute an \"adjusted\" parallel plane.  The problem is how to figure out the adjustment.  This is what I still need to consider.  One way to do it is to find a point-on-bearing to the left or right and pick the second plane's D coefficient based on that point.  I think this would work quite well actually.\n(2) The choice of which plane is \"inner\" and which plane is \"outer\" depends on whether c > ab, and on whether the radius of the circle is greater than 180 degrees.  Need to think this through too. ",
            "author": "Karl Wright"
        },
        {
            "id": "comment-16175907",
            "date": "2017-09-22T04:36:01+0000",
            "content": "Also, I played around with the vincenti bearing formula, as described here, and determined that it works reasonably even at the poles.  Giving four direction bearings seemingly does yield reasonable point values.\n\nhttp://www.movable-type.co.uk/scripts/latlong-vincenty.html\n\nIgnacio Vera, I committed the point-on-bearing code to PlanetModel, with some minor changes (the name, for instance, and the javadoc, since it's a public method).  I'd also want to be sure that we know in advance what the limits are \u2013 is it limited to any particular maximum surface distance, for instance?\n\nI think the next step is to rework the patch to meet the goals.  I'll start that work in a couple of hours.\n ",
            "author": "Karl Wright"
        },
        {
            "id": "comment-16175958",
            "date": "2017-09-22T06:01:13+0000",
            "content": "Commit d84beb415cebc3f144fdd068c2728d5468d8c343 in lucene-solr's branch refs/heads/master from Karl Wright\n[ https://git-wip-us.apache.org/repos/asf?p=lucene-solr.git;h=d84beb4 ]\n\nLUCENE-7970: Add surface point on bearing method to PlanetModel.  Committed on behalf of Ignacio Vera. ",
            "author": "ASF subversion and git services"
        },
        {
            "id": "comment-16175961",
            "date": "2017-09-22T06:02:52+0000",
            "content": "Commit c374aad51df56470a586a24e84ee87eb8cfa5766 in lucene-solr's branch refs/heads/branch_6x from Karl Wright\n[ https://git-wip-us.apache.org/repos/asf?p=lucene-solr.git;h=c374aad ]\n\nLUCENE-7970: Add surface point on bearing method to PlanetModel.  Committed on behalf of Ignacio Vera. ",
            "author": "ASF subversion and git services"
        },
        {
            "id": "comment-16175962",
            "date": "2017-09-22T06:03:58+0000",
            "content": "Commit 289e746793b0548c5c353dd36e6fecb57b208183 in lucene-solr's branch refs/heads/branch_7x from Karl Wright\n[ https://git-wip-us.apache.org/repos/asf?p=lucene-solr.git;h=289e746 ]\n\nLUCENE-7970: Add surface point on bearing method to PlanetModel.  Committed on behalf of Ignacio Vera. ",
            "author": "ASF subversion and git services"
        },
        {
            "id": "comment-16175991",
            "date": "2017-09-22T06:30:58+0000",
            "content": "Thanks [~karl wright],\n\nFor the documentation I took the method from, it seems that it might have problems for antipodal points. Other than that, I will devise a test to shows the limits in distance and maybe values for planet model.\n\nOne more observation: I think there would be a dependency on whether the center of the circle is in the north or south hemisphere. I am busy this morning but I hope to be able to spend some time on this later today. ",
            "author": "Ignacio Vera"
        },
        {
            "id": "comment-16176348",
            "date": "2017-09-22T12:43:02+0000",
            "content": "Ignacio Vera  Obviously for this strategy to work we need a robust way of locating the minimum and maximum points in the cardinal directions from the center of the circle.  So that point-on-bearing method must do that whatever the provided center is and whatever the distance provided is, within reasonable limits.\n\nOnce that's possible I am quite comfortable writing logic that produces the two necessary planes that have the correct relationship with each other.\n\nFor testing, one plane will be defined by the top/bottom (aka \"north\" and \"south\") points, while the other will be determined by the east/west points.  It's perfectly OK to have the \"top/bottom\" points be on opposite sides of the earth but we would require them both to be on a plane that goes through the north and south poles.  Then, \"east/west\" points would have to satisfy conditions as follows:\n\n(1) Compute the plane that is perpendicular to the first plane which contains both the top and bottom points.  There is likely a Plane constructor for this kind of case already.\n(2) The \"east/west\" points should be on a plane that goes through the center of the circle, and is perpendicular to both of the planes we've now mentioned.  We have logic that computes this plane too, I believe, that we could use for the test.\n\nIf we have the above planes and points, it's straightforward to pick the two ellipses that will define this shape.  I think that your point-on-bearing method will pick the right points if bearings are chosen in cardinal directions, but that's what we need to verify with a test.  Please also make sure to verify that that works for a sample of points that includes the north and south poles.\n\nThanks! ",
            "author": "Karl Wright"
        },
        {
            "id": "comment-16176451",
            "date": "2017-09-22T13:52:46+0000",
            "content": "Hi Karl Wright\n\nAttached is a random test to check that cardinality points are correctly computed. The check is performed by comparing the result from the methods surfaceDistance and the original distance.\n\nThere is test specific for WGS84 and one with random planet models. When planet model is generated randomly is limitied to have ab and c between 0.9 and 1.5. It seems things do start behaving less accurate the less spherical is the planet as expected.\n\nIchanged the conditions for the iterations in surfacePointOnBearing to match the ones in surfaceDistance.\n\n\n ",
            "author": "Ignacio Vera"
        },
        {
            "id": "comment-16176499",
            "date": "2017-09-22T14:39:10+0000",
            "content": "Commit 1a698c4e4acb16192800e39571907ead564bb842 in lucene-solr's branch refs/heads/master from Karl Wright\n[ https://git-wip-us.apache.org/repos/asf?p=lucene-solr.git;h=1a698c4 ]\n\nLUCENE-7970: Add bearing point test.  Committed on behalf of Ignacio Vera. ",
            "author": "ASF subversion and git services"
        },
        {
            "id": "comment-16176503",
            "date": "2017-09-22T14:40:30+0000",
            "content": "Commit e9799644271ad3b31096d2d4789aa09f521194e6 in lucene-solr's branch refs/heads/branch_6x from Karl Wright\n[ https://git-wip-us.apache.org/repos/asf?p=lucene-solr.git;h=e979964 ]\n\nLUCENE-7970: Add bearing point test.  Committed on behalf of Ignacio Vera. ",
            "author": "ASF subversion and git services"
        },
        {
            "id": "comment-16176505",
            "date": "2017-09-22T14:41:23+0000",
            "content": "Commit 6facb1a2e794f535533295be77d01a761be7116b in lucene-solr's branch refs/heads/branch_7x from Karl Wright\n[ https://git-wip-us.apache.org/repos/asf?p=lucene-solr.git;h=6facb1a ]\n\nLUCENE-7970: Add bearing point test.  Committed on behalf of Ignacio Vera. ",
            "author": "ASF subversion and git services"
        },
        {
            "id": "comment-16176509",
            "date": "2017-09-22T14:43:12+0000",
            "content": "This test is helpful, but it's not enough, because we cannot tell whether the bearing direction does what we want.  I've committed it nonetheless.\n\nI'll look into this further later. ",
            "author": "Karl Wright"
        },
        {
            "id": "comment-16177050",
            "date": "2017-09-22T20:15:42+0000",
            "content": "Well, the test fails under some conditions, e.g.:\n\n\nFAILED:  org.apache.lucene.spatial3d.geom.GeoCircleTest.RandomPointBearingCardinalTest {seed=[E9FDB0C7D468FDF8:EAFA8E50F86DF78D]}\n\nError Message:\nPlanetModel(ab=0.9012401636526054 c=1.3895444300878061) 8.233858039830011E-12 2.8044786894992013\n\nStack Trace:\njava.lang.AssertionError: PlanetModel(ab=0.9012401636526054 c=1.3895444300878061) 8.233858039830011E-12 2.8044786894992013\n        at __randomizedtesting.SeedInfo.seed([E9FDB0C7D468FDF8:EAFA8E50F86DF78D]:0)\n        at org.junit.Assert.fail(Assert.java:93)\n        at org.junit.Assert.assertTrue(Assert.java:43)\n        at org.apache.lucene.spatial3d.geom.GeoCircleTest.checkBearingPoint(GeoCircleTest.java:454)\n        at org.apache.lucene.spatial3d.geom.GeoCircleTest.RandomPointBearingCardinalTest(GeoCircleTest.java:446)\n        at sun.reflect.GeneratedMethodAccessor6.invoke(Unknown Source)\n        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n        at java.lang.reflect.Method.invoke(Method.java:498)\n        at com.carrotsearch.randomizedtesting.RandomizedRunner.invoke(RandomizedRunner.java:1737)\n        at com.carrotsearch.randomizedtesting.RandomizedRunner$8.evaluate(RandomizedRunner.java:934)\n        at com.carrotsearch.randomizedtesting.RandomizedRunner$9.evaluate(RandomizedRunner.java:970)\n        at com.carrotsearch.randomizedtesting.RandomizedRunner$10.evaluate(RandomizedRunner.java:984)\n        at org.apache.lucene.util.TestRuleSetupTeardownChained$1.evaluate(TestRuleSetupTeardownChained.java:49)\n        at org.apache.lucene.util.AbstractBeforeAfterRule$1.evaluate(AbstractBeforeAfterRule.java:45)\n        at org.apache.lucene.util.TestRuleThreadAndTestName$1.evaluate(TestRuleThreadAndTestName.java:48)\n        at org.apache.lucene.util.TestRuleIgnoreAfterMaxFailures$1.evaluate(TestRuleIgnoreAfterMaxFailures.java:64)\n        at org.apache.lucene.util.TestRuleMarkFailure$1.evaluate(TestRuleMarkFailure.java:47)\n        at com.carrotsearch.randomizedtesting.rules.StatementAdapter.evaluate(StatementAdapter.java:36)\n        at com.carrotsearch.randomizedtesting.ThreadLeakControl$StatementRunner.run(ThreadLeakControl.java:368)\n        at com.carrotsearch.randomizedtesting.ThreadLeakControl.forkTimeoutingTask(ThreadLeakControl.java:817)\n        at com.carrotsearch.randomizedtesting.ThreadLeakControl$3.evaluate(ThreadLeakControl.java:468)\n        at com.carrotsearch.randomizedtesting.RandomizedRunner.runSingleTest(RandomizedRunner.java:943)\n        at com.carrotsearch.randomizedtesting.RandomizedRunner$5.evaluate(RandomizedRunner.java:829)\n        at com.carrotsearch.randomizedtesting.RandomizedRunner$6.evaluate(RandomizedRunner.java:879)\n        at com.carrotsearch.randomizedtesting.RandomizedRunner$7.evaluate(RandomizedRunner.java:890)\n        at org.apache.lucene.util.AbstractBeforeAfterRule$1.evaluate(AbstractBeforeAfterRule.java:45)\n        at com.carrotsearch.randomizedtesting.rules.StatementAdapter.evaluate(StatementAdapter.java:36)\n        at org.apache.lucene.util.TestRuleStoreClassName$1.evaluate(TestRuleStoreClassName.java:41)\n        at com.carrotsearch.randomizedtesting.rules.NoShadowingOrOverridesOnMethodsRule$1.evaluate(NoShadowingOrOverridesOnMethodsRule.java:40)\n        at com.carrotsearch.randomizedtesting.rules.NoShadowingOrOverridesOnMethodsRule$1.evaluate(NoShadowingOrOverridesOnMethodsRule.java:40)\n        at com.carrotsearch.randomizedtesting.rules.StatementAdapter.evaluate(StatementAdapter.java:36)\n        at com.carrotsearch.randomizedtesting.rules.StatementAdapter.evaluate(StatementAdapter.java:36)\n        at com.carrotsearch.randomizedtesting.rules.StatementAdapter.evaluate(StatementAdapter.java:36)\n        at org.apache.lucene.util.TestRuleAssertionsRequired$1.evaluate(TestRuleAssertionsRequired.java:53)\n        at org.apache.lucene.util.TestRuleMarkFailure$1.evaluate(TestRuleMarkFailure.java:47)\n        at org.apache.lucene.util.TestRuleIgnoreAfterMaxFailures$1.evaluate(TestRuleIgnoreAfterMaxFailures.java:64)\n        at org.apache.lucene.util.TestRuleIgnoreTestSuites$1.evaluate(TestRuleIgnoreTestSuites.java:54)\n        at com.carrotsearch.randomizedtesting.rules.StatementAdapter.evaluate(StatementAdapter.java:36)\n        at com.carrotsearch.randomizedtesting.ThreadLeakControl$StatementRunner.run(ThreadLeakControl.java:368)\n        at java.lang.Thread.run(Thread.java:748)\n\n ",
            "author": "Karl Wright"
        },
        {
            "id": "comment-16177317",
            "date": "2017-09-22T23:19:00+0000",
            "content": "The test also isn't actually random.  It uses the same values on each run, but repeats itself 10000 times anyway.  Try it.\n\n\nant -Dtestcase=GeoCircleTest -Dtestmethod=RandomPointBearingCardinalTest -Dtests.seed=E9FDB0C7D468FDF8:EAFA8E50F86DF78D test\n\n ",
            "author": "Karl Wright"
        },
        {
            "id": "comment-16177323",
            "date": "2017-09-22T23:29:23+0000",
            "content": "Commit 39100a8d4c33de406ff3295e5abde0124544477b in lucene-solr's branch refs/heads/master from Karl Wright\n[ https://git-wip-us.apache.org/repos/asf?p=lucene-solr.git;h=39100a8 ]\n\nLUCENE-7970: Increase maximum iteration count and decrease cutoff for abort in order to get test to pass. ",
            "author": "ASF subversion and git services"
        },
        {
            "id": "comment-16177325",
            "date": "2017-09-22T23:30:30+0000",
            "content": "Commit 0bd5d85087797eee446f037cd40b3f045e07baf9 in lucene-solr's branch refs/heads/branch_6x from Karl Wright\n[ https://git-wip-us.apache.org/repos/asf?p=lucene-solr.git;h=0bd5d85 ]\n\nLUCENE-7970: Increase maximum iteration count and decrease cutoff for abort in order to get test to pass. ",
            "author": "ASF subversion and git services"
        },
        {
            "id": "comment-16177327",
            "date": "2017-09-22T23:31:11+0000",
            "content": "Commit 900b68a6ca59bcc7c8b941abb686ad693db45e61 in lucene-solr's branch refs/heads/branch_7x from Karl Wright\n[ https://git-wip-us.apache.org/repos/asf?p=lucene-solr.git;h=900b68a ]\n\nLUCENE-7970: Increase maximum iteration count and decrease cutoff for abort in order to get test to pass. ",
            "author": "ASF subversion and git services"
        },
        {
            "id": "comment-16177378",
            "date": "2017-09-23T00:28:25+0000",
            "content": "I also had another look at the logic in the proposed \"complex circle\".  The real problem I see is the intersects() methods.  The code in the patch does not actually reliably determine intersection of a plane and an exact circle within the specified bounds, and that's in fact rather hard.  Computing the distance from the plane to the center of the circle isn't going to work.  \n\nYou could do this with a lagrangian multiplier, but the problem with that is that the Vincenty formula is iterative and is thus not describable as a differentiable function.\n\nThat means that instead of an analytic solution, an iterative numeric solution will be needed that finds the intersection of the exact circle edge on the surface of the ellipsoid with the given plane.  Coming up with such a thing will require a far more in-depth understanding of the Vincenty algorithm than I have at this time.  Maybe an idea will come to me but so far I am not so inspired. ",
            "author": "Karl Wright"
        },
        {
            "id": "comment-16177611",
            "date": "2017-09-23T07:36:02+0000",
            "content": "The only idea that's come to me so far is to define GeoExactCircle as implementing only Membership, GeoSizeable, and GeoDistance.  GeoOutsideDistance we can't really do at the moment, nor can we implement intersects() in any form, so GeoShape is not really possible either.\n\nFrom GeoShape, we could implement getBounds() and getEdgePoints().  getEdgePoints() is only useful in the context of intersects(), though.  getBounds() might be moved to another interface, e.g. Bounded, that we can use in a more fine-grained way.   ",
            "author": "Karl Wright"
        },
        {
            "id": "comment-16177617",
            "date": "2017-09-23T07:59:51+0000",
            "content": "Commit 347ab7e86f551ec08b8758dd250d89609126fc49 in lucene-solr's branch refs/heads/master from Karl Wright\n[ https://git-wip-us.apache.org/repos/asf?p=lucene-solr.git;h=347ab7e ]\n\nLUCENE-7970: Separate bounds computation method into its own interface, in prep for creating shapes that can't implement intersects() ",
            "author": "ASF subversion and git services"
        },
        {
            "id": "comment-16177618",
            "date": "2017-09-23T08:00:49+0000",
            "content": "Commit 58c4aeb412949a5e381ba7d4f206f18caf08aa30 in lucene-solr's branch refs/heads/branch_6x from Karl Wright\n[ https://git-wip-us.apache.org/repos/asf?p=lucene-solr.git;h=58c4aeb ]\n\nLUCENE-7970: Separate bounds computation method into its own interface, in prep for creating shapes that can't implement intersects() ",
            "author": "ASF subversion and git services"
        },
        {
            "id": "comment-16177619",
            "date": "2017-09-23T08:01:45+0000",
            "content": "Commit 9c2c4bdb94c2cc7a523eb0d376e71c43f703d691 in lucene-solr's branch refs/heads/branch_7x from Karl Wright\n[ https://git-wip-us.apache.org/repos/asf?p=lucene-solr.git;h=9c2c4bd ]\n\nLUCENE-7970: Separate bounds computation method into its own interface, in prep for creating shapes that can't implement intersects() ",
            "author": "ASF subversion and git services"
        },
        {
            "id": "comment-16177635",
            "date": "2017-09-23T08:21:14+0000",
            "content": "I committed the new Bounded interface regardless; it seemed like a worthwhile addition to granularity.\n\nI also considered what would happen if we just considered any intersection with either the inner or the outer plane to be an intersection with the exact circle.  This is worth considering in the context of what is actually computed with the intersects() method.  These are specifically GeoArea relationships.  So it is worth asking what the problems actually are if we're too inclined to detect intersection?\n\nThe main issue is that it's possible to not detect intersection when we should.  If the plane that is intersecting happens to lie between the outer and inner planes, then we will miss an intersection that actually must be there, and I don't know any way to compute the actual points of intersection.  So even though there's a boolean result, there's no way to know if the intersection in fact occurs within the given bounds.\n\nHowever, if we were just worried about overdetection of intersections, then this is actually almost workable, because if we falsely detect an intersection that actually isn't there, we simply wind up treating the shape as bigger than it really is.  As long as it behaves consistently and the user doesn't mind having the shape not perfectly detect the difference between overlaps and contains, we're good.  If the case of the plane being between the outer and inner planes can be turned into overdetection of intersection, then I think we could manage.\n\nUnfortunately, I cannot convince myself that it's impossible to have an intersection on the true circle curve that's within the provided bounds while NOT intersecting either the inner or outer planes within those same bounds. ",
            "author": "Karl Wright"
        },
        {
            "id": "comment-16178096",
            "date": "2017-09-24T07:18:13+0000",
            "content": "Hi Ignacio Vera, I think I have a solution.\n\nBasically, all we need to do is find a set of planes which, together, describe the actual circle to within MINIMUM_RESOLUTION.  And this is\nstraightforward, because we can use a \"divide and conquer\" approach, where we start with a small number of planes (2), and then\ndivide each plane into two if it turns out that a single plane has too great a degree of error.\n\nI haven't yet coded this but I suspect this will yield a small number of planes for common planetoids like WGS84.  Stay tuned. ",
            "author": "Karl Wright"
        },
        {
            "id": "comment-16178177",
            "date": "2017-09-24T12:32:17+0000",
            "content": "Ignacio Vera The splitting algorithm described above yields the following number of planes for WGS84, where the first number reported is for the circle centered at lat = 0, and the last is the circle centered at lat = Math.PI * 0.5.  So, to hit full accuracy, the number of planes is probably too high to be practical:\n\n\n   [junit4]   1> Number of planes needed: 1536\n   [junit4]   1> Number of planes needed: 1534\n   [junit4]   1> Number of planes needed: 1518\n   [junit4]   1> Number of planes needed: 1506\n   [junit4]   1> Number of planes needed: 1482\n   [junit4]   1> Number of planes needed: 2\n\n\n\nHowever, if we allow the user to determine the level of accuracy, and (for instance) the user chooses an accuracy level of 1 meter or so, then it may well be a different story.  Trying that out next.\n\nTurns out that 1M accuracy isn't prohibitive at all:\n\n\n   [junit4]   1> Number of planes needed: 14\n   [junit4]   1> Number of planes needed: 14\n   [junit4]   1> Number of planes needed: 14\n   [junit4]   1> Number of planes needed: 14\n   [junit4]   1> Number of planes needed: 14\n   [junit4]   1> Number of planes needed: 2\n\n ",
            "author": "Karl Wright"
        },
        {
            "id": "comment-16178227",
            "date": "2017-09-24T14:25:32+0000",
            "content": "Ignacio Vera, I am attaching a patch for your evaluation. ",
            "author": "Karl Wright"
        },
        {
            "id": "comment-16178583",
            "date": "2017-09-25T06:20:07+0000",
            "content": "Hi Karl Wright,\n\nThanks for the patch and the updates. Therefore you need always to be able to define the shape with a collections of planes. This approach is very nice, it is like approximating the circle as a polygon with n-sides. I have a look into the patch and first think I notice is that cardinality points are wrong: 0 degrees bearing angle is for north. I did the following changes and I was able to build circles:\n\n{{\n      final GeoPoint eastPoint = planetModel.surfacePointOnBearing(center, cutoffAngle, Math.PI * 0.5);                                                      \n      final GeoPoint westPoint = planetModel.surfacePointOnBearing(center, cutoffAngle, Math.PI * 1.5);                                                      \n      final GeoPoint northPoint = planetModel.surfacePointOnBearing(center, cutoffAngle, 0.0);                                                               \n      final GeoPoint southPoint = planetModel.surfacePointOnBearing(center, cutoffAngle, Math.PI);                                                           \n\n      this.edgePoints = new GeoPoint[]\n{northPoint}\n;                                                                                                          \n\n      if (planetModel.c > planetModel.ab) \n{                                                                                                                  \n        // z can be greater than x or y, so ellipse is longer in height than width                                                                           \n        slices.add(new ApproximationSlice(center, eastPoint, Math.PI * 0.5, westPoint, Math.PI * -0.5, northPoint, 0));                                      \n        slices.add(new ApproximationSlice(center, westPoint, 1.5 * Math.PI, eastPoint, 0.5 * Math.PI, southPoint, Math.PI));                                 \n      }\n else \n{                                                                                                                                               \n        // z will be less than x or y, so ellipse is shorter than it is tall                                                                                 \n        slices.add(new ApproximationSlice(center, northPoint, 2 * Math.PI , southPoint, Math.PI, eastPoint, 1.5  * Math.PI));                                \n        slices.add(new ApproximationSlice(center, southPoint, Math.PI, northPoint, Math.PI * 0.0, westPoint, 0.5 * Math.PI));                                \n}}\n\nNote I have to change the bearing angles of the slice so averages give the expected numbers. I need to look a bit further but it is looking very nice.\n\nThanks!\n\nI. ",
            "author": "Ignacio Vera"
        },
        {
            "id": "comment-16178584",
            "date": "2017-09-25T06:20:44+0000",
            "content": "Commit 2c79710618e7b6d8b7ecff5dc17cfe7abbd59434 in lucene-solr's branch refs/heads/master from Karl Wright\n[ https://git-wip-us.apache.org/repos/asf?p=lucene-solr.git;h=2c79710 ]\n\nLUCENE-7970: Add an exact version of a circle, which uses Vicenty logic to construct out of planes. ",
            "author": "ASF subversion and git services"
        },
        {
            "id": "comment-16178586",
            "date": "2017-09-25T06:22:59+0000",
            "content": "Commit 4d3863c6fe590dcc9251888462c5dd06f79a1287 in lucene-solr's branch refs/heads/branch_6x from Karl Wright\n[ https://git-wip-us.apache.org/repos/asf?p=lucene-solr.git;h=4d3863c ]\n\nLUCENE-7970: Add an exact version of a circle, which uses Vicenty logic to construct out of planes. ",
            "author": "ASF subversion and git services"
        },
        {
            "id": "comment-16178589",
            "date": "2017-09-25T06:23:57+0000",
            "content": "Commit 2c95fa4118c2a19fc385b23a90facc4bd0bf9006 in lucene-solr's branch refs/heads/branch_7x from Karl Wright\n[ https://git-wip-us.apache.org/repos/asf?p=lucene-solr.git;h=2c95fa4 ]\n\nLUCENE-7970: Add an exact version of a circle, which uses Vicenty logic to construct out of planes. ",
            "author": "ASF subversion and git services"
        },
        {
            "id": "comment-16178641",
            "date": "2017-09-25T07:06:59+0000",
            "content": "Commit f8f19562ee359cbf1a7711d13754e3a1c6c61920 in lucene-solr's branch refs/heads/master from Karl Wright\n[ https://git-wip-us.apache.org/repos/asf?p=lucene-solr.git;h=f8f1956 ]\n\nLUCENE-7970: Correct a misinterpretation of bearing direction ",
            "author": "ASF subversion and git services"
        },
        {
            "id": "comment-16178643",
            "date": "2017-09-25T07:07:59+0000",
            "content": "Commit bcb2076fe6ee8c1eccb8ec95d53d89408f6150c6 in lucene-solr's branch refs/heads/branch_6x from Karl Wright\n[ https://git-wip-us.apache.org/repos/asf?p=lucene-solr.git;h=bcb2076 ]\n\nLUCENE-7970: Correct a misinterpretation of bearing direction ",
            "author": "ASF subversion and git services"
        },
        {
            "id": "comment-16178645",
            "date": "2017-09-25T07:08:48+0000",
            "content": "Commit 9add14a513af620da46bfeeb05f6ccf9af61b1c2 in lucene-solr's branch refs/heads/branch_7x from Karl Wright\n[ https://git-wip-us.apache.org/repos/asf?p=lucene-solr.git;h=9add14a ]\n\nLUCENE-7970: Correct a misinterpretation of bearing direction ",
            "author": "ASF subversion and git services"
        },
        {
            "id": "comment-16178650",
            "date": "2017-09-25T07:12:37+0000",
            "content": "Ignacio Vera, I've committed both the original code and your revision.  If you have tests that verify behavior it would be great to have those committed too; my tests are clearly inadequate.\n\nThanks for verifying this! ",
            "author": "Karl Wright"
        },
        {
            "id": "comment-16180375",
            "date": "2017-09-26T07:20:52+0000",
            "content": "Commit 49583ed13da97cd11c8b9d1b3a88079175a6c69d in lucene-solr's branch refs/heads/master from Karl Wright\n[ https://git-wip-us.apache.org/repos/asf?p=lucene-solr.git;h=49583ed ]\n\nLUCENE-7970: Handle the case where we generate only a pair of identical planes, as might happen when the center is near a pole. ",
            "author": "ASF subversion and git services"
        },
        {
            "id": "comment-16180376",
            "date": "2017-09-26T07:21:56+0000",
            "content": "Commit 4ccd2a1e1b6076afcb7f50d1bee531cdd41ea37b in lucene-solr's branch refs/heads/branch_6x from Karl Wright\n[ https://git-wip-us.apache.org/repos/asf?p=lucene-solr.git;h=4ccd2a1 ]\n\nLUCENE-7970: Handle the case where we generate only a pair of identical planes, as might happen when the center is near a pole. ",
            "author": "ASF subversion and git services"
        },
        {
            "id": "comment-16180379",
            "date": "2017-09-26T07:22:52+0000",
            "content": "Commit 846d53baea0173825347470ea384e484c0f7cca2 in lucene-solr's branch refs/heads/branch_7x from Karl Wright\n[ https://git-wip-us.apache.org/repos/asf?p=lucene-solr.git;h=846d53b ]\n\nLUCENE-7970: Handle the case where we generate only a pair of identical planes, as might happen when the center is near a pole. ",
            "author": "ASF subversion and git services"
        },
        {
            "id": "comment-16180686",
            "date": "2017-09-26T12:40:08+0000",
            "content": "Ignacio Vera, I'm not sure how to integrate this shape in your random test suite, but I think we should.  Also, I only have tests for a few \"isWithin()\" points in the test that I added, but you were able to more thoroughly assess a GeoExactCircle, so I'd like to consider extending the existing test suite to include additional tests based on ones you were doing by hand.  Do you have a recommendation for how best to do that? ",
            "author": "Karl Wright"
        },
        {
            "id": "comment-16180738",
            "date": "2017-09-26T13:05:50+0000",
            "content": "Hi Karl Wright,\n\nApologies for not being so reactive as I would like to but I have a pretty busy week.\n\n I want to add the shape to the random generator and include it in the relationship tests.  I think I will be able to provide you with a patch tomorrow or the day after with this feature.\n\nI am actually having difficulties to translate the accuracy of the shape to values on the planet model. Is there a way to translate accuracy to values on the planet? e.g is accuracy of 1e-3 translated to accurate to 1e-3 degrees?\n\nI want to make accuracy random as well so I would like to use realistic values.\n\nThanks!\n\n\n ",
            "author": "Ignacio Vera"
        },
        {
            "id": "comment-16180796",
            "date": "2017-09-26T13:54:31+0000",
            "content": "Ignacio Vera, the accuracy value is a linear distance on the unit spheroid, not an angular distance. \n More precisely, the \"accuracy\" is defined as the maximum linear distance between any point on the surface circle and planes that describe the GeoExactCircle shape.  Since the radius of earth is 6,371,000 meters, an accuracy of 1e-6 corresponds to 6.3 meters.  For an accuracy of 1.0 meters, you'd need a value of 1.6e-7.  Does that make sense?\n\nI too want to apologize; I've rarely been busier and my interruptions have been having interruptions.  But I'm taking Thursday and Friday as vacation days so maybe I can spend a little more time finishing up some of these issues. ",
            "author": "Karl Wright"
        },
        {
            "id": "comment-16181980",
            "date": "2017-09-27T05:02:30+0000",
            "content": "Hi Karl Wright,\n\nThanks for the exlpanation, it is clear now.\n\nAttached is the random generator with the addition of the new shape. Before committing we should have a look to the test case I have included in the patch.\n\nIn some cases we get npe when creating the exact circle. I think the issue is when planet models have ab or c different to 1. I think the condition (Math.abs(cutoffAngle - Math.PI) < Vector.MINIMUM_RESOLUTION might be only valid for the sphere but needs to be adjusted depending on the planet model.\n\nIn the test is shown that for WGS84 happens when cutoff angles are close to Math.PI but for crazy planet models with low values it happens a smaller ones. ",
            "author": "Ignacio Vera"
        },
        {
            "id": "comment-16182187",
            "date": "2017-09-27T08:31:44+0000",
            "content": "Commit cc16055efe69fa16bdf33a358a44302d30403c64 in lucene-solr's branch refs/heads/master from Karl Wright\n[ https://git-wip-us.apache.org/repos/asf?p=lucene-solr.git;h=cc16055 ]\n\nLUCENE-7970: Add test suite for GeoExactCircle.  Committed on behalf of Ignacio Vera. ",
            "author": "ASF subversion and git services"
        },
        {
            "id": "comment-16182188",
            "date": "2017-09-27T08:33:02+0000",
            "content": "Commit adf4dbdad433f598fddec1932bb013015ef96301 in lucene-solr's branch refs/heads/branch_6x from Karl Wright\n[ https://git-wip-us.apache.org/repos/asf?p=lucene-solr.git;h=adf4dbd ]\n\nLUCENE-7970: Add test suite for GeoExactCircle.  Committed on behalf of Ignacio Vera. ",
            "author": "ASF subversion and git services"
        },
        {
            "id": "comment-16182190",
            "date": "2017-09-27T08:34:32+0000",
            "content": "Commit d39b2ddd2e2e609052dfaf75505123b4490a6979 in lucene-solr's branch refs/heads/branch_7x from Karl Wright\n[ https://git-wip-us.apache.org/repos/asf?p=lucene-solr.git;h=d39b2dd ]\n\nLUCENE-7970: Add test suite for GeoExactCircle.  Committed on behalf of Ignacio Vera. ",
            "author": "ASF subversion and git services"
        },
        {
            "id": "comment-16182194",
            "date": "2017-09-27T08:39:38+0000",
            "content": "Ignacio Vera, I looked at the problem and realized that since the radius for the exact circle is measured as a surface distance, even for spheres I should be using the point-on-bearing method, since the maximum surface distance has to do with the details of the planet model.  Furthermore, since it is not really feasible to determine when the surface distance describes the entire world, I removed handling for that case; instead, you get an IllegalArgumentException when you try to do something like that.  (It would only apply in the case of a sphere and for a very specific surface distance in any case \u2013 neither of which I'd expect GeoExactCircle to be used for.)\n\nI also clarified the radius argument javadoc, since that was referring to angles and these are not angles.\n\nThanks for the contribution!!! ",
            "author": "Karl Wright"
        },
        {
            "id": "comment-16182196",
            "date": "2017-09-27T08:42:15+0000",
            "content": "Commit 61d1e96b80240a9111bafcd40ae7b01c0e8fec77 in lucene-solr's branch refs/heads/master from Karl Wright\n[ https://git-wip-us.apache.org/repos/asf?p=lucene-solr.git;h=61d1e96 ]\n\nLUCENE-7970: Remove restriction on maximum cutoff angle, since it's really a radius. ",
            "author": "ASF subversion and git services"
        },
        {
            "id": "comment-16182197",
            "date": "2017-09-27T08:43:21+0000",
            "content": "Commit 588c60fa7f32a697a7c05c7b92d3ba139f7bbdf5 in lucene-solr's branch refs/heads/branch_6x from Karl Wright\n[ https://git-wip-us.apache.org/repos/asf?p=lucene-solr.git;h=588c60f ]\n\nLUCENE-7970: Remove restriction on maximum cutoff angle, since it's really a radius. ",
            "author": "ASF subversion and git services"
        },
        {
            "id": "comment-16182199",
            "date": "2017-09-27T08:44:09+0000",
            "content": "Commit 2894f23cdef6f4f257ec8678f949744eefb7769e in lucene-solr's branch refs/heads/branch_7x from Karl Wright\n[ https://git-wip-us.apache.org/repos/asf?p=lucene-solr.git;h=2894f23 ]\n\nLUCENE-7970: Remove restriction on maximum cutoff angle, since it's really a radius. ",
            "author": "ASF subversion and git services"
        },
        {
            "id": "comment-16207492",
            "date": "2017-10-17T11:04:35+0000",
            "content": "Bulk close after 7.1.0 release ",
            "author": "Shalin Shekhar Mangar"
        }
    ]
}