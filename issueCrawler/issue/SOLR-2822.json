{
    "id": "SOLR-2822",
    "title": "don't run update processors twice",
    "details": {
        "affect_versions": "None",
        "status": "Closed",
        "fix_versions": [
            "4.0-ALPHA"
        ],
        "components": [
            "SolrCloud",
            "update"
        ],
        "type": "Sub-task",
        "priority": "Major",
        "labels": "",
        "resolution": "Fixed"
    },
    "description": "An update will first go through processors until it gets to the point where it is forwarded to the leader (or forwarded to replicas if already on the leader).\nWe need a way to skip over the processors that were already run (perhaps by using a processor chain dedicated to sub-updates?",
    "attachments": {
        "SOLR-2822.patch": "https://issues.apache.org/jira/secure/attachment/12527921/SOLR-2822.patch"
    },
    "issue_links": {},
    "comments": [
        {
            "author": "Jan H\u00f8ydahl",
            "id": "comment-13125317",
            "date": "2011-10-11T19:30:56+0000",
            "content": "Nice thought to allow modeling the flow in the update-chain itself as an intuitive way of choosing which processing to do on the receiving node, on the leader node, or on each replica:\n\n\nA-UP -> B-UP -> Distrib-UP(leader) -> C-UP -> Distrib-UP(replica) -> D-UP -> Run-UP\n\n\n\nThe Distrib processor could set some state info on the request to the next node so that chain processing could continue where it left off. E.g. &update.chain.nextproc=<name/id-of-next-proc>. This would require introduction of named processor instances.\n\nThe default if no distrib explicitly specified could be to run Distrib-UP(leader) prior to the chain and Distrib-UP(replica) right before Run-UP? See SOLR-2370. In a non-cloud setting, the Distrib-UPs would do nothing. "
        },
        {
            "author": "Hoss Man",
            "id": "comment-13266272",
            "date": "2012-05-02T01:10:50+0000",
            "content": "Yonik suggested that this issue might be a good place for me to start learning more about the internals of Solr Cloud.  First some background on what i started thinking about (archived for posterity) but have since dismissed as a bad idea...\n\nMy Initial Bad Idea That I Think Sucks\nmy first impression when yonik mentioned the problem was along the lines of the initial bug summary...\n\nperhaps by using a processor chain dedicated to sub-updates\n\n...at first glance, this seemed like it would be an easy way to deal with the problem in a way that would be very easy to understand when looking at your chains in the solrconfig.xml, and wouldn't involve any sort of \"magic\" that might be hard for users to understand about how distributed updates work...\n\n\n\tsome chain(s) (probably the default) would end with DistributedUpdateProcessorFactory, which would be configured with a \"distrib.chain\" init param value having some value $foo\n\tsome other chain would be named $foo, and would end with RunUpdateProcessorFactory\n\twhen DistributedUpdateProcessorFactory was triggered, it would forward the request to all of the nodes (including itself) using the configured distrib.chain\n\n\n\nBut as i started looking at the code a bit more, i realized that was a trivially naive understanding of what's needed here \u2013 mainly because i completely forgot about that fact that there are two types of forwarding:\n\n\n\tsome arbitrary node gets the initial request from a client, and forwards to the leader\n\tthe leader does version checking/adding on the command/docs, and forwards to all the nodes\n\n\n\nThis is when i started thinking that maybe there should be three named chains, and started understanding Jan's comment above about choosing which logic should happen \"on the leader node\".\n\nBut the more i thought about the more the more the idea of specifying certain logic needed to be run on the leader node made less sense.  I can think of lots of reasons for why you would care about whether an UpdateProcessor ran on one node or N nodes (mainly the trade off between an expensive computation you might only wnat to do once, vs processors that will add a lot of fields to the request so you might want to defer until after distribution to minimize data over the wire) but i couldn't come up with any compelling reason why, if you have a processor you only want to execute once you would care if it happens on the first node randomly selected by the client, or if you really wanted to ensure it happened on the leader \u2013 particularly since leader election/promotion can happen to any node at any time, so you couldn't even use the leader logic to try and take advantage of some local resources on a particular machine.\n\nBut even if we go back to the \"two chain\" model i suggested above, because of the leader logic, the second chain would need to start with some UpdateProcessor that handled the \"version\" & \"forward to all nodes\" work currently handled by DistributedUpdateProcessor when \"isLeader\" is true.  Which means people editing their configs would need to not only remember to put some sort of \"SendDistributedUpdateProcessorFactory\" at the end of the chains they expect clients to use, but also some sort of \"RecieveDistributedUpdateProcessorFactory\" at the beginning of the chain that \"SendDistributedUpdateProcessorFactory\" would be pointing at (or maybe both are just instances of DistributedUpdateProcessorFactory and we make it smart enough to know when it's the start vs end of the chain) ... which starts sounding really tedious and easy to screw up \u2013 not to mention it doesn't play very nicely with the idea of a hardcoded default chain users get for free if they have none in their config; and it thoroughly complicates the story of someone who starts with the example (no declared chains) in cloud mode and then wants to customize a little, say by adding SignatureUpdateProcessor \u2013 they wouldn't be able to just configure a chain starting with SignatureUpdateProcessor, they'd need to add two, and be careful about how they start and end.\n\n\ni'm all for transparency and eliminating \"magic\" by having things spelled out in the configs, but even for me this idea was starting to seem like a serious pain in the ass.\n\nWhich leads me to the idea i do think has merit...\n\nMy Current Idea That I Don't Think Sucks\nI think in an ideal world... \n\n\tSolr Cloud users should be able to just declare a straightforwrd chain of processors and not need to worry about which nodes they run on (ie: any chain they used pre-cloud should still work)\n\tif a user wants to care what parts of the chain run once vs on every node, it should be simple to indicate that decision by putting some \"marker\" processor (ie: DistributedUpdateProcessorFactory) in the chain denoting when distribution should happen.\n\tIf you are using cloud mode, and don't specify where the distributed update logic happens, then Solr should pick for you \u2013 either \"first\" before any other processors, or \"last\" just before RunUpdateProcessor ... I don't have an opinion which is better, i'm sure other people who have been experimenting with Solr Cloud for a while can tell me.\n\n\n\n(I'm usually the person opposed to doing things magically behind the scenes like this, but \"Solr Cloud\" is becoming a central enough concept in Solr, with many components doing special things if \"zkEnabled\", that I think moving forward it's \"ok\" to treat distributed updating as the norm in cloud mode and optimize for it.)\n\nThe most straight forward way i can think of to do this would be:\n\n\tif Solr is in \"cloud mode\" then when SolrCore is initializing the chains from solrconfig.xml, any chain that doesn't include DistributedUpdateProcessorFactory should have it added automatically (alternatively: maybe we only add it if RunUpdateProcessor is in the chain, so anyone using chains w/o RunUpdateProcessor \u2013 for some weird bizare purpose we can't imagine \u2013 won't be surprised by DistributedUpdateProcessorFactory getting added magically)\n\tDistributedUpdateProcessor should add some param when forwarding to any other node indicating that the request is being distributed\n\twhen an update request is received, if it has this special param in it, then any processor in the chain prior to DistributedUpdateProcessorFactory is skipped\n\n\n\nThis idea is very similar to part of what Jan suggested in his comment above...\n\nThe Distrib processor could set some state info on the request to the next node so that chain processing could continue where it left off. E.g. &update.chain.nextproc=<name/id-of-next-proc>. This would require introduction of named processor instances.\n\n...but what i'm thinking of wouldn't require named processors and would be specific to distributed updates (but wouldn't precluded named processors and more enhanced logic down the road if someone wanted it).\n\nI think this would be fairly feasible just by making some small modifications to DistributedUpdateProcessor (to add the new special param when forwarding) and UpdateRequestProcessorChain (to inject the DistributedUpdateProcessorFactory if cloud mode, and to skip up to the DistributedUpdateProcessorFactory if the param is set).  I do however still think we should generalize somewhat:\n\n\n\tDistributedUpdateProcessorFactory should be made to implement some marker interface with no methods (ie: DistributedUpdateMarker)\n\tUpdateRequestProcessorChain.init should scan for instances of DistributedUpdateMarker in the chain (instead of looking explicitly for DistributedUpdateProcessorFactory) when deciding whether to inject a new DistributedUpdateProcessorFactory into the chain\n\tUpdateRequestProcessorChain.createProcessor should scan for instances of DistributedUpdateMarker in the chain (instead of looking explicitly for DistributedUpdateProcessorFactory) when \"skipping ahead\" if the special param is found in the request\n\n\n\n...that way advanced users can implement their own distributed update processor implementing that interface and register it explicitly in their chain if they are so inclined, or implement a NoOp update processor implementing that interface if they want to bipass the magic completley.\n\nAs a possible optimization/simplification to what gets sent over the wire, the new param we add that UpdateRequestProcessorChain would start looking for to \"skip ahead\" in the chain could replace the existing \"leader\" boolean param DistributedUpdateProcessor currently uses (aka: SEEN_LEADER) by having an enum style param (perhaps called \"update.distrib\" ?)...\n\n\n\tnone - default if unset, means no distribution has happend\n\ttoleader - means the request is being sent to the leader\n\tfromleader - means the leader is sending the request to all nodes\n\n\n\nUpdateRequestProcessorChain would only care if the value is not \"none\", in which case it would skip ahead to the DistributedUpdateMarker in the chain.  DistributedUpdateProcessorFactory would care if the value is \"toleader\" or \"fromleader\" in which case it's logic would toggle in the same way it does currently for SEEN_LEADER.\n\n\nSo that's my idea.  As i mentioned, this is really the first time i've looked into any of the \"Solr Cloud\" internals, and it's very possible i may still be missing something major. So if you spot any holes in this idea, please let me know \u2013 otherwise i'll try to take a stab at a patch in the next few days. "
        },
        {
            "author": "Jan H\u00f8ydahl",
            "id": "comment-13266916",
            "date": "2012-05-02T21:16:00+0000",
            "content": "\nThis idea is very similar to part of what Jan suggested in his comment above...SNIP...but what i'm thinking of wouldn't require named processors and would be specific to distributed updates (but wouldn't precluded named processors and more enhanced logic down the road if someone wanted it).\n\nYup, that's one way. However, I think we can achieve even more transparency and flexibility by introducing the concept of GOTO in our pipeline! Remember in the old days of programming, we could jump to a specified place in the code (well, HTML's anchor does the same, but I thought GOTO was a cooler analogy  ) Let's say we create an interface ChainLabel with two methods getLabel/setLabel, same as your marker but with a nametag. Then DistribProcessor would set \"distrib\" as its label, and we could imagine a future processor which delegates processing to an external pipeline cluster, which sets another label \"externalPipeline\". We could even have a dummy noop UpdateProcessor which sets the label as a config param. Then, you could call update.chain.goto=myLabel to continue processing at the label. The URPChain class would not know about DistributedUpdateProcessor, but about labels and goto in general.\n\nI like your update.distrib=none|toleader|fromleader optimization "
        },
        {
            "author": "Hoss Man",
            "id": "comment-13278266",
            "date": "2012-05-17T21:04:57+0000",
            "content": "patch i worked up during the last couple of weeks (but evidently forgot to upload)\n\n\n\timplements the general idea i outlined before (using the interface name \"DistributingUpdateProcessorFactory\" instead of DistributedUpdateMarker)\n\tincludes a randomized test demonstrating the existing problem with doc adds and update processors both before and after the distrib handler \u2013 but this was just shoehorned into an existing test and should be refactored\n\tneeds more unit tests - particularly something non randomized that does a straight forward verification of the processor skipping done by the chain\n\tI want to add a NoOpDistributingUpdateProcessorFactory - both for testing and for easy use by any existing SolrCloud users who want absolute total control of their chains (ie: isn't using DistributedUpdateProcessorFactory and is building shards their own custom way)\n\thas a few nocommits - other then things i've already mentioned, they are primarily related to docs and logging\n\n\n\nOne interesting thing i didn't realize until i started implementing this is that the deleteByQuery code path already had something nearly identical to my update.distrib=NONE|TOLEADER|FROMLEADER param value (via a \"dqb_level=1|2|3\") .. i take that as validation that generalizing it to replace the existing SEEN_LEADER logic in the other code paths isn't a bad idea. "
        },
        {
            "author": "Hoss Man",
            "id": "comment-13278292",
            "date": "2012-05-17T21:29:39+0000",
            "content": "Let's say we create an interface ChainLabel with two methods getLabel/setLabel, same as your marker but with a nametag. Then DistribProcessor would set \"distrib\" as its label, and we could imagine a future processor which delegates processing to an external pipeline cluster, which sets another label \"externalPipeline\". We could even have a dummy noop UpdateProcessor which sets the label as a config param. Then, you could call update.chain.goto=myLabel to continue processing at the label\n\nThis seems kind of dangerous to me and should probably be fleshed out in it's own issue with a lot more discussion.  As it relates to this particular problem, it really seems like \"skipping to\" the distribute update processor really needs to be independent of any sort of generalized \"goto\" support that we might add to the chain, because shouldn't this hypothetical \"goto\" logic to work in combination with distributed updates, not in place of it?   \n\nie: if a chain is A->B->DISTRIB->E->F->..., and you send a request to a random node with \"goto=F\", then should that randomly selected node really execute F locally, ignoring the rest of the cloud? it seems like should it forward to a leader (which may decide to broadcast to all shards, or all leaders if it's a deleteByQuery) and then they should skip E and goto F ... maybe.\n\nlike i said, it seems complicated. i'd rather keep the issue focused for now. "
        },
        {
            "author": "Andrzej Bialecki",
            "id": "comment-13278327",
            "date": "2012-05-17T22:09:43+0000",
            "content": "This looks good. Some comments:\n\n\tjavadocs should mention somewhere (UpdateProcessorRequestChain) the skipping of parts of the chain when FROMLEADER is seen.\n\ttests don't seem to cover any case that uses requests with TOLEADER set.\n\tre. comment in UpdateRequestProcessorChain, where DUPFactory() is inserted if missing: I'd say if someone forgot or is unaware of the need for a distrib processor then it should be inserted as it is done in the patch - right before the run processor, so that all modifications to documents are completed before distributing (modifications could affect the shard #).\n\tminor nits:\n\t\n\t\tBasicDistributedZkTest.testUpdateProcessorsRunOnlyOnce() has a hanging :TODO:, not sure what it refers to?\n\t\tDistributingUpdateProcessorFactory: typos \"not inteded\", \"skiped\".\n\t\tDistributedUpdateProcessor: typo \"exposted\"\n\t\tUpdateRequestProcessorChain: mentions DistributedUpdateProcessorFactoryMarker, \"then and\".\n\t\n\t\n\n "
        },
        {
            "author": "Hoss Man",
            "id": "comment-13278538",
            "date": "2012-05-18T02:50:48+0000",
            "content": "Updated patch dealing with all the nocommits and (i think) fixing all the TODO items that both i and andrzej mentioned, except for...\n\n* includes a randomized test demonstrating the existing problem with doc adds and update processors both before and after the distrib handler \u2013 but this was just shoehorned into an existing test and should be refactored\n\nI started looking at this and realized that the overhead of creating the cloud instance in this test was somewhat significant (in terms of wall clock time), so it seemed better to leave the test method where it was (cleaned up a bit) then to refactor into another test with the same amount of setup.\n\n* tests don't seem to cover any case that uses requests with TOLEADER set.\n\nthe processor skipping code in the chain doesn't care what the value is, or even what type of requests are processed, so the next test i added in this version of the patch covers both cases of update.distrib being set or not set.  \n\nThe only code path that cares if the values is TOLEADER is in deleteByQuery \u2013 all i did was ensure that the existing tests where changed to use the new update.distrib param instead of the old \"dbg_level\" \n\nIf we need more deleteByQuery tests, that seems like it should be a distinct issue (or at the very least: an additional patch from someone who udnerstands the distrib tests better then me.  writing new (whitebox) tests for distribted deleteByQuery is above my solrcloud foo at this point.) "
        },
        {
            "author": "Mark Miller",
            "id": "comment-13280273",
            "date": "2012-05-21T16:52:32+0000",
            "content": "I was under the impression this might solve SOLR-3215, but now I'm not sure? "
        },
        {
            "author": "Hoss Man",
            "id": "comment-13281310",
            "date": "2012-05-22T23:29:53+0000",
            "content": "updated patch to trunk.\n "
        },
        {
            "author": "Mark Miller",
            "id": "comment-13283361",
            "date": "2012-05-25T13:04:02+0000",
            "content": "+1 - approach seems as elegant as we could shoot for right now. I much prefer it to juggling multiple chains.\n\nI still worry about the 'clone doc' issue and update procs between distrib and run - if we do decide to not let procs live there, we should probably hard fail on it.\n\nLatest patch looks good to me - let's commit and iterate on trunk. "
        },
        {
            "author": "Hoss Man",
            "id": "comment-13283613",
            "date": "2012-05-25T17:26:35+0000",
            "content": "Committed revision 1342743. "
        }
    ]
}