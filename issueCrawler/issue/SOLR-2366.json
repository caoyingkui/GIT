{
    "id": "SOLR-2366",
    "title": "Facet Range Gaps",
    "details": {
        "affect_versions": "None",
        "status": "Resolved",
        "fix_versions": [],
        "components": [],
        "type": "Improvement",
        "priority": "Minor",
        "labels": "",
        "resolution": "Won't Fix"
    },
    "description": "There really is no reason why the range gap for date and numeric faceting needs to be evenly spaced.  For instance, if and when SOLR-1581 is completed and one were doing spatial distance calculations, one could facet by function into 3 different sized buckets: walking distance (0-5KM), driving distance (5KM-150KM) and everything else (150KM+), for instance.  We should be able to quantize the results into arbitrarily sized buckets.\n\n(Original syntax proposal removed, see discussion for concrete syntax)",
    "attachments": {
        "SOLR-2366.patch": "https://issues.apache.org/jira/secure/attachment/12471182/SOLR-2366.patch"
    },
    "issue_links": {},
    "comments": [
        {
            "author": "Grant Ingersoll",
            "id": "comment-12995290",
            "date": "2011-02-16T13:35:00+0000",
            "content": "Note, also, the proposed syntax is just a draft, I'm definitely open to other syntax "
        },
        {
            "author": "Grant Ingersoll",
            "id": "comment-12995345",
            "date": "2011-02-16T15:44:52+0000",
            "content": "Adds variable width gap capabilities and some tests.  Still needs some more tests for edge conditions, etc. but it is something that others can look at and comment on. "
        },
        {
            "author": "Grant Ingersoll",
            "id": "comment-12995558",
            "date": "2011-02-16T22:44:49+0000",
            "content": "Added more tests, cleaned up the patch, all tests pass.  I think it is ready to commit and will do so in a day or two or maybe this weekend. "
        },
        {
            "author": "Hoss Man",
            "id": "comment-12995585",
            "date": "2011-02-16T23:45:34+0000",
            "content": "the use case of facet.range (and facet.date before it) was always about having ranges generated for you automatcly using a fixed gap size.  if you want variable gap sizes, it's just as easy to specify them using facet.query.\n\ni don't really understand how your proposal adds value over using facet.query for the ranges you want to have specific widths, and then using facet.range for the rest of the ranges you want generated automaticly with a specific gap.\n\nit just seems like a more confusing way of expressing the same thing "
        },
        {
            "author": "Grant Ingersoll",
            "id": "comment-12995652",
            "date": "2011-02-17T03:34:23+0000",
            "content": "it just seems like a more confusing way of expressing the same thing\n\nI think it's a lot less confusing.  You only have to express start, end and the size of the buckets you want.  With facet.query, you have to write out each expression for every bucket and do the math on all the boundaries.  I don't think it is just as easy to specify using facet.query.  Not too mention that facet.query also involves a lot more parsing. "
        },
        {
            "author": "Ryan McKinley",
            "id": "comment-12995838",
            "date": "2011-02-17T14:59:29+0000",
            "content": "I agree with grant that this syntax is more clear then using facet.query for each bucket.\n\nJust throwing it out there... but is there a way to not specify the start/end, and have that based on the values in the index?  start=* end=*?  In this case, it would be nice to specify the gap as round numbers.  Perhaps gap=%10?  assuming you have the values: 22,28,35, that would give you gaps for 20-30 and 30-40 "
        },
        {
            "author": "Grant Ingersoll",
            "id": "comment-12995843",
            "date": "2011-02-17T15:11:12+0000",
            "content": "Just throwing it out there... but is there a way to not specify the start/end, and have that based on the values in the index? start=* end=*? In this case, it would be nice to specify the gap as round numbers. Perhaps gap=%10? assuming you have the values: 22,28,35, that would give you gaps for 20-30 and 30-40\n\nRyan, I think that's also an excellent variation.  Sometimes you want hard start/ends, sometimes you want percentage buckets, especially for the thing I'm working on now, which is facet by function "
        },
        {
            "author": "Ryan McKinley",
            "id": "comment-12995870",
            "date": "2011-02-17T16:04:46+0000",
            "content": "sometimes you want percentage buckets\n\nThis does not map easily since you need to know the min/max value before traversing \u2013 it may actually take two passes.  \n\nThe use case I am looking at is trying to show reasonable histograms for field values, without really knowing much about the field values as input.  Currently I run the stats component, and then in a second query facet within that range \u2013 gets the job done, but not ideal. "
        },
        {
            "author": "Hoss Man",
            "id": "comment-12996154",
            "date": "2011-02-17T23:50:54+0000",
            "content": "(FYI: i haven't looked at the patch, because i'm trying to focus on 3.1 bug fixes, but grant specifically called me out on this on irc, so i'm replying based purely on the comments)\n\nI think it's a lot less confusing. You only have to express start, end and the size of the buckets you want. With facet.query, you have to write out each expression for every bucket and do the math on all the boundaries.\n\nok ... fair enough, i can't deny the syntax you are proposing would be easier then specifying individual facet.query params, i'm just not convinced it would be completely intuitive.  If i told someone about this feature, and then showed them this request...\n\n\nfacet.range.start=10&facet.range.end=100&facet.range.gap=10,20,50\n\n\nI would be hard pressed to explain why the resulting ranges were...\n\n\n10-20, 20-40, 40-90, and 90-190\n\n\n...instead of...\n\n\n10-20, 10-30, 10-60, and 60-110\n\n\n(bearing in mind: facet.range.hardend defaults to \"false\")\n\nthe existing start/end/gap params may not be 100% intuitive purely by name, but once you read about them once, they are fairly easy to grasp and not very confusing at all when you read examples later.  likewise, a collection of facet.query objects is fairly intuitive and unambiguious.  I just don't feel that way about what you are suggesting (then agian: i unleashed \"mm\" on the world, so i'm not really in a good position to throw stones)\n\nI'm also not convinced that it really makes sense in use cases like this (where you want variable sized buckets) to specify the gap sizes as a list, instead of the specifying the boundaries on each bucket.\n\nWhat you are describing almost feels like it should be a new category of faceting \u2013 or a variation on range faceting that doesn't involve the start/end/gap params at all (but could still respects facet.range.include and facet.range.other)\n\nHere's my counter-proposal/suggestion...\n\nI'm imagining a facet.range.buckets param that (if present) would override facet.range.gap, facet.range.start, and facet.range.end (so using facet.range  would require either bucket or start/end/gap).  facet.range.buckets would take a comma separated list of value representing the specific values you wanted to see used to define adjoining range boundary points, with some syntax (\"...\" seems natural) indicating \"repeat last range size until reach this next value\"\n\nso you could say...\n\n\nfacet.range=price&facet.range.buckets=0,10,25,50,100,...,300\n\n\n...and the resulting ranges computed would be...\n\n\n0-10, 10-25, 25-50, 50-100, 100-150, 150-200, 200-250, 250-300\n\n\n...likewise you could say...\n\n\nfacet.range=age&facet.range.buckets=0,1,...,18,25,40,60,...,100\n\n\n...and you would get ranges for each year from 0 to 18, followed by 18-25, 25-40, 40-60, 60-80, 80-100.\n\nThe tricky situations would be things like...\n\n\n\t\nfacet.range.buckets=0,2,3,...,10\n\n\t\nfacet.range.buckets=0,7,...,10,20\n\n\n\n\n...the first could be dealt with using facet.range.hardend like we do today (so the resulting buckets were \"0-2,2-5,5-8,8-11\") but i don't think it should.   I think it should result in \"0-2,2-5,5-8,8-10\" ... it's hard to imaging letting a param like facet.range.hardend override the explicit \"10\" in the buckets list when we don't have programaticly generate buckets of precisesly the same size, particularly when you consider the implications that would carry over to the second case (i really can't imagine letting that produce any ranges other then \"0-7,7-10,10-20\")\n\nSo yeah ... that's what i think would make more sense then letting you specify a comma seperated list in the \"gaps\" param ... fundamentally i think it comes down to the point i alluded to earlier in this comment: is specifying a sequence of varying gap sizes more intuitive for this type of use case then specifying a sequence of boundary points? i don't think it is.\n\n(PS: i think the discussion about dynamically generating range points based on stats in the index should really be tracked in a distinct issue ... it's got a lot of complexity to it that we've talked about on the mailing list a few times that i don't really want to try and get into now) "
        },
        {
            "author": "Grant Ingersoll",
            "id": "comment-12996164",
            "date": "2011-02-18T00:22:01+0000",
            "content": "Hoss, I can live with ranges.  I had originally thought of doing that, but decided this syntax is simpler, especially for dates.  Then again, we could just as well support both.  The nice thing doing ranges gives you is you can have non-contiguous ranges, which might be interesting to some.\n\nAs for:\nwould be hard pressed to explain why the resulting ranges were...\n\nIt really isn't that hard to explain:\nstart + gap[0], prevEnd + gap[1], ... prevEnd + gap[i], ... prevEnd + gap[n] (and repeating until end)\nIn other words, it's a variable width gap starting at whatever the last end point was. "
        },
        {
            "author": "Yonik Seeley",
            "id": "comment-12996176",
            "date": "2011-02-18T00:42:44+0000",
            "content": "would be hard pressed to explain why the resulting ranges were...\n\nI agree - it requires summing all previous deltas to figure out what the current range actually is.\nI think we need to drive this from use-cases.  The first use case that comes to mind is price ranges... and that would be a pain to insert a new price range if we were just dealing with a list of deltas.  Anything I can think of where you would want variable sized buckets, it seems like you care more about the absolute values of those buckets, rather than their delta to the previous bucket.\n\nI pretty much came up with what Hoss suggested I think (except I didn't think of the \"...\" syntax).\n\nWe could potentially support a mix of absolute starting points and ranges:\n0,5,10,20,100-1000\nNormally one would stick to one syntax or the other in a single request, but we could support both in a single parameter as a convenience. "
        },
        {
            "author": "Jan H\u00f8ydahl",
            "id": "comment-12996341",
            "date": "2011-02-18T10:45:27+0000",
            "content": "+1 for using absolute values instead of gap values\n+1 for keeping the bucket spec as a separate param, including start and end\n+1 for letting the start/end in the spec automatically disable hardend\n\nI wrote down some thoughts the other day which is almost exactly what Hoss suggests, only I called it facet.range.spec  Was going to start another issue but now that the dicussion is rolling here, here we go.\n\nThe facet.range.spec must be intuitive and should include start, all absolute boundaries and end. Sample:\n\n\nfacet.range.spec=0,5,25,50,100,400 ==> 0-5, 5-25, 25-50, 50-100, 100-400.\n\n\n\nTo specify the gap size instead of next absolute threshold, we could have a +N syntax:\n\nfacet.range.spec=0,5,25,+25,+50,400\n\n\nwould be equivalent to the above absolute spec.\n\nA +N value would repeat as many times as needed to reach the next absolute value:\n\nfacet.range.spec=0,5,+10,25,50,100,+100,400 ==> 0-5, 5-15, 15-25, 25-50, 50-100, 100-200, 200-300, 300-400\nfacet.range.spec=0,5,+10,25,50,100,+100,400 ==> 0-5, 5-15, 15-25, 25-50, 50-100, 100-200, 200-300, 300-400\n\n\n\nDate example:\n\nfacet.range.spec=*,2000-01-01T00:00:00Z,+5YEARS,NOW/YEAR,+1MONTH,NOW\n\n\n...gives a range before 2000, two 5-year ranges 2000-2005, 2005-2010, one range until start of this year 2010-2011, then monthly ranges for this year until now.\n\nNow, having all this power of defining buckets available, it would be easy to introduce (i.e. feature creep  a facet.range.labels param. Imagine:\n\nfacet.range.spec=NOW/MONTH-1MONTH,NOW/MONTH,NOW/DAY-1DAY,NOW/DAY,NOW/HOUR,NOW,*\nfacet.range.labels=\"Last month\",\"This month\",\"Yesterday\",\"Today\",\"This hour\",\"Future\"\n\n "
        },
        {
            "author": "Jan H\u00f8ydahl",
            "id": "comment-12996358",
            "date": "2011-02-18T11:39:59+0000",
            "content": "Both the date ranges above and other typical use cases call for overlapping buckets. This would be a generalization of Yonik's range suggestion. Imagine a real estate site with a bedrooms facet:\n\nf.bedrooms.facet.range.spec=1..*,2..*,3..*,4..*\nf.bedrooms.facet.range.labels=\"One or more\",\"Two or more\",\"Three or more\",\"Four or more\"\n\n\nI've chosen \"..\" as range delimiter since \"-\" would be confused with Date Math. "
        },
        {
            "author": "Herman J Kiefus",
            "id": "comment-13000286",
            "date": "2011-02-28T14:03:27+0000",
            "content": "With absolute ranges (no gap) couldn\u2019t we also support alphabetic ranges?  I would find this useful. "
        },
        {
            "author": "Herman J Kiefus",
            "id": "comment-13000293",
            "date": "2011-02-28T14:11:27+0000",
            "content": "Also regarding arbitrary ranges:\n\nWhile using fact.query allows us to construct arbitrary ranges, we must then pick them out of the results separately.  This becomes more difficult if we arbitrarily facet on two or more fields/expressions.  Essentially we have to parse the results, grouping by expression and then picking out each range in the order we want to illustrate it.  This would seem to be unnecessary, if we had the ability to add n absolute ranges to a facet.range. "
        },
        {
            "author": "Hoss Man",
            "id": "comment-13015088",
            "date": "2011-04-02T23:43:37+0000",
            "content": "In no particular order...\n\n\n\tI like Jan's facet.range.spec naming suggestion better then my facet.range.buckets suggestion ... but i think facet.range.series, facet.range.seq, or facet.range.sequence might be better still.\n\n\n\n\n\tI think Jan's point about N vs +N in the sequence list as a way to mix absolute values vs increments definitely makes sense, and would be consistent with the existing date match expression.\n\n\n\n\n\tthe complexity with supporting both absolute values and increments would be the question of what solr should do with input like facet.range.seq=10,20,+50,+100,120,150 ?  what ranges would we return? (10-20, 20-70, 70-???....)  would it be an error? would we give back ranges that overlapped?  what about facet.range.seq=10,50,+50,100,150&facet.range.include=all .. would that result in one of the ranges being [100 TO 100] or would we throw that one out?  (I think it would be wise to start out only implementing the absolute value approavh, since that seems (to me) the more useful option of the two, and then consider adding the incremental values as a separate issue later after hashing out hte semantics of these types of situations)\n\n\n\n\n\tA few of Jan's sample input suggestions used {{ * }} at either the start or end of the sequence to denote \"everything before\" the second value or \"everything after\" the second to last value \u2013 i don't think we need to support this syntax, I think the existing facet.range.other would still be the right way to support this with facet.range.sequence.  if you want \"everything before\" and/or \"everything after\" use facet.range.include=before and/or facet.range.include=after .. otherwise it would be confusing to decide what things like facet.range.include=before&facet.range.seq=*,10,20 and facet.range.include=none&facet.range.seq= * ,10,20 mean.\n\n\n\n\n\tI REALLY don't think we should try to implement something like Jan's facet.range.labels suggestion.  I can't imagine any way of supporting it thta wouldn't prevent or radically complicate the \"...\" type continuation of series i suggested before, and that seems like a much more powerful feature then labels.  if a user is going to provide a label for every range, then you must enumerate every range, and you might as well enumerate them (and label them) with facet.query where the label and the query can be side by side.\n\n\n\nThis...\n\n\nfacet.query={!label=\"One or more\"}bedrooms:[1 TO *]\nfacet.query={!label=\"Two or more\"}bedrooms:[2 TO *]\nfacet.query={!label=\"Three or more\"}bedrooms:[3 TO *]\nfacet.query={!label=\"Four or more\"}bedrooms:[4 TO *]\n\n\n\n...seems way more readable, and less prone to user error in tweaking, then this...\n\n\nf.bedrooms.facet.range.spec=1..*,2..*,3..*,4..*\nf.bedrooms.facet.range.labels=\"One or more\",\"Two or more\",\"Three or more\",\"Four or more\"\n\n\n\n\n\tHerman commented...\n\n\n\nWhile using fact.query allows us to construct arbitrary ranges, we must then pick them out of the results separately. This becomes more difficult if we arbitrarily facet on two or more fields/expressions. \n\nI don't see that as being particularly hard problem that we need to worry about helping users avoid,  Especially since users can anotate those queries using localparams and set any arbitrary key=val pairs on them that you want to help organize them and identify them later when parsing the response...\n\n\nfacet.query={!group=bed label=\"One or more\"}bedrooms:[1 TO *]\nfacet.query={!group=bed label=\"Two or more\"}bedrooms:[2 TO *]\nfacet.query={!group=bed label=\"Three or more\"}bedrooms:[3 TO *]\nfacet.query={!group=bed label=\"Four or more\"}bedrooms:[4 TO *]\nfacet.query={!group=size label=\"Small\"}sqft:[* TO 1000]\nfacet.query={!group=size label=\"Medium\"}sqft:[1000 TO 2500]\nfacet.query={!group=size label=\"Large\"}sqft:[2500 TO *]\n\n\n\n "
        },
        {
            "author": "Jan H\u00f8ydahl",
            "id": "comment-13015216",
            "date": "2011-04-03T20:58:54+0000",
            "content": "If you want \"everything before\" and/or \"everything after\" use facet.range.include=before and/or facet.range.include=after .. otherwise it would be confusing to decide what things like facet.range.include=before&facet.range.seq=*,10,20 and facet.range.include=none&facet.range.seq= * ,10,20 mean.\n\nI think you meant facet.range.other=before/after, not facet.range.include=before/after - see, the syntax is confusing \n\nGuess my main point with the examples was to suggest that a facet.range.spec should not require facet.range.start and facet.range.end, but that the first and last values in the spec list should be taken as start and end, instead of requiring start and end in addition. In my opinion\n\nfacet.range.spec=0,5,25,50,100,200,400\n\n\n\nis more fluent and easy to read that the first and last buckets will be 0-5 and 200-400, than with\n\nfacet.range.spec=5,25,50,100,200\nfacet.range.start=0\nfacet.range.end=400\n\n\n\nand when talking about before/after,\n\nfacet.range.spec=0,5,25,50,100,200,400,*\n\n\n\nis in my mind better than\n\nfacet.range.spec=5,25,50,100,200\nfacet.range.start=0\nfacet.range.end=400\nfacet.range.other=after\n\n\n\nSimply document that facet.range.spec is mutually exclusive to the parameters gap,start,end and other.\n\nI REALLY don't think we should try to implement something like Jan's facet.range.labels suggestion\n\nSure, this is not a priority since it's possible with facet.query\n\n+1 on concentrating on a simple \"spec\" or \"sequence\" feature in some flavour "
        },
        {
            "author": "Robert Muir",
            "id": "comment-13043759",
            "date": "2011-06-03T16:46:55+0000",
            "content": "Bulk move 3.2 -> 3.3 "
        },
        {
            "author": "Hoss Man",
            "id": "comment-13055793",
            "date": "2011-06-27T22:00:34+0000",
            "content": "Guess my main point with the examples was to suggest that a facet.range.spec should not require facet.range.start and facet.range.end, but that the first and last values in the spec list should be taken as start and end, instead of requiring start and end in addition. ...\n\nSimply document that facet.range.spec is mutually exclusive to the parameters gap,start,end and other.\n\nI respect your argument, but i think if this new \"spec\" param is going to be mutually exclusive of facet.range.other as well as all of the existing mandatory facet.range params (facet.range.gap, facet.range.start, and facet.range.end) then it seems like what you're describing really shouldn't be an extension of \"facet.range\" at all ... it sounds should be some completley distinct type of faceting (\"sequence faceting\" ?) with it's own params and section in the response.  ie...\n\n\nfacet.seq=fieldName\nf.fieldName.facet.seq.spec=0,5,25,50,100,200,400,*\nf.fieldName.facet.seq.include=edge\n\n\n\n(where facet.seq.include has same semantics as facet.range.include ... except i don't think \"edge\" makes sense at all w/o the \"other\" param concept ... need to think it through more)\n\nOtherwise it could get really confusing for users trying to udnerstandwhat \"facet.range.*\" params do/don't make sense if they start using facet.range.gap and then switch to facet.range.spec (or vice-versa)  ... ie: \"how come i'm not getting the before/after ranges when i use 'facet.range.spec=0,5,25,50&facet.range.other=after' ?\")\n "
        },
        {
            "author": "Jan H\u00f8ydahl",
            "id": "comment-13056337",
            "date": "2011-06-28T06:32:43+0000",
            "content": "I disagree that this is a fundamentally different feature requring its own plugin. It's simply an alternative way of specifying the gaps for range facet. I won't mind working through the documentation to describe clearly how facet.range.spec interacts with the other params, and also implement a parameter check which throws an exception if the user supplies incompatible params.\n\nWhat do others think? "
        },
        {
            "author": "Jan H\u00f8ydahl",
            "id": "comment-13092956",
            "date": "2011-08-29T16:25:36+0000",
            "content": "I've attempted a possible documentation of the facet.range.spec param as I envision it, at http://wiki.apache.org/solr/VariableRangeGaps "
        },
        {
            "author": "Hoss Man",
            "id": "comment-13099315",
            "date": "2011-09-07T21:07:05+0000",
            "content": "Jan: i took a look at r3 of your VariableRangeGaps wiki, here are the things I'm concerned about because they seem a bit confusing/ambiguious....\n\n1) we need to decide what the behavior should be when the spec identifies values out of order (ie: 10, 50, 30) ... it might be tempting to say \"allow them, and swap the values\" (ie: \"10-50, 30-50\") but the merit of that approach doesn't seem worth the potential risk of silently hiding errors (ie: if the user made a typo and ment \"10-50, 50-130\") not to mention it could be really hard to understand what's going on in the case where some values are specified absolutely and some are specified as incriments (see bullet #3 in my \"02/Apr/11 23:43\" comment above \u2013 ie: what ranges would we produce for 10,20,+50,+100,120,150 ?).  \n\nI would suggest define any case where the spec contains absolute value N after (effective) value M where N < M as an error and fail fast.  \n\nStill not sure what (if anything) should be done about overlapping ranges that appear out of order (ie: 0,100,50..90,150 ... is that \"0-100,50-90,90-150\" ?)\n\n2) Independent of my opinion on the * syntax, I'm a little concerned by the descrepency in these examples...\n\n\nfacet.range.spec=*,10,50,100,250,* - gives 5 ranges: MIN-10, 10-50, 50-100, 100-250, 250->MAX\nfacet.range.spec=*,10,+40,+50,250,* - gives exactly the same ranges, using relative gap size\nfacet.range.spec=0,+10,50,250,* - gives ranges: 0-10, 10-20, 20-30, 30-40, 40-50, 20-250, 250-MAX\nfacet.range.spec=0,10,50,+50,+100,* - gives ranges: 0-10, 10-50, 50-100, 100-200, 200-300 repeating until max\n\n\n\nThe first three examples suggest that * will be treated as \"-Infinity\" and \"+Infinity\" based on position (ie: the first and last ranges will be unbounded on one end) but in the last example the wording \"...100-200, 200-300 repeating until max\" seems inconsistent with that.  \n\nIn general, i'm concerned about providing a feature that would attempt to produce an infinite number of range queries, but even if that is intentional/acceptible the discrepency in syntax bothers me \u2013 I would suggest that that sequence should result in the ranges \"0-10, 10-50, 50-100, 100-200, 200-Infinity\"\n\nIf we want to support the idea of \"repeat the last increment continuously\" that should be with it's own \"repeat\" syntax such as the \"...\" (three dots) i suggested in comment \"17/Feb/11 23:50\" above.  I would argue that this should only be legal after an increment and before a concrete value (ie: 0,+10,...,100).  Requiring it to follow an increment seems like a given (otherwise what exactly are you repeating?) requiring that it be followed by an absolute value is based on my concern that if it's the last item in the spec (or the last item before *) it results in an infinite number of ranges.\n\n3) The final comment on the page says (in section about facet.range.spec) ...\n\n\nThis parameter can be combined with facet.range.include, but is mutually exclusive to facet.range.gap, facet.range.begin, facet.range.end and facet.range.other, resulting in an exception if uncompatible mix is attempted. \n\nThat seems like it isn't specific enough about what is/isn't going to be allowed \u2013 particularly since all of the facet.range params can be specified on a per field basis.  \n\nImagine an index of \"historic people\" docs that provides range faceting on a bunch of date fields for significant milestones using common facet.range.start, facet.range.end, facet.range.gap params - and the solr admin wants to add \"facet.range=height\" and a \"f.height.facet.range.spec\" param....  \n\n\nfacet.range=birth_date\nfacet.range=first_notable_historic_event\nfacet.range=last_notable_historic_event\nfacet.range=death_date\nfacet.range.start=1500-01-01T00:00:00Z\nfacet.range.end=NOW/YEAR+1YEAR\nfacet.range.hardend=false\nfacet.range.gap=+10YEARS\nfacet.range=height\nf.height.facet.range.spec=*,100,+10,...,300,*\n\n\n\n...that should be a totally legal usecase right? to mix and match this way?  but how will the code behave?  Technically the \"height\" field has both a facet.range.spec and facet.range.start params specified and there is no way to \"unset\" the default facet.range.start/facet.range.end/facet.range.gap params in the context of the \"height\" field \n\n4) Related to the same sentence as #3, it says that facet.range.include can be used with facet.range.spec, but it doesn't explain how it will be interpreted \u2013 this is kind of important since values like \"outer\" define how the \"before\" and \"after\" ranges are affected, and values like \"edge\" affect the \"first\" and \"last\" \"gap ranges\".  \n\nShould all ranges produced by facet.range.spec be considered \"gap\" ranges?  even the ones with no lower/upper bound?   \n\nWhat would the following combination mean...\n\n\nfacet.range.spec=100,150,200,250*\nfacet.range.include=outer\nfacet.range.include=edge\n\n\n\n\n\tAre \"100\" and \"250\" considered \"edge\" boundaries?\n\tIs \"250\" considered an \"outer\" boundery (on the equivilent of an \"after\" range) ?\n\n\n\nWhat about when the spec includes overlapping ranges?\n\n\nfacet.range.spec=50..150,100..200,150,*\nfacet.range.include=outer\nfacet.range.include=edge\n\n\n\n\n\tIs \"200\" an \"edge\" boundary?\n\tIs \"150\" an \"outer\" boundary?\n\n\n "
        },
        {
            "author": "Jan H\u00f8ydahl",
            "id": "comment-13101152",
            "date": "2011-09-09T12:25:40+0000",
            "content": "Hoss: Good comments, which need to be decided upon, including corner cases.\n\n1)\nI would suggest define any case where the spec contains absolute value N after (effective) value M where N < M as an error and fail fast.\nAgree\n\nStill not sure what (if anything) should be done about overlapping ranges that appear out of order (ie: 0,100,50..90,150 ... is that \"0-100,50-90,90-150\" ?)\nIf all gaps are specified as explicit ranges this is no ambiguity, so we could require all gaps to be explicit ranges if one wants to use it?\n\n2) \n\nThe first three examples suggest that * will be treated as \"-Infinity\" and \"+Infinity\" based on position (ie: the first and last ranges will be unbounded on one end) but in the last example the wording \"...100-200, 200-300 repeating until max\" seems inconsistent with that.\nAgree. The 0,10,50,+50,+100,* example would create infinite gaps which would be less than desireable. But 0,10,50,+50,+100,500 would give repeating 100-gaps until upper bound 500, while 0,10,50,+50,+100,500,* would in addition give a last range 500-*. That was the intentional syntax.\n\nIf we want to support the idea of \"repeat the last increment continuously\" that should be with it's own \"repeat\" syntax such as the \"...\" (three dots) i suggested in comment \"17/Feb/11 23:50\" above. I would argue that this should only be legal after an increment and before a concrete value (ie: 0,+10,...,100). Requiring it to follow an increment seems like a given (otherwise what exactly are you repeating?) requiring that it be followed by an absolute value is based on my concern that if it's the last item in the spec (or the last item before *) it results in an infinite number of ranges.\n\nAgree. Alternatively, if Solr could compute myField.max(), the useful value of \"*\" could be computed a bit smarter, but that would probably be hard to scale in a multi-shard setting.\n\nThat seems like it isn't specific enough about what is/isn't going to be allowed \u2013 particularly since all of the facet.range params can be specified on a per field basis.\n\nDidn't really think much about the global params. Silently not caring about gap, begin, end, other would be one way to go, but then the error feedback is not explicit in case of misunderstanding; the user will see that he does not get back what he thought, and start reading the documentation \n\nI have no good answer to this, other than inventing some syntax. The default could be that facet.range.spec respects the global values for start and end, but also allow explicitly overriding start and end values as part of spec with a special syntax.\nThe following params would result in ranges 0-1, 1-2, 2-3, 3-5, 5-10 :\n\nfacet.range.start=0\nfacet.range.end=10\nfacet.range.gap=2\nf.bedrooms.facet.range.spec=1,2,3,5\n\n\n\nBut these params would result in the same ranges because we specify start and end with a special syntax N.. for start and ..M for end:\n\nfacet.range.start=100\nfacet.range.end=200\nfacet.range.gap=10\nf.bedrooms.facet.range.spec=0..,1,2,3,5,..10\n\n\n\nThis would be equivalent with adding the two params f.bedrooms.facet.range.start=0&f.bedrooms.facet.range.end=10, which could then still be allowed as an alternative. If the first value of the spec is not an N.., we'll require a facet.range.start. If the last value of the spec is not ..M, we'll require facet.range.end.\n\nAlso, it must not be allowed to specify both a global facet.range.gap and a global facet.range.spec.\n\nWould this be a good \"compromise\"?  My primary reason for suggesting this is to give users a terse, intuitive syntax for ranges.\n\n4)\nShould all ranges produced by facet.range.spec be considered \"gap\" ranges? even the ones with no lower/upper bound?\nGood question. I think the values facet.range.include=upper/lower is clear. Outer/edge would need some more work/definition. "
        },
        {
            "author": "Jan H\u00f8ydahl",
            "id": "comment-13101185",
            "date": "2011-09-09T12:55:37+0000",
            "content": "I've given the Wiki page another take, with the new proposed start/end syntax and added an example or two. The \"mutually exclusive\" sentence now boils down to facet.range.gap/facet.range.spec being mutually exclusive (one the same field). Have a look at http://wiki.apache.org/solr/VariableRangeGaps#facet.range.spec "
        },
        {
            "author": "Jan H\u00f8ydahl",
            "id": "comment-13101192",
            "date": "2011-09-09T13:06:38+0000",
            "content": "Here's Grant's original syntax proposal which is removed from issue description to avoid confusion:\n\n\nI'd propose the syntax to be a comma separated list of sizes for each bucket.  If only one value is specified, then it behaves as it currently does.  Otherwise, it creates the different size buckets.  If the number of buckets doesn't evenly divide up the space, then the size of the last bucket specified is used to fill out the remaining space (not sure on this)\nFor instance,\nfacet.range.start=0\nfacet.range.end=400\nfacet.range.gap=5,25,50,100\n\nwould yield buckets of:\n0-5,5-30,30-80,80-180,180-280,280-380,380-400 "
        },
        {
            "author": "Jan H\u00f8ydahl",
            "id": "comment-13101204",
            "date": "2011-09-09T13:35:46+0000",
            "content": "One thing this improvement needs to tackle is how to return the range buckets in the Response. It will not be enough with the simple range_facet format\n\n<lst name=\"facet_ranges\">\n  <lst name=\"url_length\">\n    <lst name=\"counts\">\n      <int name=\"42\">1</int>\n      <int name=\"45\">1</int>\n      <int name=\"51\">1</int>\n      <int name=\"66\">1</int>\n    </lst>\n    <int name=\"gap\">3</int>\n    <int name=\"start\">0</int>\n    <int name=\"end\">102</int>\n  </lst>\n</lst>\n\n\n\nWe need something which can return the explicit ranges, similar to what facet_queries has. This format can then be used for the old plain gap format as well.\n\n\n<lst name=\"facet_ranges\">\n  <lst name=\"url_length\">\n    <lst name=\"counts\">\n      <int name=\"[42 TO 45}\">1</int>\n      <int name=\"[45 TO 48}\">1</int>\n      <int name=\"[51 TO 54}\">1</int>\n      <int name=\"[66 TO 69}\">1</int>\n    </lst>\n    <int name=\"gap\">3</int>\n    <int name=\"start\">0</int>\n    <int name=\"end\">102</int>\n  </lst>\n  <lst name=\"bedrooms\">\n    <lst name=\"counts\">\n      <int name=\"[1 TO *]\">12</int>\n      <int name=\"[2 TO *]\">31</int>\n      <int name=\"[3 TO *]\">26</int>\n      <int name=\"[4 TO *]\">9</int>\n    </lst>\n    <int name=\"spec\">1..*,2..*,3..*,4..*</int>\n    <int name=\"include\">all</int>\n  </lst>\n</lst>\n\n "
        },
        {
            "author": "Robert Muir",
            "id": "comment-13106361",
            "date": "2011-09-16T14:50:45+0000",
            "content": "3.4 -> 3.5 "
        },
        {
            "author": "Hoss Man",
            "id": "comment-13124591",
            "date": "2011-10-11T00:10:23+0000",
            "content": "\nJan: I've got to be completely honest here \u2013 catching up on this issue, I got really confused and lost by some of your comments and the updated docs.\n\nThis sequence of comments really stands out at me...\n\n\nI have no good answer to this, other than inventing some syntax.\n...\nI think the values facet.range.include=upper/lower is clear. Outer/edge would need some more work/definition.\n...\nMy primary reason for suggesting this is to give users a terse, intuitive syntax for ranges.\n...\nOne thing this improvement needs to tackle is how to return the range buckets in the Response. It will not be enough with the simple range_facet format ... We need something which can return the explicit ranges,\n\n(emphasis added by me)\n\nI really liked the simplicity of your earlier proposal, and I agree that it would be really powerful/helpful to give users a terse, intuitive syntax for specifying sequential ranges of variable sizes \u2013 but it seems like we're really moving away from the syntax being \"intuitive\" because of the hoops you're having to jump through to treat this as an extension of the existing \"facet.range\" param in your design.\n\nI think we really ought to revisit my earlier suggestion to approach this as an entirely new \"type\" of faceting - not a new plugin or a contrib, but a new first-class type of faceting that FacetComponent would support, right along side facet.field, facet.query, and facet.range.  Let's ignore everything about the existing facet.range.* param syntax, and the facet_range response format, and think about what makes the most sense for this feature on it's own.  If there are ideas from facet.range that make sense to carry over (like facet.range.include) then great \u2013 but let's approach it from the \"something new that can borrow from facet.range\" standpoint instead of the \"extension to facet.range that has a bunch of caveats with how facet.range already works\"\n\nI mean: if it looks like a duck, walks like a duck, and quacks like a duck, then i'm happy to call it a duck \u2013 but in this case:\n\n\tdoesn't make sense with facet.range.other\n\tneeds special start/end syntax to play nice with facet.range.start/end\n\tneeds to change the response format\n\n\n\n...ie: it doesn't look the same, it doesn't walk the same, and it doesn't quack.\n\n\u2014\n\nRegardless of whether this functionality becomes part of facet.range or not, I wanted to comment specifically on this idea...\n\nIf all gaps are specified as explicit ranges this is no ambiguity, so we could require all gaps to be explicit ranges if one wants to use it?\n\nThis seems like a really harsh limitation to impose.  If the only way to use an explicit range is in use cases where you only use explicit ranges, then what value add does this feature give you over just using multiple facet.query params? (it might be marginally fewer characters, but multiple facet.query params seem more intuitive and easier to read).  I mean: I don't have a solution to propose, it just seems like there's not much point in supporting explicit ranges in that case.\n\n\u2014\n\nHaving not thought about this issue in almost a month, and revisiting it with (fairly) fresh eyes, and thinking about all the use cases that have been discussed, it seems like the main goals we should address are really:\n\n\n\tan intuitive syntax for specifying end points for ranges of varying sizes\n\tability to specify range end points using either fixed values or increments\n\tability to specify that ranges should be either use sequential end points, or be overlapping relative some fixed min/max value\n\n\n\nIn other words: the only reason (that i know of) why overlapping ranges even came up in this issue was use cases like...\n\n\n   Price: $0-10, $0-20, $0-50, $0-100\n   Date: NOW-1DAY TO NOW, NOW-1MONTH TO NOW, NOW-1YEAR TO NOW\n\n\n\n...there doesn't seem to be a lot of motivations for using overlapping ranges in the \"middle\" of a sequence, and these types of use cases where all the ranges overlap seem just as important as use cases where the ranges don't overlap at all...\n\n\n   Price: $0-10, $10-20, $20-50, $50-100\n   Date: NOW-1DAY TO NOW, NOW-1MONTH TO NOW-1DAY, NOW-1YEAR TO NOW-1MONTH\n\n\n\n...so let's try to focus on a syntax that makes both easy, using both fixed and relative values, w/o worrying about supporting arbitrary overlapping ranges (since I can't think of a use case for it, and it could always be achieved using facet.query)\n\nSo how about something like...\n\n\n facet.sequence=<fieldname>\n facet.sequence.spec=[<wild>,]?<val>,<relval>[,<relval>]*[,<wild>]?\n facet.sequence.type=[before|after|between]\n facet.sequence.include=(same as facet.range.include)\n\n\n\nWhere \"relval\" would either be a concrete value, or a relative value; the effective sequence has to either increase or decrease consistently or it's an error; and \"facet.sequence.type\" determines whether the ranges are overlapping (\"before\" and \"after\") or not (\"between\")\n\nSo if you had a spec like this...\n\n facet.sequence.spec=0,10,+10,50,+50\n\n\n\nThen depending on facet.sequence.type you could either get...\n\n\n facet.sequence.type=after\n     Price: $0-10, $0-20, $0-50, $0-100\n facet.sequence.type=between\n     Price: $0-10, $10-20, $20-50, $50-100\n facet.sequence.type=before\n     Price: $0-100, $10-100, $20-100, $50-100\n\n\n\n\"*\" could be used at the start or end to indicate that you wanted an unbounded range, but it wouldn't be a factor in determining the \"fixed point\" used if type was \"after\" or \"before\", ie...\n\n\n f.price.facet.sequence.spec=*,0,10,+10,50,+50,*\n f.created.facet.sequence.spec=NOW,-1DAY,-1MONTH,-1YEAR\n\n facet.sequence.type=after\n     Price: below $0, $0-10, $0-20, $0-50, $0-100, $100 and up\n     Created: NOW-1YEAR TO NOW, NOW-1YEAR TO NOW-1DAY, NOW-1YEAR TO NOW-1MONTH\n facet.sequence.type=between\n     Price: below $0, $0-10, $10-20, $20-50, $50-100, $100 and up\n     Created: NOW-1DAY TO NOW, NOW-1MONTH TO NOW-1DAY, NOW-1YEAR TO NOW-1MONTH\n facet.sequence.type=before\n     Price: below $0, $0-100, $10-100, $20-100, $50-100, $100 and up\n     Created: NOW-1DAY TO NOW, NOW-1MONTH TO NOW, NOW-1YEAR TO NOW\n\n\n\n...if we defined things that way, i think that would simplify a lot of the complexity we've been talking about, and simplify some of the use cases.\n\nthe only remaining issues that have been brought up (that i can think of) that would still need to be work out would be:\n\n1) what the response format needs to look like - I'd vote to punt on this until we figure out the semantics.\n\n2) when exactly ranges are inclusive/exclusive of their endpoints - i think we should be able reuse the semantics from facet.range.include here, including \"edge\", if we define ranges involving \"*\" as \"outer\" ranges, but we'd need to work through more scenarios to be sure.\n\n3) what happens if an increment overlaps with an absolute value, ie: my original example of \"10,20,+50,+100,120,150\".  The three possible solutions I can think of are:\n\n\n\tfail loudly\n\timplement \"precedence\" rules, ie: that absolute values trump relative values (10-20,20-70,70-120,120-150) or vice-versa (10-20,20-70,70-170)\n\timplement precedence rules but let them be controlled via a request param (similar to how \"facet.range.hardend\" works)\n\n\n\n\u2014\n\nWhat do you think?  Are there any key use cases / features we've talked about that you think this approach overlooks?  Do you still think it should really be an extension to \"facet.range\" ?\n "
        },
        {
            "author": "Hoss Man",
            "id": "comment-13234647",
            "date": "2012-03-21T18:08:43+0000",
            "content": "Bulk of fixVersion=3.6 -> fixVersion=4.0 for issues that have no assignee and have not been updated recently.\n\nemail notification suppressed to prevent mass-spam\npsuedo-unique token identifying these issues: hoss20120321nofix36 "
        },
        {
            "author": "Jan H\u00f8ydahl",
            "id": "comment-13243611",
            "date": "2012-03-31T23:51:48+0000",
            "content": "Note to self: catch up on this again  "
        },
        {
            "author": "Mandar",
            "id": "comment-13418298",
            "date": "2012-07-19T14:00:06+0000",
            "content": "\tI have tried using the price range facet with three different ways, but was not able to get it working for variable gaps\n\n\t1) select/?q=%3A&facet=true&facet.query=minPrice:[*+TO+500]&facet.query=minPrice:[500+TO+*]\n\n\tReturns \n\t<lst name=\"facet_queries\">\n\t\t<int name=\"minPrice:[* TO 500]\">122</int>\n\t\t<int name=\"minPrice:[500 TO *]\">5722</int>\n\t</lst>\n\n\t2) /select?q=%3A&wt=xmlfacet=true&facet.field=minPrice&facet.range=minPrice&f.minPrice.facet.range.start=0&f.minPrice.facet.range.end=10000&f.minPrice.facet.range.gap=1000\n\t<lst name=\"minPrice\">\n\t\t<lst name=\"counts\">\n\t\t<int name=\"0\">522</int>\n\t\t<int name=\"1000\">1204</int>\n\t\t<int name=\"2000\">1077</int>\n\t\t<int name=\"3000\">817</int>\n\t\t<int name=\"4000\">563</int>\n\t\t<int name=\"5000\">302</int>\n\t\t<int name=\"6000\">245</int>\n\t\t<int name=\"7000\">324</int>\n\t\t<int name=\"8000\">112</int>\n\t\t<int name=\"9000\">200</int>\n\t</lst>\n\n\t3) /select?q=%3A&wt=xmlfacet=true&facet.field=minPrice&facet.range=minPrice&f.minPrice.facet.range.start=0&f.minPrice.facet.range.end=10000&f.minPrice.facet.range.gap=1000&facet.range.spec=0,1000,3000,5000\n\n\tThere is no error, facet.range.spec with facet.range doesn't come back with expected facet results as above.\n\tTried using version 3.6 & 4 alpha \n\n\tIs there anything wrong with my query, for using range.spec\n\n\tI have even tried using f.minPrice.facet.range.gap=1000,2000,3000 and get parse error.\n\n\tOr is range.spec not a part of these versions. "
        },
        {
            "author": "Jan H\u00f8ydahl",
            "id": "comment-13419105",
            "date": "2012-07-20T12:59:32+0000",
            "content": "Mandar, since this patch is Unresolved, the feature is not part of any version (yet), there are only patches attached, which may not apply cleanly if they are old. "
        },
        {
            "author": "Markus Jelsma",
            "id": "comment-13580598",
            "date": "2013-02-18T13:15:42+0000",
            "content": "Any reason why this issue is off the radar? "
        },
        {
            "author": "Jeroen Steggink",
            "id": "comment-13626639",
            "date": "2013-04-09T14:16:50+0000",
            "content": "I'm also very interested in a variable range gap feature. "
        },
        {
            "author": "Otis Gospodnetic",
            "id": "comment-13697472",
            "date": "2013-07-02T03:42:39+0000",
            "content": "Markus Jelsma:\n\nAny reason why this issue is off the radar?\n\nBecause it's old, received a lot of attention, a lot of very verbose comments that are probably good, but hard for people to read/focus/understand, yet it wasn't committed when it was a hot topic and so it remains in status quo. Maybe Chris Hostetter (Unused) and Jan H\u00f8ydahl have the power to get this committed.  It does sounds like a very useful feature. "
        },
        {
            "author": "Steve Rowe",
            "id": "comment-13717397",
            "date": "2013-07-23T18:48:07+0000",
            "content": "Bulk move 4.4 issues to 4.5 and 5.0 "
        },
        {
            "author": "solr-user",
            "id": "comment-13833070",
            "date": "2013-11-26T21:07:52+0000",
            "content": "We are very interested in the gap feature as well.  We implemented some custom code to do this for solr 1.4x but havent updated the code to 4.5x (and probably wont do so for quite some time). "
        },
        {
            "author": "Benjamin Brandmeier",
            "id": "comment-13833604",
            "date": "2013-11-27T09:25:36+0000",
            "content": "I'm also interested in this. Currently I'm using lots of facet.query parameters. It works like that, however, I guess it could be done simpler and maybe even more performant with multiple range gap values. "
        },
        {
            "author": "Ted Sullivan",
            "id": "comment-13880220",
            "date": "2014-01-23T18:57:54+0000",
            "content": "At the very least, we should revise the discussion of this feature on the SimpleFacetParameters Wiki page. The Wiki page does contain a disclaimer \"The following section on variable width gaps discusses uncommitted code\" but the comment is anchored to \"Solr 3.6, Solr4.0\" so person might reasonably expect that it has been released by now (Solr 4.6).   "
        },
        {
            "author": "Ted Sullivan",
            "id": "comment-13881567",
            "date": "2014-01-25T00:49:09+0000",
            "content": "Updated the patch to the current svn trunk. The old patch does not work anymore because the paths have changed since this was uploaded.  "
        },
        {
            "author": "Shalin Shekhar Mangar",
            "id": "comment-13881667",
            "date": "2014-01-25T05:33:35+0000",
            "content": "Thanks Ted. \n\nI think that just having facet.range.gap accept multiple values is a good improvement to start with. We can spin it off to a new issue and commit it. It is clear that implementing the full facet.sequence.* feature is a bigger discussion and will happen when someone has the time and inclination. We should not stop this small improvement in the wait for the bigger.\n\nDoes anyone have any objections on committing Grant/Ted's patch?\nAttn: Hoss Man, Jan H\u00f8ydahl, Grant Ingersoll "
        },
        {
            "author": "Grant Ingersoll",
            "id": "comment-13881921",
            "date": "2014-01-25T15:22:14+0000",
            "content": "No objections from me, I'll defer to your review, Shalin Shekhar Mangar "
        },
        {
            "author": "Ted Sullivan",
            "id": "comment-13881953",
            "date": "2014-01-25T17:20:15+0000",
            "content": "I agree with Jan H\u00f8ydahl's earlier comment (9/Sep/11):\n\n\n\n\n One thing this improvement needs to tackle is how to return the range buckets in the Response\n\n\n\n\n\nAs is done in facet.query.  Unless we do this, the response is a bit too cryptic. I would vote for adding this code before committing it (I'll volunteer) and spinning off the facet.range.spec or facet.sequence idea to a new issue as Shalin suggests. So for a facet.range.start=0, facet.range.end=1000, facet.range.gap=10,90,900 the labels would be as Jan suggests: [0 TO 10}, [10 TO 100}, [100 TO 1000}. This would be done even if the gaps are constant. As it is now, all you see in the response are the range starts rather than the ranges. "
        },
        {
            "author": "Jan H\u00f8ydahl",
            "id": "comment-13882719",
            "date": "2014-01-27T09:55:01+0000",
            "content": "So for a facet.range.start=0, facet.range.end=1000, facet.range.gap=10,90,900 the labels would be as Jan suggests: [0 TO 10}, [10 TO 100}, [100 TO 1000}.\n\nTed Sullivan, I am not in favor of a list of relative gaps, I think it is user unfriendly. That's why I suggested a new facet.range.spec or something like Hoss' facet.range.buckets. But if you for some reason wish to extend the \"gap\" parameter, I guess it needs to remain relative gaps since that is kind of implied in the wording? "
        },
        {
            "author": "Ted Sullivan",
            "id": "comment-13882890",
            "date": "2014-01-27T15:33:40+0000",
            "content": "Right. I'm following with Shalin Shekhar Mangar suggestion to split out your/Hoss's facet.range.spec / facet.sequence idea as a separate issue. I don't think of this as extending the gap parameter - I am just providing more explicit information in the response as to what gaps you actually get (as per your suggestion of Sept/2011) - similar to what you would get if you implemented this using facet.query. Looking at the current code, it is pretty easy to add the range information to the response (right now the response labels are just the gap starts). This may be user-unfriendly as you say, but I would argue that it is more friendly than what we have right now - it is certainly more developer-friendly because it provides better feedback. There is a lot of interest in this feature (it has been advertised on the SimpleFacetsParameter Wiki for some time now) as evidenced by earlier comments in this thread. My original desire was just to make (the patch) usable for those that want to use it by upgrading Grant's original patch so that it would work with the new modular class organization. The work required to spiff up the facet.range.gap response is not large. I haven't impacted the facet.range.spec/buckets approach but that would seem to require more effort. "
        },
        {
            "author": "Grant Ingersoll",
            "id": "comment-13885250",
            "date": "2014-01-29T11:23:45+0000",
            "content": "+1 on splitting out and moving forward.  FWIW, I think the gaps are user friendly, as I just think about what size should my gaps be.  Since no one has stepped up on the other capabilities, I would suggest we move forward on what we have working now.   "
        },
        {
            "author": "Uwe Schindler",
            "id": "comment-13971074",
            "date": "2014-04-16T12:57:05+0000",
            "content": "Move issue to Solr 4.9. "
        },
        {
            "author": "Tom\u00e1s Fern\u00e1ndez L\u00f6bbe",
            "id": "comment-14074116",
            "date": "2014-07-25T06:01:56+0000",
            "content": "I didn't see this Jira before (just saw this now that I was updating the faceting wiki). Part of what's described here can be achieved by Interval Faceting (SOLR-6216). Implementation is different though, because it relies in DocValues instead of filters. "
        },
        {
            "author": "Erick Erickson",
            "id": "comment-14359890",
            "date": "2015-03-13T03:42:43+0000",
            "content": "I don't think this ever got committed, but the ref guide and Wiki page documents this feature! We need to either commit this or change the docs.... Or I'm missing something.\n\nTom\u00e1s Fern\u00e1ndez L\u00f6bbe do you have any idea what the status is here? "
        },
        {
            "author": "Jan H\u00f8ydahl",
            "id": "comment-14360040",
            "date": "2015-03-13T07:22:48+0000",
            "content": "Guess interval facets cover this now? Resolve as Won't fix? "
        },
        {
            "author": "Tom\u00e1s Fern\u00e1ndez L\u00f6bbe",
            "id": "comment-14360486",
            "date": "2015-03-13T15:14:16+0000",
            "content": "Yes, I think most of what's described here is achieved by interval faceting. Shalin Shekhar Mangar You have this Jira assigned to you, I can close this as Won't Fix unless you are planning any more work here?\n\n\nhttps://cwiki.apache.org/confluence/display/solr/Faceting#Faceting-IntervalFaceting "
        },
        {
            "author": "Shalin Shekhar Mangar",
            "id": "comment-14360516",
            "date": "2015-03-13T15:34:26+0000",
            "content": "Please go ahead. I have no plans for this right now. "
        }
    ]
}