{
    "id": "SOLR-6875",
    "title": "No data integrity between replicas",
    "details": {
        "components": [],
        "type": "Bug",
        "labels": "",
        "fix_versions": [],
        "affect_versions": "4.10.2",
        "status": "Open",
        "resolution": "Unresolved",
        "priority": "Major"
    },
    "description": "Setup: SolrCloud with 2 shards, each with 2 replicas, 4 nodes in total.\n\nIndexing is stopped, one replica of a shard (Solr1) shows 45 574 039 docs, and another (Solr1.1) 45 574 038 docs.\n\nSolr1 is the leader, these errors appeared in the logs:\n\nERROR - 2014-12-20 09:54:38.783; org.apache.solr.update.StreamingSolrServers$1; error\njava.net.SocketException: Connection reset\n        at java.net.SocketInputStream.read(SocketInputStream.java:196)\n        at java.net.SocketInputStream.read(SocketInputStream.java:122)\n        at org.apache.http.impl.io.AbstractSessionInputBuffer.fillBuffer(AbstractSessionInputBuffer.java:160)\n        at org.apache.http.impl.io.SocketInputBuffer.fillBuffer(SocketInputBuffer.java:84)\n        at org.apache.http.impl.io.AbstractSessionInputBuffer.readLine(AbstractSessionInputBuffer.java:273)\n        at org.apache.http.impl.conn.DefaultHttpResponseParser.parseHead(DefaultHttpResponseParser.java:140)\n        at org.apache.http.impl.conn.DefaultHttpResponseParser.parseHead(DefaultHttpResponseParser.java:57)\n        at org.apache.http.impl.io.AbstractMessageParser.parse(AbstractMessageParser.java:260)\n        at org.apache.http.impl.AbstractHttpClientConnection.receiveResponseHeader(AbstractHttpClientConnection.java:283)\n        at org.apache.http.impl.conn.DefaultClientConnection.receiveResponseHeader(DefaultClientConnection.java:251)\n        at org.apache.http.impl.conn.ManagedClientConnectionImpl.receiveResponseHeader(ManagedClientConnectionImpl.java:197)\n        at org.apache.http.protocol.HttpRequestExecutor.doReceiveResponse(HttpRequestExecutor.java:271)\n        at org.apache.http.protocol.HttpRequestExecutor.execute(HttpRequestExecutor.java:123)\n        at org.apache.http.impl.client.DefaultRequestDirector.tryExecute(DefaultRequestDirector.java:682)\n        at org.apache.http.impl.client.DefaultRequestDirector.execute(DefaultRequestDirector.java:486)\n        at org.apache.http.impl.client.AbstractHttpClient.doExecute(AbstractHttpClient.java:863)\n        at org.apache.http.impl.client.CloseableHttpClient.execute(CloseableHttpClient.java:82)\n        at org.apache.http.impl.client.CloseableHttpClient.execute(CloseableHttpClient.java:106)\n        at org.apache.http.impl.client.CloseableHttpClient.execute(CloseableHttpClient.java:57)\n        at org.apache.solr.client.solrj.impl.ConcurrentUpdateSolrServer$Runner.run(ConcurrentUpdateSolrServer.java:233)\n        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1145)\n        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:615)\n        at java.lang.Thread.run(Thread.java:744)\nWARN  - 2014-12-20 09:54:38.787; org.apache.solr.update.processor.DistributedUpdateProcessor; Error sending update\njava.net.SocketException: Connection reset\n        at java.net.SocketInputStream.read(SocketInputStream.java:196)\n        at java.net.SocketInputStream.read(SocketInputStream.java:122)\n        at org.apache.http.impl.io.AbstractSessionInputBuffer.fillBuffer(AbstractSessionInputBuffer.java:160)\n        at org.apache.http.impl.io.SocketInputBuffer.fillBuffer(SocketInputBuffer.java:84)\n        at org.apache.http.impl.io.AbstractSessionInputBuffer.readLine(AbstractSessionInputBuffer.java:273)\n        at org.apache.http.impl.conn.DefaultHttpResponseParser.parseHead(DefaultHttpResponseParser.java:140)\n        at org.apache.http.impl.conn.DefaultHttpResponseParser.parseHead(DefaultHttpResponseParser.java:57)\n        at org.apache.http.impl.io.AbstractMessageParser.parse(AbstractMessageParser.java:260)\n        at org.apache.http.impl.AbstractHttpClientConnection.receiveResponseHeader(AbstractHttpClientConnection.java:283)\n        at org.apache.http.impl.conn.DefaultClientConnection.receiveResponseHeader(DefaultClientConnection.java:251)\n        at org.apache.http.impl.conn.ManagedClientConnectionImpl.receiveResponseHeader(ManagedClientConnectionImpl.java:197)\n        at org.apache.http.protocol.HttpRequestExecutor.doReceiveResponse(HttpRequestExecutor.java:271)\n        at org.apache.http.protocol.HttpRequestExecutor.execute(HttpRequestExecutor.java:123)\n        at org.apache.http.impl.client.DefaultRequestDirector.tryExecute(DefaultRequestDirector.java:682)\n        at org.apache.http.impl.client.DefaultRequestDirector.execute(DefaultRequestDirector.java:486)\n        at org.apache.http.impl.client.AbstractHttpClient.doExecute(AbstractHttpClient.java:863)\n        at org.apache.http.impl.client.CloseableHttpClient.execute(CloseableHttpClient.java:82)\n        at org.apache.http.impl.client.CloseableHttpClient.execute(CloseableHttpClient.java:106)\n        at org.apache.http.impl.client.CloseableHttpClient.execute(CloseableHttpClient.java:57)\n        at org.apache.solr.client.solrj.impl.ConcurrentUpdateSolrServer$Runner.run(ConcurrentUpdateSolrServer.java:233)\n        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1145)\n        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:615)\n        at java.lang.Thread.run(Thread.java:744)\nWARN  - 2014-12-20 09:54:38.813; org.apache.solr.cloud.ZkController; Leader is publishing core=crm-prod coreNodeName =10.128.209.232:8081_solr_crm-prod state=down on behalf of un-reachable replica http://10.128.209.232:8081/solr/crm-prod/; forcePublishState? false\nERROR - 2014-12-20 09:54:38.818; org.apache.solr.update.processor.DistributedUpdateProcessor; Setting up to try to start recovery on replica http://10.128.209.232:8081/solr/crm-prod/ after: java.net.SocketException: Connection reset\n\n\n\nOn Solr1.1:\n\nWARN  - 2014-12-20 09:54:38.854; org.apache.solr.cloud.RecoveryStrategy; Stopping recovery for core=crm-prod coreNodeName=10.128.209.232:8081_solr_crm-prod\n\n\n\nIndex optimization was running at that time.\n\nIt was not a system crash, the server is up and was running smoothly with a lot of available resources on board, lots of CPU, available RAM and a very fast SSD RAID. So whatever happened Solr should get recovered properly, e.g. as mysql does.",
    "attachments": {
        "replica2.png": "https://issues.apache.org/jira/secure/attachment/12739165/replica2.png",
        "replica1.png": "https://issues.apache.org/jira/secure/attachment/12739164/replica1.png"
    },
    "issue_links": {},
    "comments": [
        {
            "date": "2015-01-11T11:32:49+0000",
            "author": "Alexander S.",
            "content": "Now we have 4 shards, each with 2 replicas (8 total nodes) and the next picture:\n\nShard 1:\n  Replica 1: 14 486 089\n  Replica 2: 14 496 445\n\nShard 2\n  Replica 1: 14 496 609\n  Replica 2: 14 496 609\n\nShard 3\n  Replica 1: 14 492 812\n  Replica 2: 14 492 812\n\nShard 4\n  Replica 1: 14 488 755\n  Replica 2: 14 488 755\n\n\n\nHow could it be? We didn't see anything like that before upgrade from 4.8.1 to 4.10.2. Also we enabled checkIntegrityAtMerge, could it be the reason? ",
            "id": "comment-14272877"
        },
        {
            "date": "2015-06-12T05:23:52+0000",
            "author": "Alexander S.",
            "content": "Got another error today on 4 shards set up, each has 2 replicas (8 nodes in total).\n\nOn the shard 4/replica 1 I see the next error: replica1.png\nOn the shard 4/replica 2 the next: replica2.png\n\nHere's the backtrace for the error on the first screenshot:\n\njava.net.SocketException: Connection reset\n\tat java.net.SocketInputStream.read(SocketInputStream.java:196)\n\tat java.net.SocketInputStream.read(SocketInputStream.java:122)\n\tat org.apache.http.impl.io.AbstractSessionInputBuffer.fillBuffer(AbstractSessionInputBuffer.java:160)\n\tat org.apache.http.impl.io.SocketInputBuffer.fillBuffer(SocketInputBuffer.java:84)\n\tat org.apache.http.impl.io.AbstractSessionInputBuffer.readLine(AbstractSessionInputBuffer.java:273)\n\tat org.apache.http.impl.conn.DefaultHttpResponseParser.parseHead(DefaultHttpResponseParser.java:140)\n\tat org.apache.http.impl.conn.DefaultHttpResponseParser.parseHead(DefaultHttpResponseParser.java:57)\n\tat org.apache.http.impl.io.AbstractMessageParser.parse(AbstractMessageParser.java:260)\n\tat org.apache.http.impl.AbstractHttpClientConnection.receiveResponseHeader(AbstractHttpClientConnection.java:283)\n\tat org.apache.http.impl.conn.DefaultClientConnection.receiveResponseHeader(DefaultClientConnection.java:251)\n\tat org.apache.http.impl.conn.ManagedClientConnectionImpl.receiveResponseHeader(ManagedClientConnectionImpl.java:197)\n\tat org.apache.http.protocol.HttpRequestExecutor.doReceiveResponse(HttpRequestExecutor.java:271)\n\tat org.apache.http.protocol.HttpRequestExecutor.execute(HttpRequestExecutor.java:123)\n\tat org.apache.http.impl.client.DefaultRequestDirector.tryExecute(DefaultRequestDirector.java:682)\n\tat org.apache.http.impl.client.DefaultRequestDirector.execute(DefaultRequestDirector.java:486)\n\tat org.apache.http.impl.client.AbstractHttpClient.doExecute(AbstractHttpClient.java:863)\n\tat org.apache.http.impl.client.CloseableHttpClient.execute(CloseableHttpClient.java:82)\n\tat org.apache.http.impl.client.CloseableHttpClient.execute(CloseableHttpClient.java:106)\n\tat org.apache.http.impl.client.CloseableHttpClient.execute(CloseableHttpClient.java:57)\n\tat org.apache.solr.client.solrj.impl.ConcurrentUpdateSolrServer$Runner.run(ConcurrentUpdateSolrServer.java:233)\n\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1145)\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:615)\n\tat java.lang.Thread.run(Thread.java:744)\n\n\n\nAfter all this replica 1 shows:\n\nnumDocs: 28 215 608\n\nAnd the replica 2 shows:\n\nnumDocs: 28 215 609\n\nEverything worked well for a few months until yesterday, when we started to reindex some data (like 1.7m records).\n\nOur Solr set up is using large pages and there's enough resources. Here's how we run the instances:\n\nexec chpst -u solr java -Xms6G -Xmx8G -XX:+UseConcMarkSweepGC -XX:+UseLargePages -XX:+CMSParallelRemarkEnabled -XX:+ParallelRefProcEnabled -XX:+UseLargePages -XX:+AggressiveOpts -XX:CMSInitiatingOccupancyFraction=75 -DzkHost=zoo5.devops:2181,zoo4.devops:2181,zoo1.devops:2181,zoo2.devops:2181,zoo3.devops:2181 -Dcollection.configName=Carmen -Dbootstrap_confdir=./solr/conf -Dbootstrap_conf=true -DnumShards=4 -jar start.jar etc/jetty.xml\n\n\n\nThe server has 16 CPU cores and SSD RAID 10, the load average is between 2 and 3 usually. The charts also don't show anything suspicious in server load, it is very stable.\n\nSo seems like something went wrong during recovery after the network error. Not sure how to debug that deeper and what those warnings in the log mean, for example the last 2 messages on the first screenshot, from DistributedUpdateProcessor and CoreAdminHandler. ",
            "id": "comment-14582960"
        },
        {
            "date": "2015-06-12T16:34:46+0000",
            "author": "Erick Erickson",
            "content": "Do any of the logs on the leaders mention \"leader initiated recovery\"? And how fast are you sending documents at Solr? I've seen situations where flooding \"too many\" updates at Solr can cause some wonky behavior, there are some inefficiencies in how leaders talk to replicas, see Tim Potter's blog here: http://lucidworks.com/blog/indexing-performance-solr-5-2-now-twice-fast/\n\nThe symptom I saw was two-fold:\n1> the leader forced the follower into recovery. No errors reported on the follower, just a timeout on the leader\n2> There were a bazillion updates coming in as fast as possible, there were a lot of threads outstanding on the leader from ConcurrentUpdateSolrServer.\n\nNot saying this is your problem, but if you see something like this it'd be good to know when tracking this down. If you don't have followers going down then this isn't the issue. ",
            "id": "comment-14583657"
        }
    ]
}