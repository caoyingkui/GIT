{
    "id": "SOLR-8109",
    "title": "Option to Copy just the first value from a multivalued field",
    "details": {
        "components": [
            "Schema and Analysis"
        ],
        "type": "Improvement",
        "labels": "",
        "fix_versions": [],
        "affect_versions": "5.3",
        "status": "Open",
        "resolution": "Unresolved",
        "priority": "Major"
    },
    "description": "Provide a firstValueOnly boolean option for copyField",
    "attachments": {
        "SOLR-8109.patch": "https://issues.apache.org/jira/secure/attachment/12764446/SOLR-8109.patch"
    },
    "issue_links": {},
    "comments": [
        {
            "date": "2015-09-30T16:59:30+0000",
            "author": "Gus Heck",
            "content": "Sometimes when using dynamic fields, the majority of the dynamic fields generated by the input data are single valued but a few annoying fields happen to be multivalued. This forces the dynamic field to be multivalued, which precludes sorting on all fields originating from the dynamic field. At present this can only be handled by having an ingestion pipeline (or other preprocessing code) anticipate the dynamic configuration and add a second field for sorting. This creates a need for the ingestion to model (and duplicate) the dynamic field configuration. Although not always appropriate, the most basic thing such processing can do is pick the first value for the \"sort\" field, and ignore the rest. The patch I am attaching adds a firstValueOnly attribute to copyField in the solr schema, which provides this first basic workaround without an ingestion pipeline. ",
            "id": "comment-14937711"
        },
        {
            "date": "2015-09-30T17:01:49+0000",
            "author": "Gus Heck",
            "content": "patch vs 5x branch ",
            "id": "comment-14937714"
        },
        {
            "date": "2015-09-30T17:15:46+0000",
            "author": "Hoss Man",
            "content": "Isn't this situation already pretty sell resolved more robustly by \nCloneFieldUpdateProcessorFactory + FirstFieldValueUpdateProcessorFactory instead of using copyField? \n\nParticularly because it can be configured on a per processor chain basis, so you can pick \"first\" in some cases, or \"max\" in others (depending on wh/what/where the docs are coming from)\n\nhttps://lucene.apache.org/solr/5_3_0/solr-core/org/apache/solr/update/processor/FirstFieldValueUpdateProcessorFactory.html\nhttps://lucene.apache.org/solr/5_3_0/solr-core/org/apache/solr/update/processor/CloneFieldUpdateProcessorFactory.html\n\nIn general i think update processors are a much better way to address problems like this moving forward, rather then adding more features at the \"schema\" level (like new copyField options) ... particularly when you consider how low level copyField operations are, and how they (by definition) must happen after both atomic update operations about any distributed processing for cloud setups ",
            "id": "comment-14937734"
        },
        {
            "date": "2015-09-30T17:50:30+0000",
            "author": "Gus Heck",
            "content": "Does FirstFieldValueUpdateProcessorFactory accept wildcards? The case that my code is designed to handle looks like this:\n\n\n  <dynamicField name=\"*_string\" type=\"text_general\" indexed=\"true\" stored=\"true\"  multiValued=\"true\" />\n  <dynamicField name=\"*_sort_string\" type=\"string\" indexed=\"true\" stored=\"true\"  multiValued=\"false\" />\n  <copyField source=\"*_string\" dest=\"*_sort_string\" firstValueOnly=\"true\" />\n\n\n\nEven if this can be done with processors that accept wild cards, the configuration of the update processor in solrConfig.xml has to coordinate with schema.xml (the wildcard patterns have to match). Granted the copyfield directive has to coordinate with the dynamic field too, but I tend to prefer having things that have to coordinate next to each other in the same file. \n\nAs for the weight of the code that \"must happen after atomic update operations\"... If you look at my code, you'll notice that the only part that gets run on a per-document basis is:\n\nDocumentBuilder.java\n              if (cf.isFirstValueOnly() && destHasValues) {\n                continue;\n              }\n\n\n\n Everything else is parsing the attribute and just passing the boolean value around (or unit tests).  ",
            "id": "comment-14938168"
        },
        {
            "date": "2015-09-30T18:10:32+0000",
            "author": "Hoss Man",
            "content": "Does FirstFieldValueUpdateProcessorFactory accept wildcards?\n\nit does, but not in the way you are asking about - all FirstFieldValueUpdateProcessorFactory does is \"prune\" a list of values down to the first value for each the configured fields (which can be specified as a regex)\n\nthe \"copy\" part is handled by CloneFieldUpdateProcessorFactory, and in looking at it's docs again, i see there is still one disconnect between it's functionality and the older style copyField: wildcards in the dest.  we should definitely add equivalent functionality to cover that case.\n\nAs for the weight of the code that \"must happen after atomic update operations\" ...\n\nI didn't say anything about the \"weight\" of your code ... my point was that, by design, copyFields (and any new features we might add to copyFields) happen after the full processor chain  \u2013 the user doesn't have any choice about it.  I nparticularly this means any new features we might add to copyFields must also happen after atomic updates and distributed/cloud updates, which makes the utility of any new features we add to copyField extremely limited, since copyField already doesn't play nicely with those other features (see the blue note box on https://cwiki.apache.org/confluence/display/solr/Updating+Parts+of+Documents, SOLR-3743, etc...).\n\nergo: i think it's a bad idea to keep trying to add features to copyField.  All the reasons mentioned above (and finer control over the order that various features may be applied via the pipeline configuration) is the whole reason why CloneFieldUpdateProcessorFactory and the various FieldMutatingUpdateProcessorFactory were added in the first place.  I think it's important to move away from encouraging copyField usage, not towards it. ",
            "id": "comment-14938196"
        },
        {
            "date": "2015-09-30T19:17:51+0000",
            "author": "Gus Heck",
            "content": "So what I think you are saying is that copyField will soon be deprecated? ",
            "id": "comment-14938312"
        },
        {
            "date": "2015-10-09T00:31:21+0000",
            "author": "Gus Heck",
            "content": "Hoss Man Did you see SOLR-8113? Any thoughts on this, that or the difference between them? ",
            "id": "comment-14949669"
        }
    ]
}