{
    "id": "SOLR-9493",
    "title": "uniqueKey generation fails if content POSTed as \"application/javabin\" and uniqueKey field comes as NULL (as opposed to not coming at all).",
    "details": {
        "components": [],
        "type": "Bug",
        "labels": "",
        "fix_versions": [],
        "affect_versions": "None",
        "status": "Closed",
        "resolution": "Not A Problem",
        "priority": "Major"
    },
    "description": "I have faced a weird issue when the same application code (using SolrJ) fails indexing a document without a unique key (should be auto-generated by SOLR) in SolrCloud and succeeds indexing it in standalone SOLR instance (or even in cloud mode, but from web interface of one of the replicas). Difference is obviously only between clients (CloudSolrClient vs HttpSolrClient) and SOLR URLs (Zokeeper hostname+port vs standalone SOLR instance hostname and port). Failure is seen as \"org.apache.solr.client.solrj.SolrServerException: org.apache.solr.client.solrj.impl.HttpSolrClient$RemoteSolrException: Document is missing mandatory uniqueKey field: id\".\n\nI am using SOLR 5.1. In cloud mode I have 1 shard and 3 replicas.\n\nAfter lot of debugging and investigation (see below as well as my StackOverflow post) I came to a conclusion that the difference in failing and succeeding calls is simply content type of the POSTing requests. Local proxy clearly shows that the request fails if content is sent as \"application/javabin\" (see attached screenshot with sensitive data removed) and succeeds if content sent as \"application/xml; charset=UTF-8\"  (see attached screenshot with sensitive data removed).\n\nWould you be able to please assist?\n\nThank you very much in advance!\n\n------------------------\nCopying whole description and investigation here as well:\n------------------------\n\nDocumentation states:Schema defaults and copyFields cannot be used to populate the uniqueKey field. You can use UUIDUpdateProcessorFactory to have uniqueKey values generated automatically.\n\nTherefore I have added my uniqueKey field to the schema:\n\n<fieldType name=\"uuid\" class=\"solr.UUIDField\" indexed=\"true\" />\n...\n<field name=\"id\" type=\"uuid\" indexed=\"true\" stored=\"true\" required=\"true\" />\n...\n<uniqueKey>id</uniqueKey>\n\nThen I have added updateRequestProcessorChain to my solrconfig:\n\n<updateRequestProcessorChain name=\"uuid\">\n    <processor class=\"solr.UUIDUpdateProcessorFactory\">\n        <str name=\"fieldName\">id</str>\n    </processor>\n    <processor class=\"solr.RunUpdateProcessorFactory\" />\n</updateRequestProcessorChain>\n\nAnd made it the default for the UpdateRequestHandler:\n\n<initParams path=\"/update/**\">\n <lst name=\"defaults\">\n  <str name=\"update.chain\">uuid</str>\n </lst>\n</initParams>\n\nAdding new documents with null/absent id works fine as from web-interface of one of the replicas, as when using SOLR in standalone mode (non-cloud) from my application. Although when only I'm using SolrCloud and add document from my application (using CloudSolrClient from SolrJ) it fails with \"org.apache.solr.client.solrj.SolrServerException: org.apache.solr.client.solrj.impl.HttpSolrClient$RemoteSolrException: Document is missing mandatory uniqueKey field: id\"\n\nAll other operations like ping or search for documents work fine in either mode (standalone or cloud).\n\nINVESTIGATION (i.e. more details):\n\nIn standalone mode obviously update request is:\n\nPOST standalone_host:port/solr/collection_name/update?wt=json\n\nIn SOLR cloud mode, when adding document from one replica's web interface, update request is (found through inspecting the call made by web interface): \n\nPOST replica_host:port/solr/collection_name_shard1_replica_1/update?wt=json\n\nIn both these cases payload is something like:\n\n{\n    \"add\": {\n        \"doc\": {\n                 .....\n        },\n        \"boost\": 1.0,\n        \"overwrite\": true,\n        \"commitWithin\": 1000\n    }\n}\n\nIn case when CloudSolrClient is used, the following happens (found through debugging):\n\nUsing ZK and some logic, URL list of replicas is constructed that looks like this:\n\n[http://replica_1_host:port/solr/collection_name/,\n http://replica_2_host:port/solr/collection_name/,\n http://replica_3_host:port/solr/collection_name/]\n\nThis code is called:\n\nLBHttpSolrClient.Req req = new LBHttpSolrClient.Req(request, theUrlList);\nLBHttpSolrClient.Rsp rsp = lbClient.request(req);\nreturn rsp.getResponse();\n\nWhere the second line fails with the exception.\nIf to debug the second line further, it ends up calling HttpClient.execute (from HttpSolrClient.executeMethod) for:\n\nPOST http://replica_1_host:port/solr/collection_name/update?wt=javabin&version=2 HTTP/1.1\nPOST http://replica_2_host:port/solr/collection_name/update?wt=javabin&version=2 HTTP/1.1\nPOST http://replica_3_host:port/solr/collection_name/update?wt=javabin&version=2 HTTP/1.1\n\nAnd the very first request returns 400 Bad Request with replica 1 logging \"Document is missing mandatory uniqueKey field: id\" in the logs.\n\nThe funny thing is that when I execute the same request using POSTMAN (but with JSON instead of binary payload), it works! Am I doing something wrong here? I assume it's definitely something in the way of how the request is made...\n\nUPDATE:\n\nI have used local proxy in order to see the difference in these 2 requests sent by my application in order to understand what is different there. Looks like the only difference is content type. In case of cloud mode the payload for POSTing document is sent as \"application/javabin\" while in standalone mode it's sent as \"application/xml; charset=UTF-8\". Everything else is the same. First request results in 400 while second is 200.",
    "attachments": {
        "SolrInputDoc_contents.png": "https://issues.apache.org/jira/secure/attachment/12828088/SolrInputDoc_contents.png",
        "Screen Shot 2016-09-11 at 16.29.50 .png": "https://issues.apache.org/jira/secure/attachment/12827938/Screen%20Shot%202016-09-11%20at%2016.29.50%20.png",
        "400.png": "https://issues.apache.org/jira/secure/attachment/12827787/400.png",
        "SolrInputDoc_headers.png": "https://issues.apache.org/jira/secure/attachment/12828089/SolrInputDoc_headers.png",
        "200.png": "https://issues.apache.org/jira/secure/attachment/12827786/200.png"
    },
    "issue_links": {},
    "comments": [
        {
            "date": "2016-09-11T05:05:07+0000",
            "author": "Alexandre Rafalovitch",
            "content": "Any chance you could try this with the latest Solr (6.2 or master)? There has been quite a lot of changes and it would be good to know if that's something that's already been fixed under a different name or still a valid issue. ",
            "id": "comment-15481057"
        },
        {
            "date": "2016-09-11T20:41:41+0000",
            "author": "Yury Kartsev",
            "content": "Alexandre Rafalovitch I have spent some time and tried version 6.2.\n\nVersion 6.2 gives the same error, although in both cases now (while using SolrJ). What I mean by that is that both CloudSolrClient and HttpSolrClient end up sending payload as \"application/javabin\" now (still through the same place of HttpSolrClient, i.e. \n\nfinal HttpResponse response = httpClient.execute(method);\n\n In version 5.1 HttpSolrClient (when not in cloud mode) was sending payload as \"application/xml; charset=UTF-8\" and that worked (generated uniqueKey) - see above.\n\nCase with payload sent as JSON (or XML) still works fine and generates uniqueKey without any issues. I ran it from SOLR web interface (Collection -> Documents -> /update).\n\nPlease see screenshot from local proxy. First request sent by SolrJ when in Cloud Mode (Solr started with ZK and -c switch, plus CloudColrClient is used). Second request sent when in Standalone Mode (Solr started without -c switch, collection created locally, HttpSolrClient is used). Third request was made by SOLR web UI while posting a document without ID as JSON (ID was auto-generated successfully).\n\nSo there is definitely some issue there uniqueKey not generating when content is posted as \"application/javabin\". ",
            "id": "comment-15482373"
        },
        {
            "date": "2016-09-12T16:46:32+0000",
            "author": "Alexandre Rafalovitch",
            "content": "I am not able to reproduce this using the following basic code against a single node single shard cloud example :\n\n        String zkHostString = \"localhost:9983\";\n        CloudSolrClient solr = new CloudSolrClient.Builder().withZkHost(zkHostString).build();\n        solr.setDefaultCollection(\"gettingstarted\");\n\n        SolrInputDocument doc = new SolrInputDocument();\n        doc.addField(\"fielda\", \"valuec\");\n        doc.addField(\"fieldb\", \"valued\");\n\n        solr.add(doc);\n        solr.commit();\n        solr.close();\n\n\n\nIf I enable full TRACEing (literally setting root to TRACE in the Admin UI under Logging/Level, I see my javabin request coming in in the solr.log (file, not Admin UI which has INFO level limit). \n\nHowever, my requests seems to have different headers from yours. I get the following:\n\nDEBUG - 2016-09-12 16:31:37.644; [   ] org.eclipse.jetty.server.Server; REQUEST on HttpChannelOverHttp@43c0621b{r=1,c=false,a=DISPATCHED,uri=//192.168.50.128:8983/solr/gettingstarted/update?wt=javabin&version=2}\nPOST /solr/gettingstarted/update HTTP/1.1\nUser-Agent: Solr[org.apache.solr.client.solrj.impl.HttpSolrClient] 1.0\nContent-Length: 70\nContent-Type: application/javabin\nHost: 192.168.50.128:8983\nConnection: keep-alive\n\n\n\nYours seems to be chunking (multiple entries? try just one) and having authorization:basic flag (are you doing anything with that?).\n\nLater in the log I see:\n\nDEBUG - 2016-09-12 16:31:37.664; [c:gettingstarted s:shard1 r:core_node1 x:gettingstarted_shard1_replica1] org.apache.solr.update.processor.LogUpdateProcessorFactory$LogUpdateProcessor; PRE_UPDATE add{,id=da8f101d-b4ac-44c1-932e-1b8c03852c6b} {update.chain=add-unknown-fields-to-the-schema&df=_text_&wt=javabin&version=2}\n\n\n\nShowing that the chain has triggered and the id has been assigned. Are you seeing anything similar to that? ",
            "id": "comment-15484595"
        },
        {
            "date": "2016-09-12T18:15:50+0000",
            "author": "Yury Kartsev",
            "content": "Thanks for your time. I've retried with TRACE log level with the following code: \n\n                CloudSolrClient cloudSolrClient = new CloudSolrClient(getSolrServerURL());\n                cloudSolrClient.setZkClientTimeout(getReadTimeout());\n                cloudSolrClient.setZkConnectTimeout(getConnectionTimeout());\n                cloudSolrClient.setDefaultCollection(getCollectionName());\n                // setting basic authentication in HTTP client\n                DefaultHttpClient httpClient = (DefaultHttpClient) cloudSolrClient.getLbClient().getHttpClient();\n                HttpClientUtil.setBasicAuth(httpClient, authUserName, authPassword);\n                // setting preemptive authentication in HTTP client to prevent \"NonRepeatableRequestException\"\n                httpClient.addRequestInterceptor(getPreemptiveBasicAuthInterceptor(authUserName, authPassword));\n\n                 solrClient.addBeans(beans); // called from different class (beans is Collection of my Serializable Solr entities with \"org.apache.solr.client.solrj.beans.Field\" annotations)\n\nYes, I am using basic authentication because my SOLR instances are secured with that. Also I'm not using multiple entries in this particular example. Well, yes, I'm passing Collection, but it consists of only one element.\n\nThe log looks like this:\n\n2016-09-12 17:57:46.841 DEBUG (qtp1989972246-80) [c:xxx-collection s:shard1 r:core_node4 x:xxx-collection] o.e.j.s.HttpConnection HttpConnection@49800692[SelectChannelEndPoint@1af89b5d{/10.100.210.241:51788<->8983,Open,in,out,-,-,1/50000,HttpConnection}{io=0/0,kio=0,kro=1}][p=HttpParser{s=CHUNKED_CONTENT,0 of -1},g=HttpGenerator@177c5e8c{s=START},c=HttpChannelOverHttp@1313573b{r=7,c=false,a=IDLE,uri=//10.100.210.241:8983/solr/xxx-collection/update?wt=javabin&version=2}] parsed true HttpParser{s=CHUNKED_CONTENT,0 of -1}\n2016-09-12 17:57:46.841 DEBUG (qtp1989972246-80) [c:xxx-collection s:shard1 r:core_node4 x:xxx-collection] o.e.j.s.HttpChannel HttpChannelOverHttp@1313573b{r=7,c=false,a=IDLE,uri=//10.100.210.241:8983/solr/xxx-collection/update?wt=javabin&version=2} handle //10.100.210.241:8983/solr/xxx-collection/update?wt=javabin&version=2 \n2016-09-12 17:57:46.841 DEBUG (qtp1989972246-80) [c:xxx-collection s:shard1 r:core_node4 x:xxx-collection] o.e.j.s.HttpChannelState HttpChannelState@2bb68922{s=IDLE a=null i=true r=!P!U w=false} handling IDLE\n2016-09-12 17:57:46.841 DEBUG (qtp1989972246-80) [c:xxx-collection s:shard1 r:core_node4 x:xxx-collection] o.e.j.s.HttpChannel HttpChannelOverHttp@1313573b{r=7,c=false,a=DISPATCHED,uri=//10.100.210.241:8983/solr/xxx-collection/update?wt=javabin&version=2} action DISPATCH\n2016-09-12 17:57:46.841 DEBUG (qtp1989972246-80) [c:xxx-collection s:shard1 r:core_node4 x:xxx-collection] o.e.j.s.Server REQUEST on HttpChannelOverHttp@1313573b{r=7,c=false,a=DISPATCHED,uri=//10.100.210.241:8983/solr/xxx-collection/update?wt=javabin&version=2}\nPOST /solr/xxx-collection/update HTTP/1.1\nUser-Agent: Solr[org.apache.solr.client.solrj.impl.HttpSolrClient] 1.0\nTransfer-Encoding: chunked\nContent-Type: application/javabin\nHost: 10.100.210.241:8983\nAuthorization: Basic *****\n2016-09-12 17:57:46.841 DEBUG (qtp1989972246-80) [c:xxx-collection s:shard1 r:core_node4 x:xxx-collection] o.e.j.s.h.ContextHandler scope null||/solr/xxx-collection/update @ o.e.j.w.WebAppContext@2ac273d3{/solr,file:///Users/yury/Library/Solr/solr-6.2.0/server/solr-webapp/webapp/,AVAILABLE}{/Users/yury/Library/Solr/solr-6.2.0/server/solr-webapp/webapp}\n2016-09-12 17:57:46.841 DEBUG (qtp1989972246-80) [c:xxx-collection s:shard1 r:core_node4 x:xxx-collection] o.e.j.s.h.ContextHandler context=/solr||/xxx-collection/update @ o.e.j.w.WebAppContext@2ac273d3{/solr,file:///Users/yury/Library/Solr/solr-6.2.0/server/solr-webapp/webapp/,AVAILABLE}{/Users/yury/Library/Solr/solr-6.2.0/server/solr-webapp/webapp}\n2016-09-12 17:57:46.841 DEBUG (qtp1989972246-80) [c:xxx-collection s:shard1 r:core_node4 x:xxx-collection] o.e.j.s.session sessionManager=org.eclipse.jetty.server.session.HashSessionManager@33723e30\n2016-09-12 17:57:46.841 DEBUG (qtp1989972246-80) [c:xxx-collection s:shard1 r:core_node4 x:xxx-collection] o.e.j.s.session session=null\n2016-09-12 17:57:46.841 DEBUG (qtp1989972246-80) [c:xxx-collection s:shard1 r:core_node4 x:xxx-collection] o.e.j.s.ServletHandler servlet /solr|/xxx-collection/update|null -> default@5c13d641==org.eclipse.jetty.servlet.DefaultServlet,0,true\n2016-09-12 17:57:46.842 DEBUG (qtp1989972246-80) [c:xxx-collection s:shard1 r:core_node4 x:xxx-collection] o.e.j.s.ServletHandler chain=SolrRequestFilter->default@5c13d641==org.eclipse.jetty.servlet.DefaultServlet,0,true\n2016-09-12 17:57:46.842 DEBUG (qtp1989972246-80) [c:xxx-collection s:shard1 r:core_node4 x:xxx-collection] o.e.j.s.ServletHandler call filter SolrRequestFilter\n2016-09-12 17:57:46.842 DEBUG (qtp1989972246-80) [c:xxx-collection s:shard1 r:core_node4 x:xxx-collection] o.e.j.w.WebAppClassLoader loadClass(org.apache.commons.fileupload.servlet.ServletFileUpload) system=false server=false cl=WebAppClassLoader=989938643@3b0143d3\n2016-09-12 17:57:46.842 DEBUG (qtp1989972246-80) [c:xxx-collection s:shard1 r:core_node4 x:xxx-collection] o.e.j.w.WebAppClassLoader loadClass(org.apache.commons.fileupload.FileUpload) system=false server=false cl=WebAppClassLoader=989938643@3b0143d3\n2016-09-12 17:57:46.843 DEBUG (qtp1989972246-80) [c:xxx-collection s:shard1 r:core_node4 x:xxx-collection] o.e.j.w.WebAppClassLoader loadClass(org.apache.commons.fileupload.FileUploadBase) system=false server=false cl=WebAppClassLoader=989938643@3b0143d3\n2016-09-12 17:57:46.844 DEBUG (qtp1989972246-80) [c:xxx-collection s:shard1 r:core_node4 x:xxx-collection] o.e.j.w.WebAppClassLoader loadedClass(org.apache.commons.fileupload.FileUploadBase)==class org.apache.commons.fileupload.FileUploadBase from=WebAppClassLoader=989938643@3b0143d3 tried_parent=false\n2016-09-12 17:57:46.844 DEBUG (qtp1989972246-80) [c:xxx-collection s:shard1 r:core_node4 x:xxx-collection] o.e.j.w.WebAppClassLoader loadedClass(org.apache.commons.fileupload.FileUpload)==class org.apache.commons.fileupload.FileUpload from=WebAppClassLoader=989938643@3b0143d3 tried_parent=false\n2016-09-12 17:57:46.845 DEBUG (qtp1989972246-80) [c:xxx-collection s:shard1 r:core_node4 x:xxx-collection] o.e.j.w.WebAppClassLoader loadedClass(org.apache.commons.fileupload.servlet.ServletFileUpload)==class org.apache.commons.fileupload.servlet.ServletFileUpload from=WebAppClassLoader=989938643@3b0143d3 tried_parent=false\n2016-09-12 17:57:46.845 DEBUG (qtp1989972246-80) [c:xxx-collection s:shard1 r:core_node4 x:xxx-collection] o.e.j.w.WebAppClassLoader loadClass(org.apache.commons.fileupload.FileItemHeaders) system=false server=false cl=WebAppClassLoader=989938643@3b0143d3\n2016-09-12 17:57:46.845 DEBUG (qtp1989972246-80) [c:xxx-collection s:shard1 r:core_node4 x:xxx-collection] o.e.j.w.WebAppClassLoader loadedClass(org.apache.commons.fileupload.FileItemHeaders)==interface org.apache.commons.fileupload.FileItemHeaders from=WebAppClassLoader=989938643@3b0143d3 tried_parent=false\n2016-09-12 17:57:46.845 DEBUG (qtp1989972246-80) [c:xxx-collection s:shard1 r:core_node4 x:xxx-collection] o.e.j.w.WebAppClassLoader loadClass(org.apache.commons.fileupload.RequestContext) system=false server=false cl=WebAppClassLoader=989938643@3b0143d3\n2016-09-12 17:57:46.845 DEBUG (qtp1989972246-80) [c:xxx-collection s:shard1 r:core_node4 x:xxx-collection] o.e.j.w.WebAppClassLoader loadedClass(org.apache.commons.fileupload.RequestContext)==interface org.apache.commons.fileupload.RequestContext from=WebAppClassLoader=989938643@3b0143d3 tried_parent=false\n2016-09-12 17:57:46.845 DEBUG (qtp1989972246-80) [c:xxx-collection s:shard1 r:core_node4 x:xxx-collection] o.e.j.w.WebAppClassLoader loadClass(org.apache.commons.fileupload.FileUploadBase$FileUploadIOException) system=false server=false cl=WebAppClassLoader=989938643@3b0143d3\n2016-09-12 17:57:46.846 DEBUG (qtp1989972246-80) [c:xxx-collection s:shard1 r:core_node4 x:xxx-collection] o.e.j.w.WebAppClassLoader loadedClass(org.apache.commons.fileupload.FileUploadBase$FileUploadIOException)==class org.apache.commons.fileupload.FileUploadBase$FileUploadIOException from=WebAppClassLoader=989938643@3b0143d3 tried_parent=false\n2016-09-12 17:57:46.846 DEBUG (qtp1989972246-80) [c:xxx-collection s:shard1 r:core_node4 x:xxx-collection] o.e.j.w.WebAppClassLoader loadClass(org.apache.commons.fileupload.FileUploadException) system=false server=false cl=WebAppClassLoader=989938643@3b0143d3\n2016-09-12 17:57:46.846 DEBUG (qtp1989972246-80) [c:xxx-collection s:shard1 r:core_node4 x:xxx-collection] o.e.j.w.WebAppClassLoader loadedClass(org.apache.commons.fileupload.FileUploadException)==class org.apache.commons.fileupload.FileUploadException from=WebAppClassLoader=989938643@3b0143d3 tried_parent=false\n2016-09-12 17:57:46.846 DEBUG (qtp1989972246-80) [c:xxx-collection s:shard1 r:core_node4 x:xxx-collection] o.e.j.w.WebAppClassLoader loadClass(org.apache.commons.fileupload.FileUploadBase$IOFileUploadException) system=false server=false cl=WebAppClassLoader=989938643@3b0143d3\n2016-09-12 17:57:46.846 DEBUG (qtp1989972246-80) [c:xxx-collection s:shard1 r:core_node4 x:xxx-collection] o.e.j.w.WebAppClassLoader loadedClass(org.apache.commons.fileupload.FileUploadBase$IOFileUploadException)==class org.apache.commons.fileupload.FileUploadBase$IOFileUploadException from=WebAppClassLoader=989938643@3b0143d3 tried_parent=false\n2016-09-12 17:57:46.846 DEBUG (qtp1989972246-80) [c:xxx-collection s:shard1 r:core_node4 x:xxx-collection] o.e.j.w.WebAppClassLoader loadClass(org.apache.commons.fileupload.FileItemIterator) system=false server=false cl=WebAppClassLoader=989938643@3b0143d3\n2016-09-12 17:57:46.846 DEBUG (qtp1989972246-80) [c:xxx-collection s:shard1 r:core_node4 x:xxx-collection] o.e.j.w.WebAppClassLoader loadedClass(org.apache.commons.fileupload.FileItemIterator)==interface org.apache.commons.fileupload.FileItemIterator from=WebAppClassLoader=989938643@3b0143d3 tried_parent=false\n2016-09-12 17:57:46.847 DEBUG (qtp1989972246-80) [c:xxx-collection s:shard1 r:core_node4 x:xxx-collection] o.e.j.w.WebAppClassLoader loadClass(org.apache.commons.fileupload.servlet.ServletRequestContext) system=false server=false cl=WebAppClassLoader=989938643@3b0143d3\n2016-09-12 17:57:46.847 DEBUG (qtp1989972246-80) [c:xxx-collection s:shard1 r:core_node4 x:xxx-collection] o.e.j.w.WebAppClassLoader loadClass(org.apache.commons.fileupload.UploadContext) system=false server=false cl=WebAppClassLoader=989938643@3b0143d3\n2016-09-12 17:57:46.847 DEBUG (qtp1989972246-80) [c:xxx-collection s:shard1 r:core_node4 x:xxx-collection] o.e.j.w.WebAppClassLoader loadedClass(org.apache.commons.fileupload.UploadContext)==interface org.apache.commons.fileupload.UploadContext from=WebAppClassLoader=989938643@3b0143d3 tried_parent=false\n2016-09-12 17:57:46.847 DEBUG (qtp1989972246-80) [c:xxx-collection s:shard1 r:core_node4 x:xxx-collection] o.e.j.w.WebAppClassLoader loadedClass(org.apache.commons.fileupload.servlet.ServletRequestContext)==class org.apache.commons.fileupload.servlet.ServletRequestContext from=WebAppClassLoader=989938643@3b0143d3 tried_parent=false\n2016-09-12 17:57:46.848 DEBUG (qtp1989972246-80) [c:xxx-collection s:shard1 r:core_node4 x:xxx-collection] o.e.j.w.WebAppClassLoader loadClass(org.apache.solr.servlet.SolrRequestParsers$HttpRequestContentStream) system=false server=false cl=WebAppClassLoader=989938643@3b0143d3\n2016-09-12 17:57:46.848 DEBUG (qtp1989972246-80) [c:xxx-collection s:shard1 r:core_node4 x:xxx-collection] o.e.j.w.WebAppClassLoader loadedClass(org.apache.solr.servlet.SolrRequestParsers$HttpRequestContentStream)==class org.apache.solr.servlet.SolrRequestParsers$HttpRequestContentStream from=WebAppClassLoader=989938643@3b0143d3 tried_parent=false\n2016-09-12 17:57:46.848 DEBUG (qtp1989972246-80) [c:xxx-collection s:shard1 r:core_node4 x:xxx-collection] o.a.s.c.S.Request [xxx-collection]  webapp=/solr path=/update params={wt=javabin&version=2}\n2016-09-12 17:57:46.849 DEBUG (qtp1989972246-80) [c:xxx-collection s:shard1 r:core_node4 x:xxx-collection] o.e.j.w.WebAppClassLoader loadClass(org.apache.solr.handler.loader.JavabinLoader$1) system=false server=false cl=WebAppClassLoader=989938643@3b0143d3\n2016-09-12 17:57:46.849 DEBUG (qtp1989972246-80) [c:xxx-collection s:shard1 r:core_node4 x:xxx-collection] o.e.j.w.WebAppClassLoader loadedClass(org.apache.solr.handler.loader.JavabinLoader$1)==class org.apache.solr.handler.loader.JavabinLoader$1 from=WebAppClassLoader=989938643@3b0143d3 tried_parent=false\n2016-09-12 17:57:46.849 DEBUG (qtp1989972246-80) [c:xxx-collection s:shard1 r:core_node4 x:xxx-collection] o.e.j.w.WebAppClassLoader loadClass(org.apache.solr.client.solrj.request.JavaBinUpdateRequestCodec) system=false server=false cl=WebAppClassLoader=989938643@3b0143d3\n2016-09-12 17:57:46.850 DEBUG (qtp1989972246-80) [c:xxx-collection s:shard1 r:core_node4 x:xxx-collection] o.e.j.w.WebAppClassLoader loadedClass(org.apache.solr.client.solrj.request.JavaBinUpdateRequestCodec)==class org.apache.solr.client.solrj.request.JavaBinUpdateRequestCodec from=WebAppClassLoader=989938643@3b0143d3 tried_parent=false\n2016-09-12 17:57:46.850 DEBUG (qtp1989972246-80) [c:xxx-collection s:shard1 r:core_node4 x:xxx-collection] o.e.j.w.WebAppClassLoader loadClass(org.apache.solr.client.solrj.request.JavaBinUpdateRequestCodec$1) system=false server=false cl=WebAppClassLoader=989938643@3b0143d3\n2016-09-12 17:57:46.850 DEBUG (qtp1989972246-80) [c:xxx-collection s:shard1 r:core_node4 x:xxx-collection] o.e.j.w.WebAppClassLoader loadedClass(org.apache.solr.client.solrj.request.JavaBinUpdateRequestCodec$1)==class org.apache.solr.client.solrj.request.JavaBinUpdateRequestCodec$1 from=WebAppClassLoader=989938643@3b0143d3 tried_parent=false\n2016-09-12 17:57:46.851 DEBUG (qtp1989972246-80) [c:xxx-collection s:shard1 r:core_node4 x:xxx-collection] o.e.j.s.HttpConnection HttpConnection@49800692[SelectChannelEndPoint@1af89b5d{/10.100.210.241:51788<->8983,Open,in,out,-,-,11/50000,HttpConnection}{io=0/0,kio=0,kro=1}][p=HttpParser{s=CHUNKED_CONTENT,0 of -1},g=HttpGenerator@177c5e8c{s=START},c=HttpChannelOverHttp@1313573b{r=7,c=false,a=DISPATCHED,uri=//10.100.210.241:8983/solr/xxx-collection/update?wt=javabin&version=2}] parse HeapByteBuffer@55e4fe05[p=276,l=737,c=8192,r=461]={POST /solr/xxx-c...2VsbDEwMjQh\\r\\n\\r\\n<<<1c1\\r\\n\\x02\\xC3\\xE0&params\\xC0\\xE0...\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x0f\\r\\n0\\r\\n\\r\\n>>>\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00...\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00} {}\n2016-09-12 17:57:46.851 DEBUG (qtp1989972246-80) [c:xxx-collection s:shard1 r:core_node4 x:xxx-collection] o.e.j.h.HttpParser parseNext s=CHUNKED_CONTENT HeapByteBuffer@55e4fe05[p=276,l=737,c=8192,r=461]={POST /solr/xxx-c...2VsbDEwMjQh\\r\\n\\r\\n<<<1c1\\r\\n\\x02\\xC3\\xE0&params\\xC0\\xE0...\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x0f\\r\\n0\\r\\n\\r\\n>>>\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00...\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00}\n2016-09-12 17:57:46.851 DEBUG (qtp1989972246-80) [c:xxx-collection s:shard1 r:core_node4 x:xxx-collection] o.e.j.h.HttpParser CHUNKED_CONTENT --> CHUNK_SIZE\n2016-09-12 17:57:46.851 DEBUG (qtp1989972246-80) [c:xxx-collection s:shard1 r:core_node4 x:xxx-collection] o.e.j.h.HttpParser CHUNK_SIZE --> CHUNK\n2016-09-12 17:57:46.851 DEBUG (qtp1989972246-80) [c:xxx-collection s:shard1 r:core_node4 x:xxx-collection] o.e.j.s.HttpChannel HttpChannelOverHttp@1313573b{r=7,c=false,a=DISPATCHED,uri=//10.100.210.241:8983/solr/xxx-collection/update?wt=javabin&version=2} content Content@52737de8{HeapByteBufferR@19f96491[p=281,l=730,c=8192,r=449]={POST /solr/xxx-c...EwMjQh\\r\\n\\r\\n1c1\\r\\n<<<\\x02\\xC3\\xE0&params\\xC0\\xE0&delB...Name\\x05\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x0f>>>\\r\\n0\\r\\n\\r\\n\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00...\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00}}\n2016-09-12 17:57:46.851 DEBUG (qtp1989972246-80) [c:xxx-collection s:shard1 r:core_node4 x:xxx-collection] o.e.j.s.HttpInput HttpInputOverHTTP@3c06f5d6[c=0,s=STREAM] addContent Content@52737de8{HeapByteBufferR@19f96491[p=281,l=730,c=8192,r=449]={POST /solr/xxx-c...EwMjQh\\r\\n\\r\\n1c1\\r\\n<<<\\x02\\xC3\\xE0&params\\xC0\\xE0&delB...Name\\x05\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x0f>>>\\r\\n0\\r\\n\\r\\n\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00...\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00}}\n2016-09-12 17:57:46.851 DEBUG (qtp1989972246-80) [c:xxx-collection s:shard1 r:core_node4 x:xxx-collection] o.e.j.h.HttpParser CHUNK --> CHUNKED_CONTENT\n2016-09-12 17:57:46.851 DEBUG (qtp1989972246-80) [c:xxx-collection s:shard1 r:core_node4 x:xxx-collection] o.e.j.h.HttpParser CHUNKED_CONTENT --> CHUNK_SIZE\n2016-09-12 17:57:46.851 DEBUG (qtp1989972246-80) [c:xxx-collection s:shard1 r:core_node4 x:xxx-collection] o.e.j.h.HttpParser CHUNK_SIZE --> CHUNK_END\n2016-09-12 17:57:46.851 DEBUG (qtp1989972246-80) [c:xxx-collection s:shard1 r:core_node4 x:xxx-collection] o.e.j.h.HttpParser CHUNK_END --> END\n2016-09-12 17:57:46.851 DEBUG (qtp1989972246-80) [c:xxx-collection s:shard1 r:core_node4 x:xxx-collection] o.e.j.s.HttpChannel HttpChannelOverHttp@1313573b{r=7,c=false,a=DISPATCHED,uri=//10.100.210.241:8983/solr/xxx-collection/update?wt=javabin&version=2} onRequestComplete\n2016-09-12 17:57:46.851 DEBUG (qtp1989972246-80) [c:xxx-collection s:shard1 r:core_node4 x:xxx-collection] o.e.j.s.HttpInput HttpInputOverHTTP@3c06f5d6[c=0,s=STREAM] addContent EOF\n2016-09-12 17:57:46.852 DEBUG (qtp1989972246-80) [c:xxx-collection s:shard1 r:core_node4 x:xxx-collection] o.e.j.s.HttpConnection HttpConnection@49800692[SelectChannelEndPoint@1af89b5d{/10.100.210.241:51788<->8983,Open,in,out,-,-,12/50000,HttpConnection}{io=0/0,kio=0,kro=1}][p=HttpParser{s=END,449 of -1},g=HttpGenerator@177c5e8c{s=START},c=HttpChannelOverHttp@1313573b{r=7,c=false,a=DISPATCHED,uri=//10.100.210.241:8983/solr/xxx-collection/update?wt=javabin&version=2}] parsed false HttpParser{s=END,449 of -1}\n2016-09-12 17:57:46.852 DEBUG (qtp1989972246-80) [c:xxx-collection s:shard1 r:core_node4 x:xxx-collection] o.e.j.s.HttpInput HttpInputOverHTTP@3c06f5d6[c=0,s=STREAM] read 8192 from Content@52737de8{HeapByteBufferR@19f96491[p=281,l=730,c=8192,r=449]={POST /solr/xxx-c...EwMjQh\\r\\n\\r\\n1c1\\r\\n<<<\\x02\\xC3\\xE0&params\\xC0\\xE0&delB...Name\\x05\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x0f>>>\\r\\n0\\r\\n\\r\\n\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00...\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00}}\n2016-09-12 17:57:46.852 DEBUG (qtp1989972246-80) [c:xxx-collection s:shard1 r:core_node4 x:xxx-collection] o.e.j.s.HttpConnection releaseRequestBuffer HttpConnection@49800692[SelectChannelEndPoint@1af89b5d{/10.100.210.241:51788<->8983,Open,in,out,-,-,12/50000,HttpConnection}{io=0/0,kio=0,kro=1}][p=HttpParser{s=END,449 of -1},g=HttpGenerator@177c5e8c{s=START},c=HttpChannelOverHttp@1313573b{r=7,c=false,a=DISPATCHED,uri=//10.100.210.241:8983/solr/xxx-collection/update?wt=javabin&version=2}]\n2016-09-12 17:57:46.852 DEBUG (qtp1989972246-80) [c:xxx-collection s:shard1 r:core_node4 x:xxx-collection] o.e.j.s.HttpInput HttpInputOverHTTP@3c06f5d6[c=449,s=STREAM] consumed Content@52737de8{HeapByteBufferR@19f96491[p=730,l=730,c=8192,r=0]={POST /solr/xxx-c...Name\\x05\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x0f<<<>>>\\r\\n0\\r\\n\\r\\n\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00...\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00}}\n2016-09-12 17:57:46.852 DEBUG (qtp1989972246-80) [c:xxx-collection s:shard1 r:core_node4 x:xxx-collection] o.e.j.w.WebAppClassLoader loadClass(org.apache.solr.common.SolrInputField) system=false server=false cl=WebAppClassLoader=989938643@3b0143d3\n2016-09-12 17:57:46.852 DEBUG (qtp1989972246-80) [c:xxx-collection s:shard1 r:core_node4 x:xxx-collection] o.e.j.w.WebAppClassLoader loadedClass(org.apache.solr.common.SolrInputField)==class org.apache.solr.common.SolrInputField from=WebAppClassLoader=989938643@3b0143d3 tried_parent=false\n2016-09-12 17:57:46.853 DEBUG (qtp1989972246-80) [c:xxx-collection s:shard1 r:core_node4 x:xxx-collection] o.e.j.w.WebAppClassLoader loadClass(org.apache.solr.common.util.JavaBinCodec$1) system=false server=false cl=WebAppClassLoader=989938643@3b0143d3\n2016-09-12 17:57:46.853 DEBUG (qtp1989972246-80) [c:xxx-collection s:shard1 r:core_node4 x:xxx-collection] o.e.j.w.WebAppClassLoader loadedClass(org.apache.solr.common.util.JavaBinCodec$1)==class org.apache.solr.common.util.JavaBinCodec$1 from=WebAppClassLoader=989938643@3b0143d3 tried_parent=false\n2016-09-12 17:57:46.854 DEBUG (qtp1989972246-80) [c:xxx-collection s:shard1 r:core_node4 x:xxx-collection] o.e.j.w.WebAppClassLoader loadClass(org.apache.solr.common.SolrException$ErrorCode) system=false server=false cl=WebAppClassLoader=989938643@3b0143d3\n2016-09-12 17:57:46.854 DEBUG (qtp1989972246-80) [c:xxx-collection s:shard1 r:core_node4 x:xxx-collection] o.e.j.w.WebAppClassLoader loadedClass(org.apache.solr.common.SolrException$ErrorCode)==class org.apache.solr.common.SolrException$ErrorCode from=WebAppClassLoader=989938643@3b0143d3 tried_parent=false\n2016-09-12 17:57:46.856 ERROR (qtp1989972246-80) [c:xxx-collection s:shard1 r:core_node4 x:xxx-collection] o.a.s.h.RequestHandlerBase org.apache.solr.common.SolrException: Document is missing mandatory uniqueKey field: id\n    at org.apache.solr.update.AddUpdateCommand.getHashableId(AddUpdateCommand.java:146)\n    at org.apache.solr.update.processor.DistributedUpdateProcessor.processAdd(DistributedUpdateProcessor.java:679)\n    at org.apache.solr.update.processor.UpdateRequestProcessor.processAdd(UpdateRequestProcessor.java:48)\n    at org.apache.solr.update.processor.AbstractDefaultValueUpdateProcessorFactory$DefaultValueUpdateProcessor.processAdd(AbstractDefaultValueUpdateProcessorFactory.java:91)\n    at org.apache.solr.handler.loader.JavabinLoader$1.update(JavabinLoader.java:97)\n    at org.apache.solr.client.solrj.request.JavaBinUpdateRequestCodec$1.readOuterMostDocIterator(JavaBinUpdateRequestCodec.java:179)\n    at org.apache.solr.client.solrj.request.JavaBinUpdateRequestCodec$1.readIterator(JavaBinUpdateRequestCodec.java:135)\n    at org.apache.solr.common.util.JavaBinCodec.readVal(JavaBinCodec.java:274)\n    at org.apache.solr.client.solrj.request.JavaBinUpdateRequestCodec$1.readNamedList(JavaBinUpdateRequestCodec.java:121)\n    at org.apache.solr.common.util.JavaBinCodec.readVal(JavaBinCodec.java:239)\n    at org.apache.solr.common.util.JavaBinCodec.unmarshal(JavaBinCodec.java:157)\n    at org.apache.solr.client.solrj.request.JavaBinUpdateRequestCodec.unmarshal(JavaBinUpdateRequestCodec.java:186)\n    at org.apache.solr.handler.loader.JavabinLoader.parseAndLoadDocs(JavabinLoader.java:107)\n    at org.apache.solr.handler.loader.JavabinLoader.load(JavabinLoader.java:54)\n    at org.apache.solr.handler.UpdateRequestHandler$1.load(UpdateRequestHandler.java:97)\n    at org.apache.solr.handler.ContentStreamHandlerBase.handleRequestBody(ContentStreamHandlerBase.java:68)\n    at org.apache.solr.handler.RequestHandlerBase.handleRequest(RequestHandlerBase.java:154)\n    at org.apache.solr.core.SolrCore.execute(SolrCore.java:2089)\n    at org.apache.solr.servlet.HttpSolrCall.execute(HttpSolrCall.java:652)\n    at org.apache.solr.servlet.HttpSolrCall.call(HttpSolrCall.java:459)\n    at org.apache.solr.servlet.SolrDispatchFilter.doFilter(SolrDispatchFilter.java:257)\n    at org.apache.solr.servlet.SolrDispatchFilter.doFilter(SolrDispatchFilter.java:208)\n    at org.eclipse.jetty.servlet.ServletHandler$CachedChain.doFilter(ServletHandler.java:1668)\n    at org.eclipse.jetty.servlet.ServletHandler.doHandle(ServletHandler.java:581)\n    at org.eclipse.jetty.server.handler.ScopedHandler.handle(ScopedHandler.java:143)\n    at org.eclipse.jetty.security.SecurityHandler.handle(SecurityHandler.java:548)\n    at org.eclipse.jetty.server.session.SessionHandler.doHandle(SessionHandler.java:226)\n    at org.eclipse.jetty.server.handler.ContextHandler.doHandle(ContextHandler.java:1160)\n    at org.eclipse.jetty.servlet.ServletHandler.doScope(ServletHandler.java:511)\n    at org.eclipse.jetty.server.session.SessionHandler.doScope(SessionHandler.java:185)\n    at org.eclipse.jetty.server.handler.ContextHandler.doScope(ContextHandler.java:1092)\n    at org.eclipse.jetty.server.handler.ScopedHandler.handle(ScopedHandler.java:141)\n    at org.eclipse.jetty.server.handler.ContextHandlerCollection.handle(ContextHandlerCollection.java:213)\n    at org.eclipse.jetty.server.handler.HandlerCollection.handle(HandlerCollection.java:119)\n    at org.eclipse.jetty.server.handler.HandlerWrapper.handle(HandlerWrapper.java:134)\n    at org.eclipse.jetty.server.Server.handle(Server.java:518)\n    at org.eclipse.jetty.server.HttpChannel.handle(HttpChannel.java:308)\n    at org.eclipse.jetty.server.HttpConnection.onFillable(HttpConnection.java:244)\n    at org.eclipse.jetty.io.AbstractConnection$ReadCallback.succeeded(AbstractConnection.java:273)\n    at org.eclipse.jetty.io.FillInterest.fillable(FillInterest.java:95)\n    at org.eclipse.jetty.io.SelectChannelEndPoint$2.run(SelectChannelEndPoint.java:93)\n    at org.eclipse.jetty.util.thread.strategy.ExecuteProduceConsume.produceAndRun(ExecuteProduceConsume.java:246)\n    at org.eclipse.jetty.util.thread.strategy.ExecuteProduceConsume.run(ExecuteProduceConsume.java:156)\n    at org.eclipse.jetty.util.thread.QueuedThreadPool.runJob(QueuedThreadPool.java:654)\n    at org.eclipse.jetty.util.thread.QueuedThreadPool$3.run(QueuedThreadPool.java:572)\n    at java.lang.Thread.run(Thread.java:745)\n\n2016-09-12 17:57:46.856 INFO  (qtp1989972246-80) [c:xxx-collection s:shard1 r:core_node4 x:xxx-collection] o.a.s.c.S.Request [xxx-collection]  webapp=/solr path=/update params={wt=javabin&version=2} status=400 QTime=14\n\n\nUPDATE: Same error occurs if I use \n\nsolrClient.addBean(beans.iterator().next());\n\n, i.e. if I send entity itself without a list. ",
            "id": "comment-15484855"
        },
        {
            "date": "2016-09-12T18:58:00+0000",
            "author": "Yury Kartsev",
            "content": "Just added a quick code that converts my Serializable Solr entity with \"org.apache.solr.client.solrj.beans.Field\" annotations into a SolrInputDocument (with this map of field name -> value) and used solrClient.add. It worked just fine (as it worked for you). And uniqueKey was generated perfectly. \n\nSolrInputDocument doc = new SolrInputDocument();\n// few lines of doc.addField(FIELD_NAME, mySolrEntity.getFieldValue());\nsolrClient.add(doc);\n\n\nBy the way, I have checked these requests in the proxy. See screenshots SolrInputDoc_contents and SolrInputDoc_headers. Headers are exactly the same, although contents differs (obviously it's a Map). I am now thinking what if the issue is that I'm passing uniqueKey as NULL instead of not passing it at all? ",
            "id": "comment-15484972"
        },
        {
            "date": "2016-09-12T19:01:52+0000",
            "author": "Yury Kartsev",
            "content": "Yes! I think I've found the exact issue  If only I add NULL field that is my uniqueKey, that error occurs even if I'm using SolrInputDocument:\n\ndoc.addField(\"id\", null);\n\n\nDocument is missing mandatory uniqueKey field: id\n\n\nI think this is definitely a bug in handling @Field value for uniqueKey that is coming as null. In this case it should be auto-generated instead of giving an error. ",
            "id": "comment-15484983"
        },
        {
            "date": "2016-09-13T00:41:15+0000",
            "author": "Alexandre Rafalovitch",
            "content": "Try adding RemoveBlankFieldUpdateProcessorFactory into the chain before your UUIDUpdateProcessorFactory. \n\nThis should remove the empty field and then key generator can do its job. ",
            "id": "comment-15485792"
        },
        {
            "date": "2016-09-13T01:22:40+0000",
            "author": "Yury Kartsev",
            "content": "Oh, I see, it's a feature, not a bug... I.e. if I send null value it's considered to be a NULL value (as opposed to 'nothing') and will be stored like this... Very good to know. Something I've never encountered despite being familiar with SOLR to a degree of writing custom similarities  Thank you, I'll try it tomorrow and let you know here. ",
            "id": "comment-15485887"
        },
        {
            "date": "2016-09-13T17:33:49+0000",
            "author": "Yury Kartsev",
            "content": "Tried it today like this:\n\n  <updateRequestProcessorChain name=\"uuid\">\n      <processor class=\"solr.RemoveBlankFieldUpdateProcessorFactory\" />\n      <processor class=\"solr.UUIDUpdateProcessorFactory\">\n          <str name=\"fieldName\">id</str>\n      </processor>\n      <processor class=\"solr.RunUpdateProcessorFactory\" />\n  </updateRequestProcessorChain>\n\n\nDid not change a bit. Same thing in both cases (addBean as well as add(SolrInputDocument) with a null value). The description for UpdateProcessorFactory states that it \"Removes any values found which are CharSequence with a length of 0. (ie: empty strings)\". I am wondering if it really removes a field itself if it's NULL. Looks like UUIDUpdateProcessorFactory needs this field to be absent in order to generate UUID... ",
            "id": "comment-15487854"
        },
        {
            "date": "2016-09-13T17:52:01+0000",
            "author": "Yury Kartsev",
            "content": "Although I have tried to use IgnoreFieldUpdateProcessorFactory here for \"id\" field instead and can confirm it works for both cases (beans and documents):\n\n<updateRequestProcessorChain name=\"uuid\">\n    <!-- Using IgnoreFieldUpdateProcessorFactory can't generate UUID for a field coming as NULL, field must be absent. -->\n    <processor class=\"solr.IgnoreFieldUpdateProcessorFactory\">\n        <str name=\"fieldName\">id</str>\n    </processor>\n    <processor class=\"solr.UUIDUpdateProcessorFactory\">\n        <str name=\"fieldName\">id</str>\n    </processor>\n    <processor class=\"solr.RunUpdateProcessorFactory\" />\n</updateRequestProcessorChain>\n\n\nFor now it would work fine because I don't plan to add documents with external ID. Although what if some day I'll need it? Can IgnoreFieldUpdateProcessorFactory be used with some condition like \"remove only if value = null\"? Or maybe there is another alternative? ",
            "id": "comment-15487901"
        },
        {
            "date": "2016-09-14T11:59:24+0000",
            "author": "Noble Paul",
            "content": "Isn't it much better to add a single line of code to your client\n\nUUID.randomUUID().toString().toLowerCase(Locale.ROOT);\n\n\n\nIn solrcloud id field is very important. The SolrJ client sends the right server by hashing the id.\n\n\nWhen you have an error like this , if you can just isolate it into a small sample code that fails, it'll be much more easy for us to write a testcase and reproduce it.   ",
            "id": "comment-15490252"
        },
        {
            "date": "2016-09-14T16:10:54+0000",
            "author": "Yury Kartsev",
            "content": "I was thinking about it, but just because as you said \"ID is very important in SolrCloud\", I wanted SOLR itself to generate that ID (as opposed to the client, especially considering that there may be more than one client nodes).\n\nI agree about isolation. Next time will come up with a small sample test to make it easier for you guys.\n\nCurrently I think the issue is solved (by using IgnoreFieldUpdateProcessorFactory), but I would like to close that small question I've asked above: what if some day I'll need to index documents with custom IDs + having an ability to generate it by SOLR as well? Can IgnoreFieldUpdateProcessorFactory be used with some condition like \"remove only if value = null\"? Or the only way is to simply generate it in the client? It's a minor question that does not really decide anything at this moment, I just want to kinda improve my SOLR knowledge in this topic for the future.\n\nThank you. ",
            "id": "comment-15490817"
        },
        {
            "date": "2016-09-17T07:40:45+0000",
            "author": "Noble Paul",
            "content": "but just because as you said \"ID is very important in SolrCloud\", I wanted SOLR itself to generate that ID\n\nYou missed the point.\nSolrJ is designed to send a doc to the right leader by hashing the id. If Solr is assigns the id, SolrJ has no clue where to send this to. So, the doc is sent to a random node. The node assigns the id and it realizes that the doc belongs to another shard and it is forwarded there. Essentially, you lost the efficiency of using SolrJ by asking Solr to assign an ID. ",
            "id": "comment-15498475"
        },
        {
            "date": "2016-09-18T14:25:33+0000",
            "author": "Shawn Heisey",
            "content": "I'd go even further and say that a uniqueKey field that exists both inside and outside Solr is particularly important in the design of a Solr index.  A unique identifier that a user can obtain from somewhere else and use to look up a specific document is extremely useful.\n\nSolr can generate a UUID value, but it's essentially just a random number, and each value has no connection to the other data in the indexed document at all.  When the generated field is used as uniqueKey, the UUIDUpdateProcessorFactory code doesn't have a check to make sure that each random value is unique within the index \u2013 so two documents could end up with the same UUID value, which would cause the second document to overwrite the first.  Because the UUID represents a VERY large number, the chance of that happening is EXTREMELY small, but it IS possible.\n\nSolr uses the uniqueKey field to locate a previous version of a document so that the old one is deleted when you index the same document again.  If that identifier is generated by Solr, then you lose the ability to index documents and have them automatically replace previous versions. ",
            "id": "comment-15501057"
        },
        {
            "date": "2016-09-18T14:42:21+0000",
            "author": "Shawn Heisey",
            "content": "The UUID processor is mostly useful for Cloud deployments.  For standalone indexes, other means of generating random identifiers will suffice, but the Update Processor is required for distributed SolrCloud indexes, to guarantee that the UUID is generated BEFORE the decision engine forwards the document to the final node(s) for indexing.\n\nI think we could likely add a configurable check to the UUID processor, such that if the field being generated is the uniqueKey field, the generated could be guaranteed within the local Lucene index.  The possible wrinkle is that I do not know whether looking up a uniqueKey in an entire SolrCloud collection is something an update processor can readily do \u2013 and this would be required. ",
            "id": "comment-15501081"
        },
        {
            "date": "2016-09-21T15:59:20+0000",
            "author": "Yury Kartsev",
            "content": "SolrJ is designed to send a doc to the right leader by hashing the id.\nVery interesting... Maybe I really missed a point. Just read more about it - I really missed this chapter while was reading SOLR In Action book. Thanks for pointing it out. Although in this case the whole ability of SOLR to generate the uniqueKey now sounds surprising just because of what you said...\n\nLuckily currently I have only one shard (with 3 replicas) - that's what was figured out to be the best for our case. But it's a very good point to consider in the future when we have more than one shard. Thank you. ",
            "id": "comment-15510369"
        },
        {
            "date": "2016-09-21T16:06:05+0000",
            "author": "Yury Kartsev",
            "content": "Solr can generate a UUID value, but it's essentially just a random number, and each value has no connection to the other data in the indexed document at all. \nThat's what I thought is false. That was the whole reason of why I wanted SOLR to generate it - to avoid that rare case when UUID matches the existing one. I thought SOLR uses some kind of algorithm that somehow eliminates such a case. I did not want to generate it on client side solely because of that reason - being afraid that one day it will generate an existing one. But if you're saying that that's what SOLR may do, then it make no difference form this point of view... Are you sure about \"has no connection to the other data in the indexed document at all\"? I.e. doesn't it have \"counter\" or \"sequence-like\" part in UUID generation algorithm? ",
            "id": "comment-15510395"
        },
        {
            "date": "2016-09-21T16:53:15+0000",
            "author": "Shawn Heisey",
            "content": "Are you sure about \"has no connection to the other data in the indexed document at all\"?\n\nYes, I am sure.  This one line is the entirety of the code in UUIDUpdateProcessorFactory that sets the default value for the field:\n\n\n  return UUID.randomUUID().toString().toLowerCase(Locale.ROOT);\n\n\n\nThis is the function being used there:\n\nhttps://docs.oracle.com/javase/8/docs/api/java/util/UUID.html#randomUUID--\n\nAlthough generating an already-used ID would be rare just because of the sheer size of the number (128 bits), there's nothing in the code to prevent it. ",
            "id": "comment-15510499"
        },
        {
            "date": "2016-09-21T18:10:02+0000",
            "author": "Yury Kartsev",
            "content": "Thank you. Then definitely it's better to generate it on the client side before indexing. Interesting, coz now I don't see any point at all in automatically generating a uniqueKey field in SOLR... unless it's a single instance/1 shard and nobody cares about ID on the client side. ",
            "id": "comment-15510708"
        },
        {
            "date": "2016-09-30T17:49:25+0000",
            "author": "Alexandre Rafalovitch",
            "content": "Can this case be closed now? It is not a bug and there is no next action on it. ",
            "id": "comment-15536574"
        },
        {
            "date": "2016-09-30T19:10:36+0000",
            "author": "Yury Kartsev",
            "content": "Closing as \"Not A Problem\". Automatic generation of the UUID field happens only if that field was not sent to SOLR. The ticket was created with assumption that generation should happen for fields sent with 'null' values as well. This is not the case by design.\nAlthough if generation is needed for null-valued fields, there is a workaround for that: IgnoreFieldUpdateProcessorFactory that can be used for that (see above).\n\nThank you everyone for your help! ",
            "id": "comment-15536771"
        }
    ]
}