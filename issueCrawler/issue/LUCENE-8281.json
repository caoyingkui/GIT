{
    "id": "LUCENE-8281",
    "title": "Random polygon test failures",
    "details": {
        "components": [
            "modules/spatial3d"
        ],
        "status": "Closed",
        "resolution": "Fixed",
        "fix_versions": [
            "6.7",
            "7.4",
            "master (8.0)"
        ],
        "affect_versions": "None",
        "labels": "",
        "priority": "Major",
        "type": "Bug"
    },
    "description": "Reproduce here:\n\n\nant test  -Dtestcase=RandomGeoPolygonTest -Dtests.method=testCompareSmallPolygons -Dtests.seed=42573983280EE568 -Dtests.multiplier=3 -Dtests.slow=true -Dtests.locale=jmc-TZ -Dtests.timezone=US/Alaska -Dtests.asserts=true -Dtests.file.encoding=US-ASCII",
    "attachments": {
        "LUCENE-8281.jpg": "https://issues.apache.org/jira/secure/attachment/12920845/LUCENE-8281.jpg",
        "LUCENE-8281-debugging.patch": "https://issues.apache.org/jira/secure/attachment/12920904/LUCENE-8281-debugging.patch"
    },
    "issue_links": {},
    "comments": [
        {
            "id": "comment-16454402",
            "author": "Karl Wright",
            "content": "Getting ready to commit AwaitsFix annotations to all the random tests that started failing with the work done within the last 12 hours for GeoComplexPolygons.  Given that this was a relatively minor change I wonder what's going on. ",
            "date": "2018-04-26T15:32:35+0000"
        },
        {
            "id": "comment-16454570",
            "author": "ASF subversion and git services",
            "content": "Commit e912ed2a2c7a04290f84f4ddfc539b877394d006 in lucene-solr's branch refs/heads/master from Karl Wright\n[ https://git-wip-us.apache.org/repos/asf?p=lucene-solr.git;h=e912ed2 ]\n\nLUCENE-8281: Add a test for the new kind of failure, but disabled ",
            "date": "2018-04-26T17:15:50+0000"
        },
        {
            "id": "comment-16454571",
            "author": "ASF subversion and git services",
            "content": "Commit f602fc19f78986cb6ba27c58cbc4bca07ba389d1 in lucene-solr's branch refs/heads/branch_7x from Karl Wright\n[ https://git-wip-us.apache.org/repos/asf?p=lucene-solr.git;h=f602fc1 ]\n\nLUCENE-8281: Add a test for the new kind of failure, but disabled ",
            "date": "2018-04-26T17:16:37+0000"
        },
        {
            "id": "comment-16454572",
            "author": "ASF subversion and git services",
            "content": "Commit 3e34429611009c7e1edde49924daf5614524bc81 in lucene-solr's branch refs/heads/branch_6x from Karl Wright\n[ https://git-wip-us.apache.org/repos/asf?p=lucene-solr.git;h=3e34429 ]\n\nLUCENE-8281: Add a test for the new kind of failure, but disabled ",
            "date": "2018-04-26T17:17:05+0000"
        },
        {
            "id": "comment-16454575",
            "author": "Karl Wright",
            "content": "Ignacio Vera, would it be possible to generate a graphic from this?  The test case is committed as part of GeoComplexPolygon. ",
            "date": "2018-04-26T17:18:53+0000"
        },
        {
            "id": "comment-16454627",
            "author": "Karl Wright",
            "content": "Ignacio Vera Looks pretty simple, but where is the second leg? ",
            "date": "2018-04-26T17:58:52+0000"
        },
        {
            "id": "comment-16454631",
            "author": "Ignacio Vera",
            "content": "This is what is happening:\n\na) Polygon is created with testpoint1 inside the polygon\n\nb) testpoint2 ins computed as inside the polygon (wrong!)\n\n3) check point is on one of the plane test but cannot be traveled so throws an exception (that is the path in the graph).\n\n4) evaluate membership with testpoint2. It does the right thing but because membership is wrongly computed it fails.\u00a0\n\n\u00a0\n\n\u00a0 ",
            "date": "2018-04-26T18:00:02+0000"
        },
        {
            "id": "comment-16454662",
            "author": "Karl Wright",
            "content": "The debugging output shows no crossings are detected, but I can't make sense of the organization of the output.  There are THREE travel planes being traversed; two for finding the in/out of set for the intersection point, and two for finding the in/out of set for the final check point:\n\n\n   [junit4]   1> Edge [[lat=-1.2617196632339242E-5, lon=-1.5701544210600105E-5([X=1.001118853788849, Y=-1.5719111944122703E-5, Z=-1.2631313432823315E-5])] --> [lat=-3.89514302068452E-6, lon=6.597839410815709E-6([X=1.0011188539630433, Y=6.605221429683868E-6, Z=-3.89950111699443E-6])]] crossed travel plane [A=0.0, B=1.0; C=0.0; D=-5.132245021274452E-6]\n   [junit4]   1> Edge [[lat=3.8977187534179774E-6, lon=1.9713406091526057E-5([X=1.0011188537902969, Y=1.9735462513207743E-5, Z=3.902079731596721E-6])] --> [lat=1.980614928404974E-5, lon=4.069266235973146E-6([X=1.0011188537865057, Y=4.07381914993205E-6, Z=1.982830947192924E-5])]] crossed travel plane [A=0.0, B=1.0; C=0.0; D=-5.132245021274452E-6]\n\n\n\nthen:\n\n\n   [junit4]   1> Edge [[lat=7.4E-323, lon=0.0([X=1.0011188539924791, Y=0.0, Z=7.4E-323])] --> [lat=-1.2617196632339242E-5, lon=-1.5701544210600105E-5([X=1.001118853788849, Y=-1.5719111944122703E-5, Z=-1.2631313432823315E-5])]] crossed travel plane [A=0.0, B=0.0; C=1.0; D=7.291706183250981E-7]\n   [junit4]   1> Edge [[lat=-2.8213942160840002E-6, lon=1.608008770581648E-5([X=1.0011188538590383, Y=1.60980789753873E-5, Z=-2.8245509442632E-6])] --> [lat=3.8977187534179774E-6, lon=1.9713406091526057E-5([X=1.0011188537902969, Y=1.9735462513207743E-5, Z=3.902079731596721E-6])]] crossed travel plane [A=0.0, B=0.0; C=1.0; D=7.291706183250981E-7]\n\n\n\nAt this point the testPoint2 in-set determination has been made.  Then, we have a run against testPoint1:\n\n\n   [junit4]   1> Edge [[lat=7.4E-323, lon=0.0([X=1.0011188539924791, Y=0.0, Z=7.4E-323])] --> [lat=-1.2617196632339242E-5, lon=-1.5701544210600105E-5([X=1.001118853788849, Y=-1.5719111944122703E-5, Z=-1.2631313432823315E-5])]] crossed travel plane [A=0.0, B=1.0; C=0.0; D=5.132245021274452E-6]\n   [junit4]   1> Edge [[lat=-1.2617196632339242E-5, lon=-1.5701544210600105E-5([X=1.001118853788849, Y=-1.5719111944122703E-5, Z=-1.2631313432823315E-5])] --> [lat=-3.89514302068452E-6, lon=6.597839410815709E-6([X=1.0011188539630433, Y=6.605221429683868E-6, Z=-3.89950111699443E-6])]] crossed travel plane [A=0.0, B=1.0; C=0.0; D=5.132245021274452E-6]\n\n\n\n... but that fails, so we do a run against testPoint2:\n\n\n   [junit4]   1> Edge [[lat=1.980614928404974E-5, lon=4.069266235973146E-6([X=1.0011188537865057, Y=4.07381914993205E-6, Z=1.982830947192924E-5])] --> [lat=7.4E-323, lon=0.0([X=1.0011188539924791, Y=0.0, Z=7.4E-323])]] crossed travel plane [A=0.0, B=0.0; C=1.0; D=-4.98859471828087E-6]\n   [junit4]   1> Edge [[lat=3.8977187534179774E-6, lon=1.9713406091526057E-5([X=1.0011188537902969, Y=1.9735462513207743E-5, Z=3.902079731596721E-6])] --> [lat=1.980614928404974E-5, lon=4.069266235973146E-6([X=1.0011188537865057, Y=4.07381914993205E-6, Z=1.982830947192924E-5])]] crossed travel plane [A=0.0, B=0.0; C=1.0; D=-4.98859471828087E-6]\n\n\n\nWhen I enable use of testPoint2 as the primary means of determining in-set-ness, we see quite a lot of failures, so clearly the logic that finds crossings going from testPoint1 to testPoint2 is not working as expected.  More research later. ",
            "date": "2018-04-26T18:20:00+0000"
        },
        {
            "id": "comment-16454866",
            "author": "Karl Wright",
            "content": "I added a reverse assertion to the code which cross-checks the second test point against the first after its in-set-ness has been determined.  This assertion fails pretty regularly.  With the assertion in place, you can blow it up with the following already-existing test:\n\n\nant test  -Dtestcase=GeoPolygonTest -Dtests.method=testLUCENE8276_case1\n\n\n\nThe assertion code is pretty straightforward:\n\n\n    assert isInSet(testPoint1.x, testPoint1.y, testPoint1.z,\n      testPoint2,\n      testPoint2InSet,\n      testPoint2FixedXPlane, testPoint2FixedXAbovePlane, testPoint2FixedXBelowPlane,\n      testPoint2FixedYPlane, testPoint2FixedYAbovePlane, testPoint2FixedYBelowPlane,\n      testPoint2FixedZPlane, testPoint2FixedZAbovePlane, testPoint2FixedZBelowPlane) == testPoint1InSet : \"Test point1 not correctly in/out of set according to test point2\";\n\n\n\nDebugging now to figure out why this doesn't reliably work. ",
            "date": "2018-04-26T21:02:12+0000"
        },
        {
            "id": "comment-16455502",
            "author": "Karl Wright",
            "content": "I'm actually more or less stumped by this.  Here's my debug output.  There are two operations here; first, figure out of the second test point is in-set or not:\n\n\n   [junit4]   1> Determining in-set-ness of test point2 ([X=-0.9999999999993657, Y=-1.124732395751746E-6, Z=-5.8143386268861615E-8]):\n   [junit4]   1> \n   [junit4]   1> IsInSet called for [-0.9999999999993657,-1.124732395751746E-6,-5.8143386268861615E-8], testPoint=[lat=5.8143386268861655E-8, lon=1.1247323957519851E-6([X=0.9999999999993657, Y=1.124732395751746E-6, Z=5.8143386268861615E-8])]; is in set? true\n   [junit4]   1>  Using two planes\n   [junit4]   1>  Picking XZ then XY\n   [junit4]   1>  Finding whether [X=0.9999999999993657, Y=-1.124732395751746E-6, Z=5.8143386268861615E-8] is in-set, based on travel from [lat=5.8143386268861655E-8, lon=1.1247323957519851E-6([X=0.9999999999993657, Y=1.124732395751746E-6, Z=5.8143386268861615E-8])] along [A=0.0, B=0.0; C=1.0; D=-5.8143386268861615E-8] (value=5.8143386268861615E-8)\n   [junit4]   1>  Constructing sector linear crossing edge iterator\n   [junit4]   1>  Edge [[lat=-2.7797906712270083E-7, lon=1.8357011217773334E-6([X=0.9999999999982765, Y=1.8357011217762314E-6, Z=-2.7797906712269723E-7])] --> [lat=4.492749557241206E-7, lon=1.8019115568534971E-6([X=0.9999999999982758, Y=1.8019115568523405E-6, Z=4.492749557241056E-7])]] potentially crosses travel plane [A=0.0, B=0.0; C=1.0; D=-5.8143386268861615E-8]\n   [junit4]   1>   There are no intersection points within bounds.\n   [junit4]   1>    Endpoint(s) of edge are not on travel plane\n   [junit4]   1>  Edge [[lat=1.255403467900245E-6, lon=1.3751481926504994E-6([X=0.9999999999982665, Y=1.3751481926489823E-6, Z=1.2554034678999154E-6])] --> [lat=1.640689686301266E-25, lon=0.0([X=1.0, Y=0.0, Z=1.640689686301266E-25])]] potentially crosses travel plane [A=0.0, B=0.0; C=1.0; D=-5.8143386268861615E-8]\n   [junit4]   1>   There were intersection points!\n   [junit4]   1>  Edge [[lat=1.255403467900245E-6, lon=1.3751481926504994E-6([X=0.9999999999982665, Y=1.3751481926489823E-6, Z=1.2554034678999154E-6])] --> [lat=1.640689686301266E-25, lon=0.0([X=1.0, Y=0.0, Z=1.640689686301266E-25])]] intersects travel plane [A=0.0, B=0.0; C=1.0; D=-5.8143386268861615E-8]\n   [junit4]   1>   Intersection point in-set? false\n   [junit4]   1>  Finding whether [-0.9999999999993657,-1.124732395751746E-6,-5.8143386268861615E-8] is in-set, based on travel from [X=0.9999999999993657, Y=-1.124732395751746E-6, Z=5.8143386268861615E-8] along [A=0.0, B=1.0; C=0.0; D=1.124732395751746E-6] (value=-1.124732395751746E-6)\n   [junit4]   1>  Constructing full linear crossing edge iterator\n   [junit4]   1>  Check point in set? false\n   [junit4]   1> \n\n\n\nWhen that is done, the code fires off an assertion, that basically says if you go back to the first test point, you should get the same in-set-ness for it that you started with:\n\n\n   [junit4]   1> ... done.  Checking against test point1 ([lat=5.8143386268861655E-8, lon=1.1247323957519851E-6([X=0.9999999999993657, Y=1.124732395751746E-6, Z=5.8143386268861615E-8])]):\n   [junit4]   1> \n   [junit4]   1> IsInSet called for [0.9999999999993657,1.124732395751746E-6,5.8143386268861615E-8], testPoint=[X=-0.9999999999993657, Y=-1.124732395751746E-6, Z=-5.8143386268861615E-8]; is in set? false\n   [junit4]   1>  Using two planes\n   [junit4]   1>  Picking XZ then XY\n   [junit4]   1>  Finding whether [X=0.9999999999993657, Y=1.124732395751746E-6, Z=-5.8143386268861615E-8] is in-set, based on travel from [X=-0.9999999999993657, Y=-1.124732395751746E-6, Z=-5.8143386268861615E-8] along [A=0.0, B=0.0; C=1.0; D=5.8143386268861615E-8] (value=-5.8143386268861615E-8)\n   [junit4]   1>  Constructing sector linear crossing edge iterator\n   [junit4]   1>  Edge [[lat=-2.7797906712270083E-7, lon=1.8357011217773334E-6([X=0.9999999999982765, Y=1.8357011217762314E-6, Z=-2.7797906712269723E-7])] --> [lat=4.492749557241206E-7, lon=1.8019115568534971E-6([X=0.9999999999982758, Y=1.8019115568523405E-6, Z=4.492749557241056E-7])]] potentially crosses travel plane [A=0.0, B=0.0; C=1.0; D=5.8143386268861615E-8]\n   [junit4]   1>   There are no intersection points within bounds.\n   [junit4]   1>    Endpoint(s) of edge are not on travel plane\n   [junit4]   1>  Edge [[lat=1.640689686301266E-25, lon=0.0([X=1.0, Y=0.0, Z=1.640689686301266E-25])] --> [lat=-1.135982425157425E-6, lon=6.109011074784121E-7([X=0.9999999999991683, Y=6.1090110747798E-7, Z=-1.1359824251571808E-6])]] potentially crosses travel plane [A=0.0, B=0.0; C=1.0; D=5.8143386268861615E-8]\n   [junit4]   1>   There are no intersection points within bounds.\n   [junit4]   1>    Endpoint(s) of edge are not on travel plane\n   [junit4]   1>   Intersection point in-set? false\n   [junit4]   1>  Finding whether [0.9999999999993657,1.124732395751746E-6,5.8143386268861615E-8] is in-set, based on travel from [X=0.9999999999993657, Y=1.124732395751746E-6, Z=-5.8143386268861615E-8] along [A=0.0, B=1.0; C=0.0; D=-1.124732395751746E-6] (value=1.124732395751746E-6)\n   [junit4]   1>  Constructing sector linear crossing edge iterator\n   [junit4]   1>  Edge [[lat=-1.135982425157425E-6, lon=6.109011074784121E-7([X=0.9999999999991683, Y=6.1090110747798E-7, Z=-1.1359824251571808E-6])] --> [lat=-2.7797906712270083E-7, lon=1.8357011217773334E-6([X=0.9999999999982765, Y=1.8357011217762314E-6, Z=-2.7797906712269723E-7])]] potentially crosses travel plane [A=0.0, B=1.0; C=0.0; D=-1.124732395751746E-6]\n   [junit4]   1>   There are no intersection points within bounds.\n   [junit4]   1>    Endpoint(s) of edge are not on travel plane\n   [junit4]   1>  Edge [[lat=1.255403467900245E-6, lon=1.3751481926504994E-6([X=0.9999999999982665, Y=1.3751481926489823E-6, Z=1.2554034678999154E-6])] --> [lat=1.640689686301266E-25, lon=0.0([X=1.0, Y=0.0, Z=1.640689686301266E-25])]] potentially crosses travel plane [A=0.0, B=1.0; C=0.0; D=-1.124732395751746E-6]\n   [junit4]   1>   There are no intersection points within bounds.\n   [junit4]   1>    Endpoint(s) of edge are not on travel plane\n   [junit4]   1>  Check point in set? false\n\n\n\nNote that there are two very different pairs of travel planes chosen for the first isInSet() check than for the second.  Both should be valid, and should yield the same number of crossings.  But they don't.  The first pair of planes has a crossing (a single one), culled from two possibilities.  The second has four possibilities, but zero intersections.  The first pair has one full-180-length span, while the second doesn't.\n\nIgnacio Vera, I need to find the error here.  (1) Are we missing any potential crossings that we should be picking up?  (2) Are we finding a potential crossing that is probably an intersection that isn't being detected as such?\n\nI've attached the debugging code I'm using, as a patch, in case you want to drill in further. ",
            "date": "2018-04-26T22:45:59+0000"
        },
        {
            "id": "comment-16455515",
            "author": "Karl Wright",
            "content": "Edges (including their bounds, which figure into what they should match):\n\n\n   [junit4]   1> Recording edge [[lat=-1.135982425157425E-6, lon=6.109011074784121E-7([X=0.9999999999991683, Y=6.1090110747798E-7, Z=-1.1359824251571808E-6])] --> [lat=-2.7797906712270083E-7, lon=1.8357011217773334E-6([X=0.9999999999982765, Y=1.8357011217762314E-6, Z=-2.7797906712269723E-7])]]; bounds = XYZBounds: [xmin=0.9999999989982765 xmax=1.0000000009991798 ymin=6.0990110747798E-7 ymax=1.8367011217762314E-6 zmin=-1.136982425157181E-6 zmax=-2.769790671226972E-7]\n   [junit4]   1> Recording edge [[lat=-2.7797906712270083E-7, lon=1.8357011217773334E-6([X=0.9999999999982765, Y=1.8357011217762314E-6, Z=-2.7797906712269723E-7])] --> [lat=4.492749557241206E-7, lon=1.8019115568534971E-6([X=0.9999999999982758, Y=1.8019115568523405E-6, Z=4.492749557241056E-7])]]; bounds = XYZBounds: [xmin=0.9999999989982759 xmax=1.0000000009983425 ymin=1.8009115568523404E-6 ymax=1.8367011217762314E-6 zmin=-2.7897906712269725E-7 zmax=4.5027495572410565E-7]\n   [junit4]   1> Recording edge [[lat=4.492749557241206E-7, lon=1.8019115568534971E-6([X=0.9999999999982758, Y=1.8019115568523405E-6, Z=4.492749557241056E-7])] --> [lat=1.255403467900245E-6, lon=1.3751481926504994E-6([X=0.9999999999982665, Y=1.3751481926489823E-6, Z=1.2554034678999154E-6])]]; bounds = XYZBounds: [xmin=0.9999999989982665 xmax=1.0000000009983752 ymin=1.3741481926489823E-6 ymax=1.8029115568523406E-6 zmin=4.482749557241056E-7 zmax=1.2564034678999155E-6]\n   [junit4]   1> Recording edge [[lat=1.255403467900245E-6, lon=1.3751481926504994E-6([X=0.9999999999982665, Y=1.3751481926489823E-6, Z=1.2554034678999154E-6])] --> [lat=1.640689686301266E-25, lon=0.0([X=1.0, Y=0.0, Z=1.640689686301266E-25])]]; bounds = XYZBounds: [xmin=0.9999999989982665 xmax=1.000000001 ymin=-1.0E-9 ymax=1.3761481926489824E-6 zmin=-1.0E-9 zmax=1.2564034678999155E-6]\n   [junit4]   1> Recording edge [[lat=1.640689686301266E-25, lon=0.0([X=1.0, Y=0.0, Z=1.640689686301266E-25])] --> [lat=-1.135982425157425E-6, lon=6.109011074784121E-7([X=0.9999999999991683, Y=6.1090110747798E-7, Z=-1.1359824251571808E-6])]]; bounds = XYZBounds: [xmin=0.9999999989991684 xmax=1.000000001 ymin=-1.0E-9 ymax=6.1190110747798E-7 zmin=-1.136982425157181E-6 zmax=1.0000000000000003E-9]\n\n ",
            "date": "2018-04-26T23:00:00+0000"
        },
        {
            "id": "comment-16455564",
            "author": "Karl Wright",
            "content": "I've confirmed that the proper edges are traversed for each travel plane \u2013 if the bounds are correct for each edge.\n ",
            "date": "2018-04-26T23:42:05+0000"
        },
        {
            "id": "comment-16455786",
            "author": "Ignacio Vera",
            "content": "This might be useful and it is something I noticed when developing the random test. If I construct the testpoint2 in the following way:\n\n// Pick the antipodes for testPoint2\nGeoPoint p = new GeoPoint(-testPoint.x, -testPoint.y, -testPoint.z);\nthis.testPoint2 = new GeoPoint(planetModel, p.getLatitude(), p.getLongitude());\n\nThen we get:\n\nFinding whether [-1.0011188539790565,-5.132245021424039E-6,-7.291706183250981E-7] is in-set, based on travel from [X=1.0011188539790565, Y=5.132245021274452E-6, Z=-7.291706183250981E-7] along [A=0.0, B=0.0; C=1.0; D=7.291706183250981E-7] (value=-7.291706183250981E-7)\n\u00a0Constructing sector linear crossing edge iterator\n\u00a0Edge [[lat=7.4E-323, lon=0.0([X=1.0011188539924791, Y=0.0, Z=7.4E-323])] --> [lat=-1.2617196632339242E-5, lon=-1.5701544210600105E-5([X=1.001118853788849, Y=-1.5719111944122703E-5, Z=-1.2631313432823315E-5])]] potentially crosses travel plane [A=0.0, B=0.0; C=1.0; D=7.291706183250981E-7]\n\u00a0 There were intersection points!\n\u00a0Edge [[lat=7.4E-323, lon=0.0([X=1.0011188539924791, Y=0.0, Z=7.4E-323])] --> [lat=-1.2617196632339242E-5, lon=-1.5701544210600105E-5([X=1.001118853788849, Y=-1.5719111944122703E-5, Z=-1.2631313432823315E-5])]] intersects travel plane [A=0.0, B=0.0; C=1.0; D=7.291706183250981E-7]\n\u00a0Edge [[lat=-2.8213942160840002E-6, lon=1.608008770581648E-5([X=1.0011188538590383, Y=1.60980789753873E-5, Z=-2.8245509442632E-6])] --> [lat=3.8977187534179774E-6, lon=1.9713406091526057E-5([X=1.0011188537902969, Y=1.9735462513207743E-5, Z=3.902079731596721E-6])]] potentially crosses travel plane [A=0.0, B=0.0; C=1.0; D=7.291706183250981E-7]\n\u00a0 There are no intersection points within bounds.\n\u00a0\u00a0 Endpoint(s) of edge are not on travel plane\n\u00a0Check point in set? false\n\nWhich is the right answer. Looking at the differences:\n\nCase 1) Failing\ntest point2 ([X=-1.0011188539790565, Y=-5.132245021274452E-6, Z=-7.291706183250981E-7]):\n\nConstructing sector linear crossing edge iterator with bounds:\n\u00a0 bound1:[A=5.126509205983227E-6, B=-0.9999999999868595, C=0.0, D=0.0, side=-1.0]\n\u00a0 bound2:[A=-5.126509205983227E-6, B=0.9999999999868595, C=0.0, D=0.0, side=-1.0]\n\nCase 2) Success\ntest point2 ([lat=-7.283556946482617E-7, lon=-3.141587527080587([X=-1.0011188539790565, Y=-5.132245021424039E-6, Z=-7.291706183250981E-7])]):\n\nConstructing sector linear crossing edge iterator with bounds:\n\u00a0 bound1:[A=7.283556946481974E-7, B=0.0, C=-0.9999999999997348, D=0.0, side=-1.0]\n\u00a0 bound2:[A=4.983019447078322E-6, B=0.0, C=-0.9999999999875847, D=0.0, side=1.0]\n\n\u00a0\n\nSo clearly bounds for the iterator are totally messed up.\n\n\u00a0 ",
            "date": "2018-04-27T05:42:02+0000"
        },
        {
            "id": "comment-16455796",
            "author": "Karl Wright",
            "content": "Ignacio Vera, that's a very good observation.  I wonder why test point 1 is not on the ellipsoid?  Your change in construction of test point 2 essentially puts test point 2 on the ellipsoid even if test point 1 is not.  Let me look at why this might be. ",
            "date": "2018-04-27T05:57:56+0000"
        },
        {
            "id": "comment-16455813",
            "author": "Karl Wright",
            "content": "Hmm, I added the following assertion for both test point 1 and 2:\n\n\n    assert planetModel.pointOnSurface(testPoint.x, testPoint.y, testPoint.z) : \"Test point is not on the ellipsoid surface\";\n\n\n\nThis assertion passes in both cases.  And yet the point you get from your \"alternate\" way of constructing the second test point is quite different in x, y, and z.  The differences look too big to be mere precision errors. ",
            "date": "2018-04-27T06:14:13+0000"
        },
        {
            "id": "comment-16455880",
            "author": "Karl Wright",
            "content": "Ignacio Vera  The edges you have and the test point you see are completely different from the ones I'm seeing and trying to analyze.  I think we first have to agree on the same test case?  This is the one I'm exploring, which has generated all the comments attached to this ticket:\n\n\nant test  -Dtestcase=GeoPolygonTest -Dtests.method=testLUCENE8276_case1\n\n ",
            "date": "2018-04-27T06:23:27+0000"
        },
        {
            "id": "comment-16455998",
            "author": "Ignacio Vera",
            "content": "Sorry I was mislead by the title of the ticket. That test case shows a similar error but somewhere else, when computing membership the check point:\n\nIsInSet called for [0.9999999999993657,1.124732395751746E-6,5.8143386268861615E-8], testPoint=[X=-0.9999999999993657, Y=-1.124732395751746E-6, Z=-5.8143386268861615E-8]; is in set? false\n\u00a0Using two planes\n\u00a0Picking XZ then XY\n\u00a0Finding whether [X=0.9999999999993657, Y=1.124732395751746E-6, Z=-5.8143386268861615E-8] is in-set, based on travel from [X=-0.9999999999993657, Y=-1.124732395751746E-6, Z=-5.8143386268861615E-8] along [A=0.0, B=0.0; C=1.0; D=5.8143386268861615E-8] (value=-5.8143386268861615E-8)\n\u00a0Constructing sector linear crossing edge iterator with bounds:\n\u00a0 bound1:[A=1.124732395751748E-6, B=-0.9999999999993675, C=0.0, D=0.0, side=-1.0]\n\u00a0 bound2:[A=-1.124732395751748E-6, B=0.9999999999993675, C=0.0, D=0.0, side=-1.0]\n\n\u00a0\n\nSo we can rule out that the problem is that points are not on the surface. ",
            "date": "2018-04-27T06:43:25+0000"
        },
        {
            "id": "comment-16456017",
            "author": "Karl Wright",
            "content": "Ignacio Vera, ok good.\nThe test case I made for the ticket originally was resolved by removing those same two lines of code you removed earlier.  My debugging patch includes that removal, and it looks like you applied it, so the original test case now passes \u2013 because it can use test point 1, and doesn't need to fall back to test point 2.\n\nBasically, the problem is that test point 2's in-set determination is unreliable, and I don't understand why.  I think if we can analyze the identified failure (testLUCENE8276_case1) we should be able to solve the problem.  This is where things stand:\n\n(1) IF we assume that the individual Edge XYZBounds are computed correctly, then we are seeing the right Edge objects are showing up in the iterator for each travel leg.\n(2) We still get a single intersection going from test point 1 -> test point 2, and no intersections going from test point 2 -> test point 1.  So we are (possibly?) missing an intersection we should find on the test point 2 -> test point 1 traverse.  I really don't know whether Test Point 2 should be in-set or not \u2013 maybe you can figure that out?\n(3) The edge endpoints are far enough from all travel planes so that it does not appear to be a case of a simple precision error.\n(4) All potential intersections that get rejected, get rejected because of bounds.  I'm working to figure out if any of these rejections is close enough that conceivably it shouldn't be rejected. ",
            "date": "2018-04-27T06:57:05+0000"
        },
        {
            "id": "comment-16456030",
            "author": "Karl Wright",
            "content": "Here's the latest complete debugging dump.\n\nNote that I've added forensics that detail why a computed intersection point gets rejected.  None of these are even close, though \u2013 at least 5 orders of magnitude from being marginal.  So I'm still stumped.\n\nI'm beginning to think that the problem must be one of the XYZBounds computations for the individual edges.  I wish there was a good way to verify those.\n\n\n   [junit4]   1> Recording edge [[lat=-1.135982425157425E-6, lon=6.109011074784121E-7([X=0.9999999999991683, Y=6.1090110747798E-7, Z=-1.1359824251571808E-6])] --> [lat=-2.7797906712270083E-7, lon=1.8357011217773334E-6([X=0.9999999999982765, Y=1.8357011217762314E-6, Z=-2.7797906712269723E-7])]]; bounds = XYZBounds: [xmin=0.9999999989982765 xmax=1.0000000009991798 ymin=6.0990110747798E-7 ymax=1.8367011217762314E-6 zmin=-1.136982425157181E-6 zmax=-2.769790671226972E-7]\n   [junit4]   1> Recording edge [[lat=-2.7797906712270083E-7, lon=1.8357011217773334E-6([X=0.9999999999982765, Y=1.8357011217762314E-6, Z=-2.7797906712269723E-7])] --> [lat=4.492749557241206E-7, lon=1.8019115568534971E-6([X=0.9999999999982758, Y=1.8019115568523405E-6, Z=4.492749557241056E-7])]]; bounds = XYZBounds: [xmin=0.9999999989982759 xmax=1.0000000009983425 ymin=1.8009115568523404E-6 ymax=1.8367011217762314E-6 zmin=-2.7897906712269725E-7 zmax=4.5027495572410565E-7]\n   [junit4]   1> Recording edge [[lat=4.492749557241206E-7, lon=1.8019115568534971E-6([X=0.9999999999982758, Y=1.8019115568523405E-6, Z=4.492749557241056E-7])] --> [lat=1.255403467900245E-6, lon=1.3751481926504994E-6([X=0.9999999999982665, Y=1.3751481926489823E-6, Z=1.2554034678999154E-6])]]; bounds = XYZBounds: [xmin=0.9999999989982665 xmax=1.0000000009983752 ymin=1.3741481926489823E-6 ymax=1.8029115568523406E-6 zmin=4.482749557241056E-7 zmax=1.2564034678999155E-6]\n   [junit4]   1> Recording edge [[lat=1.255403467900245E-6, lon=1.3751481926504994E-6([X=0.9999999999982665, Y=1.3751481926489823E-6, Z=1.2554034678999154E-6])] --> [lat=1.640689686301266E-25, lon=0.0([X=1.0, Y=0.0, Z=1.640689686301266E-25])]]; bounds = XYZBounds: [xmin=0.9999999989982665 xmax=1.000000001 ymin=-1.0E-9 ymax=1.3761481926489824E-6 zmin=-1.0E-9 zmax=1.2564034678999155E-6]\n   [junit4]   1> Recording edge [[lat=1.640689686301266E-25, lon=0.0([X=1.0, Y=0.0, Z=1.640689686301266E-25])] --> [lat=-1.135982425157425E-6, lon=6.109011074784121E-7([X=0.9999999999991683, Y=6.1090110747798E-7, Z=-1.1359824251571808E-6])]]; bounds = XYZBounds: [xmin=0.9999999989991684 xmax=1.000000001 ymin=-1.0E-9 ymax=6.1190110747798E-7 zmin=-1.136982425157181E-6 zmax=1.0000000000000003E-9]\n   [junit4]   1> Determining in-set-ness of test point2 ([X=-0.9999999999993657, Y=-1.124732395751746E-6, Z=-5.8143386268861615E-8]):\n   [junit4]   1> \n   [junit4]   1> IsInSet called for [-0.9999999999993657,-1.124732395751746E-6,-5.8143386268861615E-8], testPoint=[lat=5.8143386268861655E-8, lon=1.1247323957519851E-6([X=0.9999999999993657, Y=1.124732395751746E-6, Z=5.8143386268861615E-8])]; is in set? true\n   [junit4]   1>  Using two planes\n   [junit4]   1>   Looking for intersections between travel and test point planes...\n   [junit4]   1>  Picking XZ then XY\n   [junit4]   1>   Looking for intersections between travel and test point planes...\n   [junit4]   1>  Finding whether [X=0.9999999999993657, Y=-1.124732395751746E-6, Z=5.8143386268861615E-8] is in-set, based on travel from [lat=5.8143386268861655E-8, lon=1.1247323957519851E-6([X=0.9999999999993657, Y=1.124732395751746E-6, Z=5.8143386268861615E-8])] along [A=0.0, B=0.0; C=1.0; D=-5.8143386268861615E-8] (value=5.8143386268861615E-8)\n   [junit4]   1>  Constructing sector linear crossing edge iterator\n   [junit4]   1>  Edge [[lat=-2.7797906712270083E-7, lon=1.8357011217773334E-6([X=0.9999999999982765, Y=1.8357011217762314E-6, Z=-2.7797906712269723E-7])] --> [lat=4.492749557241206E-7, lon=1.8019115568534971E-6([X=0.9999999999982758, Y=1.8019115568523405E-6, Z=4.492749557241056E-7])]] potentially crosses travel plane [A=0.0, B=0.0; C=1.0; D=-5.8143386268861615E-8]\n   [junit4]   1>   Finding intersections between edge plane and travel plane...\n   [junit4]   1>   There are no intersection points within bounds.\n   [junit4]   1>    Crossing point [X=0.999999999998342, Y=1.820084251873324E-6, Z=5.8143386268861615E-8] rejected by bound1 (6.953518561222897E-7)\n   [junit4]   1>    Crossing point [X=-0.9999999999983322, Y=-1.8254871500725794E-6, Z=5.8143386268861615E-8] rejected by bound2 (-2.950219545821297E-6)\n   [junit4]   1>    Crossing point [X=-0.9999999999983322, Y=-1.8254871500725794E-6, Z=5.8143386268861615E-8] rejected by edge.startPlane (-2.2007283293136158E-7)\n   [junit4]   1>    Crossing point [X=-0.9999999999983322, Y=-1.8254871500725794E-6, Z=5.8143386268861615E-8] rejected by edge.endPlane (5.079657295394685E-7)\n   [junit4]   1>    Endpoint(s) of edge are not on travel plane; distances: -3.3612245339155885E-7 and 3.91131569455244E-7\n   [junit4]   1>  Edge [[lat=1.255403467900245E-6, lon=1.3751481926504994E-6([X=0.9999999999982665, Y=1.3751481926489823E-6, Z=1.2554034678999154E-6])] --> [lat=1.640689686301266E-25, lon=0.0([X=1.0, Y=0.0, Z=1.640689686301266E-25])]] potentially crosses travel plane [A=0.0, B=0.0; C=1.0; D=-5.8143386268861615E-8]\n   [junit4]   1>   Finding intersections between edge plane and travel plane...\n   [junit4]   1>   There were intersection points!\n   [junit4]   1>  Edge intersects travel plane [A=0.0, B=0.0; C=1.0; D=-5.8143386268861615E-8]\n   [junit4]   1>   Intersection point in-set? false\n   [junit4]   1>  Finding whether [-0.9999999999993657,-1.124732395751746E-6,-5.8143386268861615E-8] is in-set, based on travel from [X=0.9999999999993657, Y=-1.124732395751746E-6, Z=5.8143386268861615E-8] along [A=0.0, B=1.0; C=0.0; D=1.124732395751746E-6] (value=-1.124732395751746E-6)\n   [junit4]   1>  Constructing full linear crossing edge iterator\n   [junit4]   1>  Check point in set? false\n   [junit4]   1> \n   [junit4]   1> ... done.  Checking against test point1 ([lat=5.8143386268861655E-8, lon=1.1247323957519851E-6([X=0.9999999999993657, Y=1.124732395751746E-6, Z=5.8143386268861615E-8])]):\n   [junit4]   1> \n   [junit4]   1> IsInSet called for [0.9999999999993657,1.124732395751746E-6,5.8143386268861615E-8], testPoint=[X=-0.9999999999993657, Y=-1.124732395751746E-6, Z=-5.8143386268861615E-8]; is in set? false\n   [junit4]   1>  Using two planes\n   [junit4]   1>   Looking for intersections between travel and test point planes...\n   [junit4]   1>  Picking XZ then XY\n   [junit4]   1>   Looking for intersections between travel and test point planes...\n   [junit4]   1>  Finding whether [X=0.9999999999993657, Y=1.124732395751746E-6, Z=-5.8143386268861615E-8] is in-set, based on travel from [X=-0.9999999999993657, Y=-1.124732395751746E-6, Z=-5.8143386268861615E-8] along [A=0.0, B=0.0; C=1.0; D=5.8143386268861615E-8] (value=-5.8143386268861615E-8)\n   [junit4]   1>  Constructing sector linear crossing edge iterator\n   [junit4]   1>  Edge [[lat=-2.7797906712270083E-7, lon=1.8357011217773334E-6([X=0.9999999999982765, Y=1.8357011217762314E-6, Z=-2.7797906712269723E-7])] --> [lat=4.492749557241206E-7, lon=1.8019115568534971E-6([X=0.9999999999982758, Y=1.8019115568523405E-6, Z=4.492749557241056E-7])]] potentially crosses travel plane [A=0.0, B=0.0; C=1.0; D=5.8143386268861615E-8]\n   [junit4]   1>   Finding intersections between edge plane and travel plane...\n   [junit4]   1>   There are no intersection points within bounds.\n   [junit4]   1>    Crossing point [X=0.9999999999983322, Y=1.8254871500725794E-6, Z=-5.8143386268861615E-8] rejected by bound2 (7.007547543215527E-7)\n   [junit4]   1>    Crossing point [X=-0.999999999998342, Y=-1.820084251873324E-6, Z=-5.8143386268861615E-8] rejected by bound1 (6.953518561222897E-7)\n   [junit4]   1>    Crossing point [X=-0.999999999998342, Y=-1.820084251873324E-6, Z=-5.8143386268861615E-8] rejected by edge.startPlane (-3.364850521189999E-7)\n   [junit4]   1>    Crossing point [X=-0.999999999998342, Y=-1.820084251873324E-6, Z=-5.8143386268861615E-8] rejected by edge.endPlane (3.915535103518376E-7)\n   [junit4]   1>    Endpoint(s) of edge are not on travel plane; distances: -2.1983568085383562E-7 and 5.074183419929672E-7\n   [junit4]   1>  Edge [[lat=1.640689686301266E-25, lon=0.0([X=1.0, Y=0.0, Z=1.640689686301266E-25])] --> [lat=-1.135982425157425E-6, lon=6.109011074784121E-7([X=0.9999999999991683, Y=6.1090110747798E-7, Z=-1.1359824251571808E-6])]] potentially crosses travel plane [A=0.0, B=0.0; C=1.0; D=5.8143386268861615E-8]\n   [junit4]   1>   Finding intersections between edge plane and travel plane...\n   [junit4]   1>   There are no intersection points within bounds.\n   [junit4]   1>    Crossing point [X=-0.9999999999999978, Y=3.126796531139363E-8, Z=-5.8143386268861615E-8] rejected by bound2 (1.1560003610631194E-6)\n   [junit4]   1>    Crossing point [X=-0.9999999999999978, Y=3.126796531139363E-8, Z=-5.8143386268861615E-8] rejected by edge.endPlane (1.3558457034489254E-6)\n   [junit4]   1>    Crossing point [X=0.9999999999999978, Y=3.126796531139363E-8, Z=-5.8143386268861615E-8] rejected by bound1 (1.0934644304403715E-6)\n   [junit4]   1>    Endpoint(s) of edge are not on travel plane; distances: 5.8143386268861615E-8 and -1.0778390388883193E-6\n   [junit4]   1>   Intersection point in-set? false\n   [junit4]   1>  Finding whether [0.9999999999993657,1.124732395751746E-6,5.8143386268861615E-8] is in-set, based on travel from [X=0.9999999999993657, Y=1.124732395751746E-6, Z=-5.8143386268861615E-8] along [A=0.0, B=1.0; C=0.0; D=-1.124732395751746E-6] (value=1.124732395751746E-6)\n   [junit4]   1>  Constructing sector linear crossing edge iterator\n   [junit4]   1>  Edge [[lat=-1.135982425157425E-6, lon=6.109011074784121E-7([X=0.9999999999991683, Y=6.1090110747798E-7, Z=-1.1359824251571808E-6])] --> [lat=-2.7797906712270083E-7, lon=1.8357011217773334E-6([X=0.9999999999982765, Y=1.8357011217762314E-6, Z=-2.7797906712269723E-7])]] potentially crosses travel plane [A=0.0, B=1.0; C=0.0; D=-1.124732395751746E-6]\n   [junit4]   1>   Finding intersections between edge plane and travel plane...\n   [junit4]   1>   There are no intersection points within bounds.\n   [junit4]   1>    Crossing point [X=0.9999999999990665, Y=1.124732395751746E-6, Z=-7.76030624328578E-7] rejected by bound1 (7.178872380597327E-7)\n   [junit4]   1>    Crossing point [X=-0.9999999999966022, Y=1.124732395751746E-6, Z=2.3518375498275934E-6] rejected by bound2 (-2.4099809360962904E-6)\n   [junit4]   1>    Crossing point [X=-0.9999999999966022, Y=1.124732395751746E-6, Z=2.3518375498275934E-6] rejected by edge.endPlane (3.6145616079893093E-6)\n   [junit4]   1>    Endpoint(s) of edge are not on travel plane; distances: -5.138312882737661E-7 and 7.109687260244853E-7\n   [junit4]   1>  Edge [[lat=1.255403467900245E-6, lon=1.3751481926504994E-6([X=0.9999999999982665, Y=1.3751481926489823E-6, Z=1.2554034678999154E-6])] --> [lat=1.640689686301266E-25, lon=0.0([X=1.0, Y=0.0, Z=1.640689686301266E-25])]] potentially crosses travel plane [A=0.0, B=1.0; C=0.0; D=-1.124732395751746E-6]\n   [junit4]   1>   Finding intersections between edge plane and travel plane...\n   [junit4]   1>   There are no intersection points within bounds.\n   [junit4]   1>    Crossing point [X=-0.9999999999988402, Y=1.124732395751746E-6, Z=1.0267932995397135E-6] rejected by bound2 (-1.0849366858085427E-6)\n   [junit4]   1>    Crossing point [X=-0.9999999999988402, Y=1.124732395751746E-6, Z=1.0267932995397135E-6] rejected by edge.startPlane (-3.384940921425686E-6)\n   [junit4]   1>    Crossing point [X=0.9999999999988402, Y=1.124732395751746E-6, Z=1.0267932995397135E-6] rejected by bound2 (-9.68649913270881E-7)\n   [junit4]   1>    Endpoint(s) of edge are not on travel plane; distances: 2.5041579689723626E-7 and -1.124732395751746E-6\n   [junit4]   1>  Check point in set? false\n\n\n\n ",
            "date": "2018-04-27T07:09:17+0000"
        },
        {
            "id": "comment-16456077",
            "author": "Ignacio Vera",
            "content": "I think the problem is that we are building sector linear crossing edge iterators where maths are actually asking for full linear.\n\n\u00a0\n\nCurrently we are only creating full linear if for some reasons bounds bounds in sector linear throw an error. Maybe we need to tighten checks for the bounds in sector linear so if they are numerically identical then we should fall back to full linear. WDYT?\n\n\u00a0 ",
            "date": "2018-04-27T07:46:34+0000"
        },
        {
            "id": "comment-16456178",
            "author": "Karl Wright",
            "content": "Ignacio Vera, right now we only build full linear iterator if we cannot build the specified sector linear iterator, and we get a plane sidedness error doing so.  If we can build a sector iterator, and no error occurs, then by definition we do not need to build a full iterator.  I can think of no reason why this would be incorrect logic.\n\nI have some work-related things I need to do before I get back to looking at this problem.\n\nBy the way, if a full linear iterator would have any chance of solving the problem, the way we'd know this is because we'd see intersection point rejections due to the iterator bounds.  We do not.  As I said before, the debug output above demonstrates conclusively that there are some five orders of magnitude that says this isn't a bounds issue.\n\n\n ",
            "date": "2018-04-27T09:48:38+0000"
        },
        {
            "id": "comment-16456206",
            "author": "Karl Wright",
            "content": "I have a good way to test for whether an Edge's XYZBounds are correct.  Basically, I will add debug code at the construction of the iterator that will go over ALL Edge objects and look for intersections within bounds, and print those.  Then we can compare what we should see with what we actually do.  If there is a difference, then that would mean incorrectly computed XYZBounds for a specific edge, and I can drill into that further. ",
            "date": "2018-04-27T10:19:45+0000"
        },
        {
            "id": "comment-16456237",
            "author": "Ignacio Vera",
            "content": "Lets have a look to the Edge iterator used in testLUCENE8276_case1):\n\nDetermining in-set-ness of test point2 ([X=-0.9999999999993657, Y=-1.124732395751746E-6, Z=-5.8143386268861615E-8]):\n\nFirstLeg:\n\u00a0 Generating SectorLinearCrossingEdgeIterator with:\n\u00a0\u00a0\u00a0 Plane: [A=0.0, B=0.0; C=1.0; D=-5.8143386268861615E-8]\n\u00a0\u00a0\u00a0 Above Plane: [A=0.0, B=0.0; C=1.0; D=-5.814238626886161E-8]\n\u00a0\u00a0\u00a0 Below Plane: [A=0.0, B=0.0; C=1.0; D=-5.814438626886162E-8]\n\u00a0\u00a0\u00a0 Point: 0.9999999999993657,-1.124732395751746E-6,5.8143386268861615E-8\n\u00a0\u00a0\u00a0 Travel distance: 2.249464791503492E-6\n\u00a0\u00a0\u00a0 Bound1: [A=-1.124732395751748E-6, B=0.9999999999993675, C=0.0, D=0.0, side=-1.0]\n\u00a0\u00a0\u00a0 Bound2: [A=1.124732395751748E-6, B=0.9999999999993675, C=-0.0, D=0.0, side=1.0]\nSecond Leg:\n\u00a0 Generating SectorLinearCrossingEdgeIterator with:\n\u00a0\u00a0\u00a0 Plane: [A=0.0, B=1.0; C=0.0; D=1.124732395751746E-6]\n\u00a0\u00a0\u00a0 Above Plane: [A=0.0, B=1.0; C=0.0; D=1.1247333957517463E-6]\n\u00a0\u00a0\u00a0 Below Plane: [A=0.0, B=1.0; C=0.0; D=1.1247313957517458E-6]\n\u00a0\u00a0\u00a0 Point: -0.9999999999993657,-1.124732395751746E-6,-5.8143386268861615E-8\n\u00a0\u00a0\u00a0 Travel distance: 1.9999999999987348\n\u00a0Constructing full linear crossing edge iterator\n\n\nIsInSet called for [0.9999999999993657,1.124732395751746E-6,5.8143386268861615E-8], testPoint=[X=-0.9999999999993657, Y=-1.124732395751746E-6, Z=-5.8143386268861615E-8]\n\nFirstLeg:\n\u00a0 Generating SectorLinearCrossingEdgeIterator with:\n\u00a0\u00a0\u00a0 Plane: [A=0.0, B=0.0; C=1.0; D=5.8143386268861615E-8]\n\u00a0\u00a0\u00a0 Above Plane: [A=0.0, B=0.0; C=1.0; D=5.814438626886162E-8]\n\u00a0\u00a0\u00a0 Below Plane: [A=0.0, B=0.0; C=1.0; D=5.814238626886161E-8]\n\u00a0\u00a0\u00a0 Point: 0.9999999999993657,1.124732395751746E-6,-5.8143386268861615E-8\n\u00a0\u00a0\u00a0 Travel distance: 1.9999999999999964\n\u00a0\u00a0\u00a0 Bound1: [A=1.124732395751748E-6, B=-0.9999999999993675, C=0.0, D=0.0, side=-1.0]\n\u00a0\u00a0\u00a0 Bound2: [A=-1.124732395751748E-6, B=0.9999999999993675, C=0.0, D=0.0, side=-1.0]\nSecond Leg:\n\u00a0Generating SectorLinearCrossingEdgeIterator with:\n\u00a0\u00a0\u00a0 Plane: [A=0.0, B=1.0; C=0.0; D=-1.124732395751746E-6]\n\u00a0\u00a0\u00a0 Above Plane: [A=0.0, B=1.0; C=0.0; D=-1.1247313957517458E-6]\n\u00a0\u00a0\u00a0 Below Plane: [A=0.0, B=1.0; C=0.0; D=-1.1247333957517463E-6]\n\u00a0\u00a0\u00a0 Point: 0.9999999999993657,1.124732395751746E-6,5.8143386268861615E-8\n\u00a0\u00a0\u00a0 Travel distance: 1.1628677253772323E-7\n\u00a0\u00a0\u00a0 Bound1: [A=-5.8143386268898395E-8, B=0.0, C=-0.9999999999999983, D=0.0, side=-1.0]\n\u00a0\u00a0\u00a0 Bound2: [A=5.8143386268898395E-8, B=0.0, C=-0.9999999999999983, D=0.0, side=1.0]\n\n\u00a0\n\nFirst withIn operation generates a full linear iterator but the second does not although the distance travel is even higher. On the first leg you build the bounds but they are indeed bogus (They are numerically the same!)\n\n\u00a0 ",
            "date": "2018-04-27T11:07:05+0000"
        },
        {
            "id": "comment-16456254",
            "author": "Karl Wright",
            "content": "It looks like the Edge XYZBounds are working fine.  Here's the new output:\n\n\n   [junit4]   1> Recording edge [[lat=-1.135982425157425E-6, lon=6.109011074784121E-7([X=0.9999999999991683, Y=6.1090110747798E-7, Z=-1.1359824251571808E-6])] --> [lat=-2.7797906712270083E-7, lon=1.8357011217773334E-6([X=0.9999999999982765, Y=1.8357011217762314E-6, Z=-2.7797906712269723E-7])]]; bounds = XYZBounds: [xmin=0.9999999989982765 xmax=1.0000000009991798 ymin=6.0990110747798E-7 ymax=1.8367011217762314E-6 zmin=-1.136982425157181E-6 zmax=-2.769790671226972E-7]\n   [junit4]   1> Recording edge [[lat=-2.7797906712270083E-7, lon=1.8357011217773334E-6([X=0.9999999999982765, Y=1.8357011217762314E-6, Z=-2.7797906712269723E-7])] --> [lat=4.492749557241206E-7, lon=1.8019115568534971E-6([X=0.9999999999982758, Y=1.8019115568523405E-6, Z=4.492749557241056E-7])]]; bounds = XYZBounds: [xmin=0.9999999989982759 xmax=1.0000000009983425 ymin=1.8009115568523404E-6 ymax=1.8367011217762314E-6 zmin=-2.7897906712269725E-7 zmax=4.5027495572410565E-7]\n   [junit4]   1> Recording edge [[lat=4.492749557241206E-7, lon=1.8019115568534971E-6([X=0.9999999999982758, Y=1.8019115568523405E-6, Z=4.492749557241056E-7])] --> [lat=1.255403467900245E-6, lon=1.3751481926504994E-6([X=0.9999999999982665, Y=1.3751481926489823E-6, Z=1.2554034678999154E-6])]]; bounds = XYZBounds: [xmin=0.9999999989982665 xmax=1.0000000009983752 ymin=1.3741481926489823E-6 ymax=1.8029115568523406E-6 zmin=4.482749557241056E-7 zmax=1.2564034678999155E-6]\n   [junit4]   1> Recording edge [[lat=1.255403467900245E-6, lon=1.3751481926504994E-6([X=0.9999999999982665, Y=1.3751481926489823E-6, Z=1.2554034678999154E-6])] --> [lat=1.640689686301266E-25, lon=0.0([X=1.0, Y=0.0, Z=1.640689686301266E-25])]]; bounds = XYZBounds: [xmin=0.9999999989982665 xmax=1.000000001 ymin=-1.0E-9 ymax=1.3761481926489824E-6 zmin=-1.0E-9 zmax=1.2564034678999155E-6]\n   [junit4]   1> Recording edge [[lat=1.640689686301266E-25, lon=0.0([X=1.0, Y=0.0, Z=1.640689686301266E-25])] --> [lat=-1.135982425157425E-6, lon=6.109011074784121E-7([X=0.9999999999991683, Y=6.1090110747798E-7, Z=-1.1359824251571808E-6])]]; bounds = XYZBounds: [xmin=0.9999999989991684 xmax=1.000000001 ymin=-1.0E-9 ymax=6.1190110747798E-7 zmin=-1.136982425157181E-6 zmax=1.0000000000000003E-9]\n   [junit4]   1> Determining in-set-ness of test point2 ([X=-0.9999999999993657, Y=-1.124732395751746E-6, Z=-5.8143386268861615E-8]):\n   [junit4]   1> \n   [junit4]   1> IsInSet called for [-0.9999999999993657,-1.124732395751746E-6,-5.8143386268861615E-8], testPoint=[lat=5.8143386268861655E-8, lon=1.1247323957519851E-6([X=0.9999999999993657, Y=1.124732395751746E-6, Z=5.8143386268861615E-8])]; is in set? true\n   [junit4]   1>  Using two planes\n   [junit4]   1>   Looking for intersections between travel and test point planes...\n   [junit4]   1>  Picking XZ then XY\n   [junit4]   1>   Looking for intersections between travel and test point planes...\n   [junit4]   1>  Finding whether [X=0.9999999999993657, Y=-1.124732395751746E-6, Z=5.8143386268861615E-8] is in-set, based on travel from [lat=5.8143386268861655E-8, lon=1.1247323957519851E-6([X=0.9999999999993657, Y=1.124732395751746E-6, Z=5.8143386268861615E-8])] along [A=0.0, B=0.0; C=1.0; D=-5.8143386268861615E-8] (value=5.8143386268861615E-8)\n   [junit4]   1>  Constructing sector linear crossing edge iterator\n   [junit4]   1> \n   [junit4]   1>  The following edges intersect the travel plane within the given bounds:\n   [junit4]   1>   Edge [lat=1.255403467900245E-6, lon=1.3751481926504994E-6([X=0.9999999999982665, Y=1.3751481926489823E-6, Z=1.2554034678999154E-6])] --> [lat=1.640689686301266E-25, lon=0.0([X=1.0, Y=0.0, Z=1.640689686301266E-25])] intersects\n   [junit4]   1>  ...done\n   [junit4]   1> \n   [junit4]   1>  Edge [[lat=-2.7797906712270083E-7, lon=1.8357011217773334E-6([X=0.9999999999982765, Y=1.8357011217762314E-6, Z=-2.7797906712269723E-7])] --> [lat=4.492749557241206E-7, lon=1.8019115568534971E-6([X=0.9999999999982758, Y=1.8019115568523405E-6, Z=4.492749557241056E-7])]] potentially crosses travel plane [A=0.0, B=0.0; C=1.0; D=-5.8143386268861615E-8]\n   [junit4]   1>   Finding intersections between edge plane and travel plane...\n   [junit4]   1>   There are no intersection points within bounds.\n   [junit4]   1>    Crossing point [X=0.999999999998342, Y=1.820084251873324E-6, Z=5.8143386268861615E-8] rejected by bound1 (6.953518561222897E-7)\n   [junit4]   1>    Crossing point [X=-0.9999999999983322, Y=-1.8254871500725794E-6, Z=5.8143386268861615E-8] rejected by bound2 (-2.950219545821297E-6)\n   [junit4]   1>    Crossing point [X=-0.9999999999983322, Y=-1.8254871500725794E-6, Z=5.8143386268861615E-8] rejected by edge.startPlane (-2.2007283293136158E-7)\n   [junit4]   1>    Crossing point [X=-0.9999999999983322, Y=-1.8254871500725794E-6, Z=5.8143386268861615E-8] rejected by edge.endPlane (5.079657295394685E-7)\n   [junit4]   1>    Endpoint(s) of edge are not on travel plane; distances: -3.3612245339155885E-7 and 3.91131569455244E-7\n   [junit4]   1>  Edge [[lat=1.255403467900245E-6, lon=1.3751481926504994E-6([X=0.9999999999982665, Y=1.3751481926489823E-6, Z=1.2554034678999154E-6])] --> [lat=1.640689686301266E-25, lon=0.0([X=1.0, Y=0.0, Z=1.640689686301266E-25])]] potentially crosses travel plane [A=0.0, B=0.0; C=1.0; D=-5.8143386268861615E-8]\n   [junit4]   1>   Finding intersections between edge plane and travel plane...\n   [junit4]   1>   There were intersection points!\n   [junit4]   1>  Edge intersects travel plane [A=0.0, B=0.0; C=1.0; D=-5.8143386268861615E-8]\n   [junit4]   1>   Intersection point in-set? false\n   [junit4]   1>  Finding whether [-0.9999999999993657,-1.124732395751746E-6,-5.8143386268861615E-8] is in-set, based on travel from [X=0.9999999999993657, Y=-1.124732395751746E-6, Z=5.8143386268861615E-8] along [A=0.0, B=1.0; C=0.0; D=1.124732395751746E-6] (value=-1.124732395751746E-6)\n   [junit4]   1>  Constructing full linear crossing edge iterator\n   [junit4]   1> \n   [junit4]   1>  The following edges intersect the travel plane within the given bounds:\n   [junit4]   1>  ...done\n   [junit4]   1> \n   [junit4]   1>  Check point in set? false\n   [junit4]   1> \n   [junit4]   1> ... done.  Checking against test point1 ([lat=5.8143386268861655E-8, lon=1.1247323957519851E-6([X=0.9999999999993657, Y=1.124732395751746E-6, Z=5.8143386268861615E-8])]):\n   [junit4]   1> \n   [junit4]   1> IsInSet called for [0.9999999999993657,1.124732395751746E-6,5.8143386268861615E-8], testPoint=[X=-0.9999999999993657, Y=-1.124732395751746E-6, Z=-5.8143386268861615E-8]; is in set? false\n   [junit4]   1>  Using two planes\n   [junit4]   1>   Looking for intersections between travel and test point planes...\n   [junit4]   1>  Picking XZ then XY\n   [junit4]   1>   Looking for intersections between travel and test point planes...\n   [junit4]   1>  Finding whether [X=0.9999999999993657, Y=1.124732395751746E-6, Z=-5.8143386268861615E-8] is in-set, based on travel from [X=-0.9999999999993657, Y=-1.124732395751746E-6, Z=-5.8143386268861615E-8] along [A=0.0, B=0.0; C=1.0; D=5.8143386268861615E-8] (value=-5.8143386268861615E-8)\n   [junit4]   1>  Constructing sector linear crossing edge iterator\n   [junit4]   1> \n   [junit4]   1>  The following edges intersect the travel plane within the given bounds:\n   [junit4]   1>  ...done\n   [junit4]   1> \n   [junit4]   1>  Edge [[lat=-2.7797906712270083E-7, lon=1.8357011217773334E-6([X=0.9999999999982765, Y=1.8357011217762314E-6, Z=-2.7797906712269723E-7])] --> [lat=4.492749557241206E-7, lon=1.8019115568534971E-6([X=0.9999999999982758, Y=1.8019115568523405E-6, Z=4.492749557241056E-7])]] potentially crosses travel plane [A=0.0, B=0.0; C=1.0; D=5.8143386268861615E-8]\n   [junit4]   1>   Finding intersections between edge plane and travel plane...\n   [junit4]   1>   There are no intersection points within bounds.\n   [junit4]   1>    Crossing point [X=0.9999999999983322, Y=1.8254871500725794E-6, Z=-5.8143386268861615E-8] rejected by bound2 (7.007547543215527E-7)\n   [junit4]   1>    Crossing point [X=-0.999999999998342, Y=-1.820084251873324E-6, Z=-5.8143386268861615E-8] rejected by bound1 (6.953518561222897E-7)\n   [junit4]   1>    Crossing point [X=-0.999999999998342, Y=-1.820084251873324E-6, Z=-5.8143386268861615E-8] rejected by edge.startPlane (-3.364850521189999E-7)\n   [junit4]   1>    Crossing point [X=-0.999999999998342, Y=-1.820084251873324E-6, Z=-5.8143386268861615E-8] rejected by edge.endPlane (3.915535103518376E-7)\n   [junit4]   1>    Endpoint(s) of edge are not on travel plane; distances: -2.1983568085383562E-7 and 5.074183419929672E-7\n   [junit4]   1>  Edge [[lat=1.640689686301266E-25, lon=0.0([X=1.0, Y=0.0, Z=1.640689686301266E-25])] --> [lat=-1.135982425157425E-6, lon=6.109011074784121E-7([X=0.9999999999991683, Y=6.1090110747798E-7, Z=-1.1359824251571808E-6])]] potentially crosses travel plane [A=0.0, B=0.0; C=1.0; D=5.8143386268861615E-8]\n   [junit4]   1>   Finding intersections between edge plane and travel plane...\n   [junit4]   1>   There are no intersection points within bounds.\n   [junit4]   1>    Crossing point [X=-0.9999999999999978, Y=3.126796531139363E-8, Z=-5.8143386268861615E-8] rejected by bound2 (1.1560003610631194E-6)\n   [junit4]   1>    Crossing point [X=-0.9999999999999978, Y=3.126796531139363E-8, Z=-5.8143386268861615E-8] rejected by edge.endPlane (1.3558457034489254E-6)\n   [junit4]   1>    Crossing point [X=0.9999999999999978, Y=3.126796531139363E-8, Z=-5.8143386268861615E-8] rejected by bound1 (1.0934644304403715E-6)\n   [junit4]   1>    Endpoint(s) of edge are not on travel plane; distances: 5.8143386268861615E-8 and -1.0778390388883193E-6\n   [junit4]   1>   Intersection point in-set? false\n   [junit4]   1>  Finding whether [0.9999999999993657,1.124732395751746E-6,5.8143386268861615E-8] is in-set, based on travel from [X=0.9999999999993657, Y=1.124732395751746E-6, Z=-5.8143386268861615E-8] along [A=0.0, B=1.0; C=0.0; D=-1.124732395751746E-6] (value=1.124732395751746E-6)\n   [junit4]   1>  Constructing sector linear crossing edge iterator\n   [junit4]   1> \n   [junit4]   1>  The following edges intersect the travel plane within the given bounds:\n   [junit4]   1>  ...done\n   [junit4]   1> \n   [junit4]   1>  Edge [[lat=-1.135982425157425E-6, lon=6.109011074784121E-7([X=0.9999999999991683, Y=6.1090110747798E-7, Z=-1.1359824251571808E-6])] --> [lat=-2.7797906712270083E-7, lon=1.8357011217773334E-6([X=0.9999999999982765, Y=1.8357011217762314E-6, Z=-2.7797906712269723E-7])]] potentially crosses travel plane [A=0.0, B=1.0; C=0.0; D=-1.124732395751746E-6]\n   [junit4]   1>   Finding intersections between edge plane and travel plane...\n   [junit4]   1>   There are no intersection points within bounds.\n   [junit4]   1>    Crossing point [X=0.9999999999990665, Y=1.124732395751746E-6, Z=-7.76030624328578E-7] rejected by bound1 (7.178872380597327E-7)\n   [junit4]   1>    Crossing point [X=-0.9999999999966022, Y=1.124732395751746E-6, Z=2.3518375498275934E-6] rejected by bound2 (-2.4099809360962904E-6)\n   [junit4]   1>    Crossing point [X=-0.9999999999966022, Y=1.124732395751746E-6, Z=2.3518375498275934E-6] rejected by edge.endPlane (3.6145616079893093E-6)\n   [junit4]   1>    Endpoint(s) of edge are not on travel plane; distances: -5.138312882737661E-7 and 7.109687260244853E-7\n   [junit4]   1>  Edge [[lat=1.255403467900245E-6, lon=1.3751481926504994E-6([X=0.9999999999982665, Y=1.3751481926489823E-6, Z=1.2554034678999154E-6])] --> [lat=1.640689686301266E-25, lon=0.0([X=1.0, Y=0.0, Z=1.640689686301266E-25])]] potentially crosses travel plane [A=0.0, B=1.0; C=0.0; D=-1.124732395751746E-6]\n   [junit4]   1>   Finding intersections between edge plane and travel plane...\n   [junit4]   1>   There are no intersection points within bounds.\n   [junit4]   1>    Crossing point [X=-0.9999999999988402, Y=1.124732395751746E-6, Z=1.0267932995397135E-6] rejected by bound2 (-1.0849366858085427E-6)\n   [junit4]   1>    Crossing point [X=-0.9999999999988402, Y=1.124732395751746E-6, Z=1.0267932995397135E-6] rejected by edge.startPlane (-3.384940921425686E-6)\n   [junit4]   1>    Crossing point [X=0.9999999999988402, Y=1.124732395751746E-6, Z=1.0267932995397135E-6] rejected by bound2 (-9.68649913270881E-7)\n   [junit4]   1>    Endpoint(s) of edge are not on travel plane; distances: 2.5041579689723626E-7 and -1.124732395751746E-6\n   [junit4]   1>  Check point in set? false\n\n\n\nIn other words, we find all the intersections that there are \u2013 no more, no less \u2013 given the travel plane bounding planes and edge bounding planes.  So we're not missing any because of a wrong XYZBounds computation.\n\nI guess we still could be almost missing an intersection with an edge, because of bounds.  That's easy to rule out though.  Stay tuned. ",
            "date": "2018-04-27T11:25:17+0000"
        },
        {
            "id": "comment-16456262",
            "author": "Karl Wright",
            "content": "Added more diagnostics to rule out an \"almost miss\" for an intersection.  No such situation found.\n\nThe diagnostics basically show we're doing the right thing, but we get different counts based on the path we choose.  The counts differ because there is an intersection found for one path and no intersection is found for the other path.  It's beginning to look like that intersection that is detected is spurious in some way.\n\n\n   [junit4]   1> Recording edge [[lat=-1.135982425157425E-6, lon=6.109011074784121E-7([X=0.9999999999991683, Y=6.1090110747798E-7, Z=-1.1359824251571808E-6])] --> [lat=-2.7797906712270083E-7, lon=1.8357011217773334E-6([X=0.9999999999982765, Y=1.8357011217762314E-6, Z=-2.7797906712269723E-7])]]; bounds = XYZBounds: [xmin=0.9999999989982765 xmax=1.0000000009991798 ymin=6.0990110747798E-7 ymax=1.8367011217762314E-6 zmin=-1.136982425157181E-6 zmax=-2.769790671226972E-7]\n   [junit4]   1> Recording edge [[lat=-2.7797906712270083E-7, lon=1.8357011217773334E-6([X=0.9999999999982765, Y=1.8357011217762314E-6, Z=-2.7797906712269723E-7])] --> [lat=4.492749557241206E-7, lon=1.8019115568534971E-6([X=0.9999999999982758, Y=1.8019115568523405E-6, Z=4.492749557241056E-7])]]; bounds = XYZBounds: [xmin=0.9999999989982759 xmax=1.0000000009983425 ymin=1.8009115568523404E-6 ymax=1.8367011217762314E-6 zmin=-2.7897906712269725E-7 zmax=4.5027495572410565E-7]\n   [junit4]   1> Recording edge [[lat=4.492749557241206E-7, lon=1.8019115568534971E-6([X=0.9999999999982758, Y=1.8019115568523405E-6, Z=4.492749557241056E-7])] --> [lat=1.255403467900245E-6, lon=1.3751481926504994E-6([X=0.9999999999982665, Y=1.3751481926489823E-6, Z=1.2554034678999154E-6])]]; bounds = XYZBounds: [xmin=0.9999999989982665 xmax=1.0000000009983752 ymin=1.3741481926489823E-6 ymax=1.8029115568523406E-6 zmin=4.482749557241056E-7 zmax=1.2564034678999155E-6]\n   [junit4]   1> Recording edge [[lat=1.255403467900245E-6, lon=1.3751481926504994E-6([X=0.9999999999982665, Y=1.3751481926489823E-6, Z=1.2554034678999154E-6])] --> [lat=1.640689686301266E-25, lon=0.0([X=1.0, Y=0.0, Z=1.640689686301266E-25])]]; bounds = XYZBounds: [xmin=0.9999999989982665 xmax=1.000000001 ymin=-1.0E-9 ymax=1.3761481926489824E-6 zmin=-1.0E-9 zmax=1.2564034678999155E-6]\n   [junit4]   1> Recording edge [[lat=1.640689686301266E-25, lon=0.0([X=1.0, Y=0.0, Z=1.640689686301266E-25])] --> [lat=-1.135982425157425E-6, lon=6.109011074784121E-7([X=0.9999999999991683, Y=6.1090110747798E-7, Z=-1.1359824251571808E-6])]]; bounds = XYZBounds: [xmin=0.9999999989991684 xmax=1.000000001 ymin=-1.0E-9 ymax=6.1190110747798E-7 zmin=-1.136982425157181E-6 zmax=1.0000000000000003E-9]\n   [junit4]   1> Determining in-set-ness of test point2 ([X=-0.9999999999993657, Y=-1.124732395751746E-6, Z=-5.8143386268861615E-8]):\n   [junit4]   1> \n   [junit4]   1> IsInSet called for [-0.9999999999993657,-1.124732395751746E-6,-5.8143386268861615E-8], testPoint=[lat=5.8143386268861655E-8, lon=1.1247323957519851E-6([X=0.9999999999993657, Y=1.124732395751746E-6, Z=5.8143386268861615E-8])]; is in set? true\n   [junit4]   1>  Using two planes\n   [junit4]   1>   Looking for intersections between travel and test point planes...\n   [junit4]   1>  Picking XZ then XY\n   [junit4]   1>   Looking for intersections between travel and test point planes...\n   [junit4]   1>  Finding whether [X=0.9999999999993657, Y=-1.124732395751746E-6, Z=5.8143386268861615E-8] is in-set, based on travel from [lat=5.8143386268861655E-8, lon=1.1247323957519851E-6([X=0.9999999999993657, Y=1.124732395751746E-6, Z=5.8143386268861615E-8])] along [A=0.0, B=0.0; C=1.0; D=-5.8143386268861615E-8] (value=5.8143386268861615E-8)\n   [junit4]   1>  Constructing sector linear crossing edge iterator\n   [junit4]   1> \n   [junit4]   1>  The following edges intersect the travel plane within the given bounds:\n   [junit4]   1>   Edge [lat=-1.135982425157425E-6, lon=6.109011074784121E-7([X=0.9999999999991683, Y=6.1090110747798E-7, Z=-1.1359824251571808E-6])] --> [lat=-2.7797906712270083E-7, lon=1.8357011217773334E-6([X=0.9999999999982765, Y=1.8357011217762314E-6, Z=-2.7797906712269723E-7])]:\n   [junit4]   1>    ... intersection [X=0.9999999999973171, Y=2.3155160104520292E-6, Z=5.8143386268861615E-8] excluded by iterator bound (1.1907836147018343E-6)\n   [junit4]   1>    ... intersection [X=0.9999999999973171, Y=2.3155160104520292E-6, Z=5.8143386268861615E-8] excluded by edge end plane (5.858332792440353E-7)\n   [junit4]   1>    ... intersection [X=-0.9999999999976878, Y=-2.149516612742565E-6, Z=5.8143386268861615E-8] excluded by iterator bound (-3.274249008490353E-6)\n   [junit4]   1>    ... intersection [X=-0.9999999999976878, Y=-2.149516612742565E-6, Z=5.8143386268861615E-8] excluded by edge start plane (-1.8785831540795222E-6)\n   [junit4]   1>   Edge [lat=-2.7797906712270083E-7, lon=1.8357011217773334E-6([X=0.9999999999982765, Y=1.8357011217762314E-6, Z=-2.7797906712269723E-7])] --> [lat=4.492749557241206E-7, lon=1.8019115568534971E-6([X=0.9999999999982758, Y=1.8019115568523405E-6, Z=4.492749557241056E-7])]:\n   [junit4]   1>    ... intersection [X=0.999999999998342, Y=1.820084251873324E-6, Z=5.8143386268861615E-8] excluded by iterator bound (6.953518561222897E-7)\n   [junit4]   1>    ... intersection [X=-0.9999999999983322, Y=-1.8254871500725794E-6, Z=5.8143386268861615E-8] excluded by iterator bound (-2.950219545821297E-6)\n   [junit4]   1>    ... intersection [X=-0.9999999999983322, Y=-1.8254871500725794E-6, Z=5.8143386268861615E-8] excluded by edge start plane (-2.2007283293136158E-7)\n   [junit4]   1>    ... intersection [X=-0.9999999999983322, Y=-1.8254871500725794E-6, Z=5.8143386268861615E-8] excluded by edge end plane (5.079657295394685E-7)\n   [junit4]   1>   Edge [lat=4.492749557241206E-7, lon=1.8019115568534971E-6([X=0.9999999999982758, Y=1.8019115568523405E-6, Z=4.492749557241056E-7])] --> [lat=1.255403467900245E-6, lon=1.3751481926504994E-6([X=0.9999999999982665, Y=1.3751481926489823E-6, Z=1.2554034678999154E-6])]:\n   [junit4]   1>    ... intersection [X=0.9999999999979804, Y=2.0089760904908213E-6, Z=5.8143386268861615E-8] excluded by iterator bound (8.842436947400743E-7)\n   [junit4]   1>    ... intersection [X=0.9999999999979804, Y=2.0089760904908213E-6, Z=5.8143386268861615E-8] excluded by edge start plane (-4.4256030743337294E-7)\n   [junit4]   1>    ... intersection [X=-0.9999999999978547, Y=-2.0705381535003446E-6, Z=5.8143386268861615E-8] excluded by iterator bound (-3.1952705492483703E-6)\n   [junit4]   1>    ... intersection [X=-0.9999999999978547, Y=-2.0705381535003446E-6, Z=5.8143386268861615E-8] excluded by edge end plane (1.486261260932444E-6)\n   [junit4]   1>   Edge [lat=1.255403467900245E-6, lon=1.3751481926504994E-6([X=0.9999999999982665, Y=1.3751481926489823E-6, Z=1.2554034678999154E-6])] --> [lat=1.640689686301266E-25, lon=0.0([X=1.0, Y=0.0, Z=1.640689686301266E-25])]:\n   [junit4]   1>    ... intersects!!\n   [junit4]   1>   Edge [lat=1.640689686301266E-25, lon=0.0([X=1.0, Y=0.0, Z=1.640689686301266E-25])] --> [lat=-1.135982425157425E-6, lon=6.109011074784121E-7([X=0.9999999999991683, Y=6.1090110747798E-7, Z=-1.1359824251571808E-6])]:\n   [junit4]   1>    ... intersection [X=-0.9999999999999978, Y=-3.126796531139363E-8, Z=5.8143386268861615E-8] excluded by iterator bound (1.0934644304403715E-6)\n   [junit4]   1>    ... intersection [X=-0.9999999999999978, Y=-3.126796531139363E-8, Z=5.8143386268861615E-8] excluded by iterator bound (-1.1560003610631194E-6)\n   [junit4]   1>    ... intersection [X=-0.9999999999999978, Y=-3.126796531139363E-8, Z=5.8143386268861615E-8] excluded by edge start plane (-6.601771748193481E-8)\n   [junit4]   1>    ... intersection [X=-0.9999999999999978, Y=-3.126796531139363E-8, Z=5.8143386268861615E-8] excluded by edge end plane (1.2238102684851657E-6)\n   [junit4]   1>    ... intersection [X=0.9999999999999978, Y=-3.126796531139363E-8, Z=5.8143386268861615E-8] excluded by edge start plane (-6.601771748193481E-8)\n   [junit4]   1>  ...done\n   [junit4]   1> \n   [junit4]   1>  Edge [[lat=-2.7797906712270083E-7, lon=1.8357011217773334E-6([X=0.9999999999982765, Y=1.8357011217762314E-6, Z=-2.7797906712269723E-7])] --> [lat=4.492749557241206E-7, lon=1.8019115568534971E-6([X=0.9999999999982758, Y=1.8019115568523405E-6, Z=4.492749557241056E-7])]] potentially crosses travel plane [A=0.0, B=0.0; C=1.0; D=-5.8143386268861615E-8]\n   [junit4]   1>   Finding intersections between edge plane and travel plane...\n   [junit4]   1>   There are no intersection points within bounds.\n   [junit4]   1>    Crossing point [X=0.999999999998342, Y=1.820084251873324E-6, Z=5.8143386268861615E-8] rejected by bound1 (6.953518561222897E-7)\n   [junit4]   1>    Crossing point [X=-0.9999999999983322, Y=-1.8254871500725794E-6, Z=5.8143386268861615E-8] rejected by bound2 (-2.950219545821297E-6)\n   [junit4]   1>    Crossing point [X=-0.9999999999983322, Y=-1.8254871500725794E-6, Z=5.8143386268861615E-8] rejected by edge.startPlane (-2.2007283293136158E-7)\n   [junit4]   1>    Crossing point [X=-0.9999999999983322, Y=-1.8254871500725794E-6, Z=5.8143386268861615E-8] rejected by edge.endPlane (5.079657295394685E-7)\n   [junit4]   1>    Endpoint(s) of edge are not on travel plane; distances: -3.3612245339155885E-7 and 3.91131569455244E-7\n   [junit4]   1>  Edge [[lat=1.255403467900245E-6, lon=1.3751481926504994E-6([X=0.9999999999982665, Y=1.3751481926489823E-6, Z=1.2554034678999154E-6])] --> [lat=1.640689686301266E-25, lon=0.0([X=1.0, Y=0.0, Z=1.640689686301266E-25])]] potentially crosses travel plane [A=0.0, B=0.0; C=1.0; D=-5.8143386268861615E-8]\n   [junit4]   1>   Finding intersections between edge plane and travel plane...\n   [junit4]   1>   There were intersection points!\n   [junit4]   1>  Edge intersects travel plane [A=0.0, B=0.0; C=1.0; D=-5.8143386268861615E-8]\n   [junit4]   1>   Intersection point in-set? false\n   [junit4]   1>  Finding whether [-0.9999999999993657,-1.124732395751746E-6,-5.8143386268861615E-8] is in-set, based on travel from [X=0.9999999999993657, Y=-1.124732395751746E-6, Z=5.8143386268861615E-8] along [A=0.0, B=1.0; C=0.0; D=1.124732395751746E-6] (value=-1.124732395751746E-6)\n   [junit4]   1>  Constructing full linear crossing edge iterator\n   [junit4]   1> \n   [junit4]   1>  The following edges intersect the travel plane within the given bounds:\n   [junit4]   1>   Edge [lat=-1.135982425157425E-6, lon=6.109011074784121E-7([X=0.9999999999991683, Y=6.1090110747798E-7, Z=-1.1359824251571808E-6])] --> [lat=-2.7797906712270083E-7, lon=1.8357011217773334E-6([X=0.9999999999982765, Y=1.8357011217762314E-6, Z=-2.7797906712269723E-7])]:\n   [junit4]   1>    ... intersection [X=0.9999999999966022, Y=-1.124732395751746E-6, Z=-2.3518375498275934E-6] excluded by edge start plane (-2.1191336299823897E-6)\n   [junit4]   1>    ... intersection [X=-0.9999999999990665, Y=-1.124732395751746E-6, Z=7.76030624328578E-7] excluded by iterator bound (-8.341740105974209E-7)\n   [junit4]   1>    ... intersection [X=-0.9999999999990665, Y=-1.124732395751746E-6, Z=7.76030624328578E-7] excluded by edge start plane (-6.273658356404211E-7)\n   [junit4]   1>    ... intersection [X=-0.9999999999990665, Y=-1.124732395751746E-6, Z=7.76030624328578E-7] excluded by edge end plane (8.680621423726326E-7)\n   [junit4]   1>   Edge [lat=-2.7797906712270083E-7, lon=1.8357011217773334E-6([X=0.9999999999982765, Y=1.8357011217762314E-6, Z=-2.7797906712269723E-7])] --> [lat=4.492749557241206E-7, lon=1.8019115568534971E-6([X=0.9999999999982758, Y=1.8019115568523405E-6, Z=4.492749557241056E-7])]:\n   [junit4]   1>    ... intersection [X=-0.9999999998865037, Y=-1.124732395751746E-6, Z=-1.5024226425491994E-5] excluded by edge start plane (-1.531871304863168E-5)\n   [junit4]   1>    ... intersection [X=0.99999999798708, Y=-1.124732395751746E-6, Z=6.343953807688905E-5] excluded by iterator bound (-6.338139469073708E-5)\n   [junit4]   1>    ... intersection [X=0.99999999798708, Y=-1.124732395751746E-6, Z=6.343953807688905E-5] excluded by edge end plane (6.305821511104637E-5)\n   [junit4]   1>   Edge [lat=4.492749557241206E-7, lon=1.8019115568534971E-6([X=0.9999999999982758, Y=1.8019115568523405E-6, Z=4.492749557241056E-7])] --> [lat=1.255403467900245E-6, lon=1.3751481926504994E-6([X=0.9999999999982665, Y=1.3751481926489823E-6, Z=1.2554034678999154E-6])]:\n   [junit4]   1>    ... intersection [X=-0.999999999997874, Y=-1.124732395751746E-6, Z=-1.7284227819037767E-6] excluded by edge start plane (-1.447339206077189E-6)\n   [junit4]   1>    ... intersection [X=0.9999999999815022, Y=-1.124732395751746E-6, Z=5.977516911444968E-6] excluded by iterator bound (-5.919373525177136E-6)\n   [junit4]   1>    ... intersection [X=0.9999999999815022, Y=-1.124732395751746E-6, Z=5.977516911444968E-6] excluded by edge end plane (5.343010231138341E-6)\n   [junit4]   1>   Edge [lat=1.255403467900245E-6, lon=1.3751481926504994E-6([X=0.9999999999982665, Y=1.3751481926489823E-6, Z=1.2554034678999154E-6])] --> [lat=1.640689686301266E-25, lon=0.0([X=1.0, Y=0.0, Z=1.640689686301266E-25])]:\n   [junit4]   1>    ... intersection [X=-0.9999999999988402, Y=-1.124732395751746E-6, Z=-1.0267932995397135E-6] excluded by edge start plane (-3.390732670289466E-7)\n   [junit4]   1>    ... intersection [X=-0.9999999999988402, Y=-1.124732395751746E-6, Z=-1.0267932995397135E-6] excluded by edge end plane (1.5229338272010097E-6)\n   [junit4]   1>    ... intersection [X=0.9999999999988402, Y=-1.124732395751746E-6, Z=-1.0267932995397135E-6] excluded by edge end plane (1.5229338272010097E-6)\n   [junit4]   1>   Edge [lat=1.640689686301266E-25, lon=0.0([X=1.0, Y=0.0, Z=1.640689686301266E-25])] --> [lat=-1.135982425157425E-6, lon=6.109011074784121E-7([X=0.9999999999991683, Y=6.1090110747798E-7, Z=-1.1359824251571808E-6])]:\n   [junit4]   1>    ... intersection [X=0.9999999999971804, Y=-1.124732395751746E-6, Z=2.0914616440189845E-6] excluded by iterator bound (-2.033318257750247E-6)\n   [junit4]   1>    ... intersection [X=0.9999999999971804, Y=-1.124732395751746E-6, Z=2.0914616440189845E-6] excluded by edge start plane (-2.3747073020597835E-6)\n   [junit4]   1>    ... intersection [X=-0.9999999999971804, Y=-1.124732395751746E-6, Z=2.0914616440189845E-6] excluded by iterator bound (-2.1496050302877155E-6)\n   [junit4]   1>    ... intersection [X=-0.9999999999971804, Y=-1.124732395751746E-6, Z=2.0914616440189845E-6] excluded by edge start plane (-2.3747073020597835E-6)\n   [junit4]   1>  ...done\n   [junit4]   1> \n   [junit4]   1>  Check point in set? false\n   [junit4]   1> \n   [junit4]   1> ... done.  Checking against test point1 ([lat=5.8143386268861655E-8, lon=1.1247323957519851E-6([X=0.9999999999993657, Y=1.124732395751746E-6, Z=5.8143386268861615E-8])]):\n   [junit4]   1> \n   [junit4]   1> IsInSet called for [0.9999999999993657,1.124732395751746E-6,5.8143386268861615E-8], testPoint=[X=-0.9999999999993657, Y=-1.124732395751746E-6, Z=-5.8143386268861615E-8]; is in set? false\n   [junit4]   1>  Using two planes\n   [junit4]   1>   Looking for intersections between travel and test point planes...\n   [junit4]   1>  Picking XZ then XY\n   [junit4]   1>   Looking for intersections between travel and test point planes...\n   [junit4]   1>  Finding whether [X=0.9999999999993657, Y=1.124732395751746E-6, Z=-5.8143386268861615E-8] is in-set, based on travel from [X=-0.9999999999993657, Y=-1.124732395751746E-6, Z=-5.8143386268861615E-8] along [A=0.0, B=0.0; C=1.0; D=5.8143386268861615E-8] (value=-5.8143386268861615E-8)\n   [junit4]   1>  Constructing sector linear crossing edge iterator\n   [junit4]   1> \n   [junit4]   1>  The following edges intersect the travel plane within the given bounds:\n   [junit4]   1>   Edge [lat=-1.135982425157425E-6, lon=6.109011074784121E-7([X=0.9999999999991683, Y=6.1090110747798E-7, Z=-1.1359824251571808E-6])] --> [lat=-2.7797906712270083E-7, lon=1.8357011217773334E-6([X=0.9999999999982765, Y=1.8357011217762314E-6, Z=-2.7797906712269723E-7])]:\n   [junit4]   1>    ... intersection [X=0.9999999999976878, Y=2.149516612742565E-6, Z=-5.8143386268861615E-8] excluded by iterator bound (1.0247842169920582E-6)\n   [junit4]   1>    ... intersection [X=0.9999999999976878, Y=2.149516612742565E-6, Z=-5.8143386268861615E-8] excluded by edge end plane (3.8315517606741463E-7)\n   [junit4]   1>    ... intersection [X=-0.9999999999973171, Y=-2.3155160104520292E-6, Z=-5.8143386268861615E-8] excluded by iterator bound (1.1907836147018343E-6)\n   [junit4]   1>    ... intersection [X=-0.9999999999973171, Y=-2.3155160104520292E-6, Z=-5.8143386268861615E-8] excluded by edge start plane (-2.081261257255769E-6)\n   [junit4]   1>   Edge [lat=-2.7797906712270083E-7, lon=1.8357011217773334E-6([X=0.9999999999982765, Y=1.8357011217762314E-6, Z=-2.7797906712269723E-7])] --> [lat=4.492749557241206E-7, lon=1.8019115568534971E-6([X=0.9999999999982758, Y=1.8019115568523405E-6, Z=4.492749557241056E-7])]:\n   [junit4]   1>    ... intersection [X=0.9999999999983322, Y=1.8254871500725794E-6, Z=-5.8143386268861615E-8] excluded by iterator bound (7.007547543215527E-7)\n   [junit4]   1>    ... intersection [X=-0.999999999998342, Y=-1.820084251873324E-6, Z=-5.8143386268861615E-8] excluded by iterator bound (6.953518561222897E-7)\n   [junit4]   1>    ... intersection [X=-0.999999999998342, Y=-1.820084251873324E-6, Z=-5.8143386268861615E-8] excluded by edge start plane (-3.364850521189999E-7)\n   [junit4]   1>    ... intersection [X=-0.999999999998342, Y=-1.820084251873324E-6, Z=-5.8143386268861615E-8] excluded by edge end plane (3.915535103518376E-7)\n   [junit4]   1>   Edge [lat=4.492749557241206E-7, lon=1.8019115568534971E-6([X=0.9999999999982758, Y=1.8019115568523405E-6, Z=4.492749557241056E-7])] --> [lat=1.255403467900245E-6, lon=1.3751481926504994E-6([X=0.9999999999982665, Y=1.3751481926489823E-6, Z=1.2554034678999154E-6])]:\n   [junit4]   1>    ... intersection [X=0.9999999999978547, Y=2.0705381535003446E-6, Z=-5.8143386268861615E-8] excluded by iterator bound (9.458057577496999E-7)\n   [junit4]   1>    ... intersection [X=0.9999999999978547, Y=2.0705381535003446E-6, Z=-5.8143386268861615E-8] excluded by edge start plane (-5.741372851659536E-7)\n   [junit4]   1>    ... intersection [X=-0.9999999999979804, Y=-2.0089760904908213E-6, Z=-5.8143386268861615E-8] excluded by iterator bound (8.842436947400743E-7)\n   [junit4]   1>    ... intersection [X=-0.9999999999979804, Y=-2.0089760904908213E-6, Z=-5.8143386268861615E-8] excluded by edge end plane (1.3546842831999796E-6)\n   [junit4]   1>   Edge [lat=1.255403467900245E-6, lon=1.3751481926504994E-6([X=0.9999999999982665, Y=1.3751481926489823E-6, Z=1.2554034678999154E-6])] --> [lat=1.640689686301266E-25, lon=0.0([X=1.0, Y=0.0, Z=1.640689686301266E-25])]:\n   [junit4]   1>    ... intersection [X=-0.9999999999999961, Y=-6.36893035478623E-8, Z=-5.8143386268861615E-8] excluded by iterator bound (1.0610430922039216E-6)\n   [junit4]   1>    ... intersection [X=-0.9999999999999961, Y=-6.36893035478623E-8, Z=-5.8143386268861615E-8] excluded by edge start plane (-1.7757691631712852E-6)\n   [junit4]   1>    ... intersection [X=-0.9999999999999961, Y=-6.36893035478623E-8, Z=-5.8143386268861615E-8] excluded by edge end plane (8.623793105833298E-8)\n   [junit4]   1>    ... intersection [X=0.9999999999999961, Y=-6.36893035478623E-8, Z=-5.8143386268861615E-8] excluded by iterator bound (1.1884216992995654E-6)\n   [junit4]   1>    ... intersection [X=0.9999999999999961, Y=-6.36893035478623E-8, Z=-5.8143386268861615E-8] excluded by edge end plane (8.623793105833298E-8)\n   [junit4]   1>   Edge [lat=1.640689686301266E-25, lon=0.0([X=1.0, Y=0.0, Z=1.640689686301266E-25])] --> [lat=-1.135982425157425E-6, lon=6.109011074784121E-7([X=0.9999999999991683, Y=6.1090110747798E-7, Z=-1.1359824251571808E-6])]:\n   [junit4]   1>    ... intersection [X=-0.9999999999999978, Y=3.126796531139363E-8, Z=-5.8143386268861615E-8] excluded by iterator bound (1.1560003610631194E-6)\n   [junit4]   1>    ... intersection [X=-0.9999999999999978, Y=3.126796531139363E-8, Z=-5.8143386268861615E-8] excluded by edge end plane (1.3558457034489254E-6)\n   [junit4]   1>    ... intersection [X=0.9999999999999978, Y=3.126796531139363E-8, Z=-5.8143386268861615E-8] excluded by iterator bound (1.0934644304403715E-6)\n   [junit4]   1>  ...done\n   [junit4]   1> \n   [junit4]   1>  Edge [[lat=-2.7797906712270083E-7, lon=1.8357011217773334E-6([X=0.9999999999982765, Y=1.8357011217762314E-6, Z=-2.7797906712269723E-7])] --> [lat=4.492749557241206E-7, lon=1.8019115568534971E-6([X=0.9999999999982758, Y=1.8019115568523405E-6, Z=4.492749557241056E-7])]] potentially crosses travel plane [A=0.0, B=0.0; C=1.0; D=5.8143386268861615E-8]\n   [junit4]   1>   Finding intersections between edge plane and travel plane...\n   [junit4]   1>   There are no intersection points within bounds.\n   [junit4]   1>    Crossing point [X=0.9999999999983322, Y=1.8254871500725794E-6, Z=-5.8143386268861615E-8] rejected by bound2 (7.007547543215527E-7)\n   [junit4]   1>    Crossing point [X=-0.999999999998342, Y=-1.820084251873324E-6, Z=-5.8143386268861615E-8] rejected by bound1 (6.953518561222897E-7)\n   [junit4]   1>    Crossing point [X=-0.999999999998342, Y=-1.820084251873324E-6, Z=-5.8143386268861615E-8] rejected by edge.startPlane (-3.364850521189999E-7)\n   [junit4]   1>    Crossing point [X=-0.999999999998342, Y=-1.820084251873324E-6, Z=-5.8143386268861615E-8] rejected by edge.endPlane (3.915535103518376E-7)\n   [junit4]   1>    Endpoint(s) of edge are not on travel plane; distances: -2.1983568085383562E-7 and 5.074183419929672E-7\n   [junit4]   1>  Edge [[lat=1.640689686301266E-25, lon=0.0([X=1.0, Y=0.0, Z=1.640689686301266E-25])] --> [lat=-1.135982425157425E-6, lon=6.109011074784121E-7([X=0.9999999999991683, Y=6.1090110747798E-7, Z=-1.1359824251571808E-6])]] potentially crosses travel plane [A=0.0, B=0.0; C=1.0; D=5.8143386268861615E-8]\n   [junit4]   1>   Finding intersections between edge plane and travel plane...\n   [junit4]   1>   There are no intersection points within bounds.\n   [junit4]   1>    Crossing point [X=-0.9999999999999978, Y=3.126796531139363E-8, Z=-5.8143386268861615E-8] rejected by bound2 (1.1560003610631194E-6)\n   [junit4]   1>    Crossing point [X=-0.9999999999999978, Y=3.126796531139363E-8, Z=-5.8143386268861615E-8] rejected by edge.endPlane (1.3558457034489254E-6)\n   [junit4]   1>    Crossing point [X=0.9999999999999978, Y=3.126796531139363E-8, Z=-5.8143386268861615E-8] rejected by bound1 (1.0934644304403715E-6)\n   [junit4]   1>    Endpoint(s) of edge are not on travel plane; distances: 5.8143386268861615E-8 and -1.0778390388883193E-6\n   [junit4]   1>   Intersection point in-set? false\n   [junit4]   1>  Finding whether [0.9999999999993657,1.124732395751746E-6,5.8143386268861615E-8] is in-set, based on travel from [X=0.9999999999993657, Y=1.124732395751746E-6, Z=-5.8143386268861615E-8] along [A=0.0, B=1.0; C=0.0; D=-1.124732395751746E-6] (value=1.124732395751746E-6)\n   [junit4]   1>  Constructing sector linear crossing edge iterator\n   [junit4]   1> \n   [junit4]   1>  The following edges intersect the travel plane within the given bounds:\n   [junit4]   1>   Edge [lat=-1.135982425157425E-6, lon=6.109011074784121E-7([X=0.9999999999991683, Y=6.1090110747798E-7, Z=-1.1359824251571808E-6])] --> [lat=-2.7797906712270083E-7, lon=1.8357011217773334E-6([X=0.9999999999982765, Y=1.8357011217762314E-6, Z=-2.7797906712269723E-7])]:\n   [junit4]   1>    ... intersection [X=0.9999999999990665, Y=1.124732395751746E-6, Z=-7.76030624328578E-7] excluded by iterator bound (7.178872380597327E-7)\n   [junit4]   1>    ... intersection [X=-0.9999999999966022, Y=1.124732395751746E-6, Z=2.3518375498275934E-6] excluded by iterator bound (-2.4099809360962904E-6)\n   [junit4]   1>    ... intersection [X=-0.9999999999966022, Y=1.124732395751746E-6, Z=2.3518375498275934E-6] excluded by edge end plane (3.6145616079893093E-6)\n   [junit4]   1>   Edge [lat=-2.7797906712270083E-7, lon=1.8357011217773334E-6([X=0.9999999999982765, Y=1.8357011217762314E-6, Z=-2.7797906712269723E-7])] --> [lat=4.492749557241206E-7, lon=1.8019115568534971E-6([X=0.9999999999982758, Y=1.8019115568523405E-6, Z=4.492749557241056E-7])]:\n   [junit4]   1>    ... intersection [X=-0.99999999798708, Y=1.124732395751746E-6, Z=-6.343953807688905E-5] excluded by iterator bound (6.34976814630408E-5)\n   [junit4]   1>    ... intersection [X=-0.99999999798708, Y=1.124732395751746E-6, Z=-6.343953807688905E-5] excluded by edge start plane (-6.378625367205298E-5)\n   [junit4]   1>    ... intersection [X=0.9999999998865037, Y=1.124732395751746E-6, Z=1.5024226425491994E-5] excluded by iterator bound (-1.496608303922967E-5)\n   [junit4]   1>    ... intersection [X=0.9999999998865037, Y=1.124732395751746E-6, Z=1.5024226425491994E-5] excluded by edge end plane (1.4590674486242253E-5)\n   [junit4]   1>   Edge [lat=4.492749557241206E-7, lon=1.8019115568534971E-6([X=0.9999999999982758, Y=1.8019115568523405E-6, Z=4.492749557241056E-7])] --> [lat=1.255403467900245E-6, lon=1.3751481926504994E-6([X=0.9999999999982665, Y=1.3751481926489823E-6, Z=1.2554034678999154E-6])]:\n   [junit4]   1>    ... intersection [X=-0.9999999999815022, Y=1.124732395751746E-6, Z=-5.977516911444968E-6] excluded by iterator bound (6.035660297712781E-6)\n   [junit4]   1>    ... intersection [X=-0.9999999999815022, Y=1.124732395751746E-6, Z=-5.977516911444968E-6] excluded by edge start plane (-6.2551342068899795E-6)\n   [junit4]   1>    ... intersection [X=0.999999999997874, Y=1.124732395751746E-6, Z=1.7284227819037767E-6] excluded by iterator bound (-1.670279395634999E-6)\n   [junit4]   1>    ... intersection [X=0.999999999997874, Y=1.124732395751746E-6, Z=1.7284227819037767E-6] excluded by edge end plane (5.35215230310662E-7)\n   [junit4]   1>   Edge [lat=1.255403467900245E-6, lon=1.3751481926504994E-6([X=0.9999999999982665, Y=1.3751481926489823E-6, Z=1.2554034678999154E-6])] --> [lat=1.640689686301266E-25, lon=0.0([X=1.0, Y=0.0, Z=1.640689686301266E-25])]:\n   [junit4]   1>    ... intersection [X=-0.9999999999988402, Y=1.124732395751746E-6, Z=1.0267932995397135E-6] excluded by iterator bound (-1.0849366858085427E-6)\n   [junit4]   1>    ... intersection [X=-0.9999999999988402, Y=1.124732395751746E-6, Z=1.0267932995397135E-6] excluded by edge start plane (-3.384940921425686E-6)\n   [junit4]   1>    ... intersection [X=0.9999999999988402, Y=1.124732395751746E-6, Z=1.0267932995397135E-6] excluded by iterator bound (-9.68649913270881E-7)\n   [junit4]   1>   Edge [lat=1.640689686301266E-25, lon=0.0([X=1.0, Y=0.0, Z=1.640689686301266E-25])] --> [lat=-1.135982425157425E-6, lon=6.109011074784121E-7([X=0.9999999999991683, Y=6.1090110747798E-7, Z=-1.1359824251571808E-6])]:\n   [junit4]   1>    ... intersection [X=0.9999999999971804, Y=1.124732395751746E-6, Z=-2.0914616440189845E-6] excluded by iterator bound (2.033318257750247E-6)\n   [junit4]   1>    ... intersection [X=0.9999999999971804, Y=1.124732395751746E-6, Z=-2.0914616440189845E-6] excluded by edge end plane (1.0848793160943967E-6)\n   [junit4]   1>    ... intersection [X=-0.9999999999971804, Y=1.124732395751746E-6, Z=-2.0914616440189845E-6] excluded by iterator bound (2.1496050302877155E-6)\n   [junit4]   1>    ... intersection [X=-0.9999999999971804, Y=1.124732395751746E-6, Z=-2.0914616440189845E-6] excluded by edge end plane (3.6645352880212198E-6)\n   [junit4]   1>  ...done\n   [junit4]   1> \n   [junit4]   1>  Edge [[lat=-1.135982425157425E-6, lon=6.109011074784121E-7([X=0.9999999999991683, Y=6.1090110747798E-7, Z=-1.1359824251571808E-6])] --> [lat=-2.7797906712270083E-7, lon=1.8357011217773334E-6([X=0.9999999999982765, Y=1.8357011217762314E-6, Z=-2.7797906712269723E-7])]] potentially crosses travel plane [A=0.0, B=1.0; C=0.0; D=-1.124732395751746E-6]\n   [junit4]   1>   Finding intersections between edge plane and travel plane...\n   [junit4]   1>   There are no intersection points within bounds.\n   [junit4]   1>    Crossing point [X=0.9999999999990665, Y=1.124732395751746E-6, Z=-7.76030624328578E-7] rejected by bound1 (7.178872380597327E-7)\n   [junit4]   1>    Crossing point [X=-0.9999999999966022, Y=1.124732395751746E-6, Z=2.3518375498275934E-6] rejected by bound2 (-2.4099809360962904E-6)\n   [junit4]   1>    Crossing point [X=-0.9999999999966022, Y=1.124732395751746E-6, Z=2.3518375498275934E-6] rejected by edge.endPlane (3.6145616079893093E-6)\n   [junit4]   1>    Endpoint(s) of edge are not on travel plane; distances: -5.138312882737661E-7 and 7.109687260244853E-7\n   [junit4]   1>  Edge [[lat=1.255403467900245E-6, lon=1.3751481926504994E-6([X=0.9999999999982665, Y=1.3751481926489823E-6, Z=1.2554034678999154E-6])] --> [lat=1.640689686301266E-25, lon=0.0([X=1.0, Y=0.0, Z=1.640689686301266E-25])]] potentially crosses travel plane [A=0.0, B=1.0; C=0.0; D=-1.124732395751746E-6]\n   [junit4]   1>   Finding intersections between edge plane and travel plane...\n   [junit4]   1>   There are no intersection points within bounds.\n   [junit4]   1>    Crossing point [X=-0.9999999999988402, Y=1.124732395751746E-6, Z=1.0267932995397135E-6] rejected by bound2 (-1.0849366858085427E-6)\n   [junit4]   1>    Crossing point [X=-0.9999999999988402, Y=1.124732395751746E-6, Z=1.0267932995397135E-6] rejected by edge.startPlane (-3.384940921425686E-6)\n   [junit4]   1>    Crossing point [X=0.9999999999988402, Y=1.124732395751746E-6, Z=1.0267932995397135E-6] rejected by bound2 (-9.68649913270881E-7)\n   [junit4]   1>    Endpoint(s) of edge are not on travel plane; distances: 2.5041579689723626E-7 and -1.124732395751746E-6\n   [junit4]   1>  Check point in set? false\n\n ",
            "date": "2018-04-27T11:44:14+0000"
        },
        {
            "id": "comment-16456293",
            "author": "Karl Wright",
            "content": "Hi Ignacio Vera, you are talking about this iterator, right?\n\n\nFirstLeg:\n  Generating SectorLinearCrossingEdgeIterator with:\n    Plane: [A=0.0, B=0.0; C=1.0; D=5.8143386268861615E-8]\n    Above Plane: [A=0.0, B=0.0; C=1.0; D=5.814438626886162E-8]\n    Below Plane: [A=0.0, B=0.0; C=1.0; D=5.814238626886161E-8]\n    Point: 0.9999999999993657,1.124732395751746E-6,-5.8143386268861615E-8\n    Travel distance: 1.9999999999999964\n    Bound1: [A=1.124732395751748E-6, B=-0.9999999999993675, C=0.0, D=0.0, side=-1.0]\n    Bound2: [A=-1.124732395751748E-6, B=0.9999999999993675, C=0.0, D=0.0, side=-1.0]\n\n\n\nIf Bound1 and Bound2 somehow wind up describing the null set of points, between them, then the Sector iterator indeed cannot be used.  I still cannot see how that would arise in this situation but it should be possible to experiment with this for a moment. ",
            "date": "2018-04-27T12:23:03+0000"
        },
        {
            "id": "comment-16456295",
            "author": "Ignacio Vera",
            "content": "No I was refering to:\n\n\u00a0\n\nBound1: [A=1.124732395751748E-6, B=-0.9999999999993675, C=0.0, D=0.0, side=-1.0]\nBound2: [A=-1.124732395751748E-6, B=0.9999999999993675, C=0.0, D=0.0, side=-1.0]\n\n\u00a0\n\nI think the union of these two bounds is empty, therefore we will never get an intersection\n\n\u00a0 ",
            "date": "2018-04-27T12:23:11+0000"
        },
        {
            "id": "comment-16456308",
            "author": "Karl Wright",
            "content": "Ignacio Vera, using identical bounds as a check does fix the problem.  Thanks!  I will commit the fix shortly. ",
            "date": "2018-04-27T12:38:11+0000"
        },
        {
            "id": "comment-16456326",
            "author": "ASF subversion and git services",
            "content": "Commit 43f0c67046c62cddcde42157f42d14c35cc621e9 in lucene-solr's branch refs/heads/master from Karl Wright\n[ https://git-wip-us.apache.org/repos/asf?p=lucene-solr.git;h=43f0c67 ]\n\nLUCENE-8281: Make sure we use the right iterator, and don't allow the construction of one with a null set of points. ",
            "date": "2018-04-27T12:52:56+0000"
        },
        {
            "id": "comment-16456327",
            "author": "ASF subversion and git services",
            "content": "Commit 8b29e5eef40e4877cefd2da957365ea310877c6e in lucene-solr's branch refs/heads/branch_7x from Karl Wright\n[ https://git-wip-us.apache.org/repos/asf?p=lucene-solr.git;h=8b29e5e ]\n\nLUCENE-8281: Make sure we use the right iterator, and don't allow the construction of one with a null set of points. ",
            "date": "2018-04-27T12:53:53+0000"
        },
        {
            "id": "comment-16456328",
            "author": "ASF subversion and git services",
            "content": "Commit 9fb34c2b1064fb3eb89b993a5ef4fdd2fe264277 in lucene-solr's branch refs/heads/branch_6x from Karl Wright\n[ https://git-wip-us.apache.org/repos/asf?p=lucene-solr.git;h=9fb34c2 ]\n\nLUCENE-8281: Make sure we use the right iterator, and don't allow the construction of one with a null set of points. ",
            "date": "2018-04-27T12:54:18+0000"
        },
        {
            "id": "comment-16493524",
            "author": "Steve Rowe",
            "content": "Reopening for a new reproducing failure from Policeman Jenkins https://jenkins.thetaphi.de/job/Lucene-Solr-master-Solaris/1895/:\n\n\nChecking out Revision fd929c1d601bd6e946489f51e7b3c0887a3392a6 (refs/remotes/origin/master)\n[...]\n   [junit4] Suite: org.apache.lucene.spatial3d.geom.RandomGeoPolygonTest\n   [junit4]   2> NOTE: reproduce with: ant test  -Dtestcase=RandomGeoPolygonTest -Dtests.method=testCompareSmallPolygons -Dtests.seed=6369EE055A678918 -Dtests.slow=true -Dtests.locale=es-BO -Dtests.timezone=Europe/Jersey -Dtests.asserts=true -Dtests.file.encoding=UTF-8\n   [junit4] FAILURE 0.03s J0 | RandomGeoPolygonTest.testCompareSmallPolygons {seed=[6369EE055A678918:B5D2F4B1CA30632A]} <<<\n   [junit4]    > Throwable #1: java.lang.AssertionError: \n   [junit4]    > Standard polygon: GeoCompositePolygon: {[GeoConvexPolygon: {planetmodel=PlanetModel.WGS84, points=[[lat=1.4379241972924144E-5, lon=-3.141520309370815([X=-1.0011188512685139, Y=-7.24251615257059E-5, Z=1.4395330244708275E-5])], [lat=-1.858900171939205E-5, lon=-3.1415059739464217([X=-1.001118850057461, Y=-8.677662511280753E-5, Z=-1.860980009708855E-5])], [lat=2.7071641284581073E-5, lon=-3.141469177092562([X=-1.001118845991408, Y=-1.2361464904363391E-4, Z=2.7101930495137982E-5])], [lat=8.285235549000288E-5, lon=-3.1414967545451287([X=-1.0011188459297669, Y=-9.600634121467467E-5, Z=8.29450550819143E-5])]], internalEdges={3}}, GeoConvexPolygon: {planetmodel=PlanetModel.WGS84, points=[[lat=1.4379241972924144E-5, lon=-3.141520309370815([X=-1.0011188512685139, Y=-7.24251615257059E-5, Z=1.4395330244708275E-5])], [lat=8.285235549000288E-5, lon=-3.1414967545451287([X=-1.0011188459297669, Y=-9.600634121467467E-5, Z=8.29450550819143E-5])], [lat=-8.956596846349593E-303, lon=-3.1415926535897922([X=-1.0011188539924791, Y=-1.0117738616818362E-15, Z=-8.966617970490158E-303])]], internalEdges={0}}]}\n   [junit4]    > Large polygon: GeoComplexPolygon: {planetmodel=PlanetModel.WGS84, number of shapes=1, address=c865f21d, testPoint=[lat=2.114284741800425E-5, lon=-3.141516973708951([X=-1.0011188509002849, Y=-7.57645554894811E-5, Z=2.1166503175641402E-5])], testPointInSet=true, shapes={ {[lat=1.4379241972924144E-5, lon=-3.141520309370815([X=-1.0011188512685139, Y=-7.24251615257059E-5, Z=1.4395330244708275E-5])], [lat=-1.858900171939205E-5, lon=-3.1415059739464217([X=-1.001118850057461, Y=-8.677662511280753E-5, Z=-1.860980009708855E-5])], [lat=2.7071641284581073E-5, lon=-3.141469177092562([X=-1.001118845991408, Y=-1.2361464904363391E-4, Z=2.7101930495137982E-5])], [lat=8.285235549000288E-5, lon=-3.1414967545451287([X=-1.0011188459297669, Y=-9.600634121467467E-5, Z=8.29450550819143E-5])], [lat=-8.956596846349593E-303, lon=-3.1415926535897922([X=-1.0011188539924791, Y=-1.0117738616818362E-15, Z=-8.966617970490158E-303])]}}\n   [junit4]    > Point: [lat=-6.499661194605612E-10, lon=-2.0286460544410216([X=-0.4425148814082194, Y=-0.8980086522698344, Z=-6.506933366482957E-10])]\n   [junit4]    > WKT: POLYGON((-179.9950336222651 -0.001065071343882595,-179.9929253178396 0.001551090790098614,-179.9945053894814 0.004747090292294721,-179.99999999999994 -5.131751980960148E-301,-179.99585498158038 8.238698776459206E-4,-179.9950336222651 -0.001065071343882595))\n   [junit4]    > WKT: POINT(-116.23285704533717 -3.7240315471586036E-8)\n   [junit4]    > normal polygon: false\n   [junit4]    > large polygon: true\n   [junit4]    > \tat __randomizedtesting.SeedInfo.seed([6369EE055A678918:B5D2F4B1CA30632A]:0)\n   [junit4]    > \tat org.apache.lucene.spatial3d.geom.RandomGeoPolygonTest.checkPoint(RandomGeoPolygonTest.java:227)\n   [junit4]    > \tat org.apache.lucene.spatial3d.geom.RandomGeoPolygonTest.testComparePolygons(RandomGeoPolygonTest.java:202)\n   [junit4]    > \tat org.apache.lucene.spatial3d.geom.RandomGeoPolygonTest.testCompareSmallPolygons(RandomGeoPolygonTest.java:109)\n   [junit4]    > \tat java.lang.Thread.run(Thread.java:748)\n   [junit4]   2> NOTE: test params are: codec=Lucene70, sim=Asserting(org.apache.lucene.search.similarities.AssertingSimilarity@735f0010), locale=es-BO, timezone=Europe/Jersey\n   [junit4]   2> NOTE: SunOS 5.11 amd64/Oracle Corporation 1.8.0_172 (64-bit)/cpus=3,threads=1,free=256153464,total=524288000\n   [junit4]   2> NOTE: All tests run in this JVM: [TestGeo3DDocValues, GeoCircleTest, GeoExactCircleTest, GeoPolygonTest, RandomBinaryCodecTest, RandomGeoPolygonTest]\n   [junit4] Completed [12/18 (1!)] on J0 in 12.28s, 32 tests, 1 failure <<< FAILURES!\n\n ",
            "date": "2018-05-29T13:27:04+0000"
        },
        {
            "id": "comment-16493568",
            "author": "Steve Rowe",
            "content": "Another reproducing seed, from https://jenkins.thetaphi.de/job/Lucene-Solr-7.x-Linux/2006/:\n\n\nChecking out Revision 1cbadda4d35a0f61458e16339271e9fe67894228 (refs/remotes/origin/branch_7x)\n[...]\n   [junit4] Suite: org.apache.lucene.spatial3d.geom.RandomGeoPolygonTest\n   [junit4]   2> NOTE: reproduce with: ant test  -Dtestcase=RandomGeoPolygonTest -Dtests.method=testCompareSmallPolygons -Dtests.seed=5F21B65C4DF637F7 -Dtests.multiplier=3 -Dtests.slow=true -Dtests.locale=kok -Dtests.timezone=Pacific/Wake -Dtests.asserts=true -Dtests.file.encoding=UTF-8\n   [junit4] FAILURE 0.16s J1 | RandomGeoPolygonTest.testCompareSmallPolygons {seed=[5F21B65C4DF637F7:EBA6C7233C2F439C]} <<<\n   [junit4]    > Throwable #1: java.lang.AssertionError: \n   [junit4]    > Standard polygon: GeoCompositePolygon: {[GeoConvexPolygon: {planetmodel=PlanetModel.WGS84, points=[[lat=-1.2378566953267578E-4, lon=1.0778629610541657E-4([X=1.0011188404553268, Y=1.0790689219191246E-4, Z=-1.2392416730036597E-4])], [lat=1.3037683296181198E-5, lon=4.861815800261127E-5([X=1.001118852723635, Y=4.8672554599460124E-5, Z=1.3052270559812557E-5])], [lat=8.747061945410853E-5, lon=-1.6995681235698612E-6([X=1.0011188501353872, Y=-1.7014696855966553E-6, Z=8.756848619198565E-5])], [lat=1.7686603873417388E-4, lon=-2.1857732025232224E-4([X=1.0011188143139031, Y=-2.1882187117172968E-4, Z=1.770639250659407E-4])], [lat=7.933403216731911E-5, lon=-2.691288112401935E-4([X=1.0011188145651035, Y=-2.69429922979063E-4, Z=7.942279528095147E-5])]], internalEdges={}}]}\n   [junit4]    > Large polygon: GeoComplexPolygon: {planetmodel=PlanetModel.WGS84, number of shapes=1, address=a133508d, testPoint=[lat=4.658454143323334E-5, lon=-6.660024865859933E-5([X=1.0011188506786064, Y=-6.667476449058707E-5, Z=4.663666271619482E-5])], testPointInSet=true, shapes={ {[lat=7.933403216731911E-5, lon=-2.691288112401935E-4([X=1.0011188145651035, Y=-2.69429922979063E-4, Z=7.942279528095147E-5])], [lat=-1.2378566953267578E-4, lon=1.0778629610541657E-4([X=1.0011188404553268, Y=1.0790689219191246E-4, Z=-1.2392416730036597E-4])], [lat=1.3037683296181198E-5, lon=4.861815800261127E-5([X=1.001118852723635, Y=4.8672554599460124E-5, Z=1.3052270559812557E-5])], [lat=8.747061945410853E-5, lon=-1.6995681235698612E-6([X=1.0011188501353872, Y=-1.7014696855966553E-6, Z=8.756848619198565E-5])], [lat=1.7686603873417388E-4, lon=-2.1857732025232224E-4([X=1.0011188143139031, Y=-2.1882187117172968E-4, Z=1.770639250659407E-4])]}}\n   [junit4]    > Point: [lat=1.1024952274600388, lon=5.880124943259361E-6([X=0.45066834482497653, Y=2.6499861755732973E-6, Z=0.890947403623827])]\n   [junit4]    > WKT: POLYGON((0.0061756998561877515 -0.007092396428423464,0.002785615261249814 7.470042274993943E-4,-9.737808047552182E-5 0.005011697326115332,-0.012523557947737438 0.010133677558665505,-0.015419945029436078 0.004545505214942496,0.0061756998561877515 -0.007092396428423464))\n   [junit4]    > WKT: POINT(3.3690634225836405E-4 63.168323466775924)\n   [junit4]    > normal polygon: false\n   [junit4]    > large polygon: true\n   [junit4]    > \tat __randomizedtesting.SeedInfo.seed([5F21B65C4DF637F7:EBA6C7233C2F439C]:0)\n   [junit4]    > \tat org.apache.lucene.spatial3d.geom.RandomGeoPolygonTest.checkPoint(RandomGeoPolygonTest.java:227)\n   [junit4]    > \tat org.apache.lucene.spatial3d.geom.RandomGeoPolygonTest.testComparePolygons(RandomGeoPolygonTest.java:202)\n   [junit4]    > \tat org.apache.lucene.spatial3d.geom.RandomGeoPolygonTest.testCompareSmallPolygons(RandomGeoPolygonTest.java:109)\n   [junit4]    > \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n   [junit4]    > \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n   [junit4]    > \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n   [junit4]    > \tat java.base/java.lang.reflect.Method.invoke(Method.java:564)\n   [junit4]    > \tat java.base/java.lang.Thread.run(Thread.java:844)\n   [junit4]   2> NOTE: test params are: codec=Asserting(Lucene70): {}, docValues:{}, maxPointsInLeafNode=92, maxMBSortInHeap=7.016058309271684, sim=RandomSimilarity(queryNorm=false): {}, locale=kok, timezone=Pacific/Wake\n   [junit4]   2> NOTE: Linux 4.13.0-41-generic amd64/Oracle Corporation 9.0.4 (64-bit)/cpus=8,threads=1,free=368840776,total=518979584\n   [junit4]   2> NOTE: All tests run in this JVM: [GeoPolygonTest, RandomGeoPolygonTest]\n   [junit4] Completed [17/18 (1!)] on J1 in 7.09s, 32 tests, 1 failure <<< FAILURES!\n\n ",
            "date": "2018-05-29T14:15:31+0000"
        },
        {
            "id": "comment-16493597",
            "author": "Karl Wright",
            "content": "Please don't reopen old tickets with new failures. ",
            "date": "2018-05-29T14:41:27+0000"
        },
        {
            "id": "comment-16493632",
            "author": "Steve Rowe",
            "content": "Please don't reopen old tickets with new failures.\n\nIt's the same test method, for an as-yet unreleased fix.  Please help me understand what should instead be done. ",
            "date": "2018-05-29T14:47:51+0000"
        },
        {
            "id": "comment-16493647",
            "author": "Karl Wright",
            "content": "Steve Rowe, this is yet another randomized test failure.  The cause of each such failure is likely to be entirely different.  The fix for one is not the same as the fix for another, so unless you see a non-randomized test failing, the right thing to do is open a new ticket.  I've already done so in this case. ",
            "date": "2018-05-29T14:57:36+0000"
        },
        {
            "id": "comment-16493653",
            "author": "Steve Rowe",
            "content": "Karl Wright: so according to your logic you should open a new JIRAs for the second seed I posted here, no? ",
            "date": "2018-05-29T15:00:30+0000"
        },
        {
            "id": "comment-16493740",
            "author": "Karl Wright",
            "content": "Yes. ",
            "date": "2018-05-29T15:49:57+0000"
        }
    ]
}