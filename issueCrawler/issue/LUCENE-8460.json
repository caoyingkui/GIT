{
    "id": "LUCENE-8460",
    "title": "Better argument validation in StoredField",
    "details": {
        "components": [
            "core/other"
        ],
        "status": "Closed",
        "resolution": "Fixed",
        "fix_versions": [
            "7.5",
            "master (8.0)"
        ],
        "affect_versions": "None",
        "labels": "",
        "priority": "Major",
        "type": "Improvement"
    },
    "description": "I have found some invalid Javadocs in StoredField Class.\n (and I think Field\u00a0Class has some problems too )\n\n\u00a0\n\n1) Line 45 method\n\n/**\n * Expert: allows you to customize the {@link\n * ...\n * @throws IllegalArgumentException if the field name is null.\n */\nprotected StoredField(String name, FieldType type) {\n  super(name, type);\n}\n\n\nIt is misleading because there is no explanation for type.\n If you follow that super class, you can see the following code(Field class).\n\n/**\n * Expert: creates a field with no initial value.\n * ...\n * @throws IllegalArgumentException if either the name or type\n *         is null.\n */\nprotected Field(String name, IndexableFieldType type) {\n  if (name == null) {\n    throw new IllegalArgumentException(\"name must not be null\");\n  }\n  this.name = name;\n  if (type == null) {\n    throw new IllegalArgumentException(\"type must not be null\");\n  }\n  this.type = type;\n}\n\nField class has the exception handling(IllegalArgumentException) for null\u00a0IndexableFieldType\u00a0object.\n For that reason, I changed the Javadoc to:\n\n/**\n * Expert: allows you to customize the {@link\n * ...\n * @throws IllegalArgumentException if the field name or type\n *         is null.\n */\nprotected StoredField(String name, FieldType type) {\n  super(name, type);\n}\n\n\n\u00a0\n\n2) Line 59 method\n\n/**\n * Expert: allows you to customize the {@link\n * ...\n * @throws IllegalArgumentException if the field name\n */\npublic StoredField(String name, BytesRef bytes, FieldType type) {\n  super(name, bytes, type);\n}\n\n\nIt is misleading because there is no explanation for bytes.\n If you follow that super class, you can see the following code(Field class).\n\n/**\n * Create field with binary value.\n *\n * ...\n * @throws IllegalArgumentException if the field name is null,\n *         or the field's type is indexed()\n * @throws NullPointerException if the type is null\n */\npublic Field(String name, BytesRef bytes, IndexableFieldType type) {\n  if (name == null) {\n    throw new IllegalArgumentException(\"name must not be null\");\n  }\n  if (bytes == null) {\n    throw new IllegalArgumentException(\"bytes must not be null\");\n  }\n  this.fieldsData = bytes;\n  this.type = type;\n  this.name = name;\n}\n\n\nField class has the exception handling(IllegalArgumentException) for null\u00a0BytesRef\u00a0object.\n For that reason,\u00a0I changed the Javadoc to:\n\n/**\n * Expert: allows you to customize the {@link\n * ...\n * @throws IllegalArgumentException if the field name or value\n *         is null.\n */\npublic StoredField(String name, BytesRef bytes, FieldType type) {\n  super(name, bytes, type);\n}\n\n\n\u00a0\n\n3) Line 71 method\n\n/**\n * Create a stored-only field with the given binary value.\n * ...\n * @throws IllegalArgumentException if the field name is null.\n */\npublic StoredField(String name, byte[] value) {\n  super(name, value, TYPE);\n}\n\n\nIt is misleading because there is no explanation for\u00a0byte array.\n If you follow that super class, you can see the following code(Field class).\n\npublic Field(String name, byte[] value, IndexableFieldType type) {\n  this(name, value, 0, value.length, type);\n}\n// To\npublic Field(String name, byte[] value, int offset, int length, IndexableFieldType type) {\n  this(name, new BytesRef(value, offset, length), type);\n}\n\nWhen declaring a new BytesRef, an Illegal exception will be thrown if\u00a0value is null.\n\npublic BytesRef(byte[] bytes, int offset, int length) {\n  this.bytes = bytes;\n  this.offset = offset;\n  this.length = length;\n  assert isValid();\n}\n\npublic boolean isValid() {\n  if (bytes == null) {\n    throw new IllegalStateException(\"bytes is null\");\n  }\n  ...\n}\n\nFor that reason,\u00a0I changed the Javadoc to:\n\n/**\n * Create a stored-only field with the given binary value.\n * <p>NOTE: the provided byte[] is not copied so be sure\n * not to change it until you're done with this field.\n * @param name field name\n * @param value byte array pointing to binary content (not copied)\n * @throws IllegalArgumentException if the field name is null.\n * @throws IllegalStateException if the value is null.\n */\npublic StoredField(String name, byte[] value) {\n  super(name, value, TYPE);\n}\n\n\n\u00a0\n\n4) Line 85 method\n\nFor the same reason as \"3)\", I changed the Javadoc to:\n\n/**\n * Create a stored-only field with the given binary value.\n * <p>NOTE: the provided byte[] is not copied so be sure\n * not to change it until you're done with this field.\n * @param name field name\n * @param value byte array pointing to binary content (not copied)\n * @param offset starting position of the byte array\n * @param length valid length of the byte array\n * @throws IllegalArgumentException if the field name is null.\n * @throws IllegalStateException if the value is null.\n */\npublic StoredField(String name, byte[] value, int offset, int length) {\n  super(name, value, offset, length, TYPE);\n}\n\n\n\u00a0\n\n5) Line 97 method\n\nFor the\u00a0same reason as \"2)\", I changed the Javadoc to:\n\n/**\n * Create a stored-only field with the given binary value.\n * <p>NOTE: the provided BytesRef is not copied so be sure\n * not to change it until you're done with this field.\n * @param name field name\n * @param value BytesRef pointing to binary content (not copied)\n * @throws IllegalArgumentException if the field name or value\n *         is null.\n */\npublic StoredField(String name, BytesRef value) {\n  super(name, value, TYPE);\n}\n\n\n\u00a0\n\n6) Line 119 method\n\n/**\n * Expert: allows you to customize the {@link\n * ...\n * @throws IllegalArgumentException if the field name or value is null.\n */\npublic StoredField(String name, String value, FieldType type) {\n  super(name, value, type);\n}\n\n\nIt is misleading because there is no explanation for\u00a0type.\n If you follow that super class, you can see the following code(Field class).\n\n/**\n * Create field with String value.\n * @param name field name\n * @param value string value\n * @param type field type\n * @throws IllegalArgumentException if either the name or value\n *         is null, or if the field's type is neither indexed() nor stored(), \n *         or if indexed() is false but storeTermVectors() is true.\n * @throws NullPointerException if the type is null\n */\npublic Field(String name, String value, IndexableFieldType type) {\n  if (name == null) {\n    throw new IllegalArgumentException(\"name must not be null\");\n  }\n  if (value == null) {\n    throw new IllegalArgumentException(\"value must not be null\");\n  }\n  if (!type.stored() && type.indexOptions() == IndexOptions.NONE) {\n    throw new IllegalArgumentException(\"it doesn't make sense to have a field that \"\n      + \"is neither indexed nor stored\");\n  }\n  this.type = type;\n  this.name = name;\n  this.fieldsData = value;\n}\n\n\nField class has the exception handling(NPE) for\u00a0null IndexableFieldType\u00a0object.\n (if type is null, NPE can be occured when run type.stored())\n For that reason,\u00a0I changed the Javadoc to:\n\n/**\n * Expert: allows you to customize the {@link\n * FieldType}.\n * @param name field name\n * @param value string value\n * @param type custom {@link FieldType} for this field\n * @throws IllegalArgumentException if the field name or value is null.\n * @throws NullPointerException if the type is null.\n */\npublic StoredField(String name, String value, FieldType type) {\n  super(name, value, type);\n}\n\n\n\u00a0\n\n7)\u00a0Wrong Javadocs in Field Class.\n\nI saw the wrong \"NullPointerException\" throws in Javadoc.\n\nLine 176, 194 and 210 methods have a NPE throws in Javadoc.\n\n// Line 176 method\n/**\n * Create field with binary value.\n * ...\n * @throws NullPointerException if the type is null\n */\npublic Field(String name, byte[] value, IndexableFieldType type) {\n  this(name, value, 0, value.length, type);\n}\n\n// Line 194 method\n/**\n * Create field with binary value.\n * ...\n * @throws NullPointerException if the type is null\n */\npublic Field(String name, byte[] value, int offset, int length, IndexableFieldType type) {\n  this(name, new BytesRef(value, offset, length), type);\n}\n\n// Line 210 method\n/**\n * Create field with binary value.\n * ...\n * @throws NullPointerException if the type is null\n */\npublic Field(String name, BytesRef bytes, IndexableFieldType type) {\n  if (name == null) {\n    throw new IllegalArgumentException(\"name must not be null\");\n  }\n  if (bytes == null) {\n    throw new IllegalArgumentException(\"bytes must not be null\");\n  }\n  this.fieldsData = bytes;\n  this.type = type;\n  this.name = name;\n}\n\nLine 176 and 194 methods call Line 210 method.\n However, this method can not cause the NullPointerException.\n If type is null, it is just the following code.\n\nprotected final IndexableFieldType type = null;\n\n\nIn fact, I think the null check is missing.\n But it's just my idea, so I can not decide whether to remove Javadoc's throws or insert a null check code.\n\nIf it is decided, I will work on the related issue separately.",
    "attachments": {
        "LUCENE-8460.patch": "https://issues.apache.org/jira/secure/attachment/12936302/LUCENE-8460.patch"
    },
    "issue_links": {},
    "comments": [
        {
            "id": "comment-16586289",
            "author": "Namgyu Kim",
            "content": "Because of the \"Field Class\", I set it to major issue.\nBut if someone doesn't think it's valid, I'll change it to minor issue. ",
            "date": "2018-08-20T17:44:49+0000"
        },
        {
            "id": "comment-16586661",
            "author": "Lucene/Solr QA",
            "content": "\n\n\n  -1 overall \n\n\n\n\n\n\n\n\n\n Vote \n Subsystem \n Runtime \n Comment \n\n\n\u00a0\n\u00a0\n\u00a0\n  Prechecks  \n\n\n -1 \n  test4tests  \n   0m  0s \n  The patch doesn't appear to include any new or modified tests. Please justify why no new tests are needed for this patch. Also please list what manual steps were performed to verify this patch.  \n\n\n\u00a0\n\u00a0\n\u00a0\n  master Compile Tests  \n\n\n +1 \n  compile  \n   0m 20s \n  master passed  \n\n\n\u00a0\n\u00a0\n\u00a0\n  Patch Compile Tests  \n\n\n +1 \n  compile  \n   0m 20s \n  the patch passed  \n\n\n +1 \n  javac  \n   0m 20s \n  the patch passed  \n\n\n +1 \n  Release audit (RAT)  \n   0m 20s \n  the patch passed  \n\n\n +1 \n  Check forbidden APIs  \n   0m 20s \n  the patch passed  \n\n\n +1 \n  Validate source patterns  \n   0m 20s \n  the patch passed  \n\n\n\u00a0\n\u00a0\n\u00a0\n  Other Tests  \n\n\n +1 \n  unit  \n  11m 38s \n  core in the patch passed.  \n\n\n  \n   \n  13m 47s \n   \n\n\n\n\n\n\n\n\n\n Subsystem \n Report/Notes \n\n\n JIRA Issue \n LUCENE-8460 \n\n\n JIRA Patch URL \n https://issues.apache.org/jira/secure/attachment/12936302/LUCENE-8460.patch \n\n\n Optional Tests \n  compile  javac  unit  ratsources  checkforbiddenapis  validatesourcepatterns  \n\n\n uname \n Linux lucene1-us-west 4.4.0-130-generic #156~14.04.1-Ubuntu SMP Thu Jun 14 13:51:47 UTC 2018 x86_64 x86_64 x86_64 GNU/Linux \n\n\n Build tool \n ant \n\n\n Personality \n /home/jenkins/jenkins-slave/workspace/PreCommit-LUCENE-Build/sourcedir/dev-tools/test-patch/lucene-solr-yetus-personality.sh \n\n\n git revision \n master / 5eab1c3 \n\n\n ant \n version: Apache Ant(TM) version 1.9.3 compiled on July 24 2018 \n\n\n Default Java \n 1.8.0_172 \n\n\n  Test Results \n https://builds.apache.org/job/PreCommit-LUCENE-Build/77/testReport/ \n\n\n modules \n C: lucene/core U: lucene/core \n\n\n Console output \n https://builds.apache.org/job/PreCommit-LUCENE-Build/77/console \n\n\n Powered by \n Apache Yetus 0.7.0   http://yetus.apache.org \n\n\n\n\n\n\nThis message was automatically generated.\n ",
            "date": "2018-08-20T23:39:40+0000"
        },
        {
            "id": "comment-16591299",
            "author": "Adrien Grand",
            "content": "In fact, I think the null check is missing.\n\n+1 Let's update the patch to add the missing null checks and only throw instances of IllegalArgumentException? ",
            "date": "2018-08-24T08:04:09+0000"
        },
        {
            "id": "comment-16592158",
            "author": "Namgyu Kim",
            "content": "Hi, Adrien Grand.\n\nThank you for your reply.\n\nI uploaded a new patch.\n\n\u00a0\n\n\u25a0 Added content\n\n1) Add Null Check (Field)\n\nif (type == null) {\n  throw new IllegalArgumentException(\"type must not be null\");\n}\n\n\nI added a null check for \"IndexableFieldType\".\n\n\u00a0\n\n2) Edit Javadoc (Field, StoredField)\n\nI changed Javadoc to fit the new \"Field\" class.\n\n(like delete throws NullPointerException)\n\n\u00a0\n\n3) Very Small Refactoring (Field)\n\nbefore\n\n// Line 210 method\npublic Field(String name, BytesRef bytes, IndexableFieldType type) {\n  ...\n  this.fieldsData = bytes;\n  this.type = type;\n  this.name = name;\n}\n\n// Line 234 method\npublic Field(String name, String value, IndexableFieldType type) {\n  ...\n  this.type = type;\n  this.name = name;\n  this.fieldsData = value;\n}\n\n\nafter\n\n// Line 210 method\npublic Field(String name, BytesRef bytes, IndexableFieldType type) {\n  ...\n  this.name = name;\n  this.fieldsData = bytes;\n  this.type = type;\n}\n\n// Line 234 method\npublic Field(String name, String value, IndexableFieldType type) {\n  ...\n  this.name = name;\n  this.fieldsData = value;\n  this.type = type;\n}\n\n\n\u00a0\n\n\u25a0 Discussion\n\n1) Remaining NullPointerException throws\u00a0\n\n// Line 112 method\n/**\n* Create field with Reader value.\n* ...\n* @throws NullPointerException if the reader is null\n*/\npublic Field(String name, Reader reader, IndexableFieldType type) {\n  ...\n  if (reader == null) {\n    throw new NullPointerException(\"reader must not be null\");\n  }\n  ...\n}\n\n// Line 144 method\n/**\n* Create field with TokenStream value.\n* ...\n* @throws NullPointerException if the tokenStream is null\n*/\npublic Field(String name, TokenStream tokenStream, IndexableFieldType type) {\n  ...\n  if (tokenStream == null) {\n    throw new NullPointerException(\"tokenStream must not be null\");\n  }\n  ...\n}\n\nAre the above throws NullPointerException codes okay?\n\n\u00a0\n\n2) Issue Name\n\nThe current issue name is \"Javadoc changes in StoredField\".\n However, I think that the content has changed so much that it needs to be modified.\n What do you think a good name is? ",
            "date": "2018-08-24T20:58:07+0000"
        },
        {
            "id": "comment-16592435",
            "author": "Lucene/Solr QA",
            "content": "\n\n\n  -1 overall \n\n\n\n\n\n\n\n\n\n Vote \n Subsystem \n Runtime \n Comment \n\n\n\u00a0\n\u00a0\n\u00a0\n  Prechecks  \n\n\n -1 \n  test4tests  \n   0m  0s \n  The patch doesn't appear to include any new or modified tests. Please justify why no new tests are needed for this patch. Also please list what manual steps were performed to verify this patch.  \n\n\n\u00a0\n\u00a0\n\u00a0\n  master Compile Tests  \n\n\n +1 \n  compile  \n   0m 20s \n  master passed  \n\n\n\u00a0\n\u00a0\n\u00a0\n  Patch Compile Tests  \n\n\n +1 \n  compile  \n   0m 18s \n  the patch passed  \n\n\n +1 \n  javac  \n   0m 18s \n  the patch passed  \n\n\n +1 \n  Release audit (RAT)  \n   0m 18s \n  the patch passed  \n\n\n +1 \n  Check forbidden APIs  \n   0m 18s \n  the patch passed  \n\n\n +1 \n  Validate source patterns  \n   0m 18s \n  the patch passed  \n\n\n\u00a0\n\u00a0\n\u00a0\n  Other Tests  \n\n\n +1 \n  unit  \n  11m 13s \n  core in the patch passed.  \n\n\n  \n   \n  13m 26s \n   \n\n\n\n\n\n\n\n\n\n Subsystem \n Report/Notes \n\n\n JIRA Issue \n LUCENE-8460 \n\n\n JIRA Patch URL \n https://issues.apache.org/jira/secure/attachment/12937064/LUCENE-8460.patch \n\n\n Optional Tests \n  compile  javac  unit  ratsources  checkforbiddenapis  validatesourcepatterns  \n\n\n uname \n Linux lucene1-us-west 4.4.0-130-generic #156~14.04.1-Ubuntu SMP Thu Jun 14 13:51:47 UTC 2018 x86_64 x86_64 x86_64 GNU/Linux \n\n\n Build tool \n ant \n\n\n Personality \n /home/jenkins/jenkins-slave/workspace/PreCommit-LUCENE-Build/sourcedir/dev-tools/test-patch/lucene-solr-yetus-personality.sh \n\n\n git revision \n master / f26dd13 \n\n\n ant \n version: Apache Ant(TM) version 1.9.3 compiled on July 24 2018 \n\n\n Default Java \n 1.8.0_172 \n\n\n  Test Results \n https://builds.apache.org/job/PreCommit-LUCENE-Build/79/testReport/ \n\n\n modules \n C: lucene/core U: lucene/core \n\n\n Console output \n https://builds.apache.org/job/PreCommit-LUCENE-Build/79/console \n\n\n Powered by \n Apache Yetus 0.7.0   http://yetus.apache.org \n\n\n\n\n\n\nThis message was automatically generated.\n ",
            "date": "2018-08-25T04:03:22+0000"
        },
        {
            "id": "comment-16593741",
            "author": "Adrien Grand",
            "content": "Looking further at the patch, the \"throws IllegalStateException\" javadocs are not really correct, since this exception is only thrown by BytesRef#isValid which is called via an assert? Let's check for null values before the BytesRef constructor and throw an IllegalArgumentException?\n\nAre the above throws NullPointerException codes okay?\n\nAn IllegalArgumentException would be more consistent with other constructors, but a NullPointerException isn't bad either. I'm fine either way.\n\nThe current issue name is \"Javadoc changes in StoredField\". However, I think that the content has changed so much that it needs to be modified. What do you think a good name is?\n\nNot sure, maybe something like \"Better argument validation in StoredField\"? ",
            "date": "2018-08-27T14:29:09+0000"
        },
        {
            "id": "comment-16593928",
            "author": "Namgyu Kim",
            "content": "Thank you for your reply. Adrien Grand.\nI uploaded a new patch file.\nIt contains the following information.\n\n\u00a0\n\n1) throws IllegalStateException problem\nThe \"throws IllegalStateException\" javadocs are not really correct, since this exception is only thrown by BytesRef#isValid which is called via an assert? Let's check for null values before the BytesRef constructor and throw an IllegalArgumentException?\nYes, you're right. I saw it wrong.\nSo I change it to the following code.\n\n// Line 176 method\n/**\n * Create field with binary value.\n * ...\n * @throws IllegalArgumentException if the field name, value or type\n *         is null, or the field's type is indexed().\n */\npublic Field(String name, byte[] value, IndexableFieldType type) {\n  this(name, value, 0, value.length, type);\n}\n\n// Line 194 method\n/**\n * Create field with binary value.\n * ...\n * @throws IllegalArgumentException if the field name, value or type\n *         is null, or the field's type is indexed().\n */\npublic Field(String name, byte[] value, int offset, int length, IndexableFieldType type) {\n  this(name, value != null ? new BytesRef(value, offset, length) : null, type);\n}\n\n\nI implemented it using a ternary operator, because of the Java rules that can not place any code before the constructor.\nIf you have any other comments about this, please let me know.\n\n\u00a0\n\n2)\u00a0Issue name\n\nI reflected your opinion. Thank you\u00a0 ",
            "date": "2018-08-27T16:50:09+0000"
        },
        {
            "id": "comment-16597534",
            "author": "ASF subversion and git services",
            "content": "Commit a30eeae7956c8c59037ca1c08e7f69474da10e7a in lucene-solr's branch refs/heads/master from Namgyu Kim\n[ https://git-wip-us.apache.org/repos/asf?p=lucene-solr.git;h=a30eeae ]\n\nLUCENE-8460: Better argument validation in StoredField\n\nSigned-off-by: Namgyu Kim <kng0828@gmail.com>\nSigned-off-by: Adrien Grand <jpountz@gmail.com> ",
            "date": "2018-08-30T14:45:31+0000"
        },
        {
            "id": "comment-16597867",
            "author": "ASF subversion and git services",
            "content": "Commit b1d165c6e8d4d3e78a7c7222ff634779a9677d5b in lucene-solr's branch refs/heads/branch_7x from Namgyu Kim\n[ https://git-wip-us.apache.org/repos/asf?p=lucene-solr.git;h=b1d165c ]\n\nLUCENE-8460: Better argument validation in StoredField\n\nSigned-off-by: Namgyu Kim <kng0828@gmail.com>\nSigned-off-by: Adrien Grand <jpountz@gmail.com> ",
            "date": "2018-08-30T20:02:02+0000"
        },
        {
            "id": "comment-16597878",
            "author": "Adrien Grand",
            "content": "Thank you Namgyu Kim! ",
            "date": "2018-08-30T20:06:50+0000"
        },
        {
            "id": "comment-16599556",
            "author": "Namgyu Kim",
            "content": "You're welcome,\u00a0Adrien Grand.\n\nThank you for applying my code\u00a0 ",
            "date": "2018-09-01T06:52:23+0000"
        }
    ]
}