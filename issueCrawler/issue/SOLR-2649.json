{
    "id": "SOLR-2649",
    "title": "MM ignored in edismax queries with operators",
    "details": {
        "affect_versions": "None",
        "status": "Closed",
        "fix_versions": [
            "5.5",
            "6.0"
        ],
        "components": [
            "query parsers"
        ],
        "type": "Improvement",
        "priority": "Major",
        "labels": "",
        "resolution": "Fixed"
    },
    "description": "Hypothetical scenario:\n  1. User searches for \"stocks oil gold\" with MM set to \"50%\"\n  2. User adds \"-stockings\" to the query: \"stocks oil gold -stockings\"\n  3. User gets no hits since MM was ignored and all terms where AND-ed together\n\nThe behavior seems to be intentional, although the reason why is never explained:\n  // For correct lucene queries, turn off mm processing if there\n  // were explicit operators (except for AND).\n  boolean doMinMatched = (numOR + numNOT + numPluses + numMinuses) == 0; \n(lines 232-234 taken from tags/lucene_solr_3_3/solr/src/java/org/apache/solr/search/ExtendedDismaxQParserPlugin.java)\n\nThis makes edismax unsuitable as an replacement to dismax; mm is one of the primary features of dismax.",
    "attachments": {
        "SOLR-2649-with-Qop.patch": "https://issues.apache.org/jira/secure/attachment/12642810/SOLR-2649-with-Qop.patch",
        "SOLR-2649.diff": "https://issues.apache.org/jira/secure/attachment/12623283/SOLR-2649.diff",
        "SOLR-2649.patch": "https://issues.apache.org/jira/secure/attachment/12636154/SOLR-2649.patch"
    },
    "issue_links": {},
    "comments": [
        {
            "author": "Ahmet Arslan",
            "id": "comment-13068925",
            "date": "2011-07-21T11:45:23+0000",
            "content": "I experienced the same issue.  When i added one negative clause to the query string (that has two optional clauses), mm is ignored and default operator is used instead.\nq=word1 word2 -word3&mm=100%&defType=edismax \nand \nq=word1 word2 -word3&mm=100%&defType=dismax \nreturns different result sets. \n\nedismax returns documents containing either word1 or word2, although there are two optional clauses in the query and mm is set to 100%. "
        },
        {
            "author": "Hoss Man",
            "id": "comment-13069215",
            "date": "2011-07-21T21:21:40+0000",
            "content": "I believe the intention here was that if a query string contains any query operators (AND/OR/NOT/+/-) then it's assumed the user wants exactly what they asked for, and the \"mm\" value should not be used.\n\nI believe in the cases where false==doMinMatched then the q.op (which defaults to <solrQueryParser defaultOperator=\"...\"/> should come into play, so folks using mm=100%&q.op=AND or mm=0&q.op=OR should already get the behavior they expect (if it's not using q.op then that definitely seems like a bug)\n\nwhen people are using middle ground values for mm (ie: mm=50% etc...) then it definitely seems like we need some way for them to indicate to edismax thta the mm should always be used. "
        },
        {
            "author": "Sean Daugherty",
            "id": "comment-13089244",
            "date": "2011-08-23T03:17:05+0000",
            "content": "As far as I can tell, q.op is being ignored. In my case, it defaults to \"OR\"/MM0%. I'm not sure why it's doing that, but it's certainly not responding to either q.op or <solrQueryParser/>. "
        },
        {
            "author": "Mike Lissner",
            "id": "comment-13190640",
            "date": "2012-01-22T10:19:05+0000",
            "content": "Yeah, I'm seeing this too. A user has reported that they queried:\n(internet OR online OR web) \"personal jurisdiction\"\n\nI have defaultOperator set to AND, so I'd expect the query to get processed as:\n(internet OR online OR web) AND \"personal jurisdiction\"\n\nBut it is instead getting processed with an OR statement. I've confirmed this using debug.\n\nThis doesn't seem like ideal functionality for the default operator to work, except when the user tries to override it in parts of a query. This seems like more than a minor issue to me. "
        },
        {
            "author": "Brian Carver",
            "id": "comment-13190715",
            "date": "2012-01-22T17:27:01+0000",
            "content": "If this bug is responsible for the behavior Mike describes, then I agree with him that this should not be classed \"minor\" as it results in precisely the opposite behavior that the user/maintainer would anticipate. "
        },
        {
            "author": "Ron Davies",
            "id": "comment-13190909",
            "date": "2012-01-23T07:30:43+0000",
            "content": "A significant portion of our users (professional searchers) would never accept this behaviour so this issue is a blocker for us, i.e. prevents us us from using edismax (which we would very much like to do).  "
        },
        {
            "author": "Jan H\u00f8ydahl",
            "id": "comment-13199181",
            "date": "2012-02-02T20:23:07+0000",
            "content": "So how should the parser interpret these examples?\n\n\nq=word1 word2 word3 -word4&mm=100%\n\n\nI agree with Ahmet that here both word1, word2 and word3 must be required since mm is explicitly specified. If mm is not specified, mm is set from defaultOperator, i.e. AND=>100%, OR=>0\n\n\nq=word1 word2 word3 -word4%mm=50%\n\n\nHere you'd expect that two of of the three first words must match.\n\n\nq=word1 OR word2 word3%mm=100%\nExample after having indexed exampledocs:\nhttp://localhost:8983/solr/browse?q=ipod%20OR%20samsung%20printer&debugQuery=true&mm=100%25\n\n\nWith ipod OR samsung I get 5 hits. Adding the word \"printer\" yields 6 hits, i.e. it is OR'ed too. Here I'd expect the equivalent of (word1 OR word2) AND word3.\n\n\nq=word1 AND word2 word3%mm=50%\n\n\nWhat would you expect for this? Perhaps (word1 AND word2) to be treated as clause1 and word3 as clause2 and then apply mm=1?\n\n\nq=word1 OR word2 word3 word4 word5%mm=50%\n\n\nHow about this? Again, it would make sense to respect (word1 OR word2) as one clause and then require two clauses out of the resulting four. "
        },
        {
            "author": "Jan H\u00f8ydahl",
            "id": "comment-13199182",
            "date": "2012-02-02T20:23:08+0000",
            "content": "So how should the parser interpret these examples?\n\n\nq=word1 word2 word3 -word4&mm=100%\n\n\nI agree with Ahmet that here both word1, word2 and word3 must be required since mm is explicitly specified. If mm is not specified, mm is set from defaultOperator, i.e. AND=>100%, OR=>0\n\n\nq=word1 word2 word3 -word4%mm=50%\n\n\nHere you'd expect that two of of the three first words must match.\n\n\nq=word1 OR word2 word3%mm=100%\nExample after having indexed exampledocs:\nhttp://localhost:8983/solr/browse?q=ipod%20OR%20samsung%20printer&debugQuery=true&mm=100%25\n\n\nWith ipod OR samsung I get 5 hits. Adding the word \"printer\" yields 6 hits, i.e. it is OR'ed too. Here I'd expect the equivalent of (word1 OR word2) AND word3.\n\n\nq=word1 AND word2 word3%mm=50%\n\n\nWhat would you expect for this? Perhaps (word1 AND word2) to be treated as clause1 and word3 as clause2 and then apply mm=1?\n\n\nq=word1 OR word2 word3 word4 word5%mm=50%\n\n\nHow about this? Again, it would make sense to respect (word1 OR word2) as one clause and then require two clauses out of the resulting four. "
        },
        {
            "author": "James Dyer",
            "id": "comment-13199194",
            "date": "2012-02-02T20:37:59+0000",
            "content": "Maybe a simple answer is to have it make \"mm\" apply to all optional terms and ignore the rest.  So for...\n\nq=word1 AND word2 word3%mm=50%\n\n\n...\"word3\" is the only optional term, so mm=50% only applies to \"word3\".\n\nAnd for...\n\nq=word1 OR word2 word3 word4 word5%mm=50%\n\n\n...Everything here is optional, so \"mm\" applies to all the terms.  Otherwise, you'd be in a situation where \"OR\" takes on a meaning that is different from \"optional\" and I'm not sure you want to introduce a 4th concept here beyond what we already have: required/optional/prohibited.\n\nThe semantics of \"mm\" would then become \"the minimum of all optional terms that need to match\". "
        },
        {
            "author": "Mike Lissner",
            "id": "comment-13199199",
            "date": "2012-02-02T20:41:56+0000",
            "content": "That makes sense to me and sounds like the simplest, most logical solution.\n\nI'm mostly in favor of the easiest thing that will make default AND queries work properly as quickly as possible. "
        },
        {
            "author": "Jan H\u00f8ydahl",
            "id": "comment-13199259",
            "date": "2012-02-02T21:43:45+0000",
            "content": "Yes I think the key here is what terms are part of some user imposed operator (forced MUST or MUST NOT) vs what terms are left dangling in the wild to be subject to mm. But what about this\n\n\nq=word1 AND word2 (word3 OR word4) word5%mm=100%\n\n\nShould this be interpreted as MUST have word1 AND word2 and set mm=3 for word3, word4, word5? Don't think so. An OR does not mean the same as a \"loose\" term. This would clearly (perhaps because of the parens) signal that word3 OR word4 should be treated as one unit, not requiring both of them? "
        },
        {
            "author": "James Dyer",
            "id": "comment-13199286",
            "date": "2012-02-02T22:21:19+0000",
            "content": "It seems it would be simpler to implement and understand if we just counted up the optional words in the query and apply \"mm\" to those.  I suppose you could create a subtle rule that naked terms count for \"mm\" but OR-ed terms do not.  This might be functionality someone wants but then again it might confuse others who would expect \"x OR y\" to mean the same as \"x y\".  \n\nCounting multiple terms as 1 because they are in parenthesis together doesn't seem like a good idea to me.  But then again, maybe someone out there would appreciate all the subtle things you could do with this?\n\nI guess whatever is decided just needs to be well-documented so when/if someone is surprised by the functionality they can look it up and see what's going on.  Whatever is done, it will be a nice improvement over the current behavior. "
        },
        {
            "author": "Jan H\u00f8ydahl",
            "id": "comment-13199400",
            "date": "2012-02-03T00:20:45+0000",
            "content": "When bringing up all these cases, we may perhaps understand the reason for the current behavior after all  However, it is flawed in assuming that schema's defaultOperator should be used instead of mm.\n\nHere's a concrete suggestion for improvement\n\n\n\tFor mm=0%, mm=100% or no mm specified: Disable mm as today, but induce defaultOperator from the mm value\n\tFor all other values of mm, use James' method of counting \"optional\" terms (including OR'ed ones) and apply \"mm\" to those.\n\n\n\nThis would be a big step in right direction and probably fix most peoples needs "
        },
        {
            "author": "Hoss Man",
            "id": "comment-13200102",
            "date": "2012-02-03T22:19:54+0000",
            "content": "Counting multiple terms as 1 because they are in parenthesis together doesn't seem like a good idea to me.\n\nI disagree, but it definitely just seems like a matter of opinion \u2013 i don't know that we could ever come up with something that makes sense in all use cases\n\npersonally i think the sanest change would be to say that \"mm\" applies to all top level SHOULD clauses in the query (regardless of wether they have an explicit OR or not) \u2013 exactly as it always has in dismax.  if a top level clause is a nested boolean queries, then \"mm\" shouldn't apply to those because it doesn't make sense to blur the \"count\" of how many SHOULD clauses there are at the various levels.\n\nwould would mm=5 mean for a query like \"q=X AND Y (a b) (c d) (e f) (g h)\" if you looked at all the nested subqueries?  that only 5 of those 8 (lowercase) leaf level clauses are required?  how would that be implemented on the underlying BooleanQuery objects w/o completely flattening the query (which would break the intent of the user when they grouped them) ... it seems like mm=5 (or mm=100%) should mean 5 (or 100%) of the top level SHOULD clauses are required ... the default query op should determine how any top level clauses that are BooleanQueries are dealt with.\n\n...but that's just my opinion.  \n "
        },
        {
            "author": "Brian Carver",
            "id": "comment-13200476",
            "date": "2012-02-04T16:51:59+0000",
            "content": "I'm new to solr, so I have a tenuous grasp on some of these issues, but I've understood boolean logic for a couple of decades and it seems to me like solr's current behavior is thwarting the expectations of those who understand what they want and explicitly ask for it. Mike's example above is what troubles me.\n\nPrinciples:\n1. The maintainer sets whitespace to be interpreted as AND or OR and solr should do nothing to change that in particular instances.\n2. Where a user inputs an ambiguous query, a default rule about how operator scope will work is needed and that also should not be changed in particular instances.\n\nSo, Mike says he sets whitespace to AND, users know this, and then a user enters:\n\nExample 1: (A or B or C) \"D E\"\n\nGiven the above assumptions, the only reasonable interpretation of this is:\n\n(A or B or C) AND \"D E\" which is a conjunction with two conjuncts, both of which must be satisfied for a result to be produced, yet Mike/the user gets results that only satisfy one of the conjuncts. That shouldn't happen.\n\nI'd agree though that how to understand/apply mm in some of the examples above creates hard questions, but that is why many search engines provide two interfaces, one \"natural language\" interface and one that requires strict use of boolean syntax. Allowing people to enter some boolean operators (which they're going to expect will be respected-no-matter-what) and simultaneously interpreting their query using mm handlers intended for a more rough-and-ready approach is just going to lead to confused end users most of the time. So, in some ways, ignoring mm when operators are used is a feature, not a bug, but that seems orthogonal to the completely unacceptable outcome Mike described: whatever is causing THAT, is a bug. "
        },
        {
            "author": "Neil Hooey",
            "id": "comment-13256074",
            "date": "2012-04-17T23:51:10+0000",
            "content": "I agree with Hoss' view that mm should apply to all top-level SHOULD clauses in the query, especially since that's how it works in dismax.\n\nThe q.op and/or <defaultOperator> should definitely not get overridden when mm is at least not specified.\n\nIn our situation we currently have to add an AND operator to fix queries that have a NOT or - operator in them.\n\nDoes anyone have a patch to fix this behaviour? "
        },
        {
            "author": "Mike Lissner",
            "id": "comment-13263893",
            "date": "2012-04-27T19:07:52+0000",
            "content": "It seems like we have a general consensus here, but I want to confirm my understanding of a few queries:\n\nWith default operator set to AND, and with no mm param:\n[ a b (c OR d) ] gets interpreted as [ a AND b AND (c OR d) ]\n\n[ a -b (c OR d) ] gets interpreted as [ a NOT b AND (c OR d) ] \n\nSo basically, the trend here is that wherever the user leaves out an operator, AND is introduced, as Neil seems to be doing. This is really the only way I would expect defaultOperator to work, and I know my users think this way as well.\n\nIf that's the consensus, then it would be great to push this forward (not sure I can help with that though). "
        },
        {
            "author": "Vadim Kisselmann",
            "id": "comment-13264921",
            "date": "2012-04-30T13:15:25+0000",
            "content": "Same Problem here:\nhttp://www.mail-archive.com/solr-user@lucene.apache.org/msg65463.html\n\nIn my case, with mm=100% and defaultOperator=AND i get different results with:\nnascar AND author:serg* \nand\nnascar +author:serg* (with debugQuery i can see, that nascar is an SHOULD MATCH, but it should be an MUST MATCH with mm=100%) "
        },
        {
            "author": "Hoss Man",
            "id": "comment-13412228",
            "date": "2012-07-11T22:26:27+0000",
            "content": "bulk fixing the version info for 4.0-ALPHA and 4.0 all affected issues have \"hoss20120711-bulk-40-change\" in comment "
        },
        {
            "author": "Robert Muir",
            "id": "comment-13429828",
            "date": "2012-08-07T03:43:24+0000",
            "content": "rmuir20120906-bulk-40-change "
        },
        {
            "author": "Jack Krupansky",
            "id": "comment-13436088",
            "date": "2012-08-16T16:47:41+0000",
            "content": "I just ran a test with 4.0-BETA and it turns out that overriding the default operator (using the \"q.op\" parameter) is also ignored when any operator is present, for the exact same reason that \"mm\" is ignored - since edismax implements q.op using minMatch, which is disabled by the presence of an operator. As commented above, that aspect of the problem has been around for a year now. Wow.\n\nI'm leaning towards relaxing the \"mm\" rules so that minMatch will occur regardless of whether operators are present. But, I think the default for \"mm\" should be \"0%\", rather than based on \"q.op\" as is done today.\n\nI suspect that the restriction on use of minMatch may have been a side effect of having \"mm\" default based on \"q.op\". For example, if the user query is \"x y +z\", they are explicitly detailing which terms should be ANDed, so it wouldn't make sense in that case to apply q.op to x and y, but it still makes sense to apply minMatch to all optional terms. But if no operators are present, THEN you want q.op to apply to each term, and minMatch as well.\n\nIn short, q.op should only apply when no operators are present, but minMatch should apply when either q.op=OR or there are optional terms present.\n\nI still need to think about the interaction between edismax and the Lucene query parser, especially for nested queries, such as (a b c) AND (d e +f)&q.op=AND. Currently, the minMatch processing in edismax is limited to the top-level BooleanQuery, not any nested queries. "
        },
        {
            "author": "John Freier",
            "id": "comment-13448742",
            "date": "2012-09-05T13:57:05+0000",
            "content": "Hey folks. I ran across this issue after noticing thousands of odd seeming result sets with good ol' v3.4. I don't know all of the deeper implications, but I think Jack's summary and a couple others' comments would make the most sense and are already what seem to be described in the current documentation which states that the boolean operators in front of of various terms or phrases define them to be specifically included or excluded, while the others are classified as 'optional'. Then, in the documentation on minimum match, it states that it is based the percentages etc off of the \"optional\" terms, so I would expect the boolean-specified ones not to be considered and for the mm to just be based off of whatever optionals there are. \n\nI saw this was a recent discussion so thought I'd chip in but sorry if you've already come to this conclusion and/or implemented it. Is this how the 4.0 Alpha is patched now or could anyone point me to any sort of temporary solution to achieve this functionality? Thanks for your great work. - John "
        },
        {
            "author": "Robert Muir",
            "id": "comment-13456396",
            "date": "2012-09-15T12:49:26+0000",
            "content": "Unassigned issues -> 4.1 "
        },
        {
            "author": "Shawn Heisey",
            "id": "comment-13554489",
            "date": "2013-01-15T23:02:00+0000",
            "content": "Just ran into this (or something like it) on both my production 3.5 and dev 4.1 servers.\n\nWhat I see happening with edismax queries that contain operators is this: Both mm (100%) and q.op (AND) are ignored so that it acts as if q.op were OR.  Instead of 8k results, there are over 300k.  With a sort parameter, most of the results actually seen are invalid.  Here is an actual query from my log:\n\n(  (young man close up NOT woman NOT couple)) "
        },
        {
            "author": "Shawn Heisey",
            "id": "comment-13554524",
            "date": "2013-01-15T23:39:25+0000",
            "content": "The 3.5 schema also contains this: <solrQueryParser defaultOperator=\"AND\"/>\n\nThat has been removed from the 4.1 schema, q.op in solrconfig.xml is used instead. "
        },
        {
            "author": "Shawn Heisey",
            "id": "comment-13555085",
            "date": "2013-01-16T14:45:37+0000",
            "content": "Thank you! We have been waiting a long time for this fix.\n\nI'm a little confused here.  Were you talking to me?  I don't have a fix, I was just saying that I'm having the same problem, and that my problem is not exactly like the initial description.  The initial description says that when boolean operators are present, edismax behaves as if mm=100%.  I'm seeing the opposite.\n\nTo summarize: When boolean operators are present in the query, two versions of Solr are behaving as if I did not have mm=100%, q.op=AND, or defaultOperator=AND in the schema.  Both versions behave as if the default operator is OR.  For 3.5, I have tried all three of those options simultaneously.  For 4.1, I have tried just the first two, because defaultOperator is deprecated. "
        },
        {
            "author": "Jan H\u00f8ydahl",
            "id": "comment-13587741",
            "date": "2013-02-26T23:39:46+0000",
            "content": "So, are we ready to agree on wanted behavior and start coding?\n\nI'll try to formulate a suggestion:\n\nPresence of explicit operators in the query should not totally disregard mm/q.op.\nFor the pure 0%/q.op=OR case, mm will be 0 and work correctly - as today\nFor the pure 100%/q.op=AND case, mm will be set to # top-level SHOULD clauses and work as expected.\nFor the mm=1..n/mm=1%..99% case, mm will be calculated based on # top-level SHOULD clauses and work as expected. "
        },
        {
            "author": "Shawn Heisey",
            "id": "comment-13656449",
            "date": "2013-05-13T22:16:26+0000",
            "content": "Jan H\u00f8ydahl I like your suggestion.  I would want to be sure that if I specify mm (either in the request handler defaults or in my query params), it will ignore q.op and use the value specified.  As for coding, I think I'll be useless in this area, though I'm interested in taking a look if anyone can point me at specific class names. "
        },
        {
            "author": "Naomi Dushay",
            "id": "comment-13662455",
            "date": "2013-05-20T23:27:16+0000",
            "content": "Our dismax mm setting is 6<-1 6<90%.\n\nI would like our mm to be honored for the top-level SHOULD clauses.  Oh please, oh please?\n\nEDISMAX\n\nq=customer driven academic library:\n      +(((custom)~0.01 (driven)~0.01 (academ)~0.01 (librari)~0.01)~4)\t4 hits\n\ncustomer NOT driven academic library:\n      +((custom)~0.01 -(driven)~0.01 (academ)~0.01 (librari)~0.01)\t984300 hits  <= INSANE\n\ncustomer -driven academic library:\n      +((custom)~0.01 -(driven)~0.01 (academ)~0.01 (librari)~0.01)\t984300 hits  <= INSANE\n\ncustomer OR academic OR library NOT driven:\n      +((custom)~0.01 (academ)~0.01 (librari)~0.01 -(driven)~0.01)\t984300 hits\n\ncustomer academic library:\n      +(((custom)~0.01 (academ)~0.01 (librari)~0.01)~3)\t\t\t100 hits\n\n\nDISMAX  (plausible results!):\n\ncustomer driven academic library:\n      +(((custom)~0.01 (driven)~0.01 (academ)~0.01 (librari)~0.01)~4) ()\t4 hits\n\ncustomer NOT driven academic library:\n      +(((custom)~0.01 -(driven)~0.01 (academ)~0.01 (librari)~0.01)~3) ()\t96 hits\n\ncustomer -driven academic library:\n      +(((custom)~0.01 -(driven)~0.01 (academ)~0.01 (librari)~0.01)~3) ()\t96 hits\n\ncustomer academic library:\n      +(((custom)~0.01 (academ)~0.01 (librari)~0.01)~3)()\t\t\t100 hits\n "
        },
        {
            "author": "Steve Rowe",
            "id": "comment-13717373",
            "date": "2013-07-23T18:48:01+0000",
            "content": "Bulk move 4.4 issues to 4.5 and 5.0 "
        },
        {
            "author": "Anca Kopetz",
            "id": "comment-13822482",
            "date": "2013-11-14T14:35:30+0000",
            "content": "We need to apply Min should match for edismax query strings with operators (AND,OR) and mm parameter.\n\nFor example, when the below query was parsed, the mm was not applied\n\n&q=(((termA AND termB) OR specialTerm) (termC AND termD) (termE))&mm=2&defType=edismax&qf=title\n\n\n\nTherefore we developed our custom query parser.\nThe code is below, maybe it is useful for somebody who has the same requirements.\nCustomExtendedDismaxQParser.java\npublic class CustomExtendedDismaxQParser extends ExtendedDismaxQParser {\n   public CustomExtendedDismaxQParser(String qstr, SolrParams localParams, SolrParams params, SolrQueryRequest req) {\n      super(qstr, localParams, params, req);\n   }\n\n   @Override\n   protected Query parseOriginalQuery(ExtendedSolrQueryParser up, String mainUserQuery, List<Clause> clauses, ExtendedDismaxConfiguration config) {\n      Query query = super.parseOriginalQuery(up, mainUserQuery, clauses, config);\n      String mmValue = this.params.get(DisMaxParams.MM);\n      if(!Strings.isNullOrEmpty(mmValue)) {\n         if (query instanceof BooleanQuery) {\n            SolrPluginUtils.setMinShouldMatch((BooleanQuery)query, mmValue);\n         }\n      }\n      return query;\n   }\n}\n\n\n\nsolrconfig.xml\n<queryParser name=\"customEdismax\" class=\"com.kelkoo.search.solr.plugins.CustomExtendedDismaxQParserPlugin\"/>\n\n\n\nThen we set defType=customEdismax in the query parameters.\n\nWith these configuration, mm is applied on top-level clauses. In our example, there are 3 top-level SHOULD clauses : \n\n ((termA AND termB) OR specialTerm), (termC AND termD), (termE)\n\n\nAnd the parsed query is : \n\n+((\n    ((+(title:termA) +(title:termB)) (title:specialTerm)) \n    (+(title:termC) +(title:termD)) \n    (title:termE)\n  )~2) \n\n "
        },
        {
            "author": "Ron Davies",
            "id": "comment-13829709",
            "date": "2013-11-22T06:38:35+0000",
            "content": "\n\n "
        },
        {
            "author": "Andrew Buchanan",
            "id": "comment-13869267",
            "date": "2014-01-13T03:32:48+0000",
            "content": "I'm taking a look at fixing this one.\n\nI've tracked this all the way through the code history and back through the old solr repository. It looks like it was originally submitted this way by Yonik Seeley as SOLR-1553. Any previous history that might explain the reasoning would presumably be in Lucid Imaginations source control system (which I don't have access to). The DisMax parser on which it was based simply used the MM values as passed in, as has been previously noted.\n\nHoss Man refers to this behavior as a bug at https://issues.apache.org/jira/browse/SOLR-1553?focusedCommentId=12871244&page=com.atlassian.jira.plugin.system.issuetabpanels:comment-tabpanel#comment-12871244 on the original SOLR-1553.\n\nIf you force doMinMatched = true to disable this logic in ExtendedDismaxQParser, everything seems to work as expected above with the exception of one test case that fails (TestExtendedDismaxParser.testCJKStructured). This test case was added as part of r1406437 by Robert Muir for SOLR-3589 - Edismax parser does not honor mm parameter if analyzer splits a token.\n\nThe last query in that test case is \"\u5927\u4e9a\u6e7e OR bogus\" with mm=100% which the test is expecting to evaluate to \"((((standardtok:\u5927 standardtok:\u4e9a standardtok:\u6e7e)~3)) (standardtok:bogus))\". The comment for the test from Robert Muir indicates that it should \"always apply minShouldMatch to the inner booleanqueries created from whitespace, as these are never structured lucene queries but only come from unstructured text\". Looking at that query though, it seems to me that it should instead evaluate to \"(((((standardtok:\u5927 standardtok:\u4e9a standardtok:\u6e7e)~3)) (standardtok:bogus))~2)\", essentially applying the MM to the top level clauses. I'm certainly not a CJK language expert though, so there may be a subtlety here I'm unaware of.\n\nI can put together a patch with some test cases to make this behave as folks here seem to expect, but I would like to get some clarification from Robert if possible on whether he agrees that the existing test case should change... "
        },
        {
            "author": "Andrew Buchanan",
            "id": "comment-13869271",
            "date": "2014-01-13T03:46:50+0000",
            "content": "Just to clarify further with regards to TestExtendedDismaxParser.testCJKStructured, the following is how the queries would change.\n\n1. \"\u5927\u4e9a\u6e7e OR bogus\" MM=0%\n   From: +(((standardtok:\u5927 standardtok:\u4e9a standardtok:\u6e7e)) (standardtok:bogus))\n   To:     +(((standardtok:\u5927 standardtok:\u4e9a standardtok:\u6e7e)) (standardtok:bogus))\nUnchanged\n\n2. \"\u5927\u4e9a\u6e7e OR bogus\" MM=67%\n   From: +((((standardtok:\u5927 standardtok:\u4e9a standardtok:\u6e7e)~2)) (standardtok:bogus))\n   To:     +(((((standardtok:\u5927 standardtok:\u4e9a standardtok:\u6e7e)~2)) (standardtok:bogus))~1)\nRequires one top level clause to match (effectively the same)\n\n3. \"\u5927\u4e9a\u6e7e OR bogus\" MM=100%\n   From: +((((standardtok:\u5927 standardtok:\u4e9a standardtok:\u6e7e)~3)) (standardtok:bogus))\n   To:     +(((((standardtok:\u5927 standardtok:\u4e9a standardtok:\u6e7e)~3)) (standardtok:bogus))~2)\nRequires both top level clauses to match\n\nThis is effectively applying the MM to BOTH the inner clause AND the outer clause separately, which may or may not be what is desired... "
        },
        {
            "author": "Naomi Dushay",
            "id": "comment-13869323",
            "date": "2014-01-13T06:56:51+0000",
            "content": "I believe the changes Andrew is suggesting sound good.  I recently make careful improvements to our CJK Resource discovery (I'm in the midst of blogging about it), and in combing through our logs of the last few days, I pulled out a few actual use cases where we have CJK characters and \"OR\":\n\n\u9234\u6728\u91cd\u96c4 OR \u65e5\u672c\u7cbe\u795e\u751f\u6210\u53f2\u8ad6\n\u6bdb\u6fa4\u6771 OR \u57fa\u790e\u6230\n\u65e5\u5831 OR \u6fdf\u5357\n\u98c4 OR \u4e0a\u6d77\n\nthere are others.  Note that we have no actual cases of CJK + non-CJK characters and 'OR'.\n\nIn my relevancy tests for CJK (supplied by East Asian language librarians), I didn't find many useful examples to exercise the case above.   I could try to apply a patch locally and check how it affects our ~1000 relevancy tests, but we are currently running Solr 4.4.  It would be much more tractable if there is a Solr 4.x  patch available for testing.\n\nHere is the only realistic examples I could find from our test code:\n\u30b9\u30dd\u30fc\u30c4 OR supotsu\n  both clauses translate to \"sports\" (from Japanese)\n\nSo from my perspective, the cjk test is a corner case, and I think Andrew's approach sounds great.  Tom Burton-West and I are partly behind Robert Muir's fix, so getting Tom BW to weigh in would be great. "
        },
        {
            "author": "Andrew Buchanan",
            "id": "comment-13872918",
            "date": "2014-01-16T01:30:21+0000",
            "content": "Here is the initial patch. Really it just involves removing some code and adding a few tests to confirm things work. It also modifies the previously mentioned test to conform with the expectations above. "
        },
        {
            "author": "Andrew Buchanan",
            "id": "comment-13942091",
            "date": "2014-03-20T18:24:54+0000",
            "content": "Ping for Jan H\u00f8ydahl to review "
        },
        {
            "author": "Jan H\u00f8ydahl",
            "id": "comment-13943781",
            "date": "2014-03-22T00:24:07+0000",
            "content": "Attaching new patch with CHANGES entry and a few more tests.\n\nThe query (A OR B) C with mm=100% works as (A OR B) AND C since there are only 2 top-level clauses here, but the query A OR B C mm=100% is still interpreted as all three clauses being required. \n\nWe could try detect such cases and combine clauses joined by explicit operators but that's probably a slippery slope given the messy string parsing in edismax... "
        },
        {
            "author": "Jan H\u00f8ydahl",
            "id": "comment-13944819",
            "date": "2014-03-24T08:55:20+0000",
            "content": "Any comments on the current patch? All tests pass. If there are certain boolean queries that you fear this patch will make worse than it is today then please add a unit test for it. "
        },
        {
            "author": "Andrew Buchanan",
            "id": "comment-13945159",
            "date": "2014-03-24T14:28:58+0000",
            "content": "Looks good to me "
        },
        {
            "author": "Brian Carver",
            "id": "comment-13945719",
            "date": "2014-03-24T21:24:05+0000",
            "content": "I've been following this for at least two years. See my comment from February 2012, above. I can't tell if the proposed fix is a fix. We ought to have the goal: the system behaves in a deterministic way that can be explained to users and that, as little as possible, acts in ways contrary to user expectations (especially silently). The failure to abide by this principle is what made this issue so troubling to me, because users could know that whitespace would be interpreted as \"AND\" yet they would still get results that discarded the effect that operator should have had.\n\nNow, of course, users make mistakes. They submit ambiguous queries (or in the case of mm=100% for a disjunctive query, I guess we could call that a self-defeating or self-contradictory query--if I understand mm correctly).\n\nI still think that what is really needed is (1) a set of default rules for interpreting ambiguous queries that will always provide a deterministic result. These rules could be explained to users, and then what is also needed is that (2) when a user does something that doesn't make sense, given these default rules, they should get an error message.\n\nThe ambiguous query discussed above was one where whitespace was set to \"AND\" and a user entered:\n(A or B or C) \"D E\"\n\nSuch a user must be assuming that whitespace within quotation marks is ignored, i.e., that the quotation marks make \"D E\" a single term that must be matched exactly and that, given the default to conjunction for non-quoted whitespace, that her query will be parsed as:\n(A or B or C) AND \"D E\"\n\nthat is, as a conjunction with two conjuncts, thus requiring that each conjunct be satisfied to get a matching result.\n\nMy first question then is, what will happen to this query under the new patch? Will it be interpreted as expected?\n\nMy second question is, why not adopt a set of default rules for ambiguous queries? Like the default order of operations in arithmetic, we simply need a convention to interpret 3 + 5 x 4 as 3 + (5 x 4). Just as it didn't matter in arithmetic which operators we favored, so long as everyone knows the convention, it also doesn't really matter what rules we adopt here, so long as we publicize them so users and maintainers know what to expect. I would propose the following:\n\n1. Whitespace within quotation marks is ignored (in that it is not turned into an operator), that is \"D E\" is interpreted as a single term that must match exactly.\n2. If a query lacks sufficient parentheses to create an unambiguous query, then the following rules will be applied:\na. Insert parentheses around every occurrence of AND and its two conjuncts, starting with the rightmost AND.\nb. Insert parentheses in the same fashion for OR.\nc. Right parentheses are never inserted within another set of parentheses, i.e., no existing pairings are broken up.\n3. If one's query is nonsensical, an error message will be displayed explaining the problem. For example, if one has set mm to 100%, requiring every term to match, but yet one also issues a disjunctive query (A OR B) that would be satisfied if either term were to match, then one receives an error indicating that mm cannot be set to 100% while issuing a disjunctive query.\n\nI think those rules would be sufficient to resolve all ambiguous queries and the general idea that \"If you leave out parentheses, then they'll be added to the smallest available units starting from the right, and starting with conjunction\" is one that users could (somewhat) easily grasp.\n\nBut, as I said in 2012, my grasp on how solr handles mm is tenuous at best, so perhaps someone will explain that I'm misunderstanding something important. "
        },
        {
            "author": "Uwe Schindler",
            "id": "comment-13971367",
            "date": "2014-04-16T12:57:53+0000",
            "content": "Move issue to Solr 4.9. "
        },
        {
            "author": "Greg Pendlebury",
            "id": "comment-13986408",
            "date": "2014-05-01T06:52:10+0000",
            "content": "I applied this patch to 4.7.2 Yesterday and tried it out on our dev servers. At first I thought it was pretty bad and failed completely... but then I had a good think and re-read everything on this ticket and this[1] article and realised my understanding of the problem was flawed. Using just this patch in isolation it converted all of the OR operators to AND operators with mm=100%. Very confusing behaviour for our business area, but I realise now that it is correct.\n\nPerhaps the confusion stems from the way the q.op and mm parameters interact. If the behaviour was to instead separate them more clearly then we could change the config entirely. At the moment our mm is 100% because we effectively want q.op=AND, but if q.op was instead applied 1) always, 2) first and 3) independently from mm (ie. insert AND wherever an operator is missing) we could set mm=1 and achieve what we want by respecting the OR parameters provided by the user.\n\nI've added this on top of the patch already here and deployed again to our dev servers using 'q.op=AND & mm=1' and now everything appears to function as it should. I'll upload the patch in a minute, and it includes several unit tests with different mm and q.op values. From my perspective I think the two parameters are interacting appropriately, but perhaps someone with more convoluted mm settings could give it a try?\n\nThe change is simply in the constructor of the ExtendedSolrQueryParser class where it was hardcoded to force the default operator to OR (presumably so that mm would take care of things) I've made it look at the parameter provided with the query (copied the code from the Simple QParser and adjusted to fit).\n\nThe unit test from the first patch that was marked TODO I have tweaked slightly. I think not finding a result in that case is entirely appropriate if the user can now tweak q.op. Opinions may vary of course.\n\n[1] http://searchhub.org/2011/12/28/why-not-and-or-and-not/ "
        },
        {
            "author": "Shawn Heisey",
            "id": "comment-14055567",
            "date": "2014-07-08T21:30:38+0000",
            "content": "We got bitten by this bug today.  Consider this filter query, constructed from multiple entry boxes on an advanced search form:\n\n\n{!edismax}publish:(0) AND caption:(john lennon)\n\n\n\nThe mm value is 100%, but we get results as if mm were 0.\n\nWhat we're going to do for a solution is create multiple fq parameters instead of combining with AND. "
        },
        {
            "author": "Matthew Dickinson",
            "id": "comment-14088931",
            "date": "2014-08-07T07:16:28+0000",
            "content": "We have set mm=100% and q.op=AND\ndeftype=edismax\n\nWhen we run the following queries we get different results:\n\n1. banking (obama lloyds)       behaves as banking AND (obama OR lloyds)\n2. banking obama lloyds         behaves as banking AND obama AND lloyds\n\nMy expectations are that #1 should behave same as  #2.  "
        },
        {
            "author": "Andrew Buchanan",
            "id": "comment-14089288",
            "date": "2014-08-07T14:48:37+0000",
            "content": "Matthew,\nJust looking to clarify...\n\nDo you mean that is the behavior you see with the proposed patch, or without?\n\nThanks! "
        },
        {
            "author": "Erick Erickson",
            "id": "comment-14320316",
            "date": "2015-02-13T15:49:10+0000",
            "content": "Greg Pendlebury (and others). Thanks for pinging...\n\nWow, this has been hanging around for a long time. It looks just fell off people's radar.\n\nChris Hostetter (Unused) Jan H\u00f8ydahl  Shawn Heisey et.al. I can shepherd this patch through, but don't really have the background here to weigh in on the merits of the fix. I'll volunteer to run the mechanics though, and do a code review to see what I can see but I'm looking for whether the proposals are a go/no-go from a correctness perspective. This looks like it'll change current behavior which makes me nervous. Of course if it changes incorrect behavior it's a no-brainer.\n\nProblem is that this has languished and the patch will not apply to trunk. Could someone update the patch? A couple of things:\n\n1> Just upload repeated copies of SOLR-2649.patch without changing the name. That way it's much easier to keep track of what the latest one is. I tried applying the most recent one and it failed, but guessed the most recent one was the correct one.\n\n2> Please create the patch against the current trunk. Part of the check in process is to merge it back into 5x so no separate patch is (usually) needed.\n "
        },
        {
            "author": "Greg Pendlebury",
            "id": "comment-14322219",
            "date": "2015-02-15T22:49:51+0000",
            "content": "Thanks Erick,\n\nI can recreate the SOLR-2649-with-Qop.patch this week (today looks pretty busy sorry). Just updating trunk now. Jan's SOLR-2649 patch is technically correct from everything I have looked at, but it actually makes the eDismax parser very confusing for novice end users. Our investigation seemed to indicate that the problems stem from the steps taken by Lucene/Solr to convert boolean OR operators to the SHOULD occur flags (but running off memory here). This is made very obvious by the fact that eDismax is hard coded to use OR as the default operator. We were simply tea leaf gazing, but our assumption is that this confusion may have been the original cause for disabling 'mm' when operators were present.\n\nSo the patch we submitted simply does the same as Jan's, but also makes eDismax read the default operator from the 'q.op' parameter. With access to both parameters we have always been able to respond meaningfully to the queries our users are submitting. "
        },
        {
            "author": "Greg Pendlebury",
            "id": "comment-14325322",
            "date": "2015-02-18T02:17:00+0000",
            "content": "Replacement patch for 'SOLR-2649-with-Qop.patch' against current trunk. "
        },
        {
            "author": "Rebecca Tang",
            "id": "comment-14333987",
            "date": "2015-02-23T22:21:55+0000",
            "content": "When will this patch be released? Is there a targeted 5X release?\n\nWill this patch be back ported into 4x releases?  We are currently running solr 4.10.1.  Do we need to upgrade to solr 5 in order to get the bug fix? "
        },
        {
            "author": "Erick Erickson",
            "id": "comment-14334058",
            "date": "2015-02-23T23:13:32+0000",
            "content": "I hope to get this in for 5.1, but it's always a time question. If any other committer wants to to take it over it won't hurt my feelings . "
        },
        {
            "author": "Rebecca Tang",
            "id": "comment-14494512",
            "date": "2015-04-14T18:10:06+0000",
            "content": "Just saw the announcement that solr 5.1.0 is released.  Looks like this bug didn't make it in.  Is it likely for it to be included in the next release? "
        },
        {
            "author": "Miko\u0142aj Kania",
            "id": "comment-14642501",
            "date": "2015-07-27T09:39:33+0000",
            "content": "We have lately encountered a problem with the current edismax behaviour, when \n\n((x y z) AND (a))\n\n gave the same results as \n\n((x or y or z) and (a))\n\n instead of \n\n(a and b and c and d)\n\n. Our mm was set to 100% so it was really unexpected! What's more, \n\n x y z\n\n is the same as \n\nx AND y AND z\n\n and as \n\nx AND y z\n\n, so the behaviour is experience-driven, nondeterministic. It would be nice to see patches applied as the issue is now the most upvoted, open task. "
        },
        {
            "author": "Bill Bell",
            "id": "comment-14651144",
            "date": "2015-08-02T19:16:47+0000",
            "content": "This is pretty critical to edismax. If the fix is good, let's get it checked in. ? "
        },
        {
            "author": "Andre Hagenbruch",
            "id": "comment-15031752",
            "date": "2015-11-30T13:15:02+0000",
            "content": "Is there any chance that we can get this into 5.4? Please... "
        },
        {
            "author": "James Bown",
            "id": "comment-15037912",
            "date": "2015-12-03T15:16:12+0000",
            "content": "A high criticality bug for me too... "
        },
        {
            "author": "Romain MERESSE",
            "id": "comment-15037948",
            "date": "2015-12-03T15:39:32+0000",
            "content": "Very high criticality for me too. Why is it a minor priority ? "
        },
        {
            "author": "Erick Erickson",
            "id": "comment-15038355",
            "date": "2015-12-03T19:07:49+0000",
            "content": "Yonik Seeley Jan H\u00f8ydahl Hoss Man [~rmuir] David Smiley christian Migowski\n\nPicking random names that have committed stuff to this file if any of you care to comment: \n\nI'm running precommit and tests on this at present, but it makes me nervous that the comment around line ExtendedDismaxQParser[347] in current trunk\n\n    // For correct lucene queries, turn off mm processing if there\n    // were explicit operators (except for AND).\n\nhas been in ExtendedDismaxQParser since it was first committed, and this is the bit that's being re-worked.\n\nI'm not sure about committing this at all, I'm just gathering information about the current state of the patch at this point. That said, this seems reasonable. But I confess the intricacies of all this stuff are not something I understand very well...\n "
        },
        {
            "author": "Yonik Seeley",
            "id": "comment-15038512",
            "date": "2015-12-03T20:06:40+0000",
            "content": "Changed from \"Bug\" to \"Improvement\" as the code seems to reflect the original intent.\nThat original intent/behavior can certainly be changed & improved of course, but do we have a consensus on what the new behavior should be?  That should also include how to deal with back compat issues as well. "
        },
        {
            "author": "Thomas Egense",
            "id": "comment-15038544",
            "date": "2015-12-03T20:28:54+0000",
            "content": "It is a clear \"Bug\" in the following case: MM=100% and default operator = \"AND\"\nYou search for (A B AND C)  and it is parsed as (A OR B) AND C <- not correct\n while the (A B C) will be parsed as (A AND B AND C) <- correct\nThe presence of any AND/OR present in the query will trigger this bug that that defaults to the OR operator even though AND was defined as the default operator in SolrConfig. It should \nThere is no bug if default operator=\"OR\".\n\n\n "
        },
        {
            "author": "Jack Krupansky",
            "id": "comment-15038585",
            "date": "2015-12-03T21:04:39+0000",
            "content": "The behavior of mm only applying to the top-level query is not documented at present.\n\nEven if having mm apply only to the top-level query is intended, it seems a separate matter as to how the q.op parameter applies. I've never seen any doc or discussion that suggested that the default operator should only apply to the top-level query. I haven't looked at the code lately, but it used to be that q.op was just used to set the internal mm value and then completely ignored in the sense that it was not passed down to the Lucene query parser to use as the Lucene default operator. IOW, the Lucene setDefaultOperator method was never called.\n\nSee:\nhttps://lucene.apache.org/core/5_3_0/queryparser/org/apache/lucene/queryparser/classic/QueryParserBase.html#setDefaultOperator(org.apache.lucene.queryparser.classic.QueryParser.Operator) "
        },
        {
            "author": "Ahmet Arslan",
            "id": "comment-15038596",
            "date": "2015-12-03T21:11:37+0000",
            "content": "do we have a consensus on what the new behavior should be? \nI think Jan's proposal \n\nPersonally, I understand that edismax is initially designed for power users who supposed to know what they are looking for. However, this assumption looks too strong given that wide range of users started to use edismax. "
        },
        {
            "author": "Greg Pendlebury",
            "id": "comment-15038626",
            "date": "2015-12-03T21:30:21+0000",
            "content": "I tried Jan's patch, and (whilst it is technically correct) it did not improve the usefulness of edismax without also addressing how q.op is handled. We continued to see absurd search results that failed UAT.\n\nThe combined patch with both has been on our prod servers since May 2014 without any problems, but I have not heard any feedback from others that might have tried it. The corpus is nearly 200 million fulltext newspaper articles: http://trove.nla.gov.au/newspaper/result?q= "
        },
        {
            "author": "Erick Erickson",
            "id": "comment-15038658",
            "date": "2015-12-03T21:47:21+0000",
            "content": "Greg Pendlebury Just to make sure we're talking about the same thing, when you say \"Jan's patch\", it's the one from 17/Feb/15 21:17, right? "
        },
        {
            "author": "Erick Erickson",
            "id": "comment-15038679",
            "date": "2015-12-03T22:00:26+0000",
            "content": "OK, all tests pass with with this patch. There is one (and only one) pre-existing test that had to be changed about line 1000 in TestExtendedDismaxParser.java, this test used to find 1 doc, now finds 0:\n\n    assertQ(\"test cjk (conjunction)\",\n        req(\"q\", \"\u5927\u4e9a\u6e7e OR bogus\",\n            \"qf\", \"standardtok\",\n            \"mm\", \"100%\",\n            \"defType\", \"edismax\")\n        , \"//*[@numFound='0']\");\n\nThe document it used to find is here: assertU(adoc(\"id\", \"57\", \"standardtok\", \"\u5927\u4e9a\u6e7e\")); \n\nSo this change seems reasonable given the patch. "
        },
        {
            "author": "Greg Pendlebury",
            "id": "comment-15038688",
            "date": "2015-12-03T22:04:51+0000",
            "content": "Mine shows as 18th Feb, but I assume that is just timezones. Assuming we are talking about the same patch, then, no, that is my patch (both of the 'with-Qop' patches are from me). Jan, submitted the earlier 2014 patch which I used as a baseline to add the q.op change as well. "
        },
        {
            "author": "Jan H\u00f8ydahl",
            "id": "comment-15038700",
            "date": "2015-12-03T22:12:37+0000",
            "content": "I'm positive to the latest combined approach, although I have not tested it.\n\nRegarding back-compat, I view current behavior as a bug, so most people would applaud the change.\nHowever, I'm not opposed to a new config option for keeping old behavior, and let new behavior be default based on LuceneMatchVersion. "
        },
        {
            "author": "Mike Lissner",
            "id": "comment-15038738",
            "date": "2015-12-03T22:32:53+0000",
            "content": "I know this is a spammy comment, but I can't help but say how excited I am this is finally getting fixed. It's been a thorn in my side for YEARS. Thanks to everybody that's pushing this forward today. Y'all are fantastic. "
        },
        {
            "author": "Yonik Seeley",
            "id": "comment-15038767",
            "date": "2015-12-03T22:53:44+0000",
            "content": "I view current behavior as a bug\n\nA bug in the idea?  That's not traditionally what we refer to as a bug unless it was unintended.\nThis would not qualify to go in a bugfix-only release, etc.  I'm guessing you're using the term loosely, as in \"I wouldn't have made the same design decisions\".  That's fine, and can be changed.  But I don't think we should be redefining terminology toward that end and calling things we don't agree with \"bugs\". "
        },
        {
            "author": "Jan H\u00f8ydahl",
            "id": "comment-15038840",
            "date": "2015-12-03T23:35:01+0000",
            "content": "A bug in the idea\nWell, perhaps not a bug from developer intent point of view. But users still get puzzled from this behavior time after time, even after having read the end user documentation. So let's call it an \"improvement\" and let the old behavior be available for those who might prefer it.\n\nAlso, I just recalled SOLR-4646 and SOLR-3580 which are related: The problem gets worse by the fact that lowercaseOperators defaults to true, which is a catastrophic bad default for all non-english languages. "
        },
        {
            "author": "Brian Carver",
            "id": "comment-15039704",
            "date": "2015-12-04T03:43:02+0000",
            "content": "This all began, years ago, with this query (assume whitespace=AND and mm=100%):\n\n(A or B or C) \"D E\"\n\nWill the currently proposed patch interpret such a query as:\n\n(A or B or C) AND \"D E\"\n\nor in some other way?  "
        },
        {
            "author": "Greg Pendlebury",
            "id": "comment-15039730",
            "date": "2015-12-04T04:25:14+0000",
            "content": "I just ran it against out test system (patched Solr 5.1.0): (A OR B OR C) \"D E\"\n\n1) Using mm=100%, q.op=AND and searching just the fulltext field. RAW debug:\n\n(+(+(DisjunctionMaxQuery((fulltext:a)) DisjunctionMaxQuery((fulltext:b)) DisjunctionMaxQuery((fulltext:c))) +DisjunctionMaxQuery((fulltext:\\\"d e\\\"))))\n\n\nI read that as:\n\n+(a b c) +(\"d e\")\n\n\nwhich looks correct\n\n2) switching to q.op=OR. RAW debug:\n\n(+(((DisjunctionMaxQuery((fulltext:a)) DisjunctionMaxQuery((fulltext:b)) DisjunctionMaxQuery((fulltext:c))) DisjunctionMaxQuery((fulltext:\\\"d e\\\")))~2))\n\n\nI read that as:\n\n((a b c) \"d e\")~2\n\n\nWhich again looks correct... but we don't generally use OR, so I could be wrong\n\n3) Finally, lowered mm to 50%, again with q.op=OR. RAW debug:\n\n(+(((DisjunctionMaxQuery((fulltext:a)) DisjunctionMaxQuery((fulltext:b)) DisjunctionMaxQuery((fulltext:c))) DisjunctionMaxQuery((fulltext:\\\"d e\\\")))~1))\n\n\nI read that as:\n\n((a b c) \"d e\")~1\n\n\nStill looks good. "
        },
        {
            "author": "Erick Erickson",
            "id": "comment-15039772",
            "date": "2015-12-04T05:29:25+0000",
            "content": "Greg Pendlebury OK, we're using the same patch which was what  I wanted to be sure of. Sorry for the mis-attribution.\n\nRegardless of what we call it, my questions are:\n\n1> Are we going to include this change in 5.4.x? I have no intention of doing so, that ship has already sailed.\n\n2> Does this change behavior that we've supported in the past? \n\n2a> If \"yes\", then we need to concern ourselves with back-compat and it's arguable whether this should be put in 5.x. It seems that it's better behavior than it was before, so perhaps documentation will be sufficient.\n\n2b> If \"no\", then we're free to put this in both trunk and 5x (5.5 if one comes out) if we think the behavior is better with this patch. Still add a note to CHANGES.txt, along with the issue...\n\nI'm tending at this point to put it in the 5x code line and make a point of this change in CHANGES.txt as I think it's a change that'll be seen as positive. I'm not wedded to the idea though. "
        },
        {
            "author": "Erick Erickson",
            "id": "comment-15055185",
            "date": "2015-12-13T22:08:06+0000",
            "content": "Same as SOLR-2649-with-Qop patch but CHANGES attributions.\n\nI'm going to run precommit/test on this file and commit later today unless there are objections. I looked through the added tests and they seem to cover these bases well so... "
        },
        {
            "author": "Greg Pendlebury",
            "id": "comment-15055202",
            "date": "2015-12-13T22:48:11+0000",
            "content": "Erick Erickson thanks for this! "
        },
        {
            "author": "ASF subversion and git services",
            "id": "comment-15057181",
            "date": "2015-12-15T02:08:52+0000",
            "content": "Commit 1720062 from Erick Erickson in branch 'dev/trunk'\n[ https://svn.apache.org/r1720062 ]\n\nSOLR-2649: MM ignored in edismax queries with operators "
        },
        {
            "author": "ASF subversion and git services",
            "id": "comment-15057343",
            "date": "2015-12-15T04:50:26+0000",
            "content": "Commit 1720072 from Erick Erickson in branch 'dev/branches/branch_5x'\n[ https://svn.apache.org/r1720072 ]\n\nSOLR-2649: MM ignored in edismax queries with operators "
        },
        {
            "author": "Erick Erickson",
            "id": "comment-15057345",
            "date": "2015-12-15T04:51:25+0000",
            "content": "Thanks to all who contributed here! "
        },
        {
            "author": "Mary Jo Sminkey",
            "id": "comment-15138199",
            "date": "2016-02-09T01:34:31+0000",
            "content": "This bug appears to be incorrectly referenced in the 5.5 release notes: https://builds.apache.org/job/Solr-Artifacts-5.x/lastSuccessfulBuild/artifact/solr/package/changes/Changes.html#v5.5.0.bug_fixes\n(SOLR-2469 instead of SOLR-2649) "
        },
        {
            "author": "Erick Erickson",
            "id": "comment-15138204",
            "date": "2016-02-09T01:37:47+0000",
            "content": "Oh, rats. I transposed the numbers.\n\nThanks for pointing that out!\n\nErick "
        },
        {
            "author": "ASF subversion and git services",
            "id": "comment-15138298",
            "date": "2016-02-09T03:50:35+0000",
            "content": "Commit 1f66406cb3b281bec3739b55aa4294e2d066151f in lucene-solr's branch refs/heads/master from Erick Erickson\n[ https://git-wip-us.apache.org/repos/asf?p=lucene-solr.git;h=1f66406 ]\n\nCorrected CHANGES.txt entry for SOLR-2649 "
        },
        {
            "author": "ASF subversion and git services",
            "id": "comment-15138303",
            "date": "2016-02-09T03:53:40+0000",
            "content": "Commit 21e019fab07ac8ed4fa4724c002401f84940db3f in lucene-solr's branch refs/heads/branch_5x from Erick Erickson\n[ https://git-wip-us.apache.org/repos/asf?p=lucene-solr.git;h=21e019f ]\n\nCorrected CHANGES.txt entry for SOLR-2649\n(cherry picked from commit 1f66406) "
        },
        {
            "author": "Rebecca Tang",
            "id": "comment-15292371",
            "date": "2016-05-19T23:51:23+0000",
            "content": "I upgraded to solr-5.5.1. But when I set \"mm\" to 100% for edismax, the OR operator is ignored and query is always executed as AND.\n\nThe following three queries all return the same results (I expect the first two to return the same results, but the third one should not):\neggplant tobacco\neggplant AND tobacco\neggplant OR tobacco\n\nDid anyone run into this issue after adopting this bug fix? "
        },
        {
            "author": "Greg Pendlebury",
            "id": "comment-15292397",
            "date": "2016-05-20T00:03:18+0000",
            "content": "Rebecca Tang, that sounds like expected behaviour. Your 'OR' operator is not being ignored; but rather, Solr translates OR operators into SHOULD occur flags (ie. optional search terms)... then, if 'mm' is set to 100%, this tells Solr that you require every optional search term to be present in the result set.\n\nIf you are explicitly setting 'mm' you should use a different value if you want OR operators to function. Also see SOLR-8812, which discusses setting a better default value for 'mm', particularly one that changes depending on the 'q.op' parameter. Of course that only applies in the case where you are not explicitly setting 'mm'. "
        },
        {
            "author": "Shawn Heisey",
            "id": "comment-15295115",
            "date": "2016-05-21T16:21:21+0000",
            "content": "Is setting mm to 100% the only thing you changed to force \"AND\" by default?  I ask because SOLR-8812 sounds like the issue you are running into, but according to the issue title, it happens when setting q.op=AND.  SOLR-8812 is not clear about whether mm=100% can cause the same problem. "
        },
        {
            "author": "ASF subversion and git services",
            "id": "comment-15323986",
            "date": "2016-06-10T07:01:53+0000",
            "content": "Commit 5bc34949adc911dacba29c08f1e522de4679aee6 in lucene-solr's branch refs/heads/branch_5_5 from Steve Rowe\n[ https://git-wip-us.apache.org/repos/asf?p=lucene-solr.git;h=5bc3494 ]\n\nSOLR-8812: edismax: turn off mm processing if no explicit mm spec is provided and there are explicit operators (except for AND) - addresses problems caused by SOLR-2649 "
        },
        {
            "author": "ASF subversion and git services",
            "id": "comment-15323989",
            "date": "2016-06-10T07:01:58+0000",
            "content": "Commit e88a64a0490ac2139e0aa55a8ca8b3588ce41395 in lucene-solr's branch refs/heads/branch_5x from Steve Rowe\n[ https://git-wip-us.apache.org/repos/asf?p=lucene-solr.git;h=e88a64a ]\n\nSOLR-8812: edismax: turn off mm processing if no explicit mm spec is provided and there are explicit operators (except for AND) - addresses problems caused by SOLR-2649 "
        },
        {
            "author": "ASF subversion and git services",
            "id": "comment-15323992",
            "date": "2016-06-10T07:02:02+0000",
            "content": "Commit 202b993335a370be06db02b866c62a876350b01d in lucene-solr's branch refs/heads/branch_6_0 from Steve Rowe\n[ https://git-wip-us.apache.org/repos/asf?p=lucene-solr.git;h=202b993 ]\n\nSOLR-8812: edismax: turn off mm processing if no explicit mm spec is provided and there are explicit operators (except for AND) - addresses problems caused by SOLR-2649 "
        },
        {
            "author": "ASF subversion and git services",
            "id": "comment-15323995",
            "date": "2016-06-10T07:02:07+0000",
            "content": "Commit c2aac7d005424094e129045e834aa6ffb2c7aa82 in lucene-solr's branch refs/heads/branch_6_1 from Steve Rowe\n[ https://git-wip-us.apache.org/repos/asf?p=lucene-solr.git;h=c2aac7d ]\n\nSOLR-8812: edismax: turn off mm processing if no explicit mm spec is provided and there are explicit operators (except for AND) - addresses problems caused by SOLR-2649 "
        },
        {
            "author": "ASF subversion and git services",
            "id": "comment-15323997",
            "date": "2016-06-10T07:02:09+0000",
            "content": "Commit e0c6762de8dd91e02a79a6d12b3164a052bf07ff in lucene-solr's branch refs/heads/branch_6_1 from Steve Rowe\n[ https://git-wip-us.apache.org/repos/asf?p=lucene-solr.git;h=e0c6762 ]\n\nSOLR-8812: edismax: turn off mm processing if no explicit mm spec is provided and there are explicit operators (except for AND) - addresses problems caused by SOLR-2649 "
        },
        {
            "author": "ASF subversion and git services",
            "id": "comment-15323999",
            "date": "2016-06-10T07:02:12+0000",
            "content": "Commit 3c789e9d274fb670c53c8eb6eb9dfceace2cd120 in lucene-solr's branch refs/heads/branch_6x from Steve Rowe\n[ https://git-wip-us.apache.org/repos/asf?p=lucene-solr.git;h=3c789e9 ]\n\nSOLR-8812: edismax: turn off mm processing if no explicit mm spec is provided and there are explicit operators (except for AND) - addresses problems caused by SOLR-2649 "
        },
        {
            "author": "ASF subversion and git services",
            "id": "comment-15324001",
            "date": "2016-06-10T07:02:15+0000",
            "content": "Commit 74d94ec26585d57d6991f99c892f7be1278346f9 in lucene-solr's branch refs/heads/branch_6x from Steve Rowe\n[ https://git-wip-us.apache.org/repos/asf?p=lucene-solr.git;h=74d94ec ]\n\nSOLR-8812: edismax: turn off mm processing if no explicit mm spec is provided and there are explicit operators (except for AND) - addresses problems caused by SOLR-2649 "
        },
        {
            "author": "ASF subversion and git services",
            "id": "comment-15324003",
            "date": "2016-06-10T07:02:18+0000",
            "content": "Commit 38714399760889d2d7b188a87341aade6139ffef in lucene-solr's branch refs/heads/master from Steve Rowe\n[ https://git-wip-us.apache.org/repos/asf?p=lucene-solr.git;h=3871439 ]\n\nSOLR-8812: edismax: turn off mm processing if no explicit mm spec is provided and there are explicit operators (except for AND) - addresses problems caused by SOLR-2649 "
        }
    ]
}