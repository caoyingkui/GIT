{
    "id": "SOLR-11018",
    "title": "Wrong status code in case of invalid requests",
    "details": {
        "labels": "",
        "priority": "Minor",
        "components": [],
        "type": "Bug",
        "fix_versions": [],
        "affect_versions": "6.5",
        "resolution": "Duplicate",
        "status": "Resolved"
    },
    "description": "I have small document set take from here - http://yonik.com/solr-nested-objects/\nAccording to the schema, review_dt is of type date and pubyear_i is of type int\n\nThis request,\nhttp://localhost:8983/solr/blockjoin70001-1492010056/select?q=*:*&fq=review_dt:[something%20TO%20anything]&wt=json returns\nreturns 400 as expected since, wrong range query is fired\n\n\n{\n  \"responseHeader\": {\n    \"status\": 400,\n    \"QTime\": 2,\n    \"params\": {\n      \"q\": \"*:*\",\n      \"fq\": \"review_dt:[something TO anything]\",\n      \"wt\": \"json\"\n    }\n  },\n  \"error\": {\n    \"metadata\": [\n      \"error-class\",\n      \"org.apache.solr.common.SolrException\",\n      \"root-error-class\",\n      \"org.apache.solr.common.SolrException\"\n    ],\n    \"msg\": \"Invalid Date String:'something'\",\n    \"code\": 400\n  }\n}\n\n\n\nbut for this request,\nhttp://localhost:8983/solr/blockjoin70001-1492010056/select?q=*:*&fq=pubyear_i:[something%20TO%20anything]&wt=json returns 500(Internal server error) instead of 400(Bad Request)\n\n\n{\n  \"responseHeader\": {\n    \"status\": 500,\n    \"QTime\": 11,\n    \"params\": {\n      \"q\": \"*:*\",\n      \"fq\": \"pubyear_i:[something TO anything]\",\n      \"wt\": \"json\"\n    }\n  },\n  \"error\": {\n    \"msg\": \"For input string: \\\"something\\\"\",\n    \"trace\": \"java.lang.NumberFormatException: For input string: \\\"something\\\"\\n\\tat java.lang.NumberFormatException.forInputString(NumberFormatException.java:65)\\n\\tat java.lang.Integer.parseInt(Integer.java:580)\\n\\tat java.lang.Integer.parseInt(Integer.java:615)\\n\\tat org.apache.solr.schema.TrieField.getRangeQuery(TrieField.java:373)\\n\\tat org.apache.solr.parser.SolrQueryParserBase.getRangeQueryImpl(SolrQueryParserBase.java:1047)\\n\\tat org.apache.solr.parser.SolrQueryParserBase.getRangeQuery(SolrQueryParserBase.java:1041)\\n\\tat org.apache.solr.parser.QueryParser.Term(QueryParser.java:503)\\n\\tat org.apache.solr.parser.QueryParser.Clause(QueryParser.java:277)\\n\\tat org.apache.solr.parser.QueryParser.Query(QueryParser.java:161)\\n\\tat org.apache.solr.parser.QueryParser.TopLevelQuery(QueryParser.java:130)\\n\\tat org.apache.solr.parser.SolrQueryParserBase.parse(SolrQueryParserBase.java:211)\\n\\tat org.apache.solr.search.LuceneQParser.parse(LuceneQParser.java:53)\\n\\tat org.apache.solr.search.QParser.getQuery(QParser.java:168)\\n\\tat org.apache.solr.handler.component.QueryComponent.prepare(QueryComponent.java:212)\\n\\tat org.apache.solr.handler.component.SearchHandler.handleRequestBody(SearchHandler.java:269)\\n\\tat org.apache.solr.handler.RequestHandlerBase.handleRequest(RequestHandlerBase.java:173)\\n\\tat org.apache.solr.core.SolrCore.execute(SolrCore.java:2440)\\n\\tat org.apache.solr.servlet.HttpSolrCall.execute(HttpSolrCall.java:723)\\n\\tat org.apache.solr.servlet.HttpSolrCall.call(HttpSolrCall.java:529)\\n\\tat org.apache.solr.servlet.SolrDispatchFilter.doFilter(SolrDispatchFilter.java:347)\\n\\tat org.apache.solr.servlet.SolrDispatchFilter.doFilter(SolrDispatchFilter.java:298)\\n\\tat org.eclipse.jetty.servlet.ServletHandler$CachedChain.doFilter(ServletHandler.java:1691)\\n\\tat org.eclipse.jetty.servlet.ServletHandler.doHandle(ServletHandler.java:582)\\n\\tat org.eclipse.jetty.server.handler.ScopedHandler.handle(ScopedHandler.java:143)\\n\\tat org.eclipse.jetty.security.SecurityHandler.handle(SecurityHandler.java:548)\\n\\tat org.eclipse.jetty.server.session.SessionHandler.doHandle(SessionHandler.java:226)\\n\\tat org.eclipse.jetty.server.handler.ContextHandler.doHandle(ContextHandler.java:1180)\\n\\tat org.eclipse.jetty.servlet.ServletHandler.doScope(ServletHandler.java:512)\\n\\tat org.eclipse.jetty.server.session.SessionHandler.doScope(SessionHandler.java:185)\\n\\tat org.eclipse.jetty.server.handler.ContextHandler.doScope(ContextHandler.java:1112)\\n\\tat org.eclipse.jetty.server.handler.ScopedHandler.handle(ScopedHandler.java:141)\\n\\tat org.eclipse.jetty.server.handler.ContextHandlerCollection.handle(ContextHandlerCollection.java:213)\\n\\tat org.eclipse.jetty.server.handler.HandlerCollection.handle(HandlerCollection.java:119)\\n\\tat org.eclipse.jetty.server.handler.HandlerWrapper.handle(HandlerWrapper.java:134)\\n\\tat org.eclipse.jetty.rewrite.handler.RewriteHandler.handle(RewriteHandler.java:335)\\n\\tat org.eclipse.jetty.server.handler.HandlerWrapper.handle(HandlerWrapper.java:134)\\n\\tat org.eclipse.jetty.server.Server.handle(Server.java:534)\\n\\tat org.eclipse.jetty.server.HttpChannel.handle(HttpChannel.java:320)\\n\\tat org.eclipse.jetty.server.HttpConnection.onFillable(HttpConnection.java:251)\\n\\tat org.eclipse.jetty.io.AbstractConnection$ReadCallback.succeeded(AbstractConnection.java:273)\\n\\tat org.eclipse.jetty.io.FillInterest.fillable(FillInterest.java:95)\\n\\tat org.eclipse.jetty.io.SelectChannelEndPoint$2.run(SelectChannelEndPoint.java:93)\\n\\tat org.eclipse.jetty.util.thread.strategy.ExecuteProduceConsume.executeProduceConsume(ExecuteProduceConsume.java:303)\\n\\tat org.eclipse.jetty.util.thread.strategy.ExecuteProduceConsume.produceConsume(ExecuteProduceConsume.java:148)\\n\\tat org.eclipse.jetty.util.thread.strategy.ExecuteProduceConsume.run(ExecuteProduceConsume.java:136)\\n\\tat org.eclipse.jetty.util.thread.QueuedThreadPool.runJob(QueuedThreadPool.java:671)\\n\\tat org.eclipse.jetty.util.thread.QueuedThreadPool$2.run(QueuedThreadPool.java:589)\\n\\tat java.lang.Thread.run(Thread.java:745)\\n\",\n    \"code\": 500\n  }\n}\n\n\n\nThis is because in case of DateField any parse exception is wrapped in SolrException with code set to 400\nhttps://github.com/apache/lucene-solr/blob/branch_6_5/solr/core/src/java/org/apache/solr/util/DateMathParser.java#L240\n\nBut in case of Integer, Long, Double and some other field types, Parse exception are not handled separately hence any exception in this case would be propagated.\n\nPossible approaches\n\n\n\tHandle any such parse exception in RequestHandlerBase (handleRequest method) just like SyntaxError\n\tWrap such exceptions in SolrException (just like how it is handled in DateField and LatLonField)",
    "attachments": {},
    "issue_links": {},
    "comments": [
        {
            "date": "2017-07-06T15:31:27+0000",
            "content": "I think this is the same issue fixed in SOLR-10833 (but not yet released). Could you check with the latest master code (or 7_0 branch)? ",
            "author": "Tom\u00e1s Fern\u00e1ndez L\u00f6bbe",
            "id": "comment-16076704"
        },
        {
            "date": "2017-07-15T06:02:31+0000",
            "content": "Tom\u00e1s Fern\u00e1ndez L\u00f6bbe\nThank you for the reply. As you said this issue has been fixed in SOLR-10833. Are there any plans to backport this to 6.5+ or 6.6+ version?? ",
            "author": "Munendra S N",
            "id": "comment-16088483"
        },
        {
            "date": "2017-07-15T15:19:47+0000",
            "content": "That JIRA says it's fixed in 6.7. Only critical bug fixes would be back-ported to a new 6.6 release and this doesn't qualify. My guess is that there'll be a 6.7 release although nobody has committed to one yet.\n\nThis patch will probably apply to 6.6 so you could apply it yourself locally. ",
            "author": "Erick Erickson",
            "id": "comment-16088631"
        }
    ]
}