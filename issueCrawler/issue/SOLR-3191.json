{
    "id": "SOLR-3191",
    "title": "field exclusion from fl",
    "details": {
        "affect_versions": "None",
        "status": "Open",
        "fix_versions": [],
        "components": [],
        "type": "Improvement",
        "priority": "Minor",
        "labels": "",
        "resolution": "Unresolved"
    },
    "description": "I think it would be useful to add a way to exclude field from the Solr response. If I have for example 100 stored fields and I want to return all of them but one, it would be handy to list just the field I want to exclude instead of the 99 fields for inclusion through fl.",
    "attachments": {
        "SOLR-3191.patch": "https://issues.apache.org/jira/secure/attachment/12615801/SOLR-3191.patch"
    },
    "issue_links": {},
    "comments": [
        {
            "author": "Luca Cavanna",
            "id": "comment-13221006",
            "date": "2012-03-02T15:55:03+0000",
            "content": "I previously left a comment on the SOLR-2444 asking if we can add an exclusion syntax there, but I'm honestly afraid of that now, given also the SOLR-2719 regression.\nI was thinking to keep it simple, for example using a new parameter like fl.ex or something, may I know what are your thoughts? "
        },
        {
            "author": "Jan H\u00f8ydahl",
            "id": "comment-13221533",
            "date": "2012-03-03T06:37:50+0000",
            "content": "I think by definition a field name cannot start with \"-\" since even the Lucene query syntax must support the alternative NOT syntax -inStock:true. I therefore think we should borrow this syntax over here, just as we are doing for dismax uf in SOLR-3026. It should be easy enough to parse.\n\nExamples:\n\nq=foo&fl=-title           # All fields except title (include * is implicit)\nq=foo&fl=-title,-body     # All fields except title and body\nq=foo&fl=-*_s             # All fields except those matching *_s pattern\nq=foo&fl=foo,-bar         # Would be the same as saying only &fl=foo, since an explicit field resets the list\nq=foo&fl=-bar,foo         # same as above. Order not important?\nq=foo&fl=-foo,foo         # same as above. Probably all the exclude fields should be parsed last and override positive?\nq=foo&fl=*,-title         # same as only -title as * is implicit include when only exclude fields listed?\nq=foo&fl=-*               # Hmm, makes no sense, if you're not returning anything you should ask for rows=0 ??\nq=foo&fl=*z,-*xyz         # Include all fields ending in \"z\" except those ending in \"xyz\", negative rule applied last\n\n "
        },
        {
            "author": "Yonik Seeley",
            "id": "comment-13221713",
            "date": "2012-03-03T22:09:47+0000",
            "content": "+1, looks great Jan! "
        },
        {
            "author": "Luca Cavanna",
            "id": "comment-13221855",
            "date": "2012-03-04T11:33:25+0000",
            "content": "Thanks for your feedbacks!\nI had thought about the same solution too...I was just afraid of adding complexity to the new fl syntax, but if you think that's the way to go, great, and I'd like to contribute on this!\nMy concern is just about SOLR-2719. Don't you think we should correct it and add some kind of consistency before adding new features? What do you think about adding some kind of validation for field names? Shall we open a new issue for that? "
        },
        {
            "author": "Jan H\u00f8ydahl",
            "id": "comment-13582700",
            "date": "2013-02-21T00:09:23+0000",
            "content": "Luca Cavanna, now that SOLR-2719 is fixed, I think it should be green lights for this, if you'd like to attempt a patch. I don't know if the code from UserFields class may be helpful at all.. "
        },
        {
            "author": "Bill Bell",
            "id": "comment-13736056",
            "date": "2013-08-10T21:37:19+0000",
            "content": "This is a very useful feature.... I have 80 fields and want to just eclude one large field... "
        },
        {
            "author": "Andrea Gazzarini",
            "id": "comment-13747346",
            "date": "2013-08-22T07:58:46+0000",
            "content": "Hi all, I'm going to complete the implementation of the field exclusion (using trunk code) but in order to complete I have some questions (so probably I'll have to change a little bit something on my code):\n\n\n\tNew ReturnFields implementor or SolrReturnFields change?\nAt the moment I created another class so the old implementation (SolrReturnFields) is still there. There's no code duplication (or just a little bit that can be remove if that is ok by changing the SolrReturnFields too) because the fl parsing uses a different logic (basically no QueryParsing.StrParser). \n\n\n\n\n\tSolrReturnFields:83 support for fl=' ' => *,score\nThere's a comment below this line about an old feature that could be removed. On the wiki there's no mention about that so can I remove that?\n\n\n\n\n\tAbout glob\nWhat would be the right behaviour (see below)? A full name expansion support or just *aaa bbb*? Does SOLR need that complexity? I started playing with SOLR in 2009 and honestly I never used globs in fl so I have no concrete experience for taking a decision.\n\t\n\t\tThe Wiki talks about just one example (with trailing wildcard)\n\t\torg.apache.solr.search.ReturnFieldsTest.testWilcards() considers only beginning and trailing wildcard cases (e.g. *aaa, bbb*)\n\t\tBut the code supports a wide range of globs (e.g. a*a, a?a, n*m*,n*m?)\n\t\n\t\n\n\n\n\n\tfl expressions (probably I will attach some other \"ambiguous\" case later)\nWhat would be the expected behaviour in these cases?\n\t\n\t\t* -name test\n\t\t-name test *\n\t\t-name * test\n\t\t-* I understand that should be wrong but what would be the correct behaviour? SyntaxError?\n\t\tname name:manu (at the moment it seems the \"aliased\" field always wins)\n\t\tpippo:name pippo:manu ( at the moment it seems the last alias wins)\n\t\n\t\n\n\n\nFor latest three I believe a SyntaxError would be more appropriate "
        },
        {
            "author": "David Morana",
            "id": "comment-13763116",
            "date": "2013-09-10T15:25:21+0000",
            "content": "This is exactly one of the features I was looking for. \nIf possible can you make a patch of this for Solr v4.0 Final?\nThanks, "
        },
        {
            "author": "Erick Erickson",
            "id": "comment-13763190",
            "date": "2013-09-10T16:43:36+0000",
            "content": "No body has put up any kind of patch for this, it's just a suggestion at this point.\n\nIf you'd like to supply one that would be great! "
        },
        {
            "author": "Andrea Gazzarini",
            "id": "comment-13763224",
            "date": "2013-09-10T17:00:44+0000",
            "content": "Hi, Some days ago I built a working implementation of ReturnFields some days ago. It's not yet ready because (in my free time) I'm trying to enumerate all scenarios in ReturnFieldsTest.\nHope to submit a patch soon.      "
        },
        {
            "author": "Andrea Gazzarini",
            "id": "comment-13832384",
            "date": "2013-11-26T07:49:59+0000",
            "content": "Hi all, I attached a patch for the fl exclusion feature. \nSorry for the very long post and for delay. I will try to be as short as possible, there are a lot of things that need to be considered but in general I would say that the whole stuff is easier to try than to explain.\n\nToken types\nLets start with token types. The following tokens are supported (just a short list, each type is subsequently explained): \n\n\n\n\tliteral inclusion: name, id, title, subject (can be aliased like alias:fieldname);\n\tinclusion glob: na*, n?m*, *me (cannot be aliased because the expression could match more than one fields);\n\t*: as before, that means \"all real fields\": internally is managed as a special case of inclusion glob;\n\tliteral exclusion: -name, -id, -title (cannot be aliased, doesn't make sense)\n\texclusion glob: -na*, -n?m*, -*me (cannot be aliased, doesn't make sense); as special case -* is ignored.\n\ttransformers: [explain], [docid], [shard] (can be aliased like alias:[docid])\n\tfunctions: sum(1,1), \"literal value\" (can be aliased like alias:sum(1,1), myalias:\"literal value\")\n\n\n\nLiteral inclusion\nA literal inclusion declares a (real) field that must be returned in response. Supports aliasing (myalias:fieldname) \nExamples:\n\n\n\tname\n\tthis.is.a.valid.field (see ReturnFieldsTest.testDotInFieldName)\n\tthis-is-a-valid-field (see ReturnFieldsTest.testHyphenInFieldName)\n\tthis$is$a$valid$field (see ReturnFieldsTest.testDollarInFieldName)\n\t#foo_s,fl (see ReturnFieldsTest.testFunkyFieldNames)\n\n\n\nInclusion glob\nAn inclusion glob declares an expression using * and / or ?. Fields matching that expression will be returned in response.\nExamples (see ReturnFieldsTest.testWildCards / testReturnAllFields / testReturnOnlyName)\n\n\n\tna*\n\tn?m?\n\tn*\n\t*me\n\t*m?\n\n\n\n\nAliases cannot be applied to inclusion globs because an expression could match more than one fields. The expression wont' be discarded, just the alias part. So for example\n\nfl=alias:na* will collect the na* inclusion glob \n\n\nLiteral exclusion\nA literal exclusion declares a field that will be excluded in response. Basically it is a literal inclusion prefixed by -\nExamples  (see ReturnFieldsTest.testReturnOnlyName / testReturnOnlyNameAndTitle / testReturnAllRealFieldsExceptName):\n\n\n\t-name\n\t-this.is.a.valid.field (see ReturnFieldsTest.testDotInFieldName)\n\t-this-is-a-valid-field (see ReturnFieldsTest.testHyphenInFieldName)\n\t-this$is$a$valid$field (see ReturnFieldsTest.testDollarInFieldName)\n\t-#foo_s,-fl (see ReturnFieldsTest.testFunkyFieldNames)\n\n\n\n\nAliasing is not supported so \n\nfl=-alias:fieldname\n\nis silently discarded. Note that in this case or in this one:\n\nfl=-a1:a -a2:b -a3:c\n\nall tokens are invalid so the expressions will be resolved in \n\nfl=\n\nand therefore standard procedure applies (see last testcase on ReturnFieldsTest.testReturnAllRealFields) \n\n\nexclusion glob\nAn exclusion glob is an expression that uses * and / or ?. Fields matching that expression will be excluded from response.\nExamples (see ReturnFieldsTest.testReturnOnlyName / testReturnOnlyNameAndTitle / testReturnAllRealFieldsExceptName):\n\n\n\t-na*\n\t-n?m?\n\t-n*\n\t-*me\n\t-*m?\n\n\n\n\nAs literal exclusions, you cannot use aliases in these expressions, they will be silently discarded  (see last testcase on ReturnFieldsTest.testReturnAllRealFields)\n\n\ntransformers\nJust one important thing: invalid transformers are ignored. \nExamples (you can see all the assertions below in ReturnsFieldsTest.testTransformers):\n\n\n\n\tfl=[explain] (one transformer)\n\tfl=[docid] [explain] (two transformers)\n\tfl=[shard] id (a transformer and a real field)\n\tfl=[xxxxxx] (an invalid transformer. That will have the same effect of having an empty fl)\n\tfl=[xxxxxx] [yyyyy] (two invalid transformers. That will have the same effect of having an empty fl)\n\tfl=[docid] [shard] [xxxx] (the invalid transformer will be ignored so only [docid] and [shard] will be evaluated\n\tfl=myalias:[docid] (aliased transformer)\n\tfl=alias:[yyyyyy] (invalid aliased transformer - will be ignored, see last test on ReturnFieldsTest.testReturnAllRealFields)\n\n\n\nFunctions (and literals)\nAll functions described here http://wiki.apache.org/solr/FunctionQuery#Available_Functions\ncan be declared in \"fl\" parameter. They can be aliased too.\nExamples (see ReturnFieldsTest.testFunctions)\n\n\n\n\tfl=sum(1,1)\n\tfl=\"this is a literal\", 'this is another literal\", 1.2\n\tfl=pippo:\"this is an aliased literal\", pluto:'this is another aliased literal\", paperino:1.2\n\tfl=\n{!func}add($v1,$v2)&v1=10&v2=13.0\n- fl=alias:{!func}\nadd($v1,$v2)&v1=10&v2=13.0\n\n\n\n\nWARNING: differently from transformers, in case of invalid function an exception will be thrown. \n\n\nAliases\nAliases are supported on\n\n\n\n\tliteral field names (e.g. alias:fieldname)\n\ttransformers (e.g. alias:[docid])\n\tfunctions (e.g. alias:max(1,2))\n\n\n\nand are not supported on \n\n\n\n\tinclusion globs (because expression could match multiple fields and alias in response must be uniquely associated to a field. The alias part of the token expression will be ignored, the glob expression collected)\n\tliteral exclusion (doesn't make sense, will be silently ignored)\n\texclusion globs (doesn't make sense, will be silently ignored)\n\n\n\nGeneral rules\n\n\tan inclusion (literal or glob) is ignored if in case of *.\n\t\n\t\tfl=* name na* (return all fields, name and na* fields are already included)\n\t\tfl=name * (same as before)\n\t\tany exclusion token will be ignored if an inclusion has been defined before\n\t\tfl=name -id (returns all fields except id so \"name\", with other real fields, is implicitly included)\n\t\n\t\n\tan inclusion token will clear all exclusion\n\t\n\t\tfl=-id name (means \"returns only name\", no matter what exclusions are defined before)\n\t\tfl=-id *\n\t\tthe * expression is ignored in case of an exclusion (literal or glob)\n\t\t* -name (the * doesn't make sense, or in other words is implicit: returns all fields except name)\n\t\t-name * (same as before)\n\t\n\t\n\tscore, transformers and functions doesn't change the behaviour described above, they are just added to response\n\t\n\t\tfl=score, *, name\n\t\tfl=*, [docid], name, sum(1,1), myfunctionalias:\"literal value\"\n\t\tfl=name -id [shard], exchange:1.34\n\t\n\t\n\tan empty or null fl will execute as \"*\" (all real fields). Note that we can be in this situation if we pass an empty fl, no fl or if all tokens in fl are discarded because invalid.\n\tsome other rules like multiplicity on fl parameter (see ReturnFieldsTest.testManyParameters), token separator (comma or whitespaces - see ReturnFieldsTest.testWhitespace and ReturnFieldsTest.testSeparators) remain the same.\n\n\n\nSome (technical) consideration \n\n1. I'm not sure about the test methods granularity level: some test methods, although grouping the same concept, contain a lot of sub-cases / scenarios and sometimes is hard to capture the functional behaviour (see for example ReturnFieldsTest.testTransformers or ReturnFieldsTest.testAliases). Maybe doing a test method for each sub-case should be better? I modified the ReturnFieldsTest for adding additional test cases but I followed the existing approach...let me know what you think about a much fine level of granularity..in case I can try to make some refactoring in that direction \n\n2. There are two (at least it seems to me) classes that are testing ReturnFields behaviour : ReturnFieldsTest and TestPseudoReturnFields...maybe all those test methods could be part of one test case? I don't know the reason behind the choice of having two classes so I'm just asking, the TestPseudoReturnFields is still there and all tests are green  \n\nAny feedback is warmly welcome. \nAndrea  "
        },
        {
            "author": "Andrea Gazzarini",
            "id": "comment-13832386",
            "date": "2013-11-26T07:50:57+0000",
            "content": "Patch for field exclusion in fl "
        },
        {
            "author": "Robert Muir",
            "id": "comment-13832648",
            "date": "2013-11-26T15:16:41+0000",
            "content": "the abstract ReturnFields should not have constants. its abstract, it has no syntax. that stuff needs to be moved to an implementation class.\n\nSeparately, SolrReturnFields.java i think has already reached the limit where its totally un-understandable. The original discussion on this issue talked about having a separate implementation, but it seems instead it was all piled into ReturnFields.\n\nWhat to do about fields that actually start with \"-\" ? Remember, not everyone uses the lucene query parser. The assumptions listed on the beginning of this issue about that are totally wrong.\n\nI think we should make the ReturnFields implementation something that can be plugged into the solrconfig without writing java code and provide alternatives (for example: one that is simple and where the code can be understood) "
        },
        {
            "author": "Andrea Gazzarini",
            "id": "comment-13832698",
            "date": "2013-11-26T15:50:38+0000",
            "content": "> the abstract ReturnFields should not have constants. its abstract, it has no syntax. that stuff needs to be moved to an implementation class.\n\nNo problem at all, I can reattach the patch\n\n> Separately, SolrReturnFields.java i think has already reached the limit where its totally un-understandable. The original discussion on this issue talked about having a separate implementation, but it seems instead it was all piled into ReturnFields.\n\nSorry I didn't find those assumptions in this issue. It's all into (Solr)ReturnFields class because all the described logic is there. I can separate the parser (which from \"some\" perspectives I could agree with you, inner classes complicates the reading) and the builder logic if you think is better.\n\n> I think we should make the ReturnFields implementation something that can be plugged into the solrconfig without writing java code and provide alternatives (for example: one that is simple and where the code can be understood)\n\nIf things need to be done in this way I can try to do that. Again, I didn't because in this issue there's no trace about that \"pluggabilty\". Also please clarify me about what you consider understandable so I can follow that direction.  "
        },
        {
            "author": "Yonik Seeley",
            "id": "comment-13832865",
            "date": "2013-11-26T18:46:52+0000",
            "content": "I like the direction you're going Adrea!\nFrankly, I don't understand why there is an abstract class at all, or why we need plugabillity here at all.  This should really be about interface and making the simple things simple.  The edge cases like fields starting with a \"-\" can be handled as edge cases (via field() function or whatever) and should not dominate the design here. "
        },
        {
            "author": "Andrea Gazzarini",
            "id": "comment-13833025",
            "date": "2013-11-26T20:40:54+0000",
            "content": "Thank you very much Yonik, very happy to hear that.\n\nI agree with you regarding the abstract class: ReturnFields should be an interface; I left it as a class because I don't know the past behind the code so my concern was to respect and preserve as much as possible what others did (not for SolrReturnFields  but here there were a lot if things that required changes)\n\nSo, do you want me to update the patch with\n\na) ReturnFields as interface\nb) Constants removed and put in SolrReturnFields as Robert suggested?\n "
        },
        {
            "author": "Ryan Ernst",
            "id": "comment-13833064",
            "date": "2013-11-26T21:06:10+0000",
            "content": "\na) ReturnFields as interface\n\nReturnFields is an abstract class so that changes to the interface can not break concrete implementations.  It was originally added in SOLR-4226.\n\n\nb) Constants removed and put in SolrReturnFields as Robert suggested?\nYes Robert Muir is right that there shouldn't be constants in the ReturnFields.  Leave that up to the concrete implementations.  I also think making it pluggable would be very nice, but should be a separate issue. "
        },
        {
            "author": "Yonik Seeley",
            "id": "comment-13833084",
            "date": "2013-11-26T21:18:09+0000",
            "content": "I agree with you regarding the abstract class: ReturnFields should be an interface;\n\nHeh - I see my use of \"interface\" was ambiguous.  I actually meant the higher level text (http, etc) interface to Solr is important, not the java level.  It's that interface that really counts... being able to pass fl=foo, _important, -bar, -_big\nSo I was questioning why there were even two classes, rather than just a single one.  If a super-expert user wants to make their own customized version, they can copy-n-paste the code, but it's so far into the outliers we shouldn't be designing around it. "
        },
        {
            "author": "Andrea Gazzarini",
            "id": "comment-13833553",
            "date": "2013-11-27T07:51:16+0000",
            "content": "Heh - I see my use of \"interface\" was ambiguous.\nHeheh...and in addition there's my wonderful english.\n\nI understand what you mean and I agree. The only problem I see if we want to remove ReturnFields is that it is referenced 63 times (moreless) in source code so the patch would have a more delicate impact (at the moment the patch changed just 3 isolated files).   \n\nOtherwise, from an OO perspective, what Ryan Ernst said is right so we could just remove the constants in the abstract class.   "
        },
        {
            "author": "Andrea Gazzarini",
            "id": "comment-13842552",
            "date": "2013-12-08T16:56:50+0000",
            "content": "New version of the patch \u2013 ReturnFields without constants.  "
        },
        {
            "author": "Shalin Shekhar Mangar",
            "id": "comment-13843048",
            "date": "2013-12-09T10:31:58+0000",
            "content": "I don't have time right now to review this. I assigned it to myself because there was a lot of public interest but no assignee. However it looks like a couple of other committers have interest in this issue as well. I can only look at this after a few weeks so if no one takes it up, then I will. "
        },
        {
            "author": "Kuntal Ganguly",
            "id": "comment-14106550",
            "date": "2014-08-22T06:41:00+0000",
            "content": "I have tried this patch on Solr 4.2.1 and 4.9, but this patch is not working with custom doc transformer.\n\nI have a custom transformer that does the following:\n\nThe Custom transformer for joining between two entities and merging fields from second entity into the response of 1st entity is deployed in both local and staging boxes.\n\nUsecase:\n\nSay  Entity-1 type=ProjectDocument and Entity-2 type=Projects.Now we want to search on certain fields of Entity-1 (document_createbyname),\nthen join with Entity-2 based on common field/fields between two entities (pinprojectid)and finally fetch and merge field/fields of Entity-2(projecttype) into the response of Entity-1.\n\n\nSample Query:\n\nLocal::\nhttp://10.10.87.91:4983/solr/collection1/select?q=type:ProjectDocument AND document_createbyname:\"Sudipta Sarkar\"\n&fl=*,[mytrans5 jf=pinprojectid if=type:Projects mf=projecttype]\n\nStaging::\nhttp://10.1.1.230:6983/solr/collection1/select?q=type:ProjectDocument AND document_documenttitle:testing&&fl=*,[mytrans5 jf=pinprojectid if=type:Projects mf=pwaccountid,projectaddress2,projecttype,projectenddate,project_city]\n\nDetails of transformer\n\nTransformer name->mytrans5\nIt has three parameter:\n\n1. jf (Joining Field- Mandatory)= can be single or multi-value separated by comma. This should contain common fields between two entities.\n\n2. mf (Merge Field- Mandatory)= can be single or multi-value separated by comma. This fields will be fetch from 2nd entity and merge with 1st entity response.\n\n3. if (Identity Field- Optional)= single value. This fields specify the second entity uniquely from 1st entity (say type:Projects). If this fields is not provided during query,this will then read default value from configuration file. If default value is also missing,then it will take the first value from merge field parameter.\n\n[mytrans5 jf=pinprojectid,pwaccountid if=type:Projects mf=projecttype,projectenddate,project_city]\n\n\n\nCan you suggest me what to do? Because the transformer is working fine without this patch properly as expected.\n "
        },
        {
            "author": "Kuntal Ganguly",
            "id": "comment-14106821",
            "date": "2014-08-22T13:34:09+0000",
            "content": "I modify the code to support inbuilt alias transformer as well as custom transformer:\n\nModify the method:\n\n /**\n\n\tLogic to handle Custom as well as inbuilt Doc Transformer.\n\t   */\n\n\n\n  void onTransformer(final StringBuilder expressionBuffer, final SolrQueryRequest request, final DocTransformers augmenters)\n      throws SyntaxError {\n\t  if(expressionBuffer!=null){\n\t   String fl_Content=expressionBuffer.toString();\n\t\tif(fl_Content.contains(\"[\") && fl_Content.contains(\"]\")){\n\n\t\t\tif(fl_Content.indexOf(\"[\")==0){\n\t\t\t\t //Logic to Parse Custom Transformers\n\n\t\t\t\t  final Map<String,String> augmenterCustomArgs = new HashMap<String,String>();\n\t\t\t\t  QueryParsing.parseLocalParams(expressionBuffer.toString(), 0, augmenterCustomArgs, request.getParams(), \"[\", CLOSE_BRACKET);\n\t\t\t\t  final String augmenterCustomName = augmenterCustomArgs.remove(\"type\");\n\t\t\t\t  final String customDisp='['+augmenterCustomName+']';\n\t\t\t\t  final TransformerFactory customFactory = request.getCore().getTransformerFactory(augmenterCustomName);\n\t\t\t      if( customFactory != null ) \n{\n\t\t\t      MapSolrParams augmenterCustomParams = new MapSolrParams( augmenterCustomArgs );\n\t\t\t      augmenters.addTransformer( customFactory.create(customDisp, augmenterCustomParams, request) );\n\t\t\t\t\n\t\t\t}\n\t\t\t}else if(fl_Content.indexOf(\"[\")>0 && fl_Content.contains(\":[\")){\n\t\t\t\t//Logic to Parse In_Built Transformers\n\n\t\t\t    final String alias = getExpressionAlias(expressionBuffer);\n\t\t\t    final String transfomerExpression = getExpressionValue(expressionBuffer);\n\t\t\t    final Map<String,String> augmenterArgs = new HashMap<String,String>();\n\t\t\t    QueryParsing.parseLocalParams(transfomerExpression, 0, augmenterArgs, request.getParams(), \"[\", CLOSE_BRACKET);\n\t\t\t    final String augmenterName = augmenterArgs.remove(\"type\");\n\t\t\t    final String aliasThatWillBeUsed = (alias != null) ? alias : OPEN_BRACKET + augmenterName + CLOSE_BRACKET;\n\t\t\t    final TransformerFactory factory = request.getCore().getTransformerFactory(augmenterName);\n\t\t\t    if (factory != null) \n{\n\t\t\t    augmenters.addTransformer(factory.create(aliasThatWillBeUsed, new MapSolrParams(augmenterArgs), request));\n\t\t\t    onInclusionLiteralExpression(expressionBuffer, augmenters, false, false);\t\n\t\t\t\t\t\t\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n "
        },
        {
            "author": "Erik Hatcher",
            "id": "comment-14106825",
            "date": "2014-08-22T13:39:33+0000",
            "content": "Kuntal Ganguly - could you attach a full patch against Solr trunk (or branch_4x) so that the latest success working code is available easily?  Thanks!   Test cases with a custom transformer would be great if you could add those as well.  I have interest in this issue, but it looks a bit hairy to review, so best if the latest is consolidated. "
        },
        {
            "author": "Andrea Gazzarini",
            "id": "comment-14107018",
            "date": "2014-08-22T16:07:12+0000",
            "content": "Hi guys, I created that patch some time ago, if you need something I will\nbe happy to give a help.\n\nIn my comments above you can find  all tests involved with the fl\nexclusion, I think additional tests should go there.\n\nAndrea\n "
        },
        {
            "author": "Andrea Gazzarini",
            "id": "comment-14107996",
            "date": "2014-08-23T13:17:11+0000",
            "content": "I meant \"additional test methods\"\n "
        },
        {
            "author": "Kuntal Ganguly",
            "id": "comment-14108961",
            "date": "2014-08-25T09:50:19+0000",
            "content": "Erik Hatcher Yeah i will upload the patch along with the test cases for transformer fix tomorrow. "
        },
        {
            "author": "Kuntal Ganguly",
            "id": "comment-14110458",
            "date": "2014-08-26T07:57:25+0000",
            "content": "Updated the existing patch for working with custom transformer like - [mytrans5 jf=pinprojectid if=type:Projects mf=project_accessibilitytype]  ,  that was working properly without this patch. Updated the onTransformer method in-order to make transformer( inbuilt, alias or custom) work properly. Use-case for the above transformer is mentioned above in my previous comment section.\nAlso added two test cases for it.  "
        },
        {
            "author": "Jan H\u00f8ydahl",
            "id": "comment-14183474",
            "date": "2014-10-24T20:59:36+0000",
            "content": "Are there known issues with this patch? I see a few TODO's "
        },
        {
            "author": "Andrea Gazzarini",
            "id": "comment-14183984",
            "date": "2014-10-25T05:43:40+0000",
            "content": "Hi Jan,\nif you refer to my long comment above, the two last points are questions\nabout the granularity of unit tests, so nothing important, from a\nfunctional point of view.\n "
        },
        {
            "author": "Roman Kliewer",
            "id": "comment-14184996",
            "date": "2014-10-27T09:31:07+0000",
            "content": "I think this feature should be higher prioritized since the atomic updates do require all fields stored.\n\nIn my case there are millions of documents and i do need to frequently update the ACL field, so storing of the default search field is required. This causes of course a much slower search because the default search field is returned every time since it can not be excluded and almost all other fields are dynamic.\n\nIMHO the absence of this feature renders atomic update feature completely unusable. "
        },
        {
            "author": "Jan H\u00f8ydahl",
            "id": "comment-14547338",
            "date": "2015-05-17T20:48:10+0000",
            "content": "Anyone have been using the patch in production? "
        },
        {
            "author": "Andrea Gazzarini",
            "id": "comment-14547343",
            "date": "2015-05-17T21:00:40+0000",
            "content": "Hi Jan,\nYes but with an old version of Solr (4.4.0 if I remember well) and I don't\nuse all of the stuff offered by the patch (e.g. exclusion globs, exclusion\nwith aliasing) just a simple fl=-huge_field   which was exactly the\nreason why at that time I started working on this issue\n\n "
        },
        {
            "author": "Jan H\u00f8ydahl",
            "id": "comment-14553270",
            "date": "2015-05-20T22:47:54+0000",
            "content": "Kuntal Ganguly, there is a problem with your last patch from august, it does not include the Expectation interface. "
        },
        {
            "author": "Scott Stults",
            "id": "comment-14971867",
            "date": "2015-10-23T21:19:47+0000",
            "content": "I updated this patch to work on trunk. A couple of things that didn't seem to work with the last patch were:\n\n\n\tWhen a field is requested both in its bare form as well as with an alias (e.g. \"fl=id,myid:id\") the bare form was discarded\n\tWhen fl only contains invalid transformers and aliased exclusion globs, the behavior was expected to be as if * were requested.\n\n\n\nI was able to get the first case to work by adding the requested aliases to a separate list and then applying the RenameFieldTransformer copy argument selectively.\n\nThe second case seems really fringe so the best course might be to open it as a separate Jira later if necessary. "
        },
        {
            "author": "Demian Katz",
            "id": "comment-14999068",
            "date": "2015-11-10T18:25:59+0000",
            "content": "I just took a look at test coverage for this patch, and it appears that there are a couple of areas where more tests are needed:\n\n1.) I'm not sure what public static String getFieldName(QueryParsing.StrParser sp) is for, but it's not covered at all.\n\n2.) None of the logic related to collectingLiteral seems to be getting tested. I tried adjusting the test class to include a field list containing a function and a literal:\n\n\n  @Test\n  public void testFunctionAndLiteralInFieldList() {\n\tReturnFields rf = new SolrReturnFields(req(\"fl\", \"ordOfId:{!func}ord(id),literal:1234\"));\n\tassertTrue(rf.wantsField(\"ordOfId\"));\n\tassertTrue(rf.wantsField(\"literal\"));\n\tassertFalse(rf.wantsField(\"xxx\"));\n\tassertFalse(rf.wantsAllFields());\n  }\n\n\n\nUnfortunately, while this test passes, it does not appear to affect the coverage as I had expected.\n\n3.) For a little low-hanging-fruit coverage improvement, I added this to testFunkyFieldNames, since the method was not covered at all:\n\n\nassertEquals(\"[#foo_s, id]\", rf.getRequestedFieldNames().toString());\n\n\n\nI'm not sure if that's actually valuable.\n\nApologies if any of these comments seem ill-informed; this is my first foray into the Solr code. However, we'd really like to see this patch committed to master, and I'm told that good patch test coverage helps things move along, so I thought I'd take a stab at it. I hope this is of some use! Please let me know if I can be of further assistance. "
        },
        {
            "author": "Erik Hatcher",
            "id": "comment-15002379",
            "date": "2015-11-12T16:41:15+0000",
            "content": "Commenting on the latest patch - why is there so much work to test and allow \"funky\" field names?   Shall we not start enforcing \"Field names should consist of alphanumeric or underscore characters only and not start with a digit. \" - from https://cwiki.apache.org/confluence/display/solr/Defining+Fields "
        },
        {
            "author": "Erik Hatcher",
            "id": "comment-15002394",
            "date": "2015-11-12T16:49:58+0000",
            "content": "Demian Katz thanks for the review; it got me looking at this patch deeper myself.  To address your questions, as I look into it myself:\n\n1) getFieldName is used by some unrelated (LegacyFacet) code only, so seems to be untouched/unused here.   Good eye, but no worries here.\n\n2) Another good eye (how are you testing coverage?) - collectingLiteral is only used when there are single or double quotes being parsed in an fl, which none of the tests do.  A different ParserStage is used for regular field names.\n\n3) I don't think we need to test the .toString of the Set returned, but point taken about testing getReturnFieldNames() contents.\n\nStill reviewing... "
        },
        {
            "author": "Demian Katz",
            "id": "comment-15002400",
            "date": "2015-11-12T16:54:43+0000",
            "content": "Erik,\n\nI'm using the jacoco ant task to test coverage \u2013 specifically:\n\nant jacoco -Dtests.class=org.apache.solr.search.ReturnFieldsTest\n\nThis generates lots of files under build/jacoco, and if you navigate to the one for the SolrReturnFields class you can see very clearly where the weak coverage areas lie.\n\n\n\tDemian\n\n "
        },
        {
            "author": "Erick Erickson",
            "id": "comment-15002469",
            "date": "2015-11-12T17:24:15+0000",
            "content": "bq: Field names should consist of alphanumeric or underscore characters only and not start with a digit.\n\nOh my yes!!! +Integer.MAX_VALUE I really hate saying \"Well, some other patterns may work, but we don't guarantee it\". "
        },
        {
            "author": "Erik Hatcher",
            "id": "comment-15002627",
            "date": "2015-11-12T18:53:06+0000",
            "content": "Ok, so Scott Stults - wanna take a stab at adjusting the code and tests to only allow allowed field names?   Will we get into any trouble for a 5.4 fix version for that or will there be some field names that folks use that won't pass through?   I'm ok with the implementation working for these funky field names, but that we don't \"officially\" support anything funky, so maybe it's ok as-is for now?   But it'd be good to be strict about this stuff at some point. "
        },
        {
            "author": "Scott Stults",
            "id": "comment-15002827",
            "date": "2015-11-12T20:07:15+0000",
            "content": "I'd definitely be up for trimming out funky field name checks in the tests. Applying field name restrictions just in fl might lead to the situation where data is searchable but not returnable, so should the enforcement portion go to a more central location? Also, should field aliases be restricted in exactly the same way as real field names? "
        },
        {
            "author": "Erik Hatcher",
            "id": "comment-15003020",
            "date": "2015-11-12T21:59:10+0000",
            "content": "That's a good question about field aliases - a number literal, for example, wouldn't be a valid Solr field name by these rules.   So I think field aliases are fair game to be funky.\n\nI don't necessarily propose we tackle all of these field name rules or maybe none of them at all, as part of the main gist of this issue though.  Maybe we just get the fl field exclusion aspect of this committed, and deal with field name rules and parsing in other contexts to a separate effort? "
        },
        {
            "author": "Yonik Seeley",
            "id": "comment-15003064",
            "date": "2015-11-12T22:19:21+0000",
            "content": "I think new features should be free to ignore funky field name... no back compat requirements.\nChanging existing APIs... I don't know.  I guess it depends on how many cases there are out there of funky names, how many of them will upgrade, and what the cost is to us to support.\n\nThat's a good question about field aliases - a number literal, for example, wouldn't be a valid Solr field name by these rules. So I think field aliases are fair game to be funky.\n\nMy guess is that Scott was referring to just the alias name... as in <alias_name> : <alias_value>, where alias_value can be a function query, literal, or transformer, as well as another field.\n "
        },
        {
            "author": "Scott Stults",
            "id": "comment-15004086",
            "date": "2015-11-13T15:08:49+0000",
            "content": "Right. The reason I ask is, aliases would be a decent alternative for folks who need field names like \"1_product\" should we start enforcing recommended field name restrictions in the schema. But there are other places in the response where we need to render a field name, like in facets and highlighting (I don't know the details of how that's done), so allowing funky aliases could have side effects.\n\nThere are other tickets specifically about leading digits in field names (SOLR-7070, SOLR-3407), so I like Erik Hatcher's suggestion of keeping this focused on the exclusion list aspect and addressing field name enforcement/warning elsewhere. "
        },
        {
            "author": "Demian Katz",
            "id": "comment-15045511",
            "date": "2015-12-07T19:05:43+0000",
            "content": "I just took another look at this and discovered that the patch no longer applies cleanly against the latest code. Looks like it was broken by r1714994. Any chance somebody could generate an updated patch? I don't think there are any major conflicts here \u2013 just enough to break the patch. "
        },
        {
            "author": "Jan H\u00f8ydahl",
            "id": "comment-15121713",
            "date": "2016-01-28T15:32:55+0000",
            "content": "I saw there were a lot of changes. I can help facilitate this for inclusion, if someone would provide a patch which applies to trunk or 5x. And also +1 to skip funky field name enforcing in this issue, can be introduced later. "
        },
        {
            "author": "Erik Hatcher",
            "id": "comment-15195847",
            "date": "2016-03-15T18:14:27+0000",
            "content": "This is the patch (entirely, I think) from Scott Stults that I've run been vetting.  Looks good.  Let's see if we can get some more reviewers for it before committing. "
        },
        {
            "author": "Erick Erickson",
            "id": "comment-15196544",
            "date": "2016-03-16T00:33:04+0000",
            "content": "What about Robert's point of having constants in an abstract class? It looks like they were moved in the patch dated December of 2013, but then snuck back in on the next patch (Aug 2014). Moving them to the impl would be trivial, but then the patch from August 2014 is very significantly smaller. Is that all OK?\n\nMeanwhile I'll beast this puppy tonight. The SolrReturnFields class makes me dizzy.... "
        },
        {
            "author": "Erick Erickson",
            "id": "comment-15203648",
            "date": "2016-03-21T02:31:40+0000",
            "content": "I ran this patch over 1,000 times \"last night\" (well 4 days ago) and everything was fine.\n\nFWIW "
        },
        {
            "author": "Erick Erickson",
            "id": "comment-15229690",
            "date": "2016-04-07T04:53:30+0000",
            "content": "Rats. Trunk has diverged enough that this patch doesn't apply any more and it's not trivial to merge. Anyone care to take a crack at updating it? This time I promise I'll keep after it....\n\nFrom what I can tell, the changes to, particularly, SolrReturnFields between 14-jan and now are trivial, but applying the patch sure leads to chaos. I suspect somebody with more Git mojo than I have could merge the changes in a few minutes. Pretty Please????\n "
        },
        {
            "author": "Erick Erickson",
            "id": "comment-15234509",
            "date": "2016-04-11T05:33:34+0000",
            "content": "Here's an updated patch that attempts to reconcile the original with current trunk. There are a couple of problems:\n\n1> I couldn't get a clean merge beween this patch and the minimal changes in SOLR-8902 for SolrResultField. So I essentially took this patch applied to 57d85d8 and took the SolrResultField and copied it over into trunk. The tests added for 8902 pass. Waiting for Ryan McKinley to comment here.\n\n2> TestRawTransformer doesn't work with this patch on trunk. Nor does it work with this patch applied to straight 57d85d8. \n\n3> There's a new test in trunk TestGeoJSONResponseWriter that fails with this patch applied to trunk.\n\nI chose that revision because it was the last one that changed the main files in this JIRA.\n\nSo in essence this JIRA is not committable until the three issues above are resolved. "
        },
        {
            "author": "Erick Erickson",
            "id": "comment-15235425",
            "date": "2016-04-11T16:31:58+0000",
            "content": "Ryan responded for <1>, so that's apparently not a problem. "
        },
        {
            "author": "Scott Stults",
            "id": "comment-15235622",
            "date": "2016-04-11T18:06:06+0000",
            "content": "Since this is essentially a wholesale rewrite of SolrReturnFields, would it be easier to manage if it was a separate extension of ReturnFields? That brings up another problem, namely, where we would configure that. We'd gain some flexibility in how the ResponseWriters treat return fields, so maybe that's a good place to select the particular ReturnFields implementation.\n\nKinda spitballing here because I know there is at least one ResponseWriter that requires special handling (CSV) and I suspect GeoJSONResponseWriter might need more (haven't looked yet). "
        },
        {
            "author": "Ryan McKinley",
            "id": "comment-15235930",
            "date": "2016-04-11T20:31:06+0000",
            "content": "The failure for GeoJSONResponseWriter will most likely have to do with 'fields' vs 'okFields' \u2013 that is, the fields we need to request from Lucene, and 'okFields' the fields that need to be returned to the end user.\n\n> a separate extension of ReturnFields?\n\nugg \u2013 unless there is a really good reason, we should avoid this "
        },
        {
            "author": "Gus Heck",
            "id": "comment-15459626",
            "date": "2016-09-02T21:20:38+0000",
            "content": "Folks involved here may also be interested in SOLR-9467 "
        },
        {
            "author": "ASF GitHub Bot",
            "id": "comment-16240649",
            "date": "2017-11-06T18:20:14+0000",
            "content": "GitHub user sstults opened a pull request:\n\n    https://github.com/apache/lucene-solr/pull/271\n\n    SOLR-3191: Fixes earlier issues with the patch, namely CSVWriter and \u2026\n\n    \u2026streaming errors\n\nYou can merge this pull request into a Git repository by running:\n\n    $ git pull https://github.com/sstults/lucene-solr jira/solr-3191\n\nAlternatively you can review and apply these changes as the patch at:\n\n    https://github.com/apache/lucene-solr/pull/271.patch\n\nTo close this pull request, make a commit to your master/trunk branch\nwith (at least) the following in the commit message:\n\n    This closes #271\n\n\ncommit a1b4c8f5307cf533a2abe2557b35fd105a12022a\nAuthor: Scott Stults <sstults@o19s.com>\nDate:   2017-11-06T18:15:05Z\n\n    SOLR-3191: Fixes earlier issues with the patch, namely CSVWriter and streaming errors\n\n "
        },
        {
            "author": "Erick Erickson",
            "id": "comment-16315556",
            "date": "2018-01-08T01:31:41+0000",
            "content": "It's pretty obvious I'm not going to take this up before the sun becomes a red giant so unassigning. "
        }
    ]
}