{
    "id": "SOLR-11432",
    "title": "Query Elevation breaks collection aliasing under certain conditions",
    "details": {
        "labels": "",
        "priority": "Major",
        "components": [
            "search",
            "SearchComponents - other"
        ],
        "type": "Bug",
        "fix_versions": [],
        "affect_versions": "6.6.1",
        "resolution": "Unresolved",
        "status": "Open"
    },
    "description": "I have two collections: \"intranet\" and \"mysite.tld\". I created an alias for both of these: \n\n{\"collection\":{\"all\":\"mysite.tld,intranet\"}}\n\n\n\nBoth collections have query elevation enabled, with differing contents in elevate.xml.\n\nWhen I search the \"all\" alias with any old query, it works fine:\n\n\n$ curl -s 'http://192.168.11.10:8983/solr/all/select?q=something&wt=json&qf=content' | jq .response.numFound\n20\n\n\n\nWhen I search with a query which matches the elevate.xml in one of the collections but not both, I get this error:\n\n\n$ curl -s 'http://192.168.11.10:8983/solr/all/select?q=tiedekunta&wt=json&qf=content' | jq .\n{\n  \"responseHeader\": {\n    \"zkConnected\": true,\n    \"status\": 500,\n    \"QTime\": 28,\n    \"params\": {\n      \"q\": \"tiedekunta\",\n      \"qf\": \"content\",\n      \"wt\": \"json\"\n    }\n  },\n  \"error\": {\n    \"trace\": \"java.lang.NullPointerException\\n\\tat org.apache.solr.handler.component.QueryComponent.unmarshalSortValues(QueryComponent.java:1227)\\n\\tat org.apache.solr.handler.component.QueryComponent.mergeIds(QueryComponent.java:1075)\\n\\tat org.apache.solr.handler.component.QueryComponent.handleRegularResponses(QueryComponent.java:775)\\n\\tat org.apache.solr.handler.component.QueryComponent.handleResponses(QueryComponent.java:754)\\n\\tat org.apache.solr.handler.component.SearchHandler.handleRequestBody(SearchHandler.java:429)\\n\\tat org.apache.solr.handler.RequestHandlerBase.handleRequest(RequestHandlerBase.java:173)\\n\\tat org.apache.solr.core.SolrCore.execute(SolrCore.java:2477)\\n\\tat org.apache.solr.servlet.HttpSolrCall.execute(HttpSolrCall.java:723)\\n\\tat org.apache.solr.servlet.HttpSolrCall.call(HttpSolrCall.java:529)\\n\\tat org.apache.solr.servlet.SolrDispatchFilter.doFilter(SolrDispatchFilter.java:361)\\n\\tat org.apache.solr.servlet.SolrDispatchFilter.doFilter(SolrDispatchFilter.java:305)\\n\\tat org.eclipse.jetty.servlet.ServletHandler$CachedChain.doFilter(ServletHandler.java:1691)\\n\\tat org.eclipse.jetty.servlet.ServletHandler.doHandle(ServletHandler.java:582)\\n\\tat org.eclipse.jetty.server.handler.ScopedHandler.handle(ScopedHandler.java:143)\\n\\tat org.eclipse.jetty.security.SecurityHandler.handle(SecurityHandler.java:548)\\n\\tat org.eclipse.jetty.server.session.SessionHandler.doHandle(SessionHandler.java:226)\\n\\tat org.eclipse.jetty.server.handler.ContextHandler.doHandle(ContextHandler.java:1180)\\n\\tat org.eclipse.jetty.servlet.ServletHandler.doScope(ServletHandler.java:512)\\n\\tat org.eclipse.jetty.server.session.SessionHandler.doScope(SessionHandler.java:185)\\n\\tat org.eclipse.jetty.server.handler.ContextHandler.doScope(ContextHandler.java:1112)\\n\\tat org.eclipse.jetty.server.handler.ScopedHandler.handle(ScopedHandler.java:141)\\n\\tat org.eclipse.jetty.server.handler.ContextHandlerCollection.handle(ContextHandlerCollection.java:213)\\n\\tat org.eclipse.jetty.server.handler.HandlerCollection.handle(HandlerCollection.java:119)\\n\\tat org.eclipse.jetty.server.handler.HandlerWrapper.handle(HandlerWrapper.java:134)\\n\\tat org.eclipse.jetty.rewrite.handler.RewriteHandler.handle(RewriteHandler.java:335)\\n\\tat org.eclipse.jetty.server.handler.HandlerWrapper.handle(HandlerWrapper.java:134)\\n\\tat org.eclipse.jetty.server.Server.handle(Server.java:534)\\n\\tat org.eclipse.jetty.server.HttpChannel.handle(HttpChannel.java:320)\\n\\tat org.eclipse.jetty.server.HttpConnection.onFillable(HttpConnection.java:251)\\n\\tat org.eclipse.jetty.io.AbstractConnection$ReadCallback.succeeded(AbstractConnection.java:273)\\n\\tat org.eclipse.jetty.io.FillInterest.fillable(FillInterest.java:95)\\n\\tat org.eclipse.jetty.io.SelectChannelEndPoint$2.run(SelectChannelEndPoint.java:93)\\n\\tat org.eclipse.jetty.util.thread.strategy.ExecuteProduceConsume.executeProduceConsume(ExecuteProduceConsume.java:303)\\n\\tat org.eclipse.jetty.util.thread.strategy.ExecuteProduceConsume.produceConsume(ExecuteProduceConsume.java:148)\\n\\tat org.eclipse.jetty.util.thread.strategy.ExecuteProduceConsume.run(ExecuteProduceConsume.java:136)\\n\\tat org.eclipse.jetty.util.thread.QueuedThreadPool.runJob(QueuedThreadPool.java:671)\\n\\tat org.eclipse.jetty.util.thread.QueuedThreadPool$2.run(QueuedThreadPool.java:589)\\n\\tat java.lang.Thread.run(Thread.java:748)\\n\",\n    \"code\": 500\n  }\n}\n\n\n\nIf I add enableElevation=false, it works fine:\n\n\n$ curl -s 'http://192.168.11.10:8983/solr/all/select?q=tiedekunta&wt=json&qf=content&enableElevation=false' | jq .response.numFound\n170\n\n\n\nSimilarly, if I search for the same word in either of the collections themselves, it works fine:\n\n\n$ curl -s 'http://192.168.11.10:8983/solr/intranet/select?q=tiedekunta&wt=json&qf=content' | jq .response.numFound\n100\n$ curl -s 'http://192.168.11.10:8983/solr/mysite.tld/select?q=tiedekunta&wt=json&qf=content' | jq .response.numFound\n71\n\n\n\nAnd finally, if I search the \"all\" alias for a word which is found in both collections' elevate.xml, it works fine:\n\n\n$ curl -s 'http://192.168.11.10:8983/solr/all/select?q=avoin&wt=json&qf=content' | jq .\n{\n  \"responseHeader\": {\n    \"zkConnected\": true,\n    \"status\": 0,\n    \"QTime\": 46,\n    \"params\": {\n      \"q\": \"avoin\",\n      \"qf\": \"content\",\n      \"wt\": \"json\"\n    }\n  },\n  \"response\": {\n    \"numFound\": 300,\n    \"start\": 0,\n    \"maxScore\": 5.8714366,\n    \"docs\": [\n      {\n        \"url\": REDACTED,\n        \"contentLength\": 62564,\n        \"mimetype\": \"text/html\",\n        \"id\": REDACTED,\n        \"[elevated]\": true\n      },\n      {\n        \"url\": REDACTED,\n        \"contentLength\": 38354,\n        \"mimetype\": \"text/html\",\n        \"id\": REDACTED,\n        \"[elevated]\": false\n      },\n --SNIP--\n\n\n\nTo conclude: Query Elevation breaks collection aliasing (atleast in cloud mode) when the queried string is a hit in one of the aliased collections' elevate.xml but not all of them.",
    "attachments": {},
    "issue_links": {},
    "comments": []
}