{
    "id": "LUCENE-2694",
    "title": "MTQ rewrite + weight/scorer init should be single pass",
    "details": {
        "labels": "",
        "priority": "Major",
        "components": [
            "core/search"
        ],
        "type": "Improvement",
        "fix_versions": [
            "4.0-ALPHA"
        ],
        "affect_versions": "None",
        "resolution": "Fixed",
        "status": "Closed"
    },
    "description": "Spinoff of LUCENE-2690 (see the hacked patch on that issue)...\n\nOnce we fix MTQ rewrite to be per-segment, we should take it further and make weight/scorer init also run in the same single pass as rewrite.",
    "attachments": {
        "LUCENE-2694_hack.patch": "https://issues.apache.org/jira/secure/attachment/12467887/LUCENE-2694_hack.patch",
        "LUCENE-2694-FTE.patch": "https://issues.apache.org/jira/secure/attachment/12466529/LUCENE-2694-FTE.patch",
        "LUCENE-2694.patch": "https://issues.apache.org/jira/secure/attachment/12459929/LUCENE-2694.patch"
    },
    "issue_links": {},
    "comments": [
        {
            "date": "2010-11-18T17:46:53+0000",
            "content": "I started on this issue with a rough idea and wanna upload it to get some initial feedback. The idea is to provide access to TermState via the TermsEnum Attribute API to eventually use the TermState inside of TermQuery to prevent a second lookup as well as term cache. Its very rough and I tried to go the least intrusive way as possible so the implementation is mainly to show the main principles.\n\nfeedback welcome. ",
            "author": "Simon Willnauer",
            "id": "comment-12933499"
        },
        {
            "date": "2010-11-18T18:06:55+0000",
            "content": "Havent looked closely into the patch (still need to understand the whole thing), just some comments from attribute policeman in general:\n\n\tThe TermStateAttributeImpl.copyTo should throw ClassCastEx if attributes are not conform (compare other impls), so the if statement should not be there. AttributeSource takes care of copying. This is not used, but for completeness.\n\tthe convenience addClause() method in abstract base class should be final! Else you could incorrectly override the wrong one. We already have code duplication in your patch because of this. When you make it final you will see!\n\twhy is the attribute using a SetOnce? Attributes generally should be modifiable multiple times. Now you have to call clear() first. This may change in future when we have set-once attributes, but for now that violates the contract \n\tIs the docFreq no already part of the state so TermCollectingRewrite does not need to expose it separately?\n\tWhat happens in the term collectors when the same term with different states are merged in the PQ/TermsHash/...?\n\n ",
            "author": "Uwe Schindler",
            "id": "comment-12933505"
        },
        {
            "date": "2010-11-18T18:45:03+0000",
            "content": "I would rather not use an attribute here \u2013 this is a very core thing so I think we should extend TermsEnum API.\n\nWe can just add a getTermState and a seek(TermState) to terms enum (and, actually, remove cacheTermState)?\n\nAlso, then we wouldn't need to add the get docs/positions enum methods to TermState. ",
            "author": "Michael McCandless",
            "id": "comment-12933517"
        },
        {
            "date": "2010-11-18T18:49:32+0000",
            "content": "Uwe I agree with your comments - I just didn't pay lots of attention to it since I was rather interested in feedback for the idea....\n\nI actually think that we should move the getTermState into the termsEnum though rather than using an attribute but for now that was easier to implement though.\n\nWhat happens in the term collectors when the same term with different states are merged in the PQ/TermsHash/...?\nThat one should work since I map the TermState per reader in a PerReaderTermState though.\n\nsimon ",
            "author": "Simon Willnauer",
            "id": "comment-12933522"
        },
        {
            "date": "2010-11-18T19:43:23+0000",
            "content": "We can just add a getTermState and a seek(TermState) to terms enum (and, actually, remove cacheTermState)?\nYes! please! - i used the attribute to move faster here since it didn't require to change the API really.\n\nAlso, then we wouldn't need to add the get docs/positions enum methods to TermState.\n\nyeah see above....\n\ni will workout a cleaner patch ",
            "author": "Simon Willnauer",
            "id": "comment-12933541"
        },
        {
            "date": "2010-11-19T16:54:08+0000",
            "content": "next iteration. This patch removes the term cache completely and exposes getTermState via TermsEnum. Terms, TermsEnum and IndexReader can now obtain a DocEnum directly by passing in a TermState.\n\nI need to run some benchmarks on an index with several segments on a index with two segments its just slightly faster...\nmike do you have one ready? ",
            "author": "Simon Willnauer",
            "id": "comment-12933862"
        },
        {
            "date": "2010-11-19T17:57:09+0000",
            "content": "Phew that was fast!\n\nWow, you nuked the terms dict cache  Nice!\n\nThough it makes me a bit nervous... like there'll always be a risk\nwe've missed some path through Lucene that does two lookups...  And,\neven for external reasons (eg same query arrives to Lucene, looking\nfor next page or something), the cache is useful.\n\nEG, a straight TermQuery (not spawned by MTQ) is now hitting the terms\ndict twice.  Once inside Sim.idfExplain, where it calls\nsearcher.docFreq(term), and then again to pull the scorers per sub\nreader.  Probably, TermQuery should pull the PerReaderTermState, up\nfront, if it wasn't already handed it?  And then pass the docFreq to\nSim.idfExplain.\n\nShould we add a PerReaderTermState.docFreq(), which just sums up\nacross all subs?\n\nDoes TermState really need field()?  Seems wasteful to have to store\nthat... eg an MTQ will store many TermStates against the same field.\nI think we should keep TermState lean.\n\nAlso, I think it shouldn't need that clone method?\n\nI think instead of duplicating docs/docsAndPositions (and soon\nbulkPostings) on TermsEnum, once for TermState and once without, we\nshould just add a seek(TermState)?  And then the single\ndocs/docsAndPositions/etc. method can be used to get the enum for that\nterm.  (Likewise for Terms) Also, we should remove docFreq and ord\nfrom TermsEnum since you should get it from TermState?\n\nI think IndexReader can offer the sugar methods (that take either\nBytesRef term or String field + TermState state).\n\nAlso: I tried to run the benchmark on beast but unfortunately there's\na bug somewhere (even though Lucene core tests pass) \u2013 I see\ndifferent results for some fuzzy queries.\n\nNice work!!  Getting to single term lookup for all queries will be awesome! ",
            "author": "Michael McCandless",
            "id": "comment-12933888"
        },
        {
            "date": "2010-11-21T12:04:05+0000",
            "content": "BTW, one use case where this patch should show a sizable performance gain is a \"primary key lookup\" against a multi-segment index.\n\nSo this'd be a TermQuery against eg an \"id\" field, where the app knows at most one doc contains the requested value.\n\nToday, we pay a high price for the 2nd pass, because we do not cache a miss against a segment.  So on the first pass (computing IDF) we know which segment has a match and which segments do not, but then on the 2nd pass we re-pay the lookup cost against all the misses (the single segment w/ the hit will be cached).\n\nSo this ought to be a big win... especially once we combine this w/ the speedups from pulsing codec (we still need to cutover to this as a default) then primary key lookups in a Lucene index will be much faster... ",
            "author": "Michael McCandless",
            "id": "comment-12934260"
        },
        {
            "date": "2010-12-16T15:57:52+0000",
            "content": "Attaching current state - all test pass for me and luceneutils brings consistent results with trunk.\n\n\n               Query   QPS trunkQPS termstate  Pct diff\n            unit~2.0       14.70       14.39     -2.1%\n          united~2.0        6.91        6.83     -1.1%\n          united~1.0        7.42        7.38     -0.6%\n        \"unit state\"       12.31       12.37      0.5%\n            unit~1.0       15.41       15.49      0.5%\n                uni*        7.18        7.22      0.6%\n                un*d        7.97        8.04      0.9%\n               unit*       12.89       13.09      1.6%\n        +unit +state       28.16       28.64      1.7%\n    +nebraska +state       81.26       82.67      1.7%\nspanNear([unit, state], 10, true)       11.60       11.83      2.0%\n               state       40.50       41.47      2.4%\n  spanFirst(unit, 5)       47.65       48.84      2.5%\n          unit state       17.72       18.19      2.7%\n                 u*d        4.27        4.48      5.0%\n\n\nthose are the results I have for now.... Fuzzy only expands to 50 terms so that might no be very meaningful. I re-added the TermCache for this patch though... \nWill attach more info tomorrow. ",
            "author": "Simon Willnauer",
            "id": "comment-12972125"
        },
        {
            "date": "2010-12-16T16:06:15+0000",
            "content": "We shouldn't lose the clone() optimization in StandardPostingsReader... \nthe class is final so it should use 'copy' instead of calling super.clone()\nThis is important for -client. ",
            "author": "Robert Muir",
            "id": "comment-12972127"
        },
        {
            "date": "2010-12-17T18:40:41+0000",
            "content": "FYI - there is a coding error in the latest patch that causes the TermState to be ignored - TermWeight uses the wrong reference to the PerReaderTermState. I will upload a new patch later this weekend\n\nsimon ",
            "author": "Simon Willnauer",
            "id": "comment-12972586"
        },
        {
            "date": "2010-12-17T19:24:41+0000",
            "content": "here is a new patch. I removed the hacky TermWeight part to make only MTQ single pass for now. Other TermQueries will hit the TermCache for now.  No nocommit left. Currently there is some duplication / unncessary classes in the TermState hierarchy - that needs cleanup. \n\nBTW. I see some highlighter test failing - will look into this later...\nsimon ",
            "author": "Simon Willnauer",
            "id": "comment-12972607"
        },
        {
            "date": "2010-12-18T09:35:21+0000",
            "content": "If I force scoring BQ rewrite for wildcard & prefix queries (ie set that rewrite mode and then relax BQ max clause count) I see healthy speedups (~23-27%) for these queries!  Great \n\nWhile this doesn't happen w/ our default settings (ie these queries quickly cutover to constant filter rewrite), apps that change these defaults will see a gain, plus, the term cache (which today \"protects\" you) is terribly fragile since apps w/ many MTQ queries in flight can thrash that cache thus killing performance.  This patch prevents that entirely since MTQs do their own caching of the TermStates they need: awesome. ",
            "author": "Michael McCandless",
            "id": "comment-12972758"
        },
        {
            "date": "2010-12-18T09:35:43+0000",
            "content": "I love seeing cacheCurrentTerm removed!!\n\nOK I think we are close!  A bunch of smallish things:\n\n\n\tI think we should remove TermsEnum.docFreq and .ord?  Ie replace\n    with .termState().docFreq() and .ord()?\n\n\n\n\n\tAt first I was thinking we should merge up TermStateBase into\n    TermState but actually there are cases (eg PulsingCodec, which )\n    where you want the separation.\n\n\n\n\n\tMaybe rename TermStateBase -> PrefixCodedTermState?  Ie this is\n    really the TermState impl used by any codec using\n    PrefixCodedTerms?  EG the fact that it stores the filePointer into\n    a _X.tis file is particular to it...\n\n\n\n\n\tMaybe rename MockTermState -> BasicTermState?  At first I was\n    thinking the codec should return null if it cannot seek by\n    TermState... (I generally don't like mock returns that hide/lose\n    information...) but then it's convenient to always have something\n    to hold the docFreq for the term to avoid lots of special cased\n    code... so I think it's OK?\n\n\n\n\n\tWe lost the \"clone using new\" in StandardTermState...\n\n\n\n\n\tMaybe revert changes to AppendingCodec?  (Ie let it pass its terms\n    dict cache size again)\n\n\n\n\n\tI wonder if we can somehow make PerReaderTermState use an array\n    (keyed by sub reader index) instead... seems like a new HashMap\n    per Term in an MTQ could be heavy.  It's tricky because we don't\n    store enough information (ie to quickly map parent reader + sub\n    reader -> sub index). But I don't think this should hold up\n    committing... since our defaults don't typically allow for that\n    many terms in-flight it should be fine...\n\n\n\n\n\tIt's a little spooky the TermQuery.scorer calls .take()\n    (destructive), eg it means if you ask for scorer again on same\n    reader you get diff't behavior?  Can we make that a .get() instead\n    of .take()?  (This may also bite us if we use diff't threads to\n    score each segment, ie suddenly this .take() must be thread safe).\n    In fact, same deal w/ nulling out the TQ.perReaderTermState?\n\n\n\n\n\tThe comment on top of TermStateByteStart looks wrong?\n\n\n\n\n\tSmall whitespace issue \u2013 missing space on \"if(\".  Also, our\n    generics are not supposed to have whitespace inside, eg we\n    shouldn't have the space in \"new DoubleBarrelLRUCache<FieldAndTerm, TermStateBase>(termsCacheSize);\"\n\n\n\n\n\tI think the TQ ctor that takes both docFreq and states can drop\n    the docFreq?  Ie it can ask the states for it?\n\n ",
            "author": "Michael McCandless",
            "id": "comment-12972759"
        },
        {
            "date": "2010-12-18T10:34:57+0000",
            "content": "I have also some things:\n\n\tWe currently don't support seeking a FilteredTermsEnum, this is disallowed by UnsupportedOperationException (we may change this, but its complicated, Robert and me are thinking about it, but for now its disallowed, as it would break the enum logic). So the TermState seek method in FilteredTermsEnum should also throw UOE:\n\n/** This enum does not support seeking!\n * @throws UnsupportedOperationException\n */\n@Override\npublic SeekStatus seek(BytesRef term, boolean useCache) throws IOException {\n  throw new UnsupportedOperationException(getClass().getName()+\" does not support seeking\");\n}\n\n\n\tAdditionally, can the next() implementation in FilteredTermsEnum use TermState? It does lots of seeking on the underlying (filtered) TermsEnum. This is the reason why sekking on the FilteredTermsEnum is not allowed. Filtering is done here on the accept() methods.\n\tFor what is setNextReader in TermCollector? I don't like that, but you seems to need it for the PerReaderTermState. The collector should really only work on the enum not on any reader. At least the\n\n\n\nThats what I have seen on first patch review, will now apply patch and look closer into it  But the first point is important, FilteredTermsEnum currently should not support seeking. ",
            "author": "Uwe Schindler",
            "id": "comment-12972769"
        },
        {
            "date": "2010-12-18T11:36:11+0000",
            "content": "Here just the patch for a correct behaving FilteredTermsEnum (according to docs, that it does currently not support seeking). The assert is also not needed, as tenum is guranteed to be not null (its final and ctor already asserts this)  ",
            "author": "Uwe Schindler",
            "id": "comment-12972777"
        },
        {
            "date": "2010-12-19T15:46:54+0000",
            "content": "\nI think we should remove TermsEnum.docFreq and .ord? Ie replace\nwith .termState().docFreq() and .ord()?\n\nI disagree on that - at least docFreq() is an essential part of the API and we should not force TermState creation just to get the df. Yet, TermState is an expert API you should not need to pull an expert API to get something essential like df.\nI would leave those as they are or only pull ord into TermState.\n\n\nMaybe rename TermStateBase -> PrefixCodedTermState? Ie this is\nreally the TermState impl used by any codec using\nPrefixCodedTerms? EG the fact that it stores the filePointer into\na _X.tis file is particular to it..\nYeah that sounds reasonable.\n\n\nMaybe rename MockTermState -> BasicTermState? At first I was\nthinking the codec should return null if it cannot seek by\nTermState... (I generally don't like mock returns that hide/lose\ninformation...) but then it's convenient to always have something\nto hold the docFreq for the term to avoid lots of special cased\ncode... so I think it's OK?\n\nI think we can get rid of it entirely. We can use TermStateBase for it and let PrefixCodedTermState just add the pointer though. That way we get rid of it nicely. I would like to keep that api as it is since it makes the usage easier especially in the rewrite methods..\n\nWe lost the \"clone using new\" in StandardTermState...\nI don't get that really - IMO this is quite minor but I will look into it again... \n\n\nMaybe revert changes to AppendingCodec? (Ie let it pass its terms\ndict cache size again)\n\nunintentional - will fix \n\n\n\n wonder if we can somehow make PerReaderTermState use an array\n(keyed by sub reader index) instead... seems like a new HashMap\nper Term in an MTQ could be heavy. It's tricky because we don't\nstore enough information (ie to quickly map parent reader + sub\nreader -> sub index). But I don't think this should hold up\ncommitting... since our defaults don't typically allow for that\nmany terms in-flight it should be fine...\n\nI actually had this in a very similar way. I used a custom linked list and relied on the fact that the incoming reader are applied in the same order and skipped until the next reader with that term appeared. I changed that back to Map impl to make it simpler since I didn't see speedups - well this was caused by a very nifty coding error  \n\ni think I have that patch around somewhere is the history... lets see..\n\nI think the TQ ctor that takes both docFreq and states can drop the docFreq? Ie it can ask the states for it?\n\nyeah sure - well the patch is my current state since I had to drop everything and leave on friday... I clean up an upload a new patch early this week\n\n@Uwe: I will incorporate your fix - thanks\n\n ",
            "author": "Simon Willnauer",
            "id": "comment-12973003"
        },
        {
            "date": "2010-12-19T16:57:22+0000",
            "content": "I would leave those as they are or only pull ord into TermState.\n\nI agree about docfreq, but ord should go. Ord should be in e.g. StandardTermState, but not in TermState nor TermsEnum.\n\nThis is an implementation detail for our current terms dictionary, and its silly how we just throw UOE for other codecs:\nIts codec-specific. Other terms implementations might have \"something like an ord\" but it definitely might not even be a long!\n\nWithin StandardCodec etc this creates no problem as it still has access to it. If we find ourselves wanting/needing to use ord\noutside of Standard we should ask ourselves why this is and instead fix the APIs to not depend on some codec-specific long value. ",
            "author": "Robert Muir",
            "id": "comment-12973018"
        },
        {
            "date": "2010-12-19T18:38:56+0000",
            "content": "Here are some numbers for the latest patch with 10M wiki index (commitpoint: delmulti) and all MTQ rewriting to ScoreBoolean:\n\n\n               Query    QPS base    QPS spec  Pct diff\n    +nebraska +state       42.96       42.17     -1.8%\n          unit state        3.63        3.61     -0.4%\n        \"unit state\"        1.72        1.71     -0.3%\n               state       10.55       10.54     -0.1%\nspanNear([unit, state], 10, true)        0.96        0.96      0.1%\n        +unit +state        4.03        4.04      0.2%\n  spanFirst(unit, 5)        4.83        4.86      0.7%\n          united~1.0        4.76        4.86      2.1%\n            unit~1.0        2.62        2.69      2.7%\n          united~2.0        0.82        0.84      2.8%\n            unit~2.0        0.34        0.37      8.2%\n                un*d        3.55        4.14     16.6%\n                uni*        0.52        0.61     18.1%\n                 u*d        0.47        0.57     19.9%\n               unit*        2.04        2.52     23.8%\n\n ",
            "author": "Simon Willnauer",
            "id": "comment-12973031"
        },
        {
            "date": "2010-12-19T22:19:41+0000",
            "content": "\nI disagree on that - at least docFreq() is an essential part of the API and we should not force TermState creation just to get the df. Yet, TermState is an expert API you should not need to pull an expert API to get something essential like df.\nI would leave those as they are or only pull ord into TermState.\n\nOK I agree, let's leave at least dF directly in TermsEnum.\n\nCalling .termState presumably entails a clone right?  Ie the returned object is guaranteed private?  So that's a good reason not to require it...\n\n\nI actually had this in a very similar way. I used a custom linked list and relied on the fact that the incoming reader are applied in the same order and skipped until the next reader with that term appeared. I changed that back to Map impl to make it simpler since I didn't see speedups - well this was caused by a very nifty coding error \n\nLet's just stick w/ map for now I think?  Progress not perfection! ",
            "author": "Michael McCandless",
            "id": "comment-12973046"
        },
        {
            "date": "2010-12-20T15:25:59+0000",
            "content": "here is a new patch with a slightly different implementation of PerReaderTermState. I build a view from the subreader used to build the MTQ which is shared across all PerReaderTermState instance for the query. The PrTS then uses only the ordinal from the ReaderView to reference a TermState which prevents us from creating Map instances for each term. In turn this also made it possible to fall back to re-seeking the TermDict if the reader is not in the view. \n\nI fixed all other issues and all tests including the highlighter pass now.\n ",
            "author": "Simon Willnauer",
            "id": "comment-12973226"
        },
        {
            "date": "2010-12-20T18:46:03+0000",
            "content": "mike - do you mind if I take this?\n\nsimon ",
            "author": "Simon Willnauer",
            "id": "comment-12973295"
        },
        {
            "date": "2010-12-21T11:43:23+0000",
            "content": "mike - do you mind if I take this?\n\nOf course not!  Please take it  ",
            "author": "Michael McCandless",
            "id": "comment-12973589"
        },
        {
            "date": "2010-12-21T11:44:04+0000",
            "content": "Patch looks awesome!\n\nReally, ord() support is a function of the terms dict impl, not the\ncodec (well, indirectly codec has ord() support if its terms dict impl\ndoes).  PrefixCodedTermsDict, in turn, supports ord() only if its\nterms index does.\n\nCan we move TermStateBase (now under codecs.standard) up into codecs\nand rename it to PrefixCodedTermState?  Ie, it's awkward that\nPrefixCodedTermsReader (a terms dict impl shared across many codecs)\nis reaching into standard codec to get its TermState impl.  Then, the\nprivate static class in StandardPostingsReader can be renamed to\nStandardTermState?\n\nI like this new ReaderView!  I think it can be more generally useful\noutside of PerReaderTermState, eg Filter/Collector could receive this\nso that they can map sub reader to context in parent.  But let's leave\nthat for another day.\n\nStill some small whitespace issues, eg if( ",
            "author": "Michael McCandless",
            "id": "comment-12973591"
        },
        {
            "date": "2010-12-21T11:46:43+0000",
            "content": "OK I tested perf on 10 M wiki index, multi-segment no deletes.  For the test I [unnaturally] forced Prefix & Wildcard queries to always use scoring BQ rewrite (and upped the BQ max clause count way high) to force testing of TermState.\n\n\n\n\nQuery\nQPS mmap\nQPS mmap\nPct diff\n\n\n\"unit state\"~3\n5.29\n4.96\n-6.3%\n\n\nunit state\n11.70\n11.21\n-4.2%\n\n\n\"unit state\"\n7.80\n7.71\n-1.2%\n\n\nspanNear([unit, state], 10, true)\n4.58\n4.53\n-1.1%\n\n\nstate\n29.42\n29.39\n-0.1%\n\n\nunit~2.0\n9.90\n9.91\n0.2%\n\n\ndoctimesecnum:[10000 TO 60000]\n9.52\n9.55\n0.3%\n\n\n+unit +state\n11.04\n11.09\n0.4%\n\n\nunit~1.0\n10.11\n10.19\n0.7%\n\n\nunited~2.0\n3.34\n3.36\n0.8%\n\n\nspanFirst(unit, 5)\n16.71\n16.93\n1.3%\n\n\n+nebraska +state\n195.03\n198.25\n1.7%\n\n\nunited~1.0\n15.78\n16.11\n2.1%\n\n\nun*d\n12.59\n29.45\n133.9%\n\n\nunit*\n6.87\n16.54\n140.7%\n\n\nu*d\n2.39\n6.66\n178.2%\n\n\nuni*\n1.82\n5.29\n190.6%\n\n\n\n\n\nAwesome speedups! ",
            "author": "Michael McCandless",
            "id": "comment-12973592"
        },
        {
            "date": "2010-12-21T15:33:13+0000",
            "content": "\nCan we move TermStateBase (now under codecs.standard) up into codecs\nand rename it to PrefixCodedTermState? Ie, it's awkward that\nPrefixCodedTermsReader (a terms dict impl shared across many codecs)\nis reaching into standard codec to get its TermState impl. Then, the\nprivate static class in StandardPostingsReader can be renamed to\nStandardTermState?\ndone - that makes sense \n\n\nStill some small whitespace issues, eg if(\ndone\n\nI think we are close  ",
            "author": "Simon Willnauer",
            "id": "comment-12973703"
        },
        {
            "date": "2010-12-21T21:25:31+0000",
            "content": "I think instead of ReaderView we could change Weight.scorer API so that instead of receiving IndexReader reader, it receives a struct that has parent reader, sub reader, ord of that sub?\n\nIt's easy to be back compat because we could just forward to prior scorer method with only the sub? ",
            "author": "Michael McCandless",
            "id": "comment-12973895"
        },
        {
            "date": "2010-12-22T09:28:34+0000",
            "content": "\nI think instead of ReaderView we could change Weight.scorer API so that instead of receiving IndexReader reader, it receives a struct that has parent reader, sub reader, ord of that sub?\nIt's easy to be back compat because we could just forward to prior scorer method with only the sub?\nMike I am not sure if that helps us here. If you use this method you can not disambiguate between the set of readers that where used to create the PerReaderTermState and the once that have a certain ord assigned to it. Disambiguation would be more difficult if we do that. IMO sharing a ReaderView seems to be the best solution so far. I don't think we should bind it to an IR directly since users can easily build a ReaderView from a Composite Reader. Yet, for searching it would be nice to have a ReaderView on Seacher / IndexSearcher which can be triggered upon weight creation.\nThat way we can also disambiguate between PerReaderTermState given to the TermQuery ctor when we create the weight so that if the view doesn' t match we either create a new PerReaderTermState or just don't use it for this weight.\n\nI thought about TermsEnum#ord() again. I don' t think we should really add it back though. Its really an implementation detail and folks that wanna use it should be aware of that and cast correctly. On the other hand I don't like to have the seek(ord) in TermsEnum either if we remove #ord(). I think we should remove it from the interface entirely though.\n\nsimon ",
            "author": "Simon Willnauer",
            "id": "comment-12974121"
        },
        {
            "date": "2010-12-22T15:53:55+0000",
            "content": "I think instead of ReaderView we could change Weight.scorer API so that instead of receiving IndexReader reader, it receives a struct that has parent reader, sub reader, ord of that sub?\n\nso I changed the Weight#scorer API to use a class called ScoreContext that holds the parent reader, the current sub and the subs ord. That change is absolutely massive! I don't upload that change since I think if we do that we need to do it in a different issue anyway. I ran into a couple of problems:\n\n\n\tif we pass in such a context we also need to change the explain interface since its calling Weight#scorer here and there\n\tOnce we pass in the Context stuff like QueryWrapperFilter doesn't work anymore since it doesn't know which ord the incoming reader has. So Filters would need a context too. I don't like that!\n\tStuff like scoreDocsInOrder are hard to put into such a context since almost all scorers internally are called with scoreDocsInOrder=true with a contant. meaning that nobody really respects the incoming value for subscorers though. but if i just forward the context the member needs to be set to true or the context needs to be cloned for subs - see BooleanQuery for instance.\n\n\n\n\n\tsuch a context would somehow enforce that MTQ are only executed against the Reader they where rewritten against. Which is how it should be IMO but we are also depending on that everybody who uses a MTQ knows exactly how the query was rewritten which is kind of not obvious. I think we need a better way to enforce stuff like that.\n\n\n\nafter all I think this must be done in a different issue though. This issue was meant to make MTQ single pass so lets do that first.... progress over perfection ey mike . \nNonetheless, it seems like that we need to rethink the Weight API entirely I also don't like that Weight operates on Searcher instead of IndexSearcher though. ",
            "author": "Simon Willnauer",
            "id": "comment-12974251"
        },
        {
            "date": "2010-12-22T16:32:48+0000",
            "content": "after all I think this must be done in a different issue though\n\n+1\n\nIf, when we now pass a naked IndexReader (eg to Weight.scorer, Weight.explain, Filter.getDocIdSet) we replace that with a ReaderContext which has reader, its parent, and its ord, then this precursor makes both TermState (this issue) and the awesome PK speedup (LUCENE-2829) much simpler.  And I agree we should break it out as its own issue.  It's good to do that as its own issue since that's a rote API cutover \u2013 we are passing a struct instead of a naked reader, but otherwise no change.\n\nThis also lets us solve cases where the Filter needs the full context, eg LUCENE-2348.\n\nAlso, with this I think we should sharpen in the jdocs that when you call Query.rewrite the returned query must be searched only against he same reader you rewrote against.  Similarly when you create a Weight, it should only be used against the same Searcher used to create it from a Query. ",
            "author": "Michael McCandless",
            "id": "comment-12974265"
        },
        {
            "date": "2011-01-10T11:27:15+0000",
            "content": "Another iteration on this after LUCENE-2831 was committed last week. \n\n\n\tupdated to trunk & all test pass\n\tre-added all ord() related stuff back to TermsEnum since I think we should decouple this and solve it in a different issue. There is already enough changes in here and discussions should be focused on making MTQ single pass.\n\tChanged IndexSearcher to run concurrent searches on a \"leaf slice\" rather than on a leaf converted to a Top-Level Context. That made the callables a bit simpler and is more consistent since the hierarchy is preserved.\n\tTermState is now referenced by leaf ordinal and asserted using the leaf's top-level ctx.\n\tTermQuery is not single pass for all queries while state is only hold in Weight unless PerReaderTermState as not set. But even then the top-level ctx must be identical to the given IS's top-level ctx otherwise the give PerReaderTermState is not used.\n\n\n\nthis one seems pretty close  ",
            "author": "Simon Willnauer",
            "id": "comment-12979544"
        },
        {
            "date": "2011-01-10T12:21:58+0000",
            "content": "One question, I'm look at the definition of TermState:\n\nHolds all state required for {@link TermsEnum} to produce a {@link DocsEnum} without re-seeking the terms dict.\n\n\n\nSo why do we have seek(BytesRef, TermState)\nshouldnt it just be seek(Termstate) ?\nI think its confusing it takes an unnecessary bytes parameter. ",
            "author": "Robert Muir",
            "id": "comment-12979562"
        },
        {
            "date": "2011-01-10T13:35:07+0000",
            "content": "here's a hack patch (dont think it actually works) just showing what i mean.\n\nI think termsenum should only have seek(TermState).\nin the hack-patch, i made the termState() and seekTermState() non-abstract:\nthe default impl returns a 'SimpleTermState' containing the term bytes and saved docFreq and implements seek(TermState) with those bytes.\n\nThis is basically what the patch had everywhere anyway as an implementation (for many of these, we should use more efficient impls, i fixed this for MemoryIndex as an example, but MultiTermsEnum comes to mind).\n\nAlso, i don't understand what was going on with setting bytes on the DeltaBytesReader with your seek(BytesRef, TermState) before.\n\nIf StandardCodec needs to know the shared byte[] prefix or something like that to reposition the enum, then it\nshould put this in its termstate.\n\n ",
            "author": "Robert Muir",
            "id": "comment-12979576"
        },
        {
            "date": "2011-01-11T11:44:41+0000",
            "content": "Next iteration.  I took roberts patch and cleaned up a few things and added a new OrdTermState that can be used for instanceof testing and thoughout all TermsEnum that use ord primarily. I also removed the docFreq() getter from TermState since its really an impl. detail. The downside of this patch is that PrefixCodedTermState is kind of heavyweight now since it carries the BytesRef to re-init the DeltaBytesReader but I didn't see another way to fix this right now.\n ",
            "author": "Simon Willnauer",
            "id": "comment-12980065"
        },
        {
            "date": "2011-01-11T12:18:39+0000",
            "content": "The failure in TestFSTs is because PrefixCodedTermsReader is somehow returning an OrdTermState when its terms index (var gap) does not support ord.\n\nThe ord member of PrefixCodedTermState is undefined when the terms dict doesn't support ord (ie when ord() throws UOE).\n\nSo to fix this we should fix TestFSTs to go back to calling .ord() and catching the UOE, maybe?  Separately, make sure you don't overwrite storeOrds in that test.  Ie the test randomly sets it to true or false (so that we test both cases); only if the terms index cannot suppord ord should we wire it to false.  If it can support ord then we should leave it as the random value... ",
            "author": "Michael McCandless",
            "id": "comment-12980081"
        },
        {
            "date": "2011-01-11T15:26:20+0000",
            "content": "fixed the TestFST - thanks mike for looking into that and updated to trunk ",
            "author": "Simon Willnauer",
            "id": "comment-12980144"
        },
        {
            "date": "2011-01-12T14:07:38+0000",
            "content": "This patch changes TermsEnum#seek(TermState) back to TermsEnum#seek(BytesRef, TermState). Yet, TermState is opaque now and TermsEnum has a default impl for TermsEnum#seek(BytesRef, TermState). Holding the BytesRef in TermState for our PrefixCoded* based codecs seems way too costly though. seems like this time perf rules out purity in the interface. ",
            "author": "Simon Willnauer",
            "id": "comment-12980722"
        },
        {
            "date": "2011-01-12T15:22:14+0000",
            "content": "seems like this time perf rules out purity in the interface.\n\nI know i didn't like this aspect of the patch, but I am ok with it for now as long as we keep things experimental and try to keep an eye on improving the 'purity' of TermsEnum a bit.\nwe are making a lot of progress on the terms handling with flexible indexing and i could easily see more interesting implementations being available other than just PrefixCoded...\nIn some ideal world I guess i'd prefer if TermsEnum was an attributesource with seek() and next(), FilteredTermsEnum was like tokenFilter, and TermState was just captureState/restoreState...\nbut I agree we should just lean towards whatever works for now.\n\ndefinitely like it better now that things such as docFreq() are pulled out of termstate and its completely opaque, i think this is the right way to go. ",
            "author": "Robert Muir",
            "id": "comment-12980748"
        },
        {
            "date": "2011-01-12T16:23:35+0000",
            "content": "Added Changes.txt entry and fixed the remaining JavaDoc on TermState. \n\nMy latest benchmark results with that patch are here:\n\n          unit state        3.81        3.70     -2.9%\n    +nebraska +state       41.26       40.61     -1.6%\n        +unit +state        3.95        3.90     -1.1%\n  spanFirst(unit, 5)        4.55        4.51     -0.9%\n               state       10.11       10.07     -0.3%\n      \"unit state\"~3        0.98        0.98     -0.2%\n        \"unit state\"        1.49        1.49     -0.0%\n          united~1.0        3.66        3.72      1.5%\n            unit~1.0        2.33        2.37      1.6%\n          united~2.0        0.81        0.83      2.7%\n            unit~2.0        0.35        0.38     10.1%\n                 u*d        0.52        0.67     29.5%\ndoctitle:.*[Uu]nited.*        0.19        0.25     31.6%\n                un*d        3.59        4.77     33.0%\n                uni*        0.56        0.75     34.9%\n               unit*        2.20        3.15     43.3%\n\n\n\nI think we are ready to go - I will commit later today if nobody objects ",
            "author": "Simon Willnauer",
            "id": "comment-12980778"
        },
        {
            "date": "2011-01-12T16:55:45+0000",
            "content": "I just figured that PKLookups are actually slower with this patch 164 msec for 1000 lookups (164 us per lookup) vs 144 msec for 1000 lookups (144 us per lookup) on trunk. I will dig! ",
            "author": "Simon Willnauer",
            "id": "comment-12980805"
        },
        {
            "date": "2011-01-12T20:53:39+0000",
            "content": "Actually I see PK lookups faster \u2013 23 usec w/ patch vs 33 usec w/ trunk (per lookup) for 20K lookups.\n\nAnd good speedups on many-term MTQs when I force BQ rewrite:\n\n\n\n\n\nQuery\nQPS base\nQPS termstate\nPct diff\n\n\n+nebraska +state\n169.75\n154.64\n-8.9%\n\n\ndoctitle:.[Uu]nited.\n4.26\n4.11\n-3.5%\n\n\n+unit +state\n11.40\n11.09\n-2.7%\n\n\nspanFirst(unit, 5)\n17.38\n16.93\n-2.6%\n\n\nspanNear([unit, state], 10, true)\n4.37\n4.32\n-1.2%\n\n\n\"unit state\"~3\n4.94\n4.89\n-1.0%\n\n\n\"unit state\"\n8.05\n8.03\n-0.2%\n\n\nstate\n26.58\n26.76\n0.7%\n\n\nunit state\n11.24\n11.46\n1.9%\n\n\nunited~2.0\n3.87\n3.98\n2.8%\n\n\ndoctimesecnum:[10000 TO 60000]\n8.26\n8.70\n5.3%\n\n\nunit~2.0\n10.04\n10.59\n5.4%\n\n\nunited~1.0\n16.84\n18.13\n7.7%\n\n\nunit~1.0\n10.09\n10.99\n8.9%\n\n\nun*d\n11.96\n21.63\n80.8%\n\n\nunit*\n7.60\n14.23\n87.3%\n\n\nu*d\n2.22\n4.17\n87.8%\n\n\nuni*\n1.83\n3.53\n93.7%\n\n\n\n\n\n+1 to commit! ",
            "author": "Michael McCandless",
            "id": "comment-12980921"
        },
        {
            "date": "2011-01-12T21:32:31+0000",
            "content": "Here is a final patch, I opened up Terms#getThreadTermsEnum() to reuse TermsEnum in PRTE#build().\nPRTE#build() now also accepts a boolean if the termlookup should be cached or not which makes sense for common TermQuery.\n\nI will commit that shortly - yay! ",
            "author": "Simon Willnauer",
            "id": "comment-12980938"
        },
        {
            "date": "2011-01-12T21:34:29+0000",
            "content": "Actually I see PK lookups faster - 23 usec w/ patch vs 33 usec w/ trunk (per lookup) for 20K lookups.\nso I run that on a 32bit machine which is quite slow in general though. I will further investigate that on 32bit platform vs. 64 bit. Yet, I only used 1k lookups though. ",
            "author": "Simon Willnauer",
            "id": "comment-12980941"
        },
        {
            "date": "2011-01-12T21:40:50+0000",
            "content": "Committed revision 1058328. ",
            "author": "Simon Willnauer",
            "id": "comment-12980947"
        }
    ]
}