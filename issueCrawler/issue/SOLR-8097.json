{
    "id": "SOLR-8097",
    "title": "Implement a builder pattern for constructing a Solrj client",
    "details": {
        "components": [
            "SolrJ"
        ],
        "type": "Improvement",
        "labels": "",
        "fix_versions": [
            "6.1",
            "7.0"
        ],
        "affect_versions": "6.0",
        "status": "Resolved",
        "resolution": "Fixed",
        "priority": "Major"
    },
    "description": "Currently Solrj clients (e.g. CloudSolrClient) supports multiple constructors as follows,\npublic CloudSolrClient(String zkHost) \npublic CloudSolrClient(String zkHost, HttpClient httpClient) \npublic CloudSolrClient(Collection<String> zkHosts, String chroot)\npublic CloudSolrClient(Collection<String> zkHosts, String chroot, HttpClient httpClient)\npublic CloudSolrClient(String zkHost, boolean updatesToLeaders)\npublic CloudSolrClient(String zkHost, boolean updatesToLeaders, HttpClient httpClient)\n\nIt is kind of problematic while introducing an additional parameters (since we need to introduce additional constructors). Instead it will be helpful to provide SolrClient Builder which can provide either default values or support overriding specific parameter.",
    "attachments": {
        "SOLR-8097.patch": "https://issues.apache.org/jira/secure/attachment/12785439/SOLR-8097.patch"
    },
    "issue_links": {},
    "comments": [
        {
            "date": "2016-01-09T23:49:17+0000",
            "author": "Jason Gerlowski",
            "content": "I'm gonna take a first pass at this.\n\nIs the goal/hope for this JIRA that the builder will allow us to deprecate/remove the CloudSearchClient ctors?  (If so, should I remove them in this patch?)  Or is the hope just that this will prevent additional ctors from being needed in the future? ",
            "id": "comment-15090826"
        },
        {
            "date": "2016-01-10T21:53:07+0000",
            "author": "Jason Gerlowski",
            "content": "My comment above implies some questions about the measures we try to take in ensuring backward-compatibility in SolrJ code.  I'm still new to the Solr community, so I'm not quite sure how things are typically done here.\n\nMy assumption up to this point is that core SolrJ APIs (i.e. Java ctor/method signatures) can only be changed by a major release.  (This appears to have been confirmed by most of the discussion on the recent \"Breaking Java back-compat in Solr\" mailing list thread, by my reading of it at least.)\n\nI'm also a little unclear on what \"deprecation\" means within the Solr community.  Can a deprecation warning appear on a non-major release?  How long does a deprecation warning typically stay around before the API can be removed altogether?  Anyone have a pointer to an article/wiki where I can read up on this?\n\n\nThat said, this isn't relevant/necessary to start working on a patch, as long as I don't touch any of the existing ctors.  So that's how I'll go forward with things until I hear feedback otherwise.  I'll start putting together a purely-additive patch off of trunk later tonight or tomorrow. ",
            "id": "comment-15091257"
        },
        {
            "date": "2016-01-11T03:16:34+0000",
            "author": "Shawn Heisey",
            "content": "Code written and compiled with a particular version of SolrJ should work properly if the SolrJ jar is replaced with a newer minor version.  This compatibility is not expected if the jar is replaced with a newer major version.\n\nThe general goal is that the Solr Java API will not change in minor versions, but this is not guaranteed.  The later discussion related to back-compat talks about some new annotations designed to make it more clear which APIs will be static and which are expected to change.  The SolrJ API will always be guarded more closely against change than the rest of Solr, because it is the API that is used most commonly in user code.\n\nWhen public APIs do change in a minor version, the old API is generally marked as deprecated, so that existing code will still compile and function properly.  The deprecated API is completely removed from the next major version (trunk). ",
            "id": "comment-15091375"
        },
        {
            "date": "2016-01-31T23:49:39+0000",
            "author": "Jason Gerlowski",
            "content": "I've attached a first pass at the creation of a CloudSolrClientBuilder class.  The attached patch contains the builder class, an added CloudSolrClient ctor that takes all parameters, and some basic tests for the builder and new ctor.\n\nSome notes on the patch:\n\n\n\tpatch is off of trunk/master.  I assume we'd also want it in 5.x, but one thing at a time...\n\tcreated two small helper methods in CloudSolrClient.  Maybe I shouldn't've done that, but I found myself copy-pasting the code, so it seemed like the right thing to do at the time.  Happy to change if necessary.\n\tI didn't change any other code in the project to actually use the new builder.  I'm happy to do this, just wasn't sure it was the right thing and wanted to wait on feedback from others.\n\tI didn't touch (delete, re-scope, deprecate, etc.) any of the existing ctors.  I assume an eventual version of this patch on 5.x should deprecate the existing ctors.  Should I also have the ctors be deprecated in the trunk/master version?  Or should I do something more aggressive, like deleting them altogether?  Happy to do whatever; just wasn't entirely sure what the right move was (even after Shawn Heisey addressed my earlier, less directed questions above...thanks btw).\n\n\n\nAll-in-all, the patch still needs a bit of work, but should be a solid start.  Looking forward to hearing what people think/want-changed! ",
            "id": "comment-15125571"
        },
        {
            "date": "2016-02-08T16:44:57+0000",
            "author": "Jason Gerlowski",
            "content": "Hi all,\n\nJust wanted to give this issue a little 'bump'.  If there's not much interest in this issue, that's fine with me.  Not trying to push this over other important things people are working on.  Just wanted to make sure it wasn't missed on accident.\n\nSo if you're interested in seeing this go forward and have time to take a look, please review the attached patch, and let me know what you'd like tweaked/improved in the next iteration. ",
            "id": "comment-15137198"
        },
        {
            "date": "2016-02-08T19:02:11+0000",
            "author": "Shawn Heisey",
            "content": "I like the idea of going with a builder pattern.\n\nI would probably start with initial work on HttpSolrClient, work out the kinks there, then do the Concurrent and LB objects, and tackle Cloud last.  I would do it this way so that each class can utilize methods from the \"lower\" class.  I don't know if it makes sense to create a \"SolrClientBuilder\" interface or abstract class, but that can be investigated.\n\nIf the embedded server needs similar treatment, then we should see whether it makes any sense to incorporate changes into the parent class \u2013 SolrClient.  A builder pattern for the embedded server probably does make sense, but I haven't looked deeper to verify.\n\nTo delay the impact to client programs as long as possible, we should skip branch_5x, and just make the change in the master branch.  The old constructors can be removed in master once branch_6x is created. ",
            "id": "comment-15137480"
        },
        {
            "date": "2016-02-08T23:22:31+0000",
            "author": "Jason Gerlowski",
            "content": "Hey Shawn, thanks for the review.\n\nI hadn't realized this JIRA was intended to cover each of the SolrClient implementations.  The list of CloudSearchClient ctors in the description narrowed my focus; on a re-read it's clear that was just an example.  With that in mind all your feedback makes sense to me.\n\nI'll expand this patch out to the other SolrClients then, in a way that leverages inheritance where possible.  Since I was focused more narrowly before, I'm also not sure what makes the most sense with regards to also covering SolrServer.  I'll give your suggestions a shot and check back in with a patch or an update. ",
            "id": "comment-15137983"
        },
        {
            "date": "2016-02-09T00:23:38+0000",
            "author": "Shawn Heisey",
            "content": "In master (6.0), most of the *Server variants should be removed, as they were deprecated in 5.0.  EmbeddedSolrServer is the exception there.  I haven't looked at the code in master yet to verify whether those classes are gone. ",
            "id": "comment-15138100"
        },
        {
            "date": "2016-02-09T02:37:33+0000",
            "author": "Jason Gerlowski",
            "content": "Looks like the only remaining *Server variants are EmbeddedSolrServer (appears to only be used in tests, and the map-reduce contrib module), and EmbeddedTestSolrServer (lives in the morphline-core contrib module).  My guess is that it's probably not worth writing a builder for these, since their use is restricted, and they don't really suffer from the too-many-ctor-args problem that the other SolrClients seem to. ",
            "id": "comment-15138253"
        },
        {
            "date": "2016-02-09T03:05:27+0000",
            "author": "Shawn Heisey",
            "content": "We get semi-regular questions about EmbeddedSolrServer on the mailing lists and sometimes in the IRC channel.  Users ARE using it.\n\nThe reason I thought it could maybe use a builder pattern is that the way to create an instance is kind of arcane and non-obvious ... but I suppose that could be called a feature, because it might discourage people from using it.  The embedded server is not recommended for general use, but it does make sense for certain highly specialized use cases. ",
            "id": "comment-15138268"
        },
        {
            "date": "2016-02-09T16:50:00+0000",
            "author": "Anshum Gupta",
            "content": "Thanks for the patch Jason. The patch doesn't apply cleanly on master but I tried looking at the patch through the diff file directly and this is a good direction to move in. Let's cover other Clients too and I'd leave out Embedded for now and tackle that one in the end. ",
            "id": "comment-15139189"
        },
        {
            "date": "2016-02-14T12:46:31+0000",
            "author": "Jason Gerlowski",
            "content": "Ok, so after a bit of a delay, I've got an updated patch which attempts to incorporate Shawn and Anshum's input.\n\nIn This Patch\n\n\tbuilder types for CloudSolrClient, LBHttpSolrClient, HttpSolrClient, and ConcurrentUpdateSolrClient.\n\ttwo abstract types which enabled some sharing of setters: HttpClientBasedSolrClientBuilder, and ResponseParserBasedSolrClientBuilder.  I say  some , because while the inheritance-chain-to-allow-shared-setters sounded like a great idea, it turned out to be tough in practice.  Only one param was present in all builders (HttpClient).  Others were more hit-and-miss, which made getting good re-use hard in Java's single-inheritance world.\n\n\n\nNot In This Patch\n\n\tGood Javadocs\n\tMuch testing.\n\tAny deprecation notes.\n\tInternal usage of these builder types in SolrJ.\n\n\n\nI plan on eventually adding items in the list above, but I wanted to get some feedback on the builder class structure before continuing.  Shawn Heisey, are you happy with the re-use I was able to get from things here?  It was your suggestion, so just wanted to make sure I was faithful to your idea and didn't misinterpret what you wanted.\n\n(Patch is on top of latest trunk.) ",
            "id": "comment-15146528"
        },
        {
            "date": "2016-02-21T22:13:54+0000",
            "author": "Jason Gerlowski",
            "content": "Just wanted to give this issue a little 'bump'. If there's not much interest in this issue, that's fine with me. Not trying to push this over other important things people are working on. Just wanted to make sure it wasn't missed on accident.\n\nSo if you're interested in seeing this go forward and have time to take a look, please review the attached patch, and let me know what you'd like tweaked/improved in the next iteration. ",
            "id": "comment-15156251"
        },
        {
            "date": "2016-02-21T23:12:21+0000",
            "author": "Anshum Gupta",
            "content": "I'll take a look tomorrow as I'd be away from the computer for most part of today. ",
            "id": "comment-15156283"
        },
        {
            "date": "2016-02-22T17:23:44+0000",
            "author": "Anshum Gupta",
            "content": "Thanks Jason. This looks good to me, how ever I'm debating about using an interface instead of an abstract class as that would do away with the single-inheritance restriction. I don't feel too strongly about it so I'm fine with either.\n\nHere are a few minor things I spotted so far:\n\n\n\tupdateLeadersOnly - let's just keep that as updatesToLeaders for consistency. It would make things easier for users and future developers. If you want to change it, it's best to change it throughout the file.\n\tUnused imports cleanup\n\tJavadocs wouldn't render correctly as the @return tag swallows the return char.\n\n\n\nA couple of changes in the patch seem unrelated. Let's move them into their own issue:\n\n\tCUSC change seems unrelated.\n\tBinaryResponseParser being used as default in the HttpSolrClient constructor and LBHttpSolrClient.\n\n\n\nLet's carry on with adding tests, javadocs, deprecation, and also using this in existing tests. We might not want to change all the tests but optionally pick between builder and existing way of constructing the clients for now in the tests though. ",
            "id": "comment-15157327"
        },
        {
            "date": "2016-02-22T17:35:43+0000",
            "author": "Mark Miller",
            "content": "updateLeadersOnly \n\nIf you want to make it more specific, I believe it should be preferLeaders. updateLeadersOnly does not really make sense. ",
            "id": "comment-15157357"
        },
        {
            "date": "2016-02-22T17:41:37+0000",
            "author": "Anshum Gupta",
            "content": "I think we should not use 'prefer' as it's not a preference but an explicit choice to send the request to the shard leaders. It wouldn't fall back to non-leaders if the preferred choice isn't available. ",
            "id": "comment-15157365"
        },
        {
            "date": "2016-02-22T17:49:26+0000",
            "author": "Mark Miller",
            "content": "I don't think you are right. All it does it prefer leaders. They are tried first, and the replicas are tried after rather than full random. The javadoc is incorrect. ",
            "id": "comment-15157378"
        },
        {
            "date": "2016-02-22T18:04:09+0000",
            "author": "Anshum Gupta",
            "content": "Ah ok. I was just looking at the code and it might just be an idea thing, but seems like that param isn't even used right now and that seems strange.\nbut yes, I agree that is 'should' only prefer sending the request to the leader.\n\nI'll dig more into this. ",
            "id": "comment-15157394"
        },
        {
            "date": "2016-02-22T18:11:09+0000",
            "author": "Mark Miller",
            "content": "Yup, looks like someone just made it hardcoded to true. I think Chris Hostetter (Unused) or someone has mentioned valid reasons for keeping the option, so probably we should fix it rather than remove the param in 6.0. ",
            "id": "comment-15157403"
        },
        {
            "date": "2016-02-22T18:19:10+0000",
            "author": "Hoss Man",
            "content": "I'm guessing mark is remembering SOLR-6312.\n\nI don't have a strong opinion about the default behavior \u2013 but as for \"that param isn't even used right now and that seems strange\" that's the heart of SOLR-6312, and that issue mentions reasons why supporting an explicit \"false\" to do round robin updates can be useful in some usecases. ",
            "id": "comment-15157414"
        },
        {
            "date": "2016-02-22T18:48:32+0000",
            "author": "Anshum Gupta",
            "content": "Thanks Hoss. I'll work on adding support for this in SOLR-6312 without changing the default. ",
            "id": "comment-15157463"
        },
        {
            "date": "2016-02-27T18:11:52+0000",
            "author": "Jason Gerlowski",
            "content": "Gonna revert my different name (updateLeadersOnly) as Anshum initially suggested, and keep the name updatesToLeaders as it is for now.  Maybe the name/behavior/Javadocs should change, but I'd rather not touch that in this JIRA, as I don't have a great understanding of the background there, and it'd take some time to look into that.\n\nIf there's still changes regarding that param, I'm happy to do that in a separate JIRA/patch if you guys want. ",
            "id": "comment-15170676"
        },
        {
            "date": "2016-02-27T18:40:25+0000",
            "author": "Jason Gerlowski",
            "content": "Thanks for the review Anshum.  Sorry it took me a few days to get back to this.  Wanted to respond to your comments:\n\n\n\tre: updateLeadersOnly.  Done; I've changed the name back to updatesToLeaders.\n\tre: import cleanup.  Done.\n\tre: Javadoc return tag.  Didn't quite understand your comment.  Looking through the patch, I couldn't find the @return tag anywhere.  Can you clarify what you meant please?\n\tre: CUSC change being unrelated.  I think this change is necessary.  The CUSC ctor that the change occurs in is now called from CUSCB (CUSCBuilder), which may or may not have a real ExecutorService to pass in.  Since CUSC needs an ExecutorService, I changed to ctor to create its own if the param is null.  Hence those lines in the patch.  I'm sure there's other ways to solve this problem if there's something you don't like about those lines, but they are related/required for the patch as it is now.\n\tre: BRP is now used as default in HSC/LBHSC.  Looking at these classes, the ctors that don't take in a ResponseParser create their own BinaryResponseParser to take its place.  So BRP is already the default here.  I had to make this explicit in the ctors that take a ResponseParser, due to the same dynamic mentioned in the bullet point above (That is, the ctor is now called from a builder, where responseParser may or may not have actually been set).  So I think this change is also related/required for this patch.\n\n\n ",
            "id": "comment-15170695"
        },
        {
            "date": "2016-02-27T22:43:34+0000",
            "author": "Jason Gerlowski",
            "content": "So, looking close at these builder classes, I'm not sure that either an abstract-class, or an interface approach will allow these methods to be shared the way we want.\n\nIn a nutshell, the problem is that each builder type returns itself, so that calls can be chained.  Setters inherited from an abstract-class/interface return the type of that abstract interface, which only has a small subset of the methods of the implementation.  This really limits how calls can be chained.\n\nThe explanation above seems a little, well, abstract when I re-read it, so maybe an example will clarify what I'm trying to say.  Consider:\n\n\nabstract class FooBasedBuilder {\n    public FooBasedBuilder withFoo(Foo foo) { ... return this;}\n    public abstract Bar build();\n}\n\nclass BarBuilder extends FooBasedBuilder {\n    public BarBuilder withBoo(Boo boo) { ... return this; }\n    public Bar build() {...}\n}\n\n// WORKS!\nnew BarBuilder()\n    .withBoo(...)  //returns BarBuilder\n    .withFoo(...)  // BarBuilder has a withFoo() method, so this works.\n    .build()\n\n// ERROR!\nnew BarBuilder()\n    .withFoo(...)  // returns FooBuilder reference\n    .withBoo(...)  // FooBuilder type doesn't know about withBar(), so this is a compilation error!\n\n\n\nAs the examples above show, with the abstract-class-for-code-sharing design, the order that setters are called in matters. Once a parent class method is called, subclass methods can't be chained on.\n\nMaybe there's a way around this, but I haven't been able to find one after spending an hour or so racking my brains about it.  With this in mind, if no one can find an alternative, I'm going to go back to removing the code-sharing portion of this patch, as much as that sucks.\n\nIf no one has any better ideas, I'm hoping to push up a patch with this change (and the others Anshum suggested above). ",
            "id": "comment-15170749"
        },
        {
            "date": "2016-02-27T22:50:32+0000",
            "author": "Jason Gerlowski",
            "content": "Puts patch on top of latest trunk/master.  Fixes some of Anshum's concerns.  Still needs tests, fixes based on comments above before it's ready for another review.  But I wanted to push up the changes I have so far at least. ",
            "id": "comment-15170751"
        },
        {
            "date": "2016-02-29T18:30:16+0000",
            "author": "Jason Gerlowski",
            "content": "Adds tests for each builder.  Removes abstract-class approach.\n\nStill need to push usage of builders into other SolrJ tests.  Coming soon hopefully. ",
            "id": "comment-15172319"
        },
        {
            "date": "2016-03-02T04:56:36+0000",
            "author": "Jason Gerlowski",
            "content": "Let's carry on with adding tests, javadocs, deprecation, and also using this in existing tests. We might not want to change all the tests but optionally pick between builder and existing way of constructing the clients for now in the tests though.\n\nTime for a short check-in on making the revisions you suggested Anshum Gupta:\n\n\n\ttests?  check.\n\tjavadocs? check.\n\tdeprecation? nope.\n\tusing in existing tests? In progress (see below).\n\n\n\nThe attached patch changes all tests that previously created HttpSolrClient objects directly.  With this patch, these tests now either use the builder, or create the objects directly, based on the tests' random() value.  Is that about what you were thinking of when you suggested this Anshum?\n\nShould this (or a similar change) be made to all test files that create SolrClients, or just enough of the tests to get decent exposure for the builder?  I'd push for creating SolrClients uniformly in all the tests, though that does make this patch/commit much more burdensome in many aspects (keeping it up to date, reviewing it, etc.).  So I see arguments either way.  I'll revise the changes in the HttpSolrClient-consuming tests, and make similar changes for tests consuming the other types of SolrClients once I hear any thoughts that others might have. ",
            "id": "comment-15175027"
        },
        {
            "date": "2016-03-02T19:10:51+0000",
            "author": "Anshum Gupta",
            "content": "Thanks Jason. Looking at it now. Let's not move all the tests and have a massive patch. Also, we need to continue testing the current SolrJ implementation too i.e. non-builder pattern. ",
            "id": "comment-15176276"
        },
        {
            "date": "2016-03-02T19:25:18+0000",
            "author": "Anshum Gupta",
            "content": "Seems like there's some issue with the patch as it has .orig files.\nDo you mind posting another one? ",
            "id": "comment-15176292"
        },
        {
            "date": "2016-03-02T20:02:18+0000",
            "author": "Jason Gerlowski",
            "content": "Oops, the carelessness of git add -A (and the user who ran it) strikes again.\n\nSorry for wasting your time.  The updated patch should work. ",
            "id": "comment-15176366"
        },
        {
            "date": "2016-03-02T20:30:26+0000",
            "author": "Jason Gerlowski",
            "content": "we need to continue testing the current SolrJ implementation too\n\nDoes RandomizedSolrClientCreator address your concerns there?  I wrote it with that in mind, but I might've misinterpretted what you were asking for.  It does a coin flip using each test's Random object, and does builder or non-builder SolrClient creation based on the result.  I thought that was what you were suggested having a way to \"optionally pick between builder and existing way\" in your comment above.\n\nI'm happy to back out the changes to all the tests if you aren't happy with a coin-flip-creation approach here.  In that case, should I only be changing a subset of the tests? ",
            "id": "comment-15176410"
        },
        {
            "date": "2016-03-04T04:15:41+0000",
            "author": "Jason Gerlowski",
            "content": "Hmm, still seeing some test failures with this patch.  Haven't narrowed down the problem yet, but I'm working on it.\n\nNot ready for review yet (other than general feedback on how to expose the new builders into existing tests). ",
            "id": "comment-15179287"
        },
        {
            "date": "2016-03-09T04:17:02+0000",
            "author": "Jason Gerlowski",
            "content": "Updates patch on top of recent changes in master. Tests pass locally.  Should be ready for review.\n\nThe only/main open question on this that I know of is \"testing\". Right now the patch changes many tests to randomly choose between (1) normal creation and (2) using the new builder when creating HttpSolrClient instances.  It does nothing for other SolrClient implementations (excepting unit tests on the builders themselves, which are included).\n\nIt was kindof unclear to me whether these changes were desired or not.  I'm happy to move this in either direction (remove the random-client-creation changes vs. expanding the changes to encompass other SolrClient types), based on how people would like this to be structured.  Looking for some feedback here in particular; I don't know how to move forward until the testing approach either gets a \"thumbs up\" or \"thumbs down\". ",
            "id": "comment-15186473"
        },
        {
            "date": "2016-03-10T06:38:57+0000",
            "author": "Anshum Gupta",
            "content": "Thanks Jason. Looks good overall.\n\n\n\tChange maybeCreateHttpSolrClientWithBuilder to getNewSolrClient() ? 'maybe' makes it sound like a client may/may not be created. Also, with a method called getNewSolrClient(), we could just change it to always construct a new client object using the new design, without having to rename the method to a non-maybe* pattern. Also, we passing the 'random()' isn't really required.\n\tDeprecation to the non-builder calls. Ideally, we should move the builder classes to be static inner classes for the existing Client implementations. Then we could switch everything to private and leave out the Builder exposed when we want to remove the builder, rather than moving the code around.\n\tCUSC, and HttpSolrClient changes are unrelated\n\tDo you plan on adding more tests to ConcurrentUpdateSolrClientBuilderTest ?\n\tThere are a few unused imports, we can clean them out before committing.\n\n\n\nI'm happy to move this in either direction (remove the random-client-creation changes vs. expanding the changes to encompass other SolrClient types)\nLet's have a getter for randomizing client creation, while keeping the concept of randomizing transparent i.e. the calling code doesn't ever know when we randomize. Also, let's have other clients covered too.\n\nI'll create a sub-task so we don't forget that we intend to rename updatesToLeaders to preferLeaders. Feel free to create sub-tasks for everything that you think is related but doesn't need to go with this. ",
            "id": "comment-15188773"
        },
        {
            "date": "2016-03-11T23:22:30+0000",
            "author": "Jason Gerlowski",
            "content": "Thanks for the review Anshum.  Made all the changes you suggested with 1 or 2 exceptions:\n\n\n\tI wanted to add more tests to ConcurrentUpdateSolrClientBuilderTest, but for some reason ConcurrentUpdateSolrClient lacks many of the getters that other SolrClients have.  I wrote tests for everything that has getters, but for ConcurrentUpdateSolrClient that's not that much.\n\tThe change to CUSC wasn't unrelated.  The CUSC builder now calls that ctor in such a way that the ExecutorService \u200bcould\u200b be null.  So the CUSC builder now needs to be able to handle that case.  (We actually already discussed this, just leaving this note for completeness.)\n\n\n\nOther than that, I've made all the changes you suggested.  All tests pass locally.  Should be ready to go (or at least, review again). ",
            "id": "comment-15191672"
        },
        {
            "date": "2016-03-11T23:25:30+0000",
            "author": "Jason Gerlowski",
            "content": "Thanks for the review Anshum.  Made all the changes you suggested with 1 or 2 exceptions:\n\n\n\tI wanted to add more tests to ConcurrentUpdateSolrClientBuilderTest, but for some reason ConcurrentUpdateSolrClient lacks many of the getters that other SolrClients have.  I wrote tests for everything that has getters, but for ConcurrentUpdateSolrClient that's not that much.\n\tThe change to CUSC wasn't unrelated.  The CUSC builder now calls that ctor in such a way that the ExecutorService \u200bcould\u200b be null.  So the CUSC builder now needs to be able to handle that case.  (We actually already discussed this, just leaving this note for completeness.)\n\n\n\nOther than that, I've made all the changes you suggested.  All tests pass locally.  Should be ready to go (or at least, review again). ",
            "id": "comment-15191674"
        },
        {
            "date": "2016-03-12T18:57:53+0000",
            "author": "Jason Gerlowski",
            "content": "Thanks for the review Anshum.  Made all the changes you suggested with\n1 or 2 exceptions:\n\n\n\tI wanted to add more tests to ConcurrentUpdateSolrClientBuilderTest,\nbut for some reason ConcurrentUpdateSolrClient lacks many of the\ngetters that other SolrClients have.  I wrote tests for everything\nthat has getters, but for ConcurrentUpdateSolrClient that's not that\nmuch.\n\tThe change to CUSC wasn't unrelated.  The CUSC builder now calls\nthat ctor in such a way that the ExecutorService could be null.  So\nthe CUSC builder now needs to be able to handle that case.  (We\nactually already discussed this, just leaving this note for\ncompleteness.)\n\n\n\nOther than that, I've made all the changes you suggested.  All tests\npass locally.  Should be ready to go (or at least, review again).\n\nThanks! ",
            "id": "comment-15191783"
        },
        {
            "date": "2016-03-17T21:11:51+0000",
            "author": "Anshum Gupta",
            "content": "I'll take a look at this later today. ",
            "id": "comment-15200383"
        },
        {
            "date": "2016-03-22T21:06:50+0000",
            "author": "Anshum Gupta",
            "content": "Seems like you forgot to change the usage of deprecated constructors in the code. You changed it in the tests, but not the rest of the code base.\nThe rest seems great. ",
            "id": "comment-15207314"
        },
        {
            "date": "2016-03-22T21:34:06+0000",
            "author": "Jason Gerlowski",
            "content": "I didn't forget, but I was unsure whether that should be included in this JIRA or not.  (I'm personally for changing the usage in production code, I was just being conservative.)\n\nI'll upload a patch shortly removing use of the deprecated ctors entirely. ",
            "id": "comment-15207360"
        },
        {
            "date": "2016-03-22T21:38:56+0000",
            "author": "Anshum Gupta",
            "content": "We should not be using deprecated code for anything other than back-compat testing  ",
            "id": "comment-15207366"
        },
        {
            "date": "2016-03-26T16:48:52+0000",
            "author": "Jason Gerlowski",
            "content": "Ok, this removes all* uses of the now-deprecated constructors.\n\nThe asterisk above implies there are still a few cases where the constructors are called.\n\n\tIn SolrTestCaseJ4, where there are utility methods that randomly choose whether to create clients using the builder, or the now-deprecated ctor.\n\tThere are a few classes which have a private SolrClient subclass.  In almost all cases this is done to specify some alternate behavior for SolrClient.handleError().  I changed these all to use the \"largest\" ctor for the SolrClient they're extending (the ctor with all parameters, that will be kept around with a reduced visibility after the other ctors are deleted.\n\n\n\nI'm not sure I described the second case well, but if my description is unclear, check out StreamingSolrClients.java, which has a good example of this.\n\nAll other uses have been removed.\n\nAs a side note, in this last revision, I realized that deprecating, eventually removing, and lowering the visibility of SolrClient ctors makes implementations difficult to extend anonymously.  This isn't a big deal.  Just wanted to mention it in case it bothers anyone.\n\nThis should be ready to go Anshum Gupta! ",
            "id": "comment-15213107"
        },
        {
            "date": "2016-04-05T19:14:20+0000",
            "author": "Anshum Gupta",
            "content": "Jason Gerlowski can you update the patch to current master and I'll take a final look and commit. ",
            "id": "comment-15226947"
        },
        {
            "date": "2016-04-05T19:16:27+0000",
            "author": "Anshum Gupta",
            "content": "I don't think that difficulty in anonymous extension of SolrClient should stop us from doing this. If no one else has a problem with this, I'll go ahead and commit. ",
            "id": "comment-15226950"
        },
        {
            "date": "2016-04-05T20:05:58+0000",
            "author": "Jason Gerlowski",
            "content": "Yep, working on updating the patch now.  It looks like someone's added a new HttpSolrClient ctor while this patch has been outstanding, so updating the patch is a little more involved now.  Hope to have something up shortly still though. ",
            "id": "comment-15227040"
        },
        {
            "date": "2016-04-05T20:08:09+0000",
            "author": "Anshum Gupta",
            "content": "Thanks Jason ",
            "id": "comment-15227044"
        },
        {
            "date": "2016-04-05T22:44:16+0000",
            "author": "Shawn Heisey",
            "content": "We could completely eliminate all the public constructors in master.  If a constructor is actually needed by the Builder classes, we would leave only one of them (the one with all the options) marked \"protected\".  Because the Builder would be in the same package, it would have access to that constructor.\n\nI just noticed that the HttpSolrClientBuilder class does not have its own .java file.  I think that the builders should be entirely separate classes.  This is the pattern that HttpClient uses.  I'm not sure whether this enough to veto the patch, but it's how I think we should do it.\n\nThere's no way to know whether people are actually trying to extend specific SolrClient implementations, but I would not expect that to be common.  A single protected constructor would allow some leeway in this regard. ",
            "id": "comment-15227291"
        },
        {
            "date": "2016-04-05T23:15:01+0000",
            "author": "Shawn Heisey",
            "content": "Further research on this turns up both methods as valid \u2013 including the builder class inside the class it's building, or as a separate class.\n\nThe example that I found where it was an internal class just named it \"Builder\" \u2013 which I think is wise if we are going to embed the class.  In that case, we would not need any public or protected constructors, just a single private constructor that takes the Builder object.\n\nI do like the separate class idea, but I would not be opposed to HttpSolrClient.Builder instead. ",
            "id": "comment-15227338"
        },
        {
            "date": "2016-04-05T23:40:17+0000",
            "author": "Anshum Gupta",
            "content": "from my previous comment:\nDeprecation to the non-builder calls. Ideally, we should move the builder classes to be static inner classes for the existing Client implementations. Then we could switch everything to private and leave out the Builder exposed when we want to remove the builder, rather than moving the code around.\n\nI would have liked a separate class but for the purpose of back-compat and then having to move the code around when we let go of the compat, it makes sense to have the builder as an inner class. If you think *.Builder makes more sense than Builder, I could buy that. ",
            "id": "comment-15227369"
        },
        {
            "date": "2016-04-06T15:10:05+0000",
            "author": "Jason Gerlowski",
            "content": "So, I've got an updated patch that does everything except the renaming.  I'm fine w/ shortening the names of the static *Builder classes, but when I went to do that, I ran into a bunch of compilation issues related to \"ambiguous references\" or \"type mismatch\".\n\nThe root of the problem appears to be name conflicts, most of which are with HttpClient's Builder class.  As an example, look at this snippet of code:\n\n\n          Builder requestConfigBuilder = HttpClientUtil.createDefaultRequestConfigBuilder();\n          if (soTimeout != null) {\n            requestConfigBuilder.setSocketTimeout(soTimeout);\n          }\n          if (connectionTimeout != null) {\n            requestConfigBuilder.setConnectTimeout(connectionTimeout);\n          }\n\n\n\nThis will fail to compile with the message: \"Type mismatch: Cannot convert from RequestConfig.Builder to ConcurrentUpdateSolrClient.Builder\".  This is easily fixable by changing all Builder references to be unambiguous (RequestConfig.Builder or ConcurrentUpdateSolrClient.Builder).  I'm happy to do that, if this is what we want, but I'm reluctant to let this patch get much bigger than it already is, so I wanted to check with others before piling on and making the review more onerous.\n\nThat said, I'm happy to pull the trigger if we're sure this is what we want.  If anyone else sees a better way around this that I'm missing, please let me know.  Otherwise, if there's no objections, I'll go forward with this later today. ",
            "id": "comment-15228430"
        },
        {
            "date": "2016-04-06T15:12:42+0000",
            "author": "Jason Gerlowski",
            "content": "Uploading a patch that has everything except the renames.  (See my comment above for more information about the Builder renames) ",
            "id": "comment-15228441"
        },
        {
            "date": "2016-04-06T16:19:19+0000",
            "author": "Shawn Heisey",
            "content": "I didn't think of potential naming conflicts.\n\nFully qualified references for all \"Builder\" classes other than the local one seems like a reasonable solution.  Or we could pull the builders into separate source files, but I don't think that would really reduce verbosity by enough to matter.  The only REAL advantage to separate classes is that I like the clean separation.  The relationship between a class and its builder is pretty intimate, so embedding is understandable.\n\nI will look at your patch later, when I have more than a few minutes.\n\nPatches will be as big as necessary.  Keeping the size down is a good idea when possible, but don't worry too much about the size.  Just make sure that the patch only makes required changes; keep away from massive code reformats. ",
            "id": "comment-15228549"
        },
        {
            "date": "2016-04-06T18:12:35+0000",
            "author": "Anshum Gupta",
            "content": "Here's an updated patch with renaming. I plan on getting this into master later today. ",
            "id": "comment-15228787"
        },
        {
            "date": "2016-04-07T23:25:02+0000",
            "author": "ASF subversion and git services",
            "content": "Commit b02b026b7d979a9dac3c549c156dd9706e6fc5ba in lucene-solr's branch refs/heads/master from Anshum Gupta\n[ https://git-wip-us.apache.org/repos/asf?p=lucene-solr.git;h=b02b026 ]\n\nSOLR-8097: Implement builder pattern design for constructing SolrJ clients and deprecate direct construction of clients ",
            "id": "comment-15231325"
        },
        {
            "date": "2016-04-07T23:50:56+0000",
            "author": "Anshum Gupta",
            "content": "Thanks Jason and Shawn. I'll commit this to 6x tomorrow. ",
            "id": "comment-15231355"
        },
        {
            "date": "2016-04-08T20:14:50+0000",
            "author": "ASF subversion and git services",
            "content": "Commit f479f16d3a8b57126560c19c57885a103360f1c3 in lucene-solr's branch refs/heads/branch_6x from Anshum Gupta\n[ https://git-wip-us.apache.org/repos/asf?p=lucene-solr.git;h=f479f16 ]\n\nSOLR-8097: Implement builder pattern design for constructing SolrJ clients and deprecate direct construction of clients ",
            "id": "comment-15232845"
        },
        {
            "date": "2016-04-12T13:10:02+0000",
            "author": "Shalin Shekhar Mangar",
            "content": "Can we deprecate the various setters inside HttpSolrClient and remove them from master? Some of those are missing in the Builder too e.g. setRequestWriter ",
            "id": "comment-15237124"
        },
        {
            "date": "2016-04-12T16:07:24+0000",
            "author": "Anshum Gupta",
            "content": "Sure ",
            "id": "comment-15237456"
        },
        {
            "date": "2016-04-12T17:50:46+0000",
            "author": "Jason Gerlowski",
            "content": "I thought about doing that as a part of my patch, but it seemed like it might be handled best in a separate JIRA.  I'd be happy to push up a patch with that change in a sub-task if it's one that people are interested in.\n\nOne question I have is whether there's ever a valid use-case for changing/tweaking a SolrClient after creating it.  (i.e. Does anyone ever change their RequestWriter, zkHost, collection, etc, instead of just creating a new client).  I'm not implying that there is a good reason to do so, or that I'm against removing the setters (I'm all for it).  (Just want to make sure, after the issue I partially caused in SOLR-8642)  ",
            "id": "comment-15237634"
        },
        {
            "date": "2016-04-12T18:17:12+0000",
            "author": "Anshum Gupta",
            "content": "Collection, perhaps yes. But I don't change any of the others myself. At the highest level, for anything we do, we need to handle the following (at least):\n1. If we are changing APIs, it's a deprecation, specially in minor versions and nothing is broken.\n2. There are tests for the changed behavior\n\nWe have handled those well here.\n\nAlso, let's do that as a separate JIRA. I don't have strong opinions on that. ",
            "id": "comment-15237676"
        },
        {
            "date": "2016-04-12T19:13:40+0000",
            "author": "Shawn Heisey",
            "content": "I personally would never change those things after the first use of a client \u2013 not even the default collection on a cloud client.  If the client is being used by multiple threads, determining what will happen if you change the client after you start using it is difficult.\n\nIMHO this makes all setters superfluous, even setDefaultCollection.  Anything a setter does should be handled by the builder, and you can supply a collection parameter to methods that make requests, so you're never locked in to the default.\n\n+1 to open a new issue to deprecate the setters in branch_6x and remove in master, after making sure all options are handled by the builder.  If the javadoc on the setters doesn't already say so, it should indicate that they are not thread-safe and should only be used immediately after object creation. ",
            "id": "comment-15237798"
        },
        {
            "date": "2016-04-12T20:02:13+0000",
            "author": "Jason Gerlowski",
            "content": "I created SOLR-8975 for this work, with a short description.  I'll copy over some more of the details/suggestions/requirements you've described here shortly, and get started.\n\nThanks for chiming in, let's continue this discussion over on SOLR-8975. ",
            "id": "comment-15237870"
        },
        {
            "date": "2016-05-11T17:09:59+0000",
            "author": "Hoss Man",
            "content": "Anshum Gupta - shouldn't this issue be resolved? ",
            "id": "comment-15280444"
        },
        {
            "date": "2016-05-11T19:11:22+0000",
            "author": "Anshum Gupta",
            "content": "Yes but it was only fixed for 6.1. ",
            "id": "comment-15280639"
        },
        {
            "date": "2016-05-20T19:57:48+0000",
            "author": "ASF subversion and git services",
            "content": "Commit 9645d4213292121d2f011f5440684ea25d7beaa3 in lucene-solr's branch refs/heads/branch_6_0 from Chris Hostetter\n[ https://git-wip-us.apache.org/repos/asf?p=lucene-solr.git;h=9645d42 ]\n\nSOLR-9028: Fixed some test related bugs preventing SSL + ClientAuth from ever being tested\n(cherry picked from commit 791d1e7)\n\nConflicts:\n\tsolr/core/src/test/org/apache/solr/cloud/SSLMigrationTest.java\n\tsolr/solrj/src/java/org/apache/solr/client/solrj/impl/HttpClientUtil.java\n\tsolr/test-framework/src/java/org/apache/solr/SolrTestCaseJ4.java\n\tsolr/test-framework/src/java/org/apache/solr/util/SSLTestConfig.java\n\nConflicts:\n\tsolr/core/src/test/org/apache/solr/cloud/TestMiniSolrCloudClusterSSL.java\n\nFor branch_6_0: Since SOLR-8097 will land in 6.1, remove calls in TestMiniSolrCloudClusterSSL to SolrTestCaseJ4.getHttpSolrClient(). ",
            "id": "comment-15294070"
        },
        {
            "date": "2016-09-12T15:41:38+0000",
            "author": "Perrin Bignoli",
            "content": "Why is the the visibility of the following constructor in CloudSolrClient:\n\n     private CloudSolrClient(Collection<String> zkHosts, String chroot, HttpClient httpClient, LBHttpSolrClient lbSolrClient,\n                                           boolean updatesToLeaders, boolean directUpdatesToLeadersOnly)\n\nset to private and not protected?\n\nThere are also a number of private variables in CloudSolrClient that make subclassing difficult.  I am not familiar enough with the source code to make an exhaustive list. ",
            "id": "comment-15484444"
        },
        {
            "date": "2016-09-12T18:34:31+0000",
            "author": "Anshum Gupta",
            "content": "Here's the discussion about that: https://issues.apache.org/jira/browse/SOLR-8097?focusedCommentId=15227338&page=com.atlassian.jira.plugin.system.issuetabpanels:comment-tabpanel#comment-15227338 ",
            "id": "comment-15484908"
        },
        {
            "date": "2016-09-12T19:42:16+0000",
            "author": "Perrin Bignoli",
            "content": "What was the result of that discussion?\n\nI am interested in creating a subclass of CloudSolrClient.  I don't see how that is possible with the current code or if there are only private constructors.  Other *SolrClient classes appear to have a protected \"Builder\" constructor.  They also have external Builder classes (at least on Master).  Is there a reason why CloudSolrClient is set up to prevent subclassing?  Please let me know if I am missing something obvious.\n\nAlso, that discussion does not involve member variable visibility, although that is probably outside of the scope of this particular ticket. ",
            "id": "comment-15485083"
        },
        {
            "date": "2016-09-12T21:25:36+0000",
            "author": "Shawn Heisey",
            "content": "What is your specific goal in creating a subclass?  I ask because the X is usually more important than the Y.  See this:\n\nhttp://people.apache.org/~hossman/#xyproblem\n\nA SolrClient object is a complex thing, particularly the Cloud version.  Although we try to keep the public API from changing much in minor releases, the internal implementation is a VERY different story.  Because the implementation can change dramatically from release to release, certain details are kept private.  This reduces the risk of breaking user code.\n\nThat said, there really is no reason we should prevent subclassing like we currently do, even if we recommend not doing it because it makes user code brittle.\n\nIt makes sense to change the kitchen-sink constructor from private to protected.  SOLR-8975 might be a good place to tackle this, but it might need its own issue.\n\nI think we should also recommend extending the Builder when subclassing.  When 7.0 is released, all public constructors will be gone, and the Builder will be the only way to create a client object. ",
            "id": "comment-15485336"
        },
        {
            "date": "2016-09-12T22:53:05+0000",
            "author": "Anshum Gupta",
            "content": "Marking this as resolved to avoid confusion.\n\nP.S: That only means that this was committed and released already. It's still open for fixing as part of another issue though. ",
            "id": "comment-15485548"
        },
        {
            "date": "2016-09-12T22:55:54+0000",
            "author": "Anshum Gupta",
            "content": "Right, we can open up the constructor for subclassing but I can't figure the need. I may be missing something here but the Builder could be extended instead of extending the constructor itself and I think that's the right way to go considering we'd be doing away with access to the constructors in 7.0 anyways. ",
            "id": "comment-15485554"
        },
        {
            "date": "2016-09-13T01:01:55+0000",
            "author": "Shawn Heisey",
            "content": "the Builder could be extended instead of extending the constructor itself\n\nI tried to extend the client in this way, adding a new setting to the derived client class and exposing it in the derived Builder, but ultimately it comes down to the same problem \u2013 the \"all parameters\" constructor, which is the only one that will survive the transition to 7.0, cannot be used in an extended Client/Builder because it's private.\n\nOne option, which I would not want to employ because it would involve duplicate code that will quickly become stale, is to copy all the code in the private constructor and paste it into the subclass, then add parameters as required and use that constructor in a derived Builder class.\n\nIMHO, the only sane option for experienced developers is to change the internal constructor from private to protected, allowing derivative classes to utilize it after doing class-specific setup.  The developer will usually also need to extend the internal Builder class to expose configuration of any new capability.\n\nI like what we've done with the Builder, and I agree that after 7.0 removes deprecated code, the constructor should not be public ... but making it private is too limiting. ",
            "id": "comment-15485839"
        },
        {
            "date": "2016-09-13T16:58:28+0000",
            "author": "Jason Gerlowski",
            "content": "I'll create a separate issue for changing the appropriate SolrClient ctors to be protected, and will push up a patch shortly.\n\nI'll summarize the discussion here, and others can weigh in on alternate approaches if they wish. ",
            "id": "comment-15487748"
        },
        {
            "date": "2016-09-14T03:36:24+0000",
            "author": "Anshum Gupta",
            "content": "I can't recollect right now and I'm not looking at the code but I thought there was a way around it. I'll take your word for it here .\nThe main thing here was to make sure that the end user uses the builder. Converting the constructor to be protected doesn't defeat that purpose so I'm fine. ",
            "id": "comment-15489273"
        },
        {
            "date": "2016-09-14T03:38:34+0000",
            "author": "Anshum Gupta",
            "content": "From how I'm looking at this, it's a bug really as it took away a capability that existed in previous releases and this was not a planned move. I think it'd make sense for us to push this with 6.2.1 if we're sure that the only way is to change the scope. ",
            "id": "comment-15489278"
        },
        {
            "date": "2016-09-20T13:10:26+0000",
            "author": "Jason Gerlowski",
            "content": "I created SOLR-9535 to address the recent concern brought up here, and attached a small patch containing the fix. ",
            "id": "comment-15506475"
        }
    ]
}