{
    "id": "LUCENE-169",
    "title": "[PATCH] Parallelized MultiSearcher",
    "details": {
        "labels": "",
        "priority": "Minor",
        "components": [
            "core/search"
        ],
        "type": "Improvement",
        "fix_versions": [],
        "affect_versions": "None",
        "resolution": "Fixed",
        "status": "Closed"
    },
    "description": "The following parallelizes searches among the various searchables in a \nMultiSearcher. \n\nThe patch contains an inherited MultiSearcher, a unit test class and a light \nmodification to testMultiSearch to allow subclassing it.\n\nI would be interested to know if somebody tried this on a multiple HDD\nmachine or in a distributed index architecture if performance improvement is\nnoticeable.\n\nJeff\n\n\nIndex: java/org/apache/lucene/search/ParallelMultiSearcher.java\n===================================================================\nRCS file: java/org/apache/lucene/search/ParallelMultiSearcher.java\ndiff -N java/org/apache/lucene/search/ParallelMultiSearcher.java\n\u2014 /dev/null\t1 Jan 1970 00:00:00 -0000\n+++ java/org/apache/lucene/search/ParallelMultiSearcher.java\t8 Jan 2004\n18:00:00 -0000\n@@ -0,0 +1,247 @@\n+package org.apache.lucene.search;\n+\n+/* ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2001 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The names \"Apache\" and \"Apache Software Foundation\" and\n+ *    \"Apache Lucene\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\",\n+ *    \"Apache Lucene\", nor may \"Apache\" appear in their name, without\n+ *    prior written permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+\n+import java.io.IOException;\n+\n+import org.apache.lucene.index.Term;\n+\n+/** Implements parallel search over a set of <code>Searchables</code>.\n+ *\n+ * <p>Applications usually need only call the inherited \n{@link\n#search(Query)}\n+ * or \n{@link #search(Query,Filter)}\n methods.\n+ */\n+public class ParallelMultiSearcher extends MultiSearcher \n{\n+\tprivate Searchable[] searchables;\n+\tprivate int[] starts;\n+\tprivate int maxDoc = 0;\n+\n+\t/** Creates a searcher which searches <i>searchables</i>. */\n+\tpublic ParallelMultiSearcher(Searchable[] searchables) throws \nIOException\n{\n+\t\tsuper(searchables);\n+\t}\n+\n+\t/**\n+\t * TODO: parallelize this one too\n+\t */\n+\tpublic int docFreq(Term term) throws IOException \n{\n+\t\tint docFreq = 0;\n+\t\tfor (int i = 0; i < searchables.length; i++)\n+\t\t\tdocFreq += searchables[i].docFreq(term);\n+\t\treturn docFreq;\n+\t}\n+\n+\t/**\n+\t* A search implementation which spans a new thread for each\n+\t* Searchable, waits for each search to complete and merge\n+\t* the results back together.\n+\t*/\n+\tpublic TopDocs search(Query query, Filter filter, int nDocs)\n+\t\tthrows IOException {\n+\t\tHitQueue hq = new HitQueue(nDocs);\n+\t\tint totalHits = 0;\n+\t\tMultiSearcherThread[] msta =\n+\t\t\tnew MultiSearcherThread[searchables.length];\n+\n+\t\tfor (int i = 0; i < searchables.length; i++) \n{ // search each \nsearcher\n+\t\t\t// Assume not too many searchables and cost of creating \na thread is by\nfar inferior to a search\n+\t\t\tmsta[i] =\n+\t\t\t\tnew MultiSearcherThread(\n+\t\t\t\t\tsearchables[i],\n+\t\t\t\t\tquery,\n+\t\t\t\t\tfilter,\n+\t\t\t\t\tnDocs,\n+\t\t\t\t\thq,\n+\t\t\t\t\ti,\n+\t\t\t\t\tstarts,\n+\t\t\t\t\t\"MultiSearcher thread #\" + (i + 1));\n+\t\t\tmsta[i].start();\n+\t\t}\n+\n+\t\tfor (int i = 0; i < searchables.length; i++) {\n+\t\t\ttry \n{\n+\t\t\t\tmsta[i].join();\n+\t\t\t}\n catch (InterruptedException ie) \n{\n+\t\t\t\t; // TODO: what should we do with this???\n+\t\t\t}\n+\t\t\tIOException ioe = msta[i].getIOException();\n+\t\t\tif (ioe == null) \n{\n+\t\t\t\ttotalHits += msta[i].hits();\n+\t\t\t}\n else \n{\n+\t\t\t\t// if one search produced an IOException, \nrethrow it\n+\t\t\t\tthrow ioe;\n+\t\t\t}\n+\t\t}\n+\n+\t\tScoreDoc[] scoreDocs = new ScoreDoc[hq.size()];\n+\t\tfor (int i = hq.size() - 1; i >= 0; i--) // put docs in array\n+\t\t\tscoreDocs[i] = (ScoreDoc) hq.pop();\n+\n+\t\treturn new TopDocs(totalHits, scoreDocs);\n+\t}\n+\n+\t/** Lower-level search API.\n+\t *\n+\t * <p>\n{@link HitCollector#collect(int,float)}\n is called for every non-\nzero\n+\t * scoring document.\n+\t *\n+\t * <p>Applications should only use this if they need <i>all</i> of the\n+\t * matching documents.  The high-level search API (\n{@link\n+\t * Searcher#search(Query)}\n) is usually more efficient, as it skips\n+\t * non-high-scoring hits.\n+\t *\n+\t * @param query to match documents\n+\t * @param filter if non-null, a bitset used to eliminate some documents\n+\t * @param results to receive hits\n+\t *\n+\t * TODO: parallelize this one too\n+\t */\n+\tpublic void search(Query query, Filter filter, final HitCollector \nresults)\n+\t\tthrows IOException {\n+\t\tfor (int i = 0; i < searchables.length; i++) {\n+\n+\t\t\tfinal int start = starts[i];\n+\n+\t\t\tsearchables[i].search(query, filter, new HitCollector() \n{\n+\t\t\t\tpublic void collect(int doc, float score) \n{\n+\t\t\t\t\tresults.collect(doc + start, score);\n+\t\t\t\t}\n+\t\t\t});\n+\n+\t\t}\n+\t}\n+\n+\t/*\n+\t * TODO: this one could be parallelized too\n+\t * @see\norg.apache.lucene.search.Searchable#rewrite(org.apache.lucene.search.Query)\n+\t */\n+\tpublic Query rewrite(Query original) throws IOException {\n+\t\tQuery[] queries = new Query[searchables.length];\n+\t\tfor (int i = 0; i < searchables.length; i++) \n{\n+\t\t\tqueries[i] = searchables[i].rewrite(original);\n+\t\t}\n+\t\treturn original.combine(queries);\n+\t}\n+\n+}\n+\n+/**\n+ * A thread subclass for searching a single searchable\n+ */\n+class MultiSearcherThread extends Thread {\n+\n+\tprivate Searchable searchable;\n+\tprivate Query query;\n+\tprivate Filter filter;\n+\tprivate int nDocs;\n+\tprivate int hits;\n+\tprivate TopDocs docs;\n+\tprivate int i;\n+\tprivate HitQueue hq;\n+\tprivate int[] starts;\n+\tprivate IOException ioe;\n+\n+\tpublic MultiSearcherThread(\n+\t\tSearchable searchable,\n+\t\tQuery query,\n+\t\tFilter filter,\n+\t\tint nDocs,\n+\t\tHitQueue hq,\n+\t\tint i,\n+\t\tint[] starts,\n+\t\tString name) \n{\n+\t\tsuper(name);\n+\t\tthis.searchable = searchable;\n+\t\tthis.query = query;\n+\t\tthis.filter = filter;\n+\t\tthis.nDocs = nDocs;\n+\t\tthis.hq = hq;\n+\t\tthis.i = i;\n+\t\tthis.starts = starts;\n+\t}\n+\n+\tpublic void run() {\n+\t\ttry \n{\n+\t\t\tdocs = searchable.search(query, filter, nDocs);\n+\t\t}\n+\t\t// Store the IOException for later use by the caller of this \nthread\n+\t\tcatch (IOException ioe) \n{\n+\t\t\tthis.ioe = ioe;\n+\t\t}\n+\t\tif (ioe == null) {\n+\t\t\tScoreDoc[] scoreDocs = docs.scoreDocs;\n+\t\t\tfor (int j = 0;\n+\t\t\t\tj < scoreDocs.length;\n+\t\t\t\tj++) { // merge scoreDocs into hq\n+\t\t\t\tScoreDoc scoreDoc = scoreDocs[j];\n+\t\t\t\tscoreDoc.doc += starts[i]; // convert doc\n+\t\t\t\t//it would be so nice if we had a thread-safe \ninsert\n+\t\t\t\tsynchronized (hq) \n{\n+\t\t\t\t\tif (!hq.insert(scoreDoc))\n+\t\t\t\t\t\tbreak;\n+\t\t\t\t}\n // no more scores > minScore\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tpublic int hits() \n{\n+\t\treturn docs.totalHits;\n+\t}\n+\n+\tpublic IOException getIOException() \n{\n+\t\treturn ioe;\n+\t}\n+\n+}\nIndex: test/org/apache/lucene/search/TestMultiSearcher.java\n===================================================================\nRCS file:\n/home/cvspublic/jakarta-lucene/src/test/org/apache/lucene/search/TestMultiSe\narcher.java,v\nretrieving revision 1.4\ndiff -u -r1.4 TestMultiSearcher.java\n\u2014 test/org/apache/lucene/search/TestMultiSearcher.java\t26 Nov 2002\n17:31:43 -0000\t1.4\n+++ test/org/apache/lucene/search/TestMultiSearcher.java\t8 Jan 2004\n18:00:02 -0000\n@@ -81,6 +81,14 @@\n         super(name);\n     }\n\n+\t/**\n+\t * Return a new instance of the concrete MultiSearcher class\n+\t * used in this test\n+\t */\n+\tprotected MultiSearcher getMultiSearcherInstance(Searcher[] searchers)\nthrows IOException \n{\n+\t\treturn new MultiSearcher(searchers);\n+\t}\n+\n     public void testEmptyIndex()\n         throws Exception\n     {\n@@ -134,7 +142,7 @@\n         searchers[0] = new IndexSearcher(indexStoreB);\n         searchers[1] = new IndexSearcher(indexStoreA);\n         // creating the multiSearcher\n\n\tSearcher mSearcher = new MultiSearcher(searchers);\n+        Searcher mSearcher = getMultiSearcherInstance(searchers);\n         // performing the search\n         Hits hits = mSearcher.search(query);\n\n\n\n@@ -171,7 +179,7 @@\n         searchers2[0] = new IndexSearcher(indexStoreB);\n         searchers2[1] = new IndexSearcher(indexStoreA);\n         // creating the mulitSearcher\n\n\tSearcher mSearcher2 = new MultiSearcher(searchers2);\n+        Searcher mSearcher2 = getMultiSearcherInstance(searchers2);\n         // performing the same search\n         Hits hits2 = mSearcher2.search(query);\n\n\n\n@@ -213,7 +221,7 @@\n         searchers3[0] = new IndexSearcher(indexStoreB);\n         searchers3[1] = new IndexSearcher(indexStoreA);\n         // creating the mulitSearcher\n\n\tSearcher mSearcher3 = new MultiSearcher(searchers3);\n+        Searcher mSearcher3 = getMultiSearcherInstance(searchers3);\n         // performing the same search\n         Hits hits3 = mSearcher3.search(query);\n\n\n\nIndex: test/org/apache/lucene/search/TestParallelMultiSearcher.java\n===================================================================\nRCS file: test/org/apache/lucene/search/TestParallelMultiSearcher.java\ndiff -N test/org/apache/lucene/search/TestParallelMultiSearcher.java\n\u2014 /dev/null\t1 Jan 1970 00:00:00 -0000\n+++ test/org/apache/lucene/search/TestParallelMultiSearcher.java\t8 Jan \n2004\n18:00:02 -0000\n@@ -0,0 +1,73 @@\n+package org.apache.lucene.search;\n+\n+/* ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2001 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The names \"Apache\" and \"Apache Software Foundation\" and\n+ *    \"Apache Lucene\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\",\n+ *    \"Apache Lucene\", nor may \"Apache\" appear in their name, without\n+ *    prior written permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+\n+import java.io.IOException;\n+\n+/**\n+ * Unit tests for the ParallelMultiSearcher\n+ */\n+public class TestParallelMultiSearcher extends TestMultiSearcher {\n+\n+\tpublic TestParallelMultiSearcher(String name) \n{\n+\t\tsuper(name);\n+\t}\n+\n+\tprotected MultiSearcher getMultiSearcherInstance(Searcher[] searchers)\n+\t\tthrows IOException \n{\n+\t\treturn new ParallelMultiSearcher(searchers);\n+\t}\n+\n+}",
    "attachments": {
        "ASF.LICENSE.NOT.GRANTED--patch.txt": "https://issues.apache.org/jira/secure/attachment/12312286/ASF.LICENSE.NOT.GRANTED--patch.txt"
    },
    "issue_links": {},
    "comments": [
        {
            "date": "2004-01-15T00:24:00+0000",
            "content": "Created an attachment (id=9947)\nPlease Ignore the patch included in my previous mail. This passes correctly ANT TEST. ",
            "author": "Jean-Fran\u00e7ois Halleux",
            "id": "comment-12321472"
        },
        {
            "date": "2004-01-21T02:38:07+0000",
            "content": "This patch has been applied.  Thanks for implementing this! ",
            "author": "cutting@apache.org",
            "id": "comment-12321473"
        }
    ]
}