{
    "id": "SOLR-10249",
    "title": "Allow index fetching to return a detailed result instead of a true/false value",
    "details": {
        "labels": "",
        "priority": "Trivial",
        "components": [
            "replication (java)"
        ],
        "type": "Improvement",
        "fix_versions": [
            "6.6"
        ],
        "affect_versions": "6.4.1",
        "resolution": "Fixed",
        "status": "Closed"
    },
    "description": "This gives us the ability to see into why a replication might of failed and act on it if we need to.  We use this enhancement for logging conditions so we can quantify what is happening with replication, get success rates, etc.\n\nThe idea is to create a public static class IndexFetchResult as an inner class to IndexFetcher that has strings that hold statuses that could occur while fetching an index.",
    "attachments": {
        "SOLR_10249.patch": "https://issues.apache.org/jira/secure/attachment/12860393/SOLR_10249.patch"
    },
    "issue_links": {},
    "comments": [
        {
            "date": "2017-03-08T22:59:49+0000",
            "content": "Diffs for my local testing\n\ndiff --git a/solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy.java b/solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy.java\nindex 90e515a..2483e69 100644\n\u2014 a/solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy.java\n+++ b/solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy.java\n@@ -153,7 +153,7 @@ public class RecoveryStrategy extends Thread implements Closeable {\n     solrParams.set(ReplicationHandler.MASTER_URL, leaderUrl);\n\n     if (isClosed()) return; // we check closed on return\n\n\tboolean success = replicationHandler.doFetch(solrParams, false);\n+    boolean success = replicationHandler.doFetch(solrParams, false).getStatus();\n\n\n\n     if (!success) {\n       throw new SolrException(ErrorCode.SERVER_ERROR, \"Replication for recovery failed.\");\ndiff --git a/solr/core/src/java/org/apache/solr/handler/CdcrRequestHandler.java b/solr/core/src/java/org/apache/solr/handler/CdcrRequestHandler.java\nindex f706637..a65299a 100644\n\u2014 a/solr/core/src/java/org/apache/solr/handler/CdcrRequestHandler.java\n+++ b/solr/core/src/java/org/apache/solr/handler/CdcrRequestHandler.java\n@@ -754,7 +754,7 @@ public class CdcrRequestHandler extends RequestHandlerBase implements SolrCoreAw\n         // we do not want the raw tlog files from the source\n         solrParams.set(ReplicationHandler.TLOG_FILES, false);\n\n\n\tsuccess = replicationHandler.doFetch(solrParams, false);\n+        success = replicationHandler.doFetch(solrParams, false).getStatus();\n\n\n\n         // this is required because this callable can race with HttpSolrCall#destroy\n         // which clears the request info.\ndiff --git a/solr/core/src/java/org/apache/solr/handler/IndexFetcher.java b/solr/core/src/java/org/apache/solr/handler/IndexFetcher.java\nindex b9d9f51..281e660 100644\n\u2014 a/solr/core/src/java/org/apache/solr/handler/IndexFetcher.java\n+++ b/solr/core/src/java/org/apache/solr/handler/IndexFetcher.java\n@@ -106,6 +106,8 @@ import static org.apache.solr.common.params.CommonParams.JAVABIN;\n import static org.apache.solr.common.params.CommonParams.NAME;\n import static org.apache.solr.handler.ReplicationHandler.*;\n\n+import com.google.common.base.Strings;\n+\n /**\n\n\t<p> Provides functionality of downloading changed index files as well as config files and a timer for scheduling fetches from the\n\tmaster. </p>\n@@ -161,6 +163,52 @@ public class IndexFetcher {\n\n\n\n   private Integer soTimeout;\n\n+  private static final String INTERRUPT_RESPONSE_MESSAGE = \"Interrupted while waiting for modify lock\";\n+\n+  public static class IndexFetchResult {\n+    private final String message;\n+    private final boolean status;\n+    private final Throwable exception;\n+\n+    public static final String FAILED_BY_INTERRUPT_MESSAGE = \"Fetching index failed by interrupt\";\n+    public static final String FAILED_BY_EXCEPTION_MESSAGE = \"Fetching index failed by exception\";\n+\n+    /** pre-defined results */\n+    public static final IndexFetchResult ALREADY_IN_SYNC = new IndexFetchResult(\"Local index commit is already in sync with peer\", true, null);\n+    public static final IndexFetchResult INDEX_FETCH_FAILURE = new IndexFetchResult(\"Fetching lastest index is failed\", false, null);\n+    public static final IndexFetchResult INDEX_FETCH_SUCCESS = new IndexFetchResult(\"Fetching latest index is successful\", true, null);\n+    public static final IndexFetchResult LOCK_OBTAIN_FAILED = new IndexFetchResult(\"Obtaining SnapPuller lock failed\", false, null);\n+    public static final IndexFetchResult MASTER_VERSION_ZERO = new IndexFetchResult(\"Index in peer is empty and never committed yet\", true, null);\n+    public static final IndexFetchResult NO_INDEX_COMMIT_EXIST = new IndexFetchResult(\"No IndexCommit in local index\", false, null);\n+    public static final IndexFetchResult PEER_INDEX_COMMIT_DELETED = new IndexFetchResult(\"No files to download because IndexCommit in peer was deleted\", false, null);\n+    // SFDC: adding a new failure result when replication is aborted because of local activity\n+    public static final IndexFetchResult LOCAL_ACTIVITY_DURING_REPLICATION = new IndexFetchResult(\"Local index modification during replication\", false, null);\n+\n+    IndexFetchResult(String message, boolean status, Throwable exception) \n{\n+      this.message = message;\n+      this.status = status;\n+      this.exception = exception;\n+    }\n+\n+    /*\n+     * @return exception thrown if failed by exception or interrupt, otherwise null\n+     */\n+    public Throwable getException() \n{\n+      return this.exception;\n+    }\n+\n+    /*\n+     * @return true if index fetch was successful, false otherwise\n+     */\n+    public boolean getStatus() \n{\n+      return this.status;\n+    }\n+\n+    public String getMessage() \n{\n+      return this.message;\n+    }\n+  }\n+\n   private static HttpClient createHttpClient(SolrCore core, String httpBasicAuthUser, String httpBasicAuthPassword, boolean useCompression) {\n     final ModifiableSolrParams httpClientParams = new ModifiableSolrParams();\n     httpClientParams.set(HttpClientUtil.PROP_BASIC_AUTH_USER, httpBasicAuthUser);\n@@ -264,7 +312,7 @@ public class IndexFetcher {\n     }\n   }\n\n\n\tboolean fetchLatestIndex(boolean forceReplication) throws IOException, InterruptedException {\n+  IndexFetchResult fetchLatestIndex(boolean forceReplication) throws IOException, InterruptedException \n{\n     return fetchLatestIndex(forceReplication, false);\n   }\n\n\n\n@@ -277,7 +325,7 @@ public class IndexFetcher {\n\n\t@return true on success, false if slave is already in sync\n\t@throws IOException if an exception occurs\n    */\n\n\n\tboolean fetchLatestIndex(boolean forceReplication, boolean forceCoreReload) throws IOException, InterruptedException {\n+  IndexFetchResult fetchLatestIndex(boolean forceReplication, boolean forceCoreReload) throws IOException, InterruptedException {\n\n\n\n     boolean cleanupDone = false;\n     boolean successfulInstall = false;\n@@ -302,9 +350,16 @@ public class IndexFetcher {\n       try \n{\n         response = getLatestVersion();\n       }\n catch (Exception e) \n{\n-        LOG.error(\"Master at: \" + masterUrl + \" is not available. Index fetch failed. Exception: \" + e.getMessage());\n-        return false;\n-      }\n+        final String errorMsg = e.getMessage();\n+        if (!Strings.isNullOrEmpty(errorMsg) && errorMsg.contains(INTERRUPT_RESPONSE_MESSAGE)) \n{\n+            LOG.warn(\"Master at: \" + masterUrl + \" is not available. Index fetch failed by interrupt. Exception: \" + errorMsg);\n+            return new IndexFetchResult(IndexFetchResult.FAILED_BY_INTERRUPT_MESSAGE, false, e);\n+        }\n else \n{\n+            LOG.warn(\"Master at: \" + masterUrl + \" is not available. Index fetch failed by exception: \" + errorMsg);\n+            return new IndexFetchResult(IndexFetchResult.FAILED_BY_EXCEPTION_MESSAGE, false, e);\n+        }\n+    }\n+\n       long latestVersion = (Long) response.get(CMD_INDEX_VERSION);\n       long latestGeneration = (Long) response.get(GENERATION);\n\n@@ -320,7 +375,7 @@ public class IndexFetcher {\n           searcherRefCounted = solrCore.getNewestSearcher(false);\n           if (searcherRefCounted == null) \n{\n             LOG.warn(\"No open searcher found - fetch aborted\");\n-            return false;\n+            return IndexFetchResult.NO_INDEX_COMMIT_EXIST;\n           }\n           commit = searcherRefCounted.get().getIndexReader().getIndexCommit();\n         } finally {\n@@ -347,7 +402,7 @@ public class IndexFetcher \n{\n \n         //there is nothing to be replicated\n         successfulInstall = true;\n-        return true;\n+        return IndexFetchResult.MASTER_VERSION_ZERO;\n       }\n\n       // TODO: Should we be comparing timestamps (across machines) here?\n@@ -355,14 +410,14 @@ public class IndexFetcher \n{\n         //master and slave are already in sync just return\n         LOG.info(\"Slave in sync with master.\");\n         successfulInstall = true;\n-        return true;\n+        return IndexFetchResult.ALREADY_IN_SYNC;\n       }\n       LOG.info(\"Starting replication process\");\n       // get the list of files first\n       fetchFileList(latestGeneration);\n       // this can happen if the commit point is deleted before we fetch the file list.\n       if (filesToDownload.isEmpty()) \n{\n-        return false;\n+        return IndexFetchResult.PEER_INDEX_COMMIT_DELETED;\n       }\n       LOG.info(\"Number of files in latest index in master: \" + filesToDownload.size());\n       if (tlogFilesToDownload != null) {\n@@ -550,14 +605,14 @@ public class IndexFetcher {\n           LOG.warn(\n               \"Replication attempt was not successful - trying a full index replication reloadCore={}\",\n               reloadCore);\n\n\tsuccessfulInstall = fetchLatestIndex(true, reloadCore);\n+          successfulInstall = fetchLatestIndex(true, reloadCore).getStatus();\n         }\n\n\n\n         markReplicationStop();\n\n\treturn successfulInstall;\n+        return successfulInstall ? IndexFetchResult.INDEX_FETCH_SUCCESS : IndexFetchResult.INDEX_FETCH_FAILURE;\n       } catch (ReplicationHandlerException e) \n{\n         LOG.error(\"User aborted Replication\");\n-        return false;\n+        return new IndexFetchResult(IndexFetchResult.FAILED_BY_EXCEPTION_MESSAGE, false, e);\n       }\n catch (SolrException e) \n{\n         throw e;\n       }\n catch (InterruptedException e) {\ndiff --git a/solr/core/src/java/org/apache/solr/handler/ReplicationHandler.java b/solr/core/src/java/org/apache/solr/handler/ReplicationHandler.java\nindex 84e1ba2..becec83 100644\n\t\n\t\t\n\t\t\n\t\t\ta/solr/core/src/java/org/apache/solr/handler/ReplicationHandler.java\n+++ b/solr/core/src/java/org/apache/solr/handler/ReplicationHandler.java\n@@ -88,6 +88,7 @@ import org.apache.solr.core.SolrEventListener;\n import org.apache.solr.core.backup.repository.BackupRepository;\n import org.apache.solr.core.backup.repository.LocalFileSystemRepository;\n import org.apache.solr.core.snapshots.SolrSnapshotMetaDataManager;\n+import org.apache.solr.handler.IndexFetcher.IndexFetchResult;\n import org.apache.solr.request.SolrQueryRequest;\n import org.apache.solr.response.SolrQueryResponse;\n import org.apache.solr.search.SolrIndexSearcher;\n@@ -381,10 +382,10 @@ public class ReplicationHandler extends RequestHandlerBase implements SolrCoreAw\n\t\t\n\t\t\n\t\n\t\n\n\n\n   private volatile IndexFetcher currentIndexFetcher;\n\n\n\tpublic boolean doFetch(SolrParams solrParams, boolean forceReplication) {\n+  public IndexFetchResult doFetch(SolrParams solrParams, boolean forceReplication) {\n     String masterUrl = solrParams == null ? null : solrParams.get(MASTER_URL);\n     if (!indexFetchLock.tryLock())\n\treturn false;\n+      return IndexFetchResult.LOCK_OBTAIN_FAILED;\n     try {\n       if (masterUrl != null) {\n         if (currentIndexFetcher != null && currentIndexFetcher != pollingIndexFetcher) \nUnknown macro: {@@ -400,17 +401,16 @@ public class ReplicationHandler extends RequestHandlerBase implements SolrCoreAw       if (currentIndexFetcher != pollingIndexFetcher) {\n         currentIndexFetcher.destroy();\n       }+      return new IndexFetchResult(IndexFetchResult.FAILED_BY_EXCEPTION_MESSAGE, false, e);     } \n finally {\n       if (pollingIndexFetcher != null) {\n        if( currentIndexFetcher != pollingIndexFetcher) \n{\n          currentIndexFetcher.destroy();\n        }\n\t         currentIndexFetcher = pollingIndexFetcher;\n       }\n       indexFetchLock.unlock();\n     }\n\treturn false;\n   }\n\n\n\n   boolean isReplicating() { ",
            "author": "Jeff Miller",
            "id": "comment-15902139"
        },
        {
            "date": "2017-03-13T16:51:26+0000",
            "content": "Moving to 6.5, since 6.4 has already been released. ",
            "author": "Ishan Chattopadhyaya",
            "id": "comment-15907838"
        },
        {
            "date": "2017-03-20T04:40:53+0000",
            "content": "Github user dsmiley commented on the issue:\n\n    https://github.com/apache/lucene-solr/pull/169\n\n    @millerjeff0  when you created this PR, you didn't put SOLR-10249 in in the title and therefore the PR and the Jira issue aren't linked.  Can you edit it and do that please? ",
            "author": "ASF GitHub Bot",
            "id": "comment-15932157"
        },
        {
            "date": "2017-03-20T16:18:36+0000",
            "content": "Github user millerjeff0 commented on the issue:\n\n    https://github.com/apache/lucene-solr/pull/169\n\n    Thanks I was not aware I needed to do so,  fixed it ",
            "author": "ASF GitHub Bot",
            "id": "comment-15932948"
        },
        {
            "date": "2017-03-22T19:51:24+0000",
            "content": "Github user dsmiley commented on a diff in the pull request:\n\n    https://github.com/apache/lucene-solr/pull/169#discussion_r107513516\n\n    \u2014 Diff: solr/core/src/java/org/apache/solr/handler/IndexFetcher.java \u2014\n    @@ -321,9 +369,16 @@ boolean fetchLatestIndex(boolean forceReplication, boolean forceCoreReload) thro\n           try \n{\n             response = getLatestVersion();\n           }\n catch (Exception e) \n{\n    -        LOG.error(\"Master at: \" + masterUrl + \" is not available. Index fetch failed. Exception: \" + e.getMessage());\n    -        return false;\n    -      }\n    +        final String errorMsg = e.getMessage();\n    \u2014 End diff \u2013\n\n    Granted e.getMessage() was what this code was doing before you made changes but can you please use e.toString() instead?  IMO, e.getMessage() should rarely if ever be called instead of e.toString() because e.toString() critically contains the name of the exception itself.  The \"message\" alone can be unclear without the exception class.  Consider `FileNotFoundException` and there are others. ",
            "author": "ASF GitHub Bot",
            "id": "comment-15936999"
        },
        {
            "date": "2017-03-22T19:51:25+0000",
            "content": "Github user dsmiley commented on a diff in the pull request:\n\n    https://github.com/apache/lucene-solr/pull/169#discussion_r107514170\n\n    \u2014 Diff: solr/core/src/java/org/apache/solr/handler/IndexFetcher.java \u2014\n    @@ -161,6 +163,52 @@\n\n       private Integer soTimeout;\n\n    +  private static final String INTERRUPT_RESPONSE_MESSAGE = \"Interrupted while waiting for modify lock\";\n    +\n    +  public static class IndexFetchResult {\n    \u2014 End diff \u2013\n\n    I really like how you modeled this return object. ",
            "author": "ASF GitHub Bot",
            "id": "comment-15937000"
        },
        {
            "date": "2017-03-22T19:51:25+0000",
            "content": "Github user dsmiley commented on a diff in the pull request:\n\n    https://github.com/apache/lucene-solr/pull/169#discussion_r107512860\n\n    \u2014 Diff: solr/core/src/java/org/apache/solr/handler/IndexFetcher.java \u2014\n    @@ -311,7 +359,7 @@ boolean fetchLatestIndex(boolean forceReplication, boolean forceCoreReload) thro\n             Replica replica = getLeaderReplica();\n             CloudDescriptor cd = solrCore.getCoreDescriptor().getCloudDescriptor();\n             if (cd.getCoreNodeName().equals(replica.getName())) {\n\n\treturn false;\n    +          return IndexFetchResult.CORE_NODE_IS_REPLICA;\n\t\n\t\t\n\t\t\n\t\t\tEnd diff \u2013\n\t\t\n\t\t\n\t\n\t\n\n\n\n    Maybe call this NOT_LEADER ?  Even a leader is a replica (it's the role a replica plays).  Granted many of us promote this ambiguity because we haven't clearly/consistently labelled a non-leader, e.g. a follower. ",
            "author": "ASF GitHub Bot",
            "id": "comment-15937001"
        },
        {
            "date": "2017-03-22T19:51:25+0000",
            "content": "Github user dsmiley commented on a diff in the pull request:\n\n    https://github.com/apache/lucene-solr/pull/169#discussion_r107514287\n\n    \u2014 Diff: solr/core/src/java/org/apache/solr/handler/IndexFetcher.java \u2014\n    @@ -161,6 +163,52 @@\n\n       private Integer soTimeout;\n\n    +  private static final String INTERRUPT_RESPONSE_MESSAGE = \"Interrupted while waiting for modify lock\";\n    +\n    +  public static class IndexFetchResult {\n    +    private final String message;\n    +    private final boolean status;\n    \u2014 End diff \u2013\n\n    perhaps rename \"status\" to \"successful\" (getter too)? ",
            "author": "ASF GitHub Bot",
            "id": "comment-15937002"
        },
        {
            "date": "2017-03-22T20:43:16+0000",
            "content": "Github user millerjeff0 commented on a diff in the pull request:\n\n    https://github.com/apache/lucene-solr/pull/169#discussion_r107526774\n\n    \u2014 Diff: solr/core/src/java/org/apache/solr/handler/IndexFetcher.java \u2014\n    @@ -321,9 +369,16 @@ boolean fetchLatestIndex(boolean forceReplication, boolean forceCoreReload) thro\n           try \n{\n             response = getLatestVersion();\n           }\n catch (Exception e) \n{\n    -        LOG.error(\"Master at: \" + masterUrl + \" is not available. Index fetch failed. Exception: \" + e.getMessage());\n    -        return false;\n    -      }\n    +        final String errorMsg = e.getMessage();\n    \u2014 End diff \u2013\n\n    Great point, thanks ",
            "author": "ASF GitHub Bot",
            "id": "comment-15937094"
        },
        {
            "date": "2017-03-24T17:00:14+0000",
            "content": "Here's the patch.  All tests pass and precommit.  I'll commit later today.\n\nThanks for the contribution Jeff. ",
            "author": "David Smiley",
            "id": "comment-15940734"
        },
        {
            "date": "2017-03-24T17:12:14+0000",
            "content": "Github user tflobbe commented on a diff in the pull request:\n\n    https://github.com/apache/lucene-solr/pull/169#discussion_r107954150\n\n    \u2014 Diff: solr/core/src/java/org/apache/solr/handler/IndexFetcher.java \u2014\n    @@ -161,6 +163,52 @@\n\n       private Integer soTimeout;\n\n    +  private static final String INTERRUPT_RESPONSE_MESSAGE = \"Interrupted while waiting for modify lock\";\n    +\n    +  public static class IndexFetchResult {\n    +    private final String message;\n    +    private final boolean successful;\n    +    private final Throwable exception;\n    +\n    +    public static final String FAILED_BY_INTERRUPT_MESSAGE = \"Fetching index failed by interrupt\";\n    +    public static final String FAILED_BY_EXCEPTION_MESSAGE = \"Fetching index failed by exception\";\n    +\n    +    /** pre-defined results */\n    +    public static final IndexFetchResult ALREADY_IN_SYNC = new IndexFetchResult(\"Local index commit is already in sync with peer\", true, null);\n    +    public static final IndexFetchResult INDEX_FETCH_FAILURE = new IndexFetchResult(\"Fetching lastest index is failed\", false, null);\n    +    public static final IndexFetchResult INDEX_FETCH_SUCCESS = new IndexFetchResult(\"Fetching latest index is successful\", true, null);\n    +    public static final IndexFetchResult LOCK_OBTAIN_FAILED = new IndexFetchResult(\"Obtaining SnapPuller lock failed\", false, null);\n    +    public static final IndexFetchResult MASTER_VERSION_ZERO = new IndexFetchResult(\"Index in peer is empty and never committed yet\", true, null);\n    +    public static final IndexFetchResult NO_INDEX_COMMIT_EXIST = new IndexFetchResult(\"No IndexCommit in local index\", false, null);\n    +    public static final IndexFetchResult PEER_INDEX_COMMIT_DELETED = new IndexFetchResult(\"No files to download because IndexCommit in peer was deleted\", false, null);\n    +    public static final IndexFetchResult LOCAL_ACTIVITY_DURING_REPLICATION = new IndexFetchResult(\"Local index modification during replication\", false, null);\n    +    public static final IndexFetchResult CORE_NODE_IS_NOT_LEADER = new IndexFetchResult(\"Core Name Name Equals Leader Replica Name\", false, null);\n    \u2014 End diff \u2013\n\n    This message (and variable name) seems wrong. Looking at the case where this is thrown, it seems like this would happen if \"OnlyLeaderIndexes\" feature is being used, and this replica is the current leader. Message should be something like\"Replicating from leader but I'm the shard leader\" ",
            "author": "ASF GitHub Bot",
            "id": "comment-15940753"
        },
        {
            "date": "2017-03-24T17:17:33+0000",
            "content": "Github user dsmiley commented on a diff in the pull request:\n\n    https://github.com/apache/lucene-solr/pull/169#discussion_r107955318\n\n    \u2014 Diff: solr/core/src/java/org/apache/solr/handler/IndexFetcher.java \u2014\n    @@ -161,6 +163,52 @@\n\n       private Integer soTimeout;\n\n    +  private static final String INTERRUPT_RESPONSE_MESSAGE = \"Interrupted while waiting for modify lock\";\n    +\n    +  public static class IndexFetchResult {\n    +    private final String message;\n    +    private final boolean successful;\n    +    private final Throwable exception;\n    +\n    +    public static final String FAILED_BY_INTERRUPT_MESSAGE = \"Fetching index failed by interrupt\";\n    +    public static final String FAILED_BY_EXCEPTION_MESSAGE = \"Fetching index failed by exception\";\n    +\n    +    /** pre-defined results */\n    +    public static final IndexFetchResult ALREADY_IN_SYNC = new IndexFetchResult(\"Local index commit is already in sync with peer\", true, null);\n    +    public static final IndexFetchResult INDEX_FETCH_FAILURE = new IndexFetchResult(\"Fetching lastest index is failed\", false, null);\n    +    public static final IndexFetchResult INDEX_FETCH_SUCCESS = new IndexFetchResult(\"Fetching latest index is successful\", true, null);\n    +    public static final IndexFetchResult LOCK_OBTAIN_FAILED = new IndexFetchResult(\"Obtaining SnapPuller lock failed\", false, null);\n    +    public static final IndexFetchResult MASTER_VERSION_ZERO = new IndexFetchResult(\"Index in peer is empty and never committed yet\", true, null);\n    +    public static final IndexFetchResult NO_INDEX_COMMIT_EXIST = new IndexFetchResult(\"No IndexCommit in local index\", false, null);\n    +    public static final IndexFetchResult PEER_INDEX_COMMIT_DELETED = new IndexFetchResult(\"No files to download because IndexCommit in peer was deleted\", false, null);\n    +    public static final IndexFetchResult LOCAL_ACTIVITY_DURING_REPLICATION = new IndexFetchResult(\"Local index modification during replication\", false, null);\n    +    public static final IndexFetchResult CORE_NODE_IS_NOT_LEADER = new IndexFetchResult(\"Core Name Name Equals Leader Replica Name\", false, null);\n    \u2014 End diff \u2013\n\n    Thanks @tflobbe .  I can make this simple change before committing today.  Perhaps the constant should be SELF_LEADER_REPLICATE or EXPECTING_NON_LEADER ?  Be my guest to make suggestions. ",
            "author": "ASF GitHub Bot",
            "id": "comment-15940765"
        },
        {
            "date": "2017-03-24T17:37:42+0000",
            "content": "Github user tflobbe commented on a diff in the pull request:\n\n    https://github.com/apache/lucene-solr/pull/169#discussion_r107959546\n\n    \u2014 Diff: solr/core/src/java/org/apache/solr/handler/IndexFetcher.java \u2014\n    @@ -161,6 +163,52 @@\n\n       private Integer soTimeout;\n\n    +  private static final String INTERRUPT_RESPONSE_MESSAGE = \"Interrupted while waiting for modify lock\";\n    +\n    +  public static class IndexFetchResult {\n    +    private final String message;\n    +    private final boolean successful;\n    +    private final Throwable exception;\n    +\n    +    public static final String FAILED_BY_INTERRUPT_MESSAGE = \"Fetching index failed by interrupt\";\n    +    public static final String FAILED_BY_EXCEPTION_MESSAGE = \"Fetching index failed by exception\";\n    +\n    +    /** pre-defined results */\n    +    public static final IndexFetchResult ALREADY_IN_SYNC = new IndexFetchResult(\"Local index commit is already in sync with peer\", true, null);\n    +    public static final IndexFetchResult INDEX_FETCH_FAILURE = new IndexFetchResult(\"Fetching lastest index is failed\", false, null);\n    +    public static final IndexFetchResult INDEX_FETCH_SUCCESS = new IndexFetchResult(\"Fetching latest index is successful\", true, null);\n    +    public static final IndexFetchResult LOCK_OBTAIN_FAILED = new IndexFetchResult(\"Obtaining SnapPuller lock failed\", false, null);\n    +    public static final IndexFetchResult MASTER_VERSION_ZERO = new IndexFetchResult(\"Index in peer is empty and never committed yet\", true, null);\n    +    public static final IndexFetchResult NO_INDEX_COMMIT_EXIST = new IndexFetchResult(\"No IndexCommit in local index\", false, null);\n    +    public static final IndexFetchResult PEER_INDEX_COMMIT_DELETED = new IndexFetchResult(\"No files to download because IndexCommit in peer was deleted\", false, null);\n    +    public static final IndexFetchResult LOCAL_ACTIVITY_DURING_REPLICATION = new IndexFetchResult(\"Local index modification during replication\", false, null);\n    +    public static final IndexFetchResult CORE_NODE_IS_NOT_LEADER = new IndexFetchResult(\"Core Name Name Equals Leader Replica Name\", false, null);\n    \u2014 End diff \u2013\n\n    Yes, those sound good. I personally like *EXPECTING_NON_LEADER* better ",
            "author": "ASF GitHub Bot",
            "id": "comment-15940794"
        },
        {
            "date": "2017-03-25T02:46:33+0000",
            "content": "Commit 8664f1f38a3741a7aff5988221cb7a1a7dda9e5b in lucene-solr's branch refs/heads/master from David Smiley\n[ https://git-wip-us.apache.org/repos/asf?p=lucene-solr.git;h=8664f1f ]\n\nSOLR-10249: Refactor IndexFetcher to return detailed result ",
            "author": "ASF subversion and git services",
            "id": "comment-15941534"
        },
        {
            "date": "2017-03-25T03:09:55+0000",
            "content": "Commit bd53fafc567d393dcf5318dbc99da3fd13177cc2 in lucene-solr's branch refs/heads/branch_6x from David Smiley\n[ https://git-wip-us.apache.org/repos/asf?p=lucene-solr.git;h=bd53faf ]\n\nSOLR-10249: Refactor IndexFetcher to return detailed result\n\n(cherry picked from commit 8664f1f) ",
            "author": "ASF subversion and git services",
            "id": "comment-15941543"
        }
    ]
}