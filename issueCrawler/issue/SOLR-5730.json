{
    "id": "SOLR-5730",
    "title": "make Lucene's SortingMergePolicy and EarlyTerminatingSortingCollector configurable in Solr",
    "details": {
        "affect_versions": "None",
        "status": "Resolved",
        "fix_versions": [
            "6.0"
        ],
        "components": [],
        "type": "New Feature",
        "priority": "Minor",
        "labels": "",
        "resolution": "Fixed"
    },
    "description": "Example configuration (solrconfig.xml) :\n\n-<mergePolicy class=\"TieredMergePolicy\"/>\n+<mergePolicyFactory class=\"org.apache.solr.index.SortingMergePolicyFactory\">\n+  <str name=\"wrapped.prefix\">in</str>\n+  <str name=\"in.class\">org.apache.solr.index.TieredMergePolicyFactory</str>\n+  <str name=\"sort\">timestamp desc</str>\n+</mergePolicyFactory>\n\n\n\nExample use (EarlyTerminatingSortingCollector):\n\n&sort=timestamp+desc&segmentTerminateEarly=true",
    "attachments": {
        "SOLR-5730-part1and2.patch": "https://issues.apache.org/jira/secure/attachment/12787374/SOLR-5730-part1and2.patch",
        "SOLR-5730-part1of2.patch": "https://issues.apache.org/jira/secure/attachment/12783399/SOLR-5730-part1of2.patch",
        "SOLR-5730-part2of2.patch": "https://issues.apache.org/jira/secure/attachment/12783401/SOLR-5730-part2of2.patch"
    },
    "issue_links": {},
    "comments": [
        {
            "author": "ASF GitHub Bot",
            "id": "comment-13901482",
            "date": "2014-02-14T14:45:01+0000",
            "content": "GitHub user cpoerschke opened a pull request:\n\n    https://github.com/apache/lucene-solr/pull/31\n\n    make SortingMergePolicy and EarlyTerminatingSortingCollector configurable\n\n\n    For https://issues.apache.org/jira/i#browse/SOLR-5730 ticket.\n\n    Also for the first 2 of the 5 ideas on https://issues.apache.org/jira/i#browse/SOLR-4654 ticket.\n\n\nYou can merge this pull request into a Git repository by running:\n\n    $ git pull https://github.com/apache/lucene-solr branch_4x-etsc-solr\n\nAlternatively you can review and apply these changes as the patch at:\n\n    https://github.com/apache/lucene-solr/pull/31.patch\n\nTo close this pull request, make a commit to your master/trunk branch\nwith (at least) the following in the commit message:\n\n    This closes #31\n\n\ncommit d45f8126ed8985ab085b989eed176eddddd9a694\nAuthor: Christine Poerschke <cpoerschke@bloomberg.net>\nDate:   2014-02-14T13:58:38Z\n\n    make Lucene's SortingMergePolicy and EarlyTerminatingSortingCollector configurable in Solr\n\n "
        },
        {
            "author": "Christine Poerschke",
            "id": "comment-13901520",
            "date": "2014-02-14T15:00:18+0000",
            "content": "https://issues.apache.org/jira/i#browse/LUCENE-5445 and associated github pull request are related here (ASF GitHub Bot seemingly only updated the first of the tickets mentioned in the pull request comments). "
        },
        {
            "author": "Shawn Heisey",
            "id": "comment-13909443",
            "date": "2014-02-22T17:14:15+0000",
            "content": "Christine Poerschke, are you in a position to build a test that makes sure everything does what it's expected to do, ideally when the new feature is disabled as well as enabled?  I'm evaluating whether or not I can take this issue on.  My understanding of how to use Lucene is pretty low, and I'm a little wobbly on crafting new tests. "
        },
        {
            "author": "Christine Poerschke",
            "id": "comment-13911571",
            "date": "2014-02-25T13:42:59+0000",
            "content": "Hi Shawn, yes i'm having a go at building tests for this. So far a new TestMergePolicyConfigWithMergeSorter based on the existing TestMergePolicyConfig, and tests for the IndexSchema and searching changes would be on the todo list too. "
        },
        {
            "author": "Robert Muir",
            "id": "comment-13923920",
            "date": "2014-03-07T14:38:25+0000",
            "content": "Hello, some things that might simplify some of the TODOs, is we changed the SortingMergePolicy API in LUCENE-5493 to just take Sort.\n\nThis means you can have multiple fields, they dont have to be numeric docvalues, and so on. So I think this can simplify the configuration of this thing too, e.g. you could just take a standard \"sort spec string\" and parse it with QueryParsing.getSort or whatever (some refactoring might be needed here). \n\nIt would be good though, to check that Sort.needsScores() == false, as that makes no sense at index-time... I'll open an issue to add this check to SortingMergePolicy itself in lucene.\n\nThe other difference is, EarlyTerminatingSortingCollector now also takes a Sort, except really you should just pass the Sort being used for the Query (it does the proper checking against the segments to see if the segment was sorted in a compatible way, and if so, will optimize with early termination). Today this just checks that they are exactly equal, but in the future it can be smarter (LUCENE-5499).\n\nHopefully this makes the integration easier. "
        },
        {
            "author": "ASF GitHub Bot",
            "id": "comment-14608888",
            "date": "2015-06-30T19:10:54+0000",
            "content": "GitHub user cpoerschke opened a pull request:\n\n    https://github.com/apache/lucene-solr/pull/176\n\n    [incomplete] SOLR-5730: make SortingMergePolicy/EarlyTerminatingSortingCollector configurable\n\n    incomplete. for https://issues.apache.org/jira/i#browse/SOLR-5730 ticket.\n\nYou can merge this pull request into a Git repository by running:\n\n    $ git pull https://github.com/bloomberg/lucene-solr trunk-sort-outline\n\nAlternatively you can review and apply these changes as the patch at:\n\n    https://github.com/apache/lucene-solr/pull/176.patch\n\nTo close this pull request, make a commit to your master/trunk branch\nwith (at least) the following in the commit message:\n\n    This closes #176\n\n\ncommit 5984692c660b32ddec0260e5a096b7b7eea5ea8d\nAuthor: Christine Poerschke <cpoerschke@bloomberg.net>\nDate:   2015-06-29T15:02:44Z\n\n    LUCENE-????: support SortingMergePolicy-free use of EarlyTerminatingSortingCollector\n\n    motivation:\n\n\tSOLR-5730 to make Lucene's SortingMergePolicy and EarlyTerminatingSortingCollector configurable in Solr.\n\toutline of draft SOLR-5730 changes:\n       + SolrIndexWriter constructor calls SolrIndexConfig.toIndexWriterConfig (passing the result to its lucene.IndexWriter super class)\n       + SolrIndexConfig.toIndexWriterConfig(SolrCore core) calls SolrIndexConfig.buildMergePolicy\n       + SolrIndexConfig.buildMergePolicy(IndexSchema schema) calls the SortingMergePolicy constructor (using the IndexSchema's mergeSortSpec)\n       + SolrIndexSearcher.buildAndRunCollectorChain calls the EarlyTerminatingSortingCollector constructor (using the IndexSchema's mergeSortSpec)\n\n\n\n    summary of changes:\n\n\tadded static isSorted variant to SortingMergePolicy\n\tadded SortingMergePolicy-free EarlyTerminatingSortingCollector constructor variant\n\tadded SortingMergePolicy-free EarlyTerminatingSortingCollector.canEarlyTerminate variant\n\tcorresponding changes to TestEarlyTerminatingSortingCollector (randomly choose between constructor and canEarlyTerminate variants)\n\n\n\ncommit 78de6620a9f50ab632c1fc240a336137acf9199f\nAuthor: Christine Poerschke <cpoerschke@bloomberg.net>\nDate:   2015-06-29T14:22:29Z\n\n    [incomplete] SOLR-5730: make Lucene's SortingMergePolicy and EarlyTerminatingSortingCollector configurable in Solr\n\n    summary of changes so far:\n\n\tschema.xml: added optional mergeSortSpec field to [Managed]IndexSchema\n\tsolrconfig.xml: SolrIndexConfig.buildMergePolicy to constructs a SortingMergePolicy if the useSortingMergePolicy flag is set\n\toptional segmentTerminateEarly parameter added to CommonParams and QueryComponent (defaulted to existing behaviour)\n\tSolrIndexSearcher: constructs EarlyTerminatingSortingCollector if segmentTerminateEarly flag is set (and requested sort is compatible with the mergeSortSpec)\n\n\n\n    still incomplete:\n\n\tIndexSchema: convert/parse 'String mergeSortSpecString;' into 'SortSpec mergeSortSpec;'\n\tqueryResult caching to consider the segmentTerminateEarly flag (a segmentTerminateEarly=false search should not get cached results from a segmentTerminateEarly=true search)\n\tdocumentation/example for the segmentTerminateEarly query parameter (and the new optional schema.xml/solrconfig.xml elements)\n\ttest cases\n\n\n\n "
        },
        {
            "author": "Christine Poerschke",
            "id": "comment-14608899",
            "date": "2015-06-30T19:20:45+0000",
            "content": "Uploaded incomplete rebased-against-current-trunk changes and updated example configuration to match. The proposed solr changes require the changes proposed in LUCENE-6646 because at the point that solr needs to construct an EarlyTerminatingSortingCollector object it doesn't have access to the SortingMergePolicy in use, commit message about has further details. "
        },
        {
            "author": "Christine Poerschke",
            "id": "comment-15002585",
            "date": "2015-11-12T18:27:55+0000",
            "content": "Making the SortingMergePolicy configurable means that the SortSpec configured needs to be parsed. SOLR-8283 intends to factor out SortSpecParsing[Test] from QueryParsing[Test] to help with this. "
        },
        {
            "author": "Christine Poerschke",
            "id": "comment-15109261",
            "date": "2016-01-20T19:43:26+0000",
            "content": "SOLR-5730: make Lucene's SortingMergePolicy configurable in Solr\n\nExample configuration:\n\n\tsolrconfig.xml <useSortingMergePolicy>true</useSortingMergePolicy>\n\tschema.xml <mergeSortSpec>timestamp desc</mergeSortSpec>\n\n "
        },
        {
            "author": "Christine Poerschke",
            "id": "comment-15109265",
            "date": "2016-01-20T19:45:01+0000",
            "content": "SOLR-5730: optional segmentTerminateEarly=(false|true) parameter (to allow use of Lucene's EarlyTerminatingSortingCollector)\n\nIf segmentTerminateEarly=true parameter is passed then Lucene's EarlyTerminatingSortingCollector will be used for ungrouped queries whose sort parameter is compatible with the <mergeSortSpec> configured in the schema.xml. "
        },
        {
            "author": "Christine Poerschke",
            "id": "comment-15109291",
            "date": "2016-01-20T19:58:32+0000",
            "content": "Please find attached a two-part patch against latest trunk:\n\n\tPart 1 is to make Lucene's SortingMergePolicy configurable in Solr.\n\tPart 2 is to allow use of Lucene's EarlyTerminatingSortingCollector via an optional segmentTerminateEarly=(false|true) search request parameter.\n\n\n\nRelated linked tickets already completed various preparation work and so the two patches now then are pretty pure and specific to only the change itself here.\n\nReviews, comments, etc. welcome. Thank you. "
        },
        {
            "author": "Hoss Man",
            "id": "comment-15109442",
            "date": "2016-01-20T21:20:44+0000",
            "content": "Probably a naive question, but...\n\nI understand that the reason we need new config syntax is to be able to wrap whatever was specified by <mergePolicy/> \u2013 but i'm not really a fan of the 2 new disjoint top level config options.  Why not keep those two concepts (should we sort the merges? how should we sort the merges?) in a single place? (my gut says solrconfig.xml since that's where other merge related settings live.)\n\nie...\n\n\n<sortMerges enabled=\"true\">popularity desc, timestamp desc</sortMerges>\n\n\n\nwhat's the motivation/conceptual reasoning behind part of that being configured in the schema and part of it in solrconfig? "
        },
        {
            "author": "Tom\u00e1s Fern\u00e1ndez L\u00f6bbe",
            "id": "comment-15109905",
            "date": "2016-01-21T02:07:31+0000",
            "content": "This feature sounds really good. I have some questions/comments:\n\nI'm wondering if its better to have the segmentTerminateEarly parameter or if we should just use the EarlyTerminatingSortingCollector whenever the MP is SortingMergePolicy and the sort spec is compatible. Or maybe the default should be \"use it if possible\", and if the parameter is explicitly set to true, use it if possible, and error if not? If the parameter is set to \"false\", don't use the collector even if possible.\n\nLooking at this\n\n+      if (segmentTerminatedEarly != null) {\n+        final Object existingSegmentTerminatedEarly = rb.rsp.getResponseHeader().get(SolrQueryResponse.RESPONSE_HEADER_SEGMENT_TERMINATED_EARLY_KEY);\n+        if(existingSegmentTerminatedEarly == null) {\n+          rb.rsp.getResponseHeader().add(SolrQueryResponse.RESPONSE_HEADER_SEGMENT_TERMINATED_EARLY_KEY, segmentTerminatedEarly);\n+        } else if (!segmentTerminatedEarly.equals(existingSegmentTerminatedEarly)) {\n+          rb.rsp.getResponseHeader().remove(SolrQueryResponse.RESPONSE_HEADER_SEGMENT_TERMINATED_EARLY_KEY);\n+          rb.rsp.getResponseHeader().add(SolrQueryResponse.RESPONSE_HEADER_SEGMENT_TERMINATED_EARLY_KEY, segmentTerminatedEarly);\n+        }\n+      }\n\n\nIf there is an existing value, the new one should be existing OR new, right? If we want the per shard information we could add that to the shards_info section.\n "
        },
        {
            "author": "Christine Poerschke",
            "id": "comment-15110679",
            "date": "2016-01-21T14:41:43+0000",
            "content": "... i'm not really a fan of the 2 new disjoint top level config options ...\n\nI agree that having a <useSortingMergePolicy>true</useSortingMergePolicy> element in solrconfig.xml and a <mergeSortSpec>timestamp desc</mergeSortSpec> element in schema.xml is tricky but personally am not won over by either of the obvious two alternatives either:\n\nAlternative #1 solrconfig.xml element only:\n+ advantage: the element is co-located with the existing <mergePolicy> element\n- disadvantages:\n\n\tsolrconfig.xml references schema.xml field names\n\tsolr.search.SolrIndexSearcher would need (more) access to the solr.update.SolrIndexConfig object [implementation detail: SolrIndexSearcher.buildAndRunCollectorChain needs to be able to pass the merge policy sort to EarlyTerminatingSortingCollector but only one of the two SolrIndexSearcher constructors currently takes an SolrIndexConfig argument.]\n\n\n\nAlternative #2 schema.xml element only:\n+ advantage: the element uses solr field names defined in the same file\n- disadvantage: the presence or absence of an element in schema.xml has a side effect on how the solrconfig.xml <mergePolicy> element is instantiated\n\nAlternative #3 perhaps there is another way? "
        },
        {
            "author": "Christine Poerschke",
            "id": "comment-15110684",
            "date": "2016-01-21T14:43:40+0000",
            "content": "If there is an existing value, the new one should be existing OR new, right?\n\nGood catch, will fix.\n\nIf we want the per shard information we could add that to the shards_info section.\n\nGood idea, will make a change to add that (with corresponding test). "
        },
        {
            "author": "Christine Poerschke",
            "id": "comment-15110696",
            "date": "2016-01-21T14:49:33+0000",
            "content": "I'm wondering if its better to have the segmentTerminateEarly parameter or if we should just use the EarlyTerminatingSortingCollector whenever the MP is SortingMergePolicy and the sort spec is compatible. ...\n\nGood question. segmentTerminateEarly will influence i.e. potentially reduce the numFound value in the response, so because of that I'd say that segment-terminating-early should be an opt-in rather than an opt-out parameter. "
        },
        {
            "author": "Tom\u00e1s Fern\u00e1ndez L\u00f6bbe",
            "id": "comment-15110884",
            "date": "2016-01-21T16:48:54+0000",
            "content": "Missed that.\nThe parameter makes more sense then. "
        },
        {
            "author": "Hoss Man",
            "id": "comment-15110927",
            "date": "2016-01-21T17:09:02+0000",
            "content": "Alternative #1 solrconfig.xml element only:\n\nI think this is the best approach conceptually from the standpoint of a user's mental model.\n\nsolrconfig.xml references schema.xml field names\n\nThis has always been the case \u2013 no new ground here, and not soemthing we have any reason to start avoiding.  sane solrconfig.xml settings have always depended on an understanding of the schema.xml, it's going the other way (schema.xml settings requiring some knowledge of the solrconfig.xml) that has always been avoided, because it breaks the conceptual model of the distinction between \"what, abstractly, is my data? (schema)\" and \"how, practically, do i want to use my data? (solrconfig).\n\nsegment sorting feels very much like a \"practically speaking, how am i using this data\" type question, and not a \"conceptually speaking, what do these documents represent\" type question.\n\n\nSolrIndexSearcher.buildAndRunCollectorChain needs to be able to pass the merge policy sort to EarlyTerminatingSortingCollector but only one of the two SolrIndexSearcher constructors currently takes an SolrIndexConfig\n\nWe should put more work into making the user experience better at the expense of implementation details \u2013 in this case though i'm not sure i really see the problem?  SolrIndexSearcher always knows it's SolrCore which has accessors for the SolrConfig, which exposes the SlrIndexConfig ... correct? "
        },
        {
            "author": "Christine Poerschke",
            "id": "comment-15111026",
            "date": "2016-01-21T18:14:07+0000",
            "content": "Okay, if the \"solrconfig.xml references schema.xml field names\" thing is not a show-stopper then I'm happy to run with the \"Alternative #1 solrconfig.xml element only\" approach. "
        },
        {
            "author": "Christine Poerschke",
            "id": "comment-15113257",
            "date": "2016-01-22T22:37:17+0000",
            "content": "Any thoughts on how crucial support for the enable attribute is in the solrconfig.xml element?\n\n<sortMerges enable=\"true\">popularity desc, timestamp desc</sortMerges>\n\n\n(In my opinion it is crucial for anyone wishing to use something like enable=\"${solr.sortMerges.enable:false}\" to easily transition to use a SortingMergePolicy.)\n\n\nAny views on this alternative?\n\n<sortMerges enable=\"true\">\n  <str name=\"sort\">popularity desc, timestamp desc</str>\n</sortMerges>\n\n\n(In my opinion it's almost as user-friendly and if Lucene's SortingMergePolicy's constructor in future ever were to require an extra argument this could be accommodated in a straightforward way with an extra <int name=\"answer\">42</int> element.)\n\n\nWhy the above questions?\n\n\nImplementation-wise it appears that primitive <some>string</some> elements have no support for attributes. At first glance it appears that we could in SolrIndexConfig.java creatively solve this with something like this:\n\n  lockType=solrConfig.get(prefix+\"/lockType\", def.lockType);\n  ...\n  mergePolicyInfo = getPluginInfo(prefix + \"/mergePolicy\", solrConfig, def.mergePolicyInfo);\n+ if (!solrConfig.readPluginInfos(prefix + \"/sortMerges\", false /*requireName*/, false /*requireClass*/).isEmpty()) {\n+   sortMerges = solrConfig.get(prefix + \"/sortMerges\", def.sortMerges);\n+ } else {\n+   sortMerges = def.sortMerges;\n+ }\n\n\nHowever, on further consideration a map returned by SolrIndexConfig.toMap() would then not represent the complete solrconfig.xml element (any enable attribute in the primitive sortMerges element would be missing) i.e. <sortMerges enable=\"true\">popularity desc, timestamp desc</sortMerges> would reduce down to \"sortMerges\" : \"popularity desc, timestamp desc\" in the map and <sortMerges enable=\"false\">popularity desc, timestamp desc</sortMerges> would be absent from the map. "
        },
        {
            "author": "Hoss Man",
            "id": "comment-15113266",
            "date": "2016-01-22T22:41:21+0000",
            "content": "Any views on this alternative?\n+1 "
        },
        {
            "author": "Christine Poerschke",
            "id": "comment-15117104",
            "date": "2016-01-26T12:08:45+0000",
            "content": "Have chosen\n\n+      if (segmentTerminatedEarly != null) {\n+        final Object existingSegmentTerminatedEarly = rb.rsp.getResponseHeader().get(SolrQueryResponse.RESPONSE_HEADER_SEGMENT_TERMINATED_EARLY_KEY);\n+        if(existingSegmentTerminatedEarly == null) {\n+          rb.rsp.getResponseHeader().add(SolrQueryResponse.RESPONSE_HEADER_SEGMENT_TERMINATED_EARLY_KEY, segmentTerminatedEarly);\n+        } else if (!Boolean.TRUE.equals(existingSegmentTerminatedEarly) && Boolean.TRUE.equals(segmentTerminatedEarly)) {\n+          rb.rsp.getResponseHeader().remove(SolrQueryResponse.RESPONSE_HEADER_SEGMENT_TERMINATED_EARLY_KEY);\n+          rb.rsp.getResponseHeader().add(SolrQueryResponse.RESPONSE_HEADER_SEGMENT_TERMINATED_EARLY_KEY, segmentTerminatedEarly);\n+        }\n+      }\n\n\nas implementation for the existing OR new to avoid unnecessary remove-and-then-add-back if existing is already TRUE. "
        },
        {
            "author": "Christine Poerschke",
            "id": "comment-15117111",
            "date": "2016-01-26T12:18:12+0000",
            "content": "The revised attached patch uses this alternative.\n\nA side-effect of the alternative, beneficial in my opinion, is that the simple default use is\n\n<sortMerges enable=\"true\">\n  <str name=\"sort\">popularity desc, timestamp desc</str>\n</sortMerges>\n\n\nbut something customised such as\n\n<sortMerges enable=\"true\" class=\"MyInstrumentedSortingMergePolicy\">\n  <str name=\"sort\">popularity desc, timestamp desc</str>\n</sortMerges>\n\n\nis now then also supported. Or in implementation-speak: the class attribute of the sortMerges element is optional (defaulted to org.apache.lucene.index.SortingMergePolicy).\n "
        },
        {
            "author": "Shai Erera",
            "id": "comment-15117549",
            "date": "2016-01-26T16:51:31+0000",
            "content": "I was hoping that we'd change solrconfig.xml to support something like a <mergepolicy> element which will allow you to define a nested MP. That way one can define SortingMergePolicy by an element like that:\n\n\n<mergepolicy class=\"solr.SortingMergePolicy\">\n  <params>\n    <sort>f1 desc, f2 asc ... </sort>\n  </param>\n  <mergepolicy class=\"solr.TieredMergePolicy\">\n  </mergepolicy>\n</mergepolicy>\n\n\n\nThis would allow us to define any \"wrapper\" MPs in a more general way. What do you think? "
        },
        {
            "author": "Christine Poerschke",
            "id": "comment-15117693",
            "date": "2016-01-26T18:30:39+0000",
            "content": "solrconfig.xml to support something like a <mergepolicy> element which will allow you to define a nested MP.\n\nI also had noticed the similarity between the with-class-attribute sortMerges element and the existing mergePolicy element. The elements within a mergePolicy currently can be only primitive elements and mergePolicy-within-mergePolicy elements might be confusing from a user's perspective?\n\n\n\n\nIf we want wrapper merge policies support then I would instead favour 'chaining' instead of 'nesting' of the solrconfig.xml elements, for example:\n\n<indexConfig>\n  <mergePolicy class=\"org.apache.lucene.index.TieredMergePolicy\">\n    <int name=\"segmentsPerTier\">42</int>\n  </mergePolicy>\n  <mergePolicy class=\"org.apache.lucene.index.SortingMergePolicy\">\n    <str name=\"sort\">timestamp desc</str>\n  </mergePolicy>\n</indexConfig>\n\n\nSolrIndexConfig.java code outline:\n\nprivate MergePolicy buildMergePolicyChain(IndexSchema schema) {\n  MergePolicy policy = null;\n  for (PluginInfo mergePolicyInfo : mergePolicyInfos) {\n    String mpClassName = mergePolicyInfo.className;\n    Class<?> mpClass = schema.getResourceLoader().findClass(mpClassName, MergePolicy.class);\n\n    NamedList initArgs = mergePolicyInfo.initArgs;\n\n    if (LogMergePolicy.class.isAssignableFrom(mpClass)) {\n      LogMergePolicy logMergePolicy = schema.getResourceLoader().newInstance(mpClassName, LogMergePolicy.class);\n      // ...\n      policy = logMergePolicy;\n    } else if (TieredMergePolicy.class.isAssignableFrom(mpClass)) {\n      TieredMergePolicy tieredMergePolicy = schema.getResourceLoader().newInstance(mpClassName, TieredMergePolicy.class);\n      // ...\n      policy = tieredMergePolicy;\n    } else if (SortingMergePolicy.class.isAssignableFrom(mpClass)) {\n      // clone initArgs so that we can remove the 'sort' element\n      initArgs = initArgs.clone();\n      final Object sortArg = initArgs.remove(\"sort\");\n      // now parse the 'sort' element\n      final Sort mergeSort = SortSpecParsing.parseSortSpec((String)sortArg, schema).getSort();\n      // then construct the sorting merge policy\n      log.info(\"Using {}(policy={},mergeSort={})\", mpClassName, policy, mergeSort);\n      SortingMergePolicy sortingMergePolicy = schema.getResourceLoader().newInstance(mpClassName, SortingMergePolicy.class,\n          null,\n          new Class[] { MergePolicy.class, Sort.class },\n          new Object[] { policy, mergeSort });\n      policy = sortingMergePolicy;\n    } else {\n      policy = schema.getResourceLoader().newInstance(mpClassName, MergePolicy.class);\n    }\n\n    SolrPluginUtils.invokeSetters(policy, initArgs);\n  }\n  return policy;\n}\n\n "
        },
        {
            "author": "David Smiley",
            "id": "comment-15117738",
            "date": "2016-01-26T18:51:04+0000",
            "content": "+1 to chaining.\n\nAs an aside, It's nice to see the collective input of all of us help make this feature even better than originally proposed.  Thanks for putting effort into this Christine. "
        },
        {
            "author": "Shai Erera",
            "id": "comment-15117967",
            "date": "2016-01-26T20:46:55+0000",
            "content": "I'm OK with chaining, but then can we at least wrap all MPs in a logical element?\n\n\n<indexConfig>\n  <mergePolicies>\n    ...\n  </mergePolicies>\n</indexConfig>\n\n\n\nThat way, if we see only <mergePolicy>, it's a single one, otherwise (<mergePolicies>) we activate chaining. We're both backward-compatible and also don't risk someone stuffing in between elements that aren't merge policies. Also, I feel that if I'd use it, it would make sense to me that all MPs are actually one thing, and not multiple instances... "
        },
        {
            "author": "Shai Erera",
            "id": "comment-15118799",
            "date": "2016-01-27T07:33:45+0000",
            "content": "Rethinking my proposal, I'm not sure chaining merge policies is the right approach. What does it mean if I chain LogMergePolicy and TieredMergePolicy? How about if we introduce a MergePolicyPlugin/Factory, which would allow one to implement whatever MergePolicy he wants (including wrapping others). And we introduce out-of-the-box a SortingMergePolicyPlugin/Factory which takes flat attributes to initialize itself, e.g.:\n\n\n  <mergePolicyPlugin class=\"solr.SortingMergePolicyPlugin\">\n    <sort>f1 desc, f2 asc, ... </sort>\n    <delegate.class>solr.TieredMergePolicy\"</delegate.class>\n    <delegate.mergeFactor>10</delegate.mergeFactor>\n  </mergePolicyPlugin>\n\n\n\nAlternatively, if this works too, it's better IMO:\n\n\n  <mergePolicyPlugin class=\"solr.SortingMergePolicyPlugin\">\n    <sort>f1 desc, f2 asc, ... </sort>\n    <delegate class=\"solr.TieredMergePolicy\"\n              mergeFactor=\"10\"\n              ...\n    </delegate>\n  </mergePolicyPlugin>\n\n "
        },
        {
            "author": "Christine Poerschke",
            "id": "comment-15119121",
            "date": "2016-01-27T11:59:47+0000",
            "content": "I like the idea of a MergePolicyFactory and the idea of delegate.something notation is also interesting.\n\nThere would have to be out-of-the-box factories for all existing non-wrapping merge policies e.g.\n\n<!-- public TieredMergePolicy() { -->\n<mergePolicyFactory class=\"TieredMergePolicyFactory\">\n  <int name=\"segmentsPerTier\">42</int>\n</mergePolicyFactory>\n\n\n\nAn out-of-the-box factory would also be provided for existing plain wrapping merge policies e.g.\n\n<!-- public UpgradeIndexMergePolicy(MergePolicy base) { -->\n<mergePolicyFactory class=\"UpgradeIndexMergePolicyFactory\">\n  <str name=\"base\">TieredMergePolicyFactory</str>\n  <int name=\"base.segmentsPerTier\">42</int>\n</mergePolicyFactory>\n\n\n\nThe factory for building sorting merge policies could look something like this:\n\n<!-- public SortingMergePolicy(MergePolicy in, Sort sort) { -->\n<mergePolicyFactory class=\"SortingMergePolicyFactory\">\n  <str name=\"in\">TieredMergePolicyFactory</str>\n  <int name=\"in.segmentsPerTier\">42</int>\n  <str name=\"sort\">timestamp desc</str>\n</mergePolicyFactory>\n\n\n\nFor consistency we should (in my opinion) conceptually support wrapping of wrapping merge policies e.g. someone could go and create their own MyInstrumentedMergePolicyFactory factory and use it like this:\n\n<!-- public MyInstrumentedMergePolicy(MergePolicy mergePolicy) { -->\n<mergePolicyFactory class=\"MyInstrumentedMergePolicyFactory\">\n  <str name=\"mergePolicy\">SortingMergePolicyFactory</str>\n  <str name=\"mergePolicy.in\">TieredMergePolicyFactory</str>\n  <int name=\"mergePolicy.in.segmentsPerTier\">42</int>\n  <str name=\"mergePolicy.sort\">timestamp desc</str>\n  <int name=\"instrumentationLevel\">42</int>\n</mergePolicyFactory>\n\n\n\nticketing details: if we choose to go down the MergePolicyFactory route then i would suggest this would be best done via a separate JIRA ticket and when that separate JIRA ticket completes the SOLR-5730 efforts here would resume/continue. "
        },
        {
            "author": "Shai Erera",
            "id": "comment-15119125",
            "date": "2016-01-27T12:04:32+0000",
            "content": "I don't think that we need to change all MPs to MPFs. If you encounter an MP, you parse it as usual (this is also needed for back-compat). If someone defines an explicit MPF, we use it. For now (this issue that is), we just implement a SortingMergePolicyFactory. For the \"flat\" MP, we can create a simple FlatMPF or ImplicitMPF (or whatever) that will parse the MP out of solrconfig.xml.\n\nI think that if we proceed with this issue before we have MPF, then we'll need to support both single MP, chained MP and MPF, which I don't think we want? "
        },
        {
            "author": "Christine Poerschke",
            "id": "comment-15119206",
            "date": "2016-01-27T13:09:35+0000",
            "content": "I don't think that we need to change all MPs to MPFs.\n\nWe currently have mergeFactor and maxMergeDocs elements alongside the mergePolicy element. I would see the MergePolicyFactory route as an opportunity to deprecate the mergeFactor/maxMergeDocs/mergePolicy elements i.e. for a transition period users can use the existing/deprecated elements or the new mergePolicyFactory element but eventually we will remove the deprecated elements.\n\nexisting/deprecated:\n\n<mergeFactor>12</mergeFactor>\n<maxMergeDocs>345</maxMergeDocs>\n<mergePolicy class=\"...\" />\n\n\n\nreplacement:\n\n<mergePolicyFactory class=\"...Factory\">\n  <int name=\"mergeFactor\">12</int>\n  <int name=\"maxMergeDocs\">345</int>\n</mergePolicyFactory>\n\n\n\nexisting code snippet:\nNote that maxMergeDocs only applies to LogMergePolicy policies.\nNote that mergeFactor only applies to LogMergePolicy and TieredMergePolicy policies.\n\nmaxMergeDocs=solrConfig.getInt(prefix+\"/maxMergeDocs\",def.maxMergeDocs);\nmergeFactor=solrConfig.getInt(prefix+\"/mergeFactor\",def.mergeFactor);\nmergePolicyInfo = getPluginInfo(prefix + \"/mergePolicy\", solrConfig, def.mergePolicyInfo);\n...\nif (policy instanceof LogMergePolicy) {\n  LogMergePolicy logMergePolicy = (LogMergePolicy) policy;\n  fixUseCFMergePolicyInitArg(LogMergePolicy.class);\n  if (maxMergeDocs != -1)\n    logMergePolicy.setMaxMergeDocs(maxMergeDocs);\n  if (mergeFactor != -1)\n    logMergePolicy.setMergeFactor(mergeFactor);\n} else if (policy instanceof TieredMergePolicy) {\n  TieredMergePolicy tieredMergePolicy = (TieredMergePolicy) policy;\n  fixUseCFMergePolicyInitArg(TieredMergePolicy.class);\n  if (mergeFactor != -1) {\n    tieredMergePolicy.setMaxMergeAtOnce(mergeFactor);\n    tieredMergePolicy.setSegmentsPerTier(mergeFactor);\n  }\n} else if (mergeFactor != -1) {\n  log.warn(\"Use of <mergeFactor> cannot be configured if merge policy is not an instance of LogMergePolicy or TieredMergePolicy. The configured policy's defaults will be used.\");\n}\n\n "
        },
        {
            "author": "Shai Erera",
            "id": "comment-15119287",
            "date": "2016-01-27T14:20:50+0000",
            "content": "OK I see, then in this issue you want to add another \"alongside\" attribute for SortingMP (<sortMerges>) and then deprecate the whole stuff and move to MergePolicyFactory? Or did you first intend to introduce MPF, and only then address SortingMP? I guess that adding <sortMerges> just to immediately deprecate it seems odd, especially if both will be released in 5.5...\n\nWhile we're at it, useCompoundFiles in Lucene has two meanings too: for IndexWriter it determines if flushed segments are flushed as .cfs and in MergePolicy it determines about merged segments. The two are not equivalent, so I suggest we note that in the MPF changes too. "
        },
        {
            "author": "Christine Poerschke",
            "id": "comment-15119309",
            "date": "2016-01-27T14:34:38+0000",
            "content": "... did you first intend to introduce MPF ... adding <sortMerges> just to immediately deprecate it seems odd ...\n\nYes, my preference would be to first introduce MPF with (say) UpgradeIndexMergePolicyFactory as example and for there to never be that \"alongside\" <sortMerges> attribute.\n\nThanks for mentioning about useCompoundFiles meanings. It would be good i think to not carry over the fixUseCFMergePolicyInitArg logic into the MPF code. "
        },
        {
            "author": "Shai Erera",
            "id": "comment-15119350",
            "date": "2016-01-27T14:53:10+0000",
            "content": "OK so in that case it's better. We'll put this issue on-hold for MPF, then resume with it? Is there something I can help with?  "
        },
        {
            "author": "Christine Poerschke",
            "id": "comment-15123394",
            "date": "2016-01-29T12:00:13+0000",
            "content": "SOLR-5730 will be suspended for now, to resume once SOLR-8621 is done. "
        },
        {
            "author": "Christine Poerschke",
            "id": "comment-15123397",
            "date": "2016-01-29T12:02:11+0000",
            "content": "Help and collaboration always welcome  Have created SOLR-8621's master-solr-8621 work-in-progress branch with that in mind. Thanks! "
        },
        {
            "author": "Jack Krupansky",
            "id": "comment-15128303",
            "date": "2016-02-02T14:19:22+0000",
            "content": "Sorry for arriving so late to the party here, but I've gotten lost in all the back and forth... is there going to be a simple and easy to use XML element to let the user simply enable sort merge and specify a field list, as opposed to having to manually construct an elaborate Lucene-level set of wrapped merge policies? I mean, sure, some experts will indeed wish to fully configure every detail of a Lucene merge policy, but for non-expert users who just want to assure that their index is pre-sorted to align with a query sorting, the syntax should be... simple. If the user does construct some elaborate wrapped MP, then some sort of parameter substitution would be needed, but if the user uses the default solrconfig which has no explicit MP, Solr should build that full, wrapped MP with just the sort field names substituted.\n\nIn short, I just wanted to know whether this was intended to be a very easy to use feature (supposed to be the trademark of Solr) or some super-elaborate expert-only feature that we would be forced to recommend that average users stay away from.\n\nPersonally, my preference would be to focus on introducing a first-class Solr feature of a \"preferred document order\", which is effectively a composite primary key in database nomenclature.\n\nSo, let's not forget that this is Solr we are talking about, not raw Lucene.\n\nI'd like to know that Yonik Seeley and Hoss Man are explicitly on board with what is bring proposed. "
        },
        {
            "author": "Christine Poerschke",
            "id": "comment-15128346",
            "date": "2016-02-02T14:48:57+0000",
            "content": "Jack Krupansky - it's never too late to join the party here  I've just updated the summary to reflect the latest patch state (though exact SOLR-8621 details are still a work-in-progress). Hope that clarifies things. Thanks for your input. "
        },
        {
            "author": "Hoss Man",
            "id": "comment-15128656",
            "date": "2016-02-02T17:47:04+0000",
            "content": "I think the direction being taken in SOLR-8621 looks like a good idea in general for better configuring/modeling the true state of things internally as far as merge policies are concerned.  I think it also makes sense to somewhat put this issue (SOLR-5730) on hold until some of those plumbing related questions are resolved.\n\nultimately, i suspect using SortingMergePolicy is an advanced enough option that if it requires some non-trivial config then so be it \u2013 we can document what that config looks like and provide common recipes with clear instructions of what key knobs/values users have to consider to use those recipes.\n\nIf, ultimately, we decide that the \"full syntax\" for specifying a merge policy with SortingMergePolicy warpper is overly verbose for basic users, and we also want some simplified way for users to say \"use whatever default (merge policy) Solr thinks is best, but please sort docs on disk like this...\" then that can always be added as syntactic sugar later.\n "
        },
        {
            "author": "Shai Erera",
            "id": "comment-15128698",
            "date": "2016-02-02T18:10:26+0000",
            "content": "Hoss Man, this issue is now on hold until we finish with SOLR-8621 (see Christine Poerschke earlier comment).\n\nJack Krupansky the intention of SOLR-8621 and this issue is to allow users to define compound merge policies in solrconfig.xml with ease. Currently, it's impossible and if you want to use something like UpgradeIndexMergePolicy, you have to create your own MP class which will delegate internally to UpgradeIndexMP. For users who still want to define simple merge policies like TieredMergePolicy, the structure in the XML will not be much different. Instead of:\n\n\n<mergePolicy class=\"org.apache.lucene.index.TieredMergePolicy\">\n  <int name=\"segmentsPerTier\">42</int>\n</mergePolicy>\n\n\n\nThey will need to specify\n\n\n<mergePolicyFactory class=\"org.apache.solr.index.TieredMergePolicyFactory\">\n  <int name=\"segmentsPerTier\">42</int>\n</mergePolicyFactory>\n\n\n\nThe factory allows more advanced users to create whatever MP they want, rather easily. Also, with this change, we deprecate some settings that are now defined globally (like mergeFactor), and move them inside the <mergePolicyFactory> section, where they belong.\n\nHope this clarifies it better. "
        },
        {
            "author": "Jack Krupansky",
            "id": "comment-15129131",
            "date": "2016-02-02T22:03:33+0000",
            "content": "Let me try again... again, my apologies for not commenting much earlier before things got a bit complicated. Let me see if I have this straight:\n\n1. There are three related tickets: SOLR-4654, SOLR-5730, SOLR-8621.\n2. There are three key features of interest: UpgradeIndexMergePolicy, SortingMergePolicy , and EarlyTerminatingSortingCollector.\n3. The first ticket is kind of the umbrella.\n4. The second ticket is focused on the second and third features.\n5. The third ticket is the foundation for all three features.\n6. The third ticket has some user impact and delivers some additional minor benefits, but enabling those other three features is its true purpose.\n7. SortingMergePolicy and EarlyTerminatingSortingCollector are really two sides of a single feature, the index side and the query side of (in my words) \"pre-sorted indexing\".\n\nNow, I have only one remaining question area: Isn't the forceMerge method the only real benefit of UpgradeIndexMergePolicy? Is that purely for the Solr optimize option, or is there some intent to surface it for users some other way in Solr? Isn't it more of a one-time operation rather than something that should be in place for all merge operations? Or is it so cheap if not used that we should simply pre-configure it all the time? "
        },
        {
            "author": "Shai Erera",
            "id": "comment-15130096",
            "date": "2016-02-03T09:26:09+0000",
            "content": "Hi Jack Krupansky, your understanding is correct.\n\nThe third ticket has some user impact and delivers some additional minor benefits\n\nIt depends how you view it. I recently found that defining my own MP (when it wraps another one especially) is not so trivial in solrconfig.xml. You could argue that for the majority of the users, this is a very advanced feature to have, and I would agree. But for those who want to write more advanced and tailored merge policies, SOLR-8621 will allow them to do so quite easily. And the impact to the users who don't need it is marginal (see my previous comment).\n\nThe reason I quoted that sentence is because of the words minor benefits \u2013 it's a matter of perspective of course \u2013 if you will be facing the need to write a special MP, then this feature will have huge benefits for you. I know you don't argue about the need, but just wanted to give my own perspective on this.\n\nAs for UpgradeIndexMergePolicy you're right that it's a one-time operation and the main purpose is to allow you to upgrade all segments of your index to a newer format. You will likely only use it when you upgrade to 6.0 and you think (or know) that you still have segments created by 4.x code. Note, that that you upgraded your software to Solr 5.x doesn't mean that the existing indexes' segments were upgraded too!\n\nBut even for this one-time operation, you currently have no way to define UpgradeIndexMergePolicy in a <mergePolicy> element, since it needs to take a wrapped MP which will actually decide which segments to merge together etc. (i.e. create the merge plan). So even for this one time operation, you'd need to have SOLR-8621 in place.\n\nI don't view SOLR-4654 as an umbrella ticket at all, but more of a duplicate of this one. SOLR-8621 lays the foundations for allowing users to define compound merge policies, and in this ticket we will add a SortingMergePolicyFactory. As you said, this only handles the indexing side of things, and there's still work to be done in order to make use of it during search (i.e. integrate EarlyTerminatingSortingCollector. Also, I'm pretty sure I saw in SolrIndexSearcher early termination by time (which sort of covers the second part of SOLR-4654), though I haven't seen it actually being used. "
        },
        {
            "author": "Christine Poerschke",
            "id": "comment-15139818",
            "date": "2016-02-09T21:35:06+0000",
            "content": "Resumed rebasing work for this ticket here, jira/solr-5730-master working-branch created (but final commit will still be attached as patch to this ticket for consistency and clarity), reviews, comments, etc. welcome as always.\n\n(Note that the working-branch commit marked as tentative would form part not of SOLR-5730 here but it or something equivalent will be committed as part of SOLR-8621.) "
        },
        {
            "author": "Christine Poerschke",
            "id": "comment-15141942",
            "date": "2016-02-10T23:23:03+0000",
            "content": "SOLR-5730-part1and2.patch attached against latest master/trunk. If there are no further comments or concerns and if all else goes well then that will be the final patch for this ticket, and I will commit it Thursday afternoon/evening or Friday morning London time. "
        },
        {
            "author": "Shai Erera",
            "id": "comment-15142109",
            "date": "2016-02-11T01:36:56+0000",
            "content": "Few comments about the patch:\n\n\n\tIn QueryComponent: if(existingSegmentTerminatedEarly == null) \u2013 can you add a space after the 'if'?\n\n\n\n\n\tSortingMergePolicyFactory.getMergePolicy() calls args.invokeSetters(mp);, like UpgradeIndexMergePolicyFactory. I wonder if we can have a protected abstract getMergePolicyInstance(wrappedMP), so that WrapperMergePolicyFactory.getMergePolicy() implements it by calling this method followed by args.invokeSetters(mp);. What do you think?\n\n\n\n\n\tSolrIndexSearcher:  qr.setSegmentTerminatedEarly(earlyTerminatingSortingCollector.terminatedEarly()); \u2013 should we also set qr.partialResults?\n\n\n\n\n\tDefaultSolrCoreState: you can change the to:\n\n\n\n\npublic Sort getMergePolicySort() throws IOException {\n  lock(iwLock.readLock());\n  try {\n    if (indexWriter != null) {\n      final MergePolicy mergePolicy = indexWriter.getConfig().getMergePolicy();\n      if (mergePolicy instanceof SortingMergePolicy) {\n        return ((SortingMergePolicy) mergePolicy).getSort();\n      }\n    }\n  } finally {\n    iwLock.readLock().unlock();\n  }\n}\n\n\n\n\n\tWhat's the purpose of enable=\"${solr.sortingMergePolicyFactory.enable:true}\"?\n\n\n\n\n\tI kind of feel like the test you added to TestMiniSolrCloudCluster doesn't belong in that class. Perhaps it should be in its own test class, inheriting from this class, or just using MiniSolrCloudCluster?\n\n\n\n\n\tRandomForceMergePolicyFactory is not really related to this issue. Perhaps you should commit it separately?\n\n "
        },
        {
            "author": "Christine Poerschke",
            "id": "comment-15142711",
            "date": "2016-02-11T13:24:14+0000",
            "content": "Thanks for the review comments Shai Erera!\n\n... I wonder if we can have a protected abstract getMergePolicyInstance(wrappedMP) ...\n\nYes, that makes sense and will make WrapperMergePolicyFactory similar to WrapperMergePolicyFactory i.e. both will have a protected abstract MergePolicy getMergePolicyInstance though with different arguments. Will action this under SOLR-8621 where it really belongs.\n\nRandomForceMergePolicyFactory is not really related to this issue. Perhaps you should commit it separately?\n\nYes, I agree, since RandomForceMergePolicy already exists this would belong to SOLR-8621 also. "
        },
        {
            "author": "ASF subversion and git services",
            "id": "comment-15143094",
            "date": "2016-02-11T17:24:10+0000",
            "content": "Commit 360051a414e291a7b3ffb5a0180a404fa18f3a6c in lucene-solr's branch refs/heads/master from Christine Poerschke\n[ https://git-wip-us.apache.org/repos/asf?p=lucene-solr.git;h=360051a ]\n\nSOLR-8621: factor out protected abstract WrapperMergePolicyFactory.getMergePolicyInstance method\n\nHere in SOLR-8621:\n\n\tUpgradeIndexMergePolicyFactory extends WrapperMergePolicyFactory\n\t(WrapperMergePolicyFactoryTest's) DefaultingWrapperMergePolicyFactory extends WrapperMergePolicyFactory\n\n\n\nElsewhere in SOLR-5730:\n\n\tSortingMergePolicyFactory will extend WrapperMergePolicyFactory\n\n "
        },
        {
            "author": "Christine Poerschke",
            "id": "comment-15143200",
            "date": "2016-02-11T18:22:53+0000",
            "content": "SolrIndexSearcher: qr.setSegmentTerminatedEarly(earlyTerminatingSortingCollector.terminatedEarly()); \u2013 should we also set qr.partialResults?\n\nNo, I don't think so: qr.partialResults is used to indicate that partial results were returned because the timeAllowed limit was exceeded. In comparison qr.segmentTerminatedEarly indicates that full results were returned and we made use of the EarlyTerminatingSortingCollector which early terminated the collecting of at least one segment. Had we not early-terminated for any of the segments then the results would still have been the same full results. \u2014 So why would anyone care about the qr.segmentTerminatedEarly flag in the response? If the flag is TRUE then the returned numFound will be potentially less than the numFound returned by an identical search that didn't segment-terminate-early. \u2014 As an aside, \"partialResults\" in the response can also occur if there is no timeAllowed specified but shards.tolerant=true was specified and there was a problem talking to at least one of the shards. "
        },
        {
            "author": "Christine Poerschke",
            "id": "comment-15143223",
            "date": "2016-02-11T18:36:30+0000",
            "content": "What's the purpose of enable=\"${solr.sortingMergePolicyFactory.enable:true}\"?\n\nGood catch. This used to be the enable attribute in the <sortMerges> element alongside the <mergePolicy> element i.e.\n\n<mergePolicy class=\"...\"/>\n<sortMerges enable=\"${solr.sortMerges.enable:false}\">...</sortMerges>\n\n\nbut now that we have a combined <mergePolicyFactory class=\"SortingMergePolicy\">...</mergePolicyFactory> it doesn't really make sense anymore. I will remove it.\n\nI kind of feel like the test you added to TestMiniSolrCloudCluster doesn't belong in that class. Perhaps it should be in its own test class, inheriting from this class, or just using MiniSolrCloudCluster?\n\nI agree that TestMiniSolrCloudCluster has grown to have all sorts of test methods which could be broken up somehow. SOLR-7886 exists to 'factor out a TestMiniSolrCloudClusterBase class', initial discussion was in SOLR-7877, and so for now I'd like to keep the short-ish testSegmentTerminateEarly method in TestMiniSolrCloudCluster but I will try and see if the TestSegmentTerminateEarlyState helper class with the longer logic can be factored out into a class of its own. "
        },
        {
            "author": "Christine Poerschke",
            "id": "comment-15143595",
            "date": "2016-02-11T22:13:19+0000",
            "content": "Attached revised SOLR-5730-part1and2.patch - new or further reviews and comments welcome as usual. If there are no further comments or concerns then will aim to commit the patch tomorrow/Friday towards end of London day. "
        },
        {
            "author": "Shai Erera",
            "id": "comment-15143646",
            "date": "2016-02-11T22:48:52+0000",
            "content": "Patch looks good! One minor comment \u2013 in SortingMergePolicyFactory.getMergePolicyInstance() I'd inline to return new Sorting .... "
        },
        {
            "author": "ASF subversion and git services",
            "id": "comment-15144783",
            "date": "2016-02-12T16:18:55+0000",
            "content": "Commit b2e83b6788b5b3c9ee6cf13be1cddec7f21014f4 in lucene-solr's branch refs/heads/branch_5x from Christine Poerschke\n[ https://git-wip-us.apache.org/repos/asf?p=lucene-solr.git;h=b2e83b6 ]\n\nSOLR-8621: factor out protected abstract WrapperMergePolicyFactory.getMergePolicyInstance method\n\nHere in SOLR-8621:\n\n\tUpgradeIndexMergePolicyFactory extends WrapperMergePolicyFactory\n\t(WrapperMergePolicyFactoryTest's) DefaultingWrapperMergePolicyFactory extends WrapperMergePolicyFactory\n\n\n\nElsewhere in SOLR-5730:\n\n\tSortingMergePolicyFactory will extend WrapperMergePolicyFactory\n\n "
        },
        {
            "author": "ASF subversion and git services",
            "id": "comment-15144818",
            "date": "2016-02-12T16:40:20+0000",
            "content": "Commit 6a9d89309595ff668f851c17af4f3f97af7640c1 in lucene-solr's branch refs/heads/branch_5_5 from Christine Poerschke\n[ https://git-wip-us.apache.org/repos/asf?p=lucene-solr.git;h=6a9d893 ]\n\nSOLR-8621: factor out protected abstract WrapperMergePolicyFactory.getMergePolicyInstance method\n\nHere in SOLR-8621:\n\n\tUpgradeIndexMergePolicyFactory extends WrapperMergePolicyFactory\n\t(WrapperMergePolicyFactoryTest's) DefaultingWrapperMergePolicyFactory extends WrapperMergePolicyFactory\n\n\n\nElsewhere in SOLR-5730:\n\n\tSortingMergePolicyFactory will extend WrapperMergePolicyFactory\n\n "
        },
        {
            "author": "ASF subversion and git services",
            "id": "comment-15145218",
            "date": "2016-02-12T20:16:35+0000",
            "content": "Commit 677779086c87db33406f3344736187fa10a30901 in lucene-solr's branch refs/heads/master from Christine Poerschke\n[ https://git-wip-us.apache.org/repos/asf?p=lucene-solr.git;h=6777790 ]\n\nSOLR-5730: Make Lucene's SortingMergePolicy and EarlyTerminatingSortingCollector configurable in Solr. "
        },
        {
            "author": "ASF subversion and git services",
            "id": "comment-15145292",
            "date": "2016-02-12T21:03:53+0000",
            "content": "Commit 805eeb932a872205cd6b43ab1a158c75ca939ea7 in lucene-solr's branch refs/heads/branch_5x from Christine Poerschke\n[ https://git-wip-us.apache.org/repos/asf?p=lucene-solr.git;h=805eeb9 ]\n\nSOLR-5730: Make Lucene's SortingMergePolicy and EarlyTerminatingSortingCollector configurable in Solr.\n\nCherry-picked commit 6777790 from master and resolved merge conflicts for\nsolr/core/src/java/org/apache/solr/search/Query(Command|Result).java and SolrIndexSearcher.java\n(the former had previously been factored out from the latter in master but not branch_5x). "
        },
        {
            "author": "Christine Poerschke",
            "id": "comment-15145302",
            "date": "2016-02-12T21:08:56+0000",
            "content": "Changes committed to master and cherry-picked to branch_5x (but not branch_5_5). Will resolve ticket on Monday assuming no further comments or test issues etc. "
        },
        {
            "author": "ASF subversion and git services",
            "id": "comment-15145565",
            "date": "2016-02-12T23:42:05+0000",
            "content": "Commit f9df240e5ccbd9bd5687eec1d927d3eb517ce8e4 in lucene-solr's branch refs/heads/master from Christine Poerschke\n[ https://git-wip-us.apache.org/repos/asf?p=lucene-solr.git;h=f9df240 ]\n\nSOLR-5730: rename TestSegmentTerminateEarlyState to SegmentTerminateEarlyTestState "
        },
        {
            "author": "ASF subversion and git services",
            "id": "comment-15145569",
            "date": "2016-02-12T23:43:17+0000",
            "content": "Commit a48d85fdc7d62011c2514748b963accc3c102f1c in lucene-solr's branch refs/heads/branch_5x from Christine Poerschke\n[ https://git-wip-us.apache.org/repos/asf?p=lucene-solr.git;h=a48d85f ]\n\nSOLR-5730: rename TestSegmentTerminateEarlyState to SegmentTerminateEarlyTestState "
        },
        {
            "author": "ASF subversion and git services",
            "id": "comment-15145963",
            "date": "2016-02-13T12:53:48+0000",
            "content": "Commit 779120c6a48daf25e46a00f7e6981f8afcd0f3e8 in lucene-solr's branch refs/heads/master from Uwe Schindler\n[ https://git-wip-us.apache.org/repos/asf?p=lucene-solr.git;h=779120c ]\n\nSOLR-5730: Workaround non-working javadocs link (cannot refer to classes from packages in other modules that already exist in lucene-core.jar) "
        },
        {
            "author": "ASF subversion and git services",
            "id": "comment-15145966",
            "date": "2016-02-13T12:55:47+0000",
            "content": "Commit b4811f63bc2f1af174886b379a628391fbcf2012 in lucene-solr's branch refs/heads/branch_5x from Uwe Schindler\n[ https://git-wip-us.apache.org/repos/asf?p=lucene-solr.git;h=b4811f6 ]\n\nSOLR-5730: Workaround non-working javadocs link (cannot refer to classes from packages in other modules that already exist in lucene-core.jar) "
        }
    ]
}