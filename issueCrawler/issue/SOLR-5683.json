{
    "id": "SOLR-5683",
    "title": "Documentation of Suggester V2",
    "details": {
        "affect_versions": "None",
        "status": "Resolved",
        "fix_versions": [
            "4.10",
            "6.0"
        ],
        "components": [
            "SearchComponents - other"
        ],
        "type": "Task",
        "priority": "Major",
        "labels": "",
        "resolution": "Fixed"
    },
    "description": "Place holder for documentation that will eventually end up in the Solr Ref guide.\n====\nThe new Suggester Component allows Solr to fully utilize the Lucene suggesters. \nThe main features are:\n\n\tlookup pluggability (TODO: add description):\n\t\n\t\tAnalyzingInfixLookupFactory\n\t\tAnalyzingLookupFactory\n\t\tFuzzyLookupFactory\n\t\tFreeTextLookupFactory\n\t\tFSTLookupFactory\n\t\tWFSTLookupFactory\n\t\tTSTLookupFactory\n\t\tJaspellLookupFactory\n\t\n\t\n\tDictionary pluggability (give users the option to choose the dictionary implementation to use for their suggesters to consume)\n\t\n\t\tInput from search index\n\t\t\n\t\t\tDocumentDictionaryFactory \u2013 user can specify suggestion field along with optional weight and payload fields from their search index.\n\t\t\tDocumentExpressionFactory \u2013 same as DocumentDictionaryFactory but allows users to specify arbitrary expression using existing numeric fields.\n\t\t\tHighFrequencyDictionaryFactory \u2013 user can specify a suggestion field and specify a threshold to prune out less frequent terms.\n\t\t\n\t\t\n\t\tInput from external files\n\t\t\n\t\t\tFileDictionaryFactory \u2013 user can specify a file which contains suggest entries, along with optional weights and payloads.\n\t\t\n\t\t\n\t\n\t\n\n\n\nConfig (index time) options:\n\n\tname - name of suggester\n\tsourceLocation - external file location (for file-based suggesters)\n\tlookupImpl - type of lookup to use [default JaspellLookupFactory]\n\tdictionaryImpl - type of dictionary to use (lookup input) [default\n    (sourceLocation == null ? HighFrequencyDictionaryFactory : FileDictionaryFactory)]\n\tstoreDir - location to store in-memory data structure in disk\n\tbuildOnCommit - command to build suggester for every commit\n\tbuildOnOptimize - command to build suggester for every optimize\n\n\n\n\n\nQuery time options:\n\n\tsuggest.dictionary - name of suggester to use (can occur multiple times for batching suggester requests)\n\tsuggest.count - number of suggestions to return\n\tsuggest.q - query to use for lookup\n\tsuggest.build - command to build the suggester\n\tsuggest.reload - command to reload the suggester\n\tbuildAll \u2013 command to build all suggesters in the component\n\treloadAll \u2013 command to reload all suggesters in the component\n\n\n\n\nExample query:\n\nhttp://localhost:8983/solr/suggest?suggest.dictionary=suggester1&suggest=true&suggest.build=true&suggest.q=elec\n\n\nDistributed query:\n\nhttp://localhost:7574/solr/suggest?suggest.dictionary=suggester2&suggest=true&suggest.build=true&suggest.q=elec&shards=localhost:8983/solr,localhost:7574/solr&shards.qt=/suggest\n\n\t\nResponse Format:\nThe response format can be either XML or JSON. The typical response structure is as follows:\n \n{\n  suggest: {\n    suggester_name: {\n       suggest_query: { numFound:  .., suggestions: [ {term: .., weight: .., payload: ..}, .. ]} \n   }\n}\t\n\n\n\n\n\n\n\nExample Response:\n\n{\n    responseHeader: {\n        status: 0,\n        QTime: 3\n    },\n    suggest: {\n        suggester1: {\n            e: {\n                numFound: 1,\n                suggestions: [\n                    {\n                        term: \"electronics and computer1\",\n                        weight: 100,\n                        payload: \"\"\n                    }\n                ]\n            }\n        },\n        suggester2: {\n            e: {\n                numFound: 1,\n                suggestions: [\n                    {\n                        term: \"electronics and computer1\",\n                        weight: 10,\n                        payload: \"\"\n                    }\n                ]\n            }\n        }\n    }\n}\n\n\n\nExample solrconfig snippet with multiple suggester configuration:\n\n  \n  <searchComponent name=\"suggest\" class=\"solr.SuggestComponent\">\n    <lst name=\"suggester\">\n      <str name=\"name\">suggester1</str>\n      <str name=\"lookupImpl\">FuzzyLookupFactory</str>      \n      <str name=\"dictionaryImpl\">DocumentDictionaryFactory</str>      \n      <str name=\"field\">cat</str>\n      <str name=\"weightField\">price</str>\n      <str name=\"suggestAnalyzerFieldType\">string</str>\n    </lst>\n   <lst name=\"suggester\">\n        <str name=\"name\">suggester2 </str>\n        <str name=\"dictionaryImpl\">DocumentExpressionDictionaryFactory</str>\n        <str name=\"lookupImpl\">FuzzyLookupFactory</str>\n        <str name=\"field\">product_name</str>\n        <str name=\"weightExpression\">((price * 2) + ln(popularity))</str>\n        <str name=\"sortField\">weight</str>\n        <str name=\"sortField\">price</str>\n        <str name=\"strtoreDir\">suggest_fuzzy_doc_expr_dict</str>\n        <str name=\"suggestAnalyzerFieldType\">text</str>\n      </lst>  \n</searchComponent>",
    "attachments": {},
    "issue_links": {},
    "comments": [
        {
            "author": "Areek Zillur",
            "id": "comment-13887442",
            "date": "2014-01-31T04:04:53+0000",
            "content": "The documentation still has a lot of TODOs, but should be a good start. "
        },
        {
            "author": "Uwe Schindler",
            "id": "comment-13971270",
            "date": "2014-04-16T12:57:37+0000",
            "content": "Move issue to Solr 4.9. "
        },
        {
            "author": "Varun Thacker",
            "id": "comment-14103562",
            "date": "2014-08-20T07:35:28+0000",
            "content": "First draft at documenting the suggesters - This covers all the documentation wrt suggesters under \"Issues from CHANGES.txt that were never doc'ed as part of their release:\" in the https://cwiki.apache.org/confluence/display/solr/Internal+-+TODO+List link.\n\nDocumentDictionaryFactory \u2013 user can specify suggestion field along with optional weight and payload fields from their search index.\n\nLooking at the code of DocumentDictionaryFactory the weight field is not optional.\n--------------------------------------------------------------------------------------------------------------------------------------------------------\nfield - The field from which the suggesters dictionary will be populated.\nweightField - The field from which the suggestions weight will be populated. This should be a numeric field. Suggestions will be sorted based on the value as this is the sole criteria for relevance.\npayloadField - Accompanying payload for each suggestion that gets built. \nsuggestAnalyzerFieldType - Specify the analyzer to be used for the suggester. The \"index\" analyzer of this fieldType will be used to build the suggest dictionary and the \"query\" analyzer will be used during querying.\n\nConfig (index time) options:\nname - Name of suggester. This is optional if you have only one suggester defined.\nsourceLocation - External file location for file-based suggesters only.\nlookupImpl - Type of lookup to use whose default is JaspellLookupFactory. A table below lists all the various lookup implementations present.\ndictionaryImpl - The type of dictionary to be used when building the suggester. The default is FileDictionaryFactory for a file-based suggester and it defaults to HighFrequencyDictionaryFactory otherwise.\nstoreDir - Location to store the dictionary on disk.\nbuildOnCommit - Command to build suggester automatically after every commit that is called. Useful if you want to keep the suggester in sync with your latest data.\nbuildOnOptimize - Command to build suggester automatically after every optimize that is called. Useful if you want to keep the suggester in sync with your latest data.\n\nQuery time options:\nsuggest.dictionary - name of suggester to use\nsuggest.count - number of suggestions to return\nsuggest.q - query to use for lookup\nsuggest.build - command to build the suggester\nsuggest.reload - command to reload the suggester\nbuildAll \u2013 command to build all suggesters in the component\nreloadAll \u2013 command to reload all suggesters in the component\n\n--------------------------------------------------------------------------------------------------------------------------------------------------------\n\nLookup Implementation Options - \n\n\tAnalyzingLookupFactory: Suggester that first analyzes the incoming text and adds the analyzed form to a weighted FST, and then does the same thing at lookup time.\n\tsuggestAnalyzerFieldType - The analyzer used at \"query-time\" and \"build-time\" to analyze suggestions.\n\texactMatchFirst - If true the exact suggestions are returned first, even if they are prefixes of other strings in the FST have larger weights.  Default is true.\n\tpreserveSep - If true then a separator between tokens is preserved. This means that suggestions are sensitive to tokenization (e.g. baseball is different from base ball. Default is true.\n\tpreservePositionIncrements - Whether the suggester should preserve position increments. What this means is that token filters which leave gaps (for example when StopFilter matches a stopword) the position would be respected when building the suggester. The default is false.\n\n\n\n\n\tFuzzyLookupFactory: This is a suggester which is an extension of the AnalyzingSuggester but is fuzzy in nature. The similarity is measured by the Levenshtein algorithm.\n\texactMatchFirst - If true the exact suggestions are returned first, even if they are prefixes of other strings in the FST have larger weights.  Default is true.\n\tpreserveSep - If true then a separator between tokens is preserved. This means that suggestions are sensitive to tokenization (e.g. baseball is different from base ball. Default is true.\n\tmaxSurfaceFormsPerAnalyzedForm - Maximum number of surface forms to keep for a single analyzed form. When there are too many surface forms we discard the lowest weighted ones.\n\tmaxGraphExpansions - When building the FST (\"index-time\"), we add each path through the tokenstream graph as an individual entry. This places an upper-bound on how many expansions will be added for a single suggestion. The default is -1 which means there is no limit.\n\tpreservePositionIncrements - Whether the suggester should preserve position increments. What this means is that token filters which leave gaps (for example when StopFilter matches a stopword) the position would be respected when building the suggester. The default is false.\n\tmaxEdits - Maximum number of string edits allowed. The systems hard limit is 2. The default is 1.\n\ttranspositions - If true transpositions should be treated as a primitive edit operation. The default is true.\n\tnonFuzzyPrefix - The length of the common non fuzzy prefix match which must match a suggestion. The default is 1.\n\tminFuzzyLength - The minimum length of query before which any string edits will be allowed. The default is 3.\n\tunicodeAware -  Measure maxEdits, minFuzzyLength, transpositions and nonFuzzyPrefix parameters in unicode code points (actual letters) instead of bytes. The default is false.\n\n\n\n\n\tAnalyzingInfixSuggesterFactory: Analyzes the input text and then suggests matches based on prefix matches to any tokens in the indexed text. This uses a lucene index for it's dictionary.\n\tindexPath - When using AnalyzingInfixSuggester you can provide your own path where the idnex will get built. The default is analyzingInfixSuggesterIndexDir and will be created in your collections data directory.\n\tminPrefixChars - Minimum number of leading characters before PrefixQuery is used (default 4). Prefixes shorter than this are indexed as character ngrams (increasing index size but making lookups faster).\n\n\n\n\n\tBlendedInfixLookupFactory: It is an extension of the AnalyzingInfixSugegster providing an additional functionality where the prefix matches across the matched documented can be weighted. You can tell is to score higher if a hit is closer to the start of the suggestion or vice versa.\n\tblenderType -  used to calculate weight coefficient using the position of the first matching word. \n\t\tlinear: weightFieldValue*(1 - 0.10*position)  - Matches to the start will be given a higher score (Default)\n\t\treciprocal: weightFieldValue/(1+position)  - Matches to the end will be given a higher score.\n\tnumFactor - Factor to multiply the number of searched elements from which results will be pruned. Default is 10. \n\tindexPath - When using BlendedInfixSuggester you can provide your own path where the index will get built. The default directory name is blendedInfixSuggesterIndexDir and will be created in your collections data directory.\n\tminPrefixChars - Minimum number of leading characters before PrefixQuery is used (default 4). Prefixes shorter than this are indexed as character ngrams (increasing index size but making lookups faster).\t\n\n\n\n\n\tFreeTextSuggesterFactory:  It looks at the last tokens plus the prefix of whatever final token the user is typing, if present to predict the most likely next token. How many previous tokens that need to be considered can also be specified. This suggester would only be used as a fallback, when the primary suggester fails to find any suggestions.\n\tngrams - The max number of tokens out of which singles will be make the dictionary. The default value is 2. Increasing this would mean you want more than the previous 2 tokens to be taken into consideration when making the suggestions.\n\n\n\n\n\tFSTLookupFactory: An FST based suggester.\n\texactMatchFirst - If true the exact suggestions are returned first, even if they are prefixes of other strings in the FST have larger weights.  Default is true.\n\tweightBuckets - The number of separate buckets for weights which the suggester will use while building it's dictionary.\n\n\n\n\n\tTSTLookupFactory: A simple compact ternary trie based lookup.\n\n\n\n\n\tWFSTLookupFactory: Weighted automaton representation; an alternative to FSTLookup for more fine-grained ranking. WFSTLookup does not use buckets, but instead a shortest path algorithm. Note that it expects weights to be whole numbers.\n\n\n\n\n\tJaspellLookupFactory: A more complex lookup based on a ternary trie from the JaSpell(http://jaspell.sourceforge.net/) project.\n\n\n\n--------------------------------------------------------------------------------------------------------------------------------------------------------\n\nDictionary pluggability - The option to choose the dictionary implementation to use for their suggesters to consume the input from the search index.\n\nDocumentDictionaryFactory \u2013 You need to specify the suggeestion field ('field') along with weight ('weightField') and payload('payloadField') fields from their search index.\nDocumentExpressionFactory \u2013 Same as DocumentDictionaryFactory but allows users to specify arbitrary expression into the 'weightExpression' tag.\n\tweightExpression - Specify arbitrary expression used for scoring the suggestions. The fields need to be numeric fields. \nHighFrequencyDictionaryFactory \u2013 user can specify a suggestion field and specify a threshold to prune out less frequent terms.\nInput from external files\n\tthreshold - A value between zero and one representing the minimum fraction of the total documents where a term should appear in order to be added to the lookup dictionary.\nFileDictionaryFactory \u2013 user can specify a file which contains suggest entries, along with weights and payloads. One entry is allowed per line.\n\tfieldDelimiter - Specify the delimiter to be used seperating the entries, weights and payloads. The default is tab.\n--------------------------------------------------------------------------------------------------------------------------------------------------------\nUsing Multiple Suggesters -\nYou can request multiple suggesters to provide suggestions for the same query - \nExample Syntax - localhost:8983/solr/suggest?suggest=true&suggest.dictionary=suggest1&suggest.dictionary=suggest2&suggest.q=python "
        },
        {
            "author": "Cassandra Targett",
            "id": "comment-14104063",
            "date": "2014-08-20T15:53:57+0000",
            "content": "Thanks Areek Zillur and Varun Thacker: I'll take a stab at getting all this into the 4.10 Ref Guide. "
        },
        {
            "author": "Cassandra Targett",
            "id": "comment-14105907",
            "date": "2014-08-21T20:26:45+0000",
            "content": "I'm ready to call this done at https://cwiki.apache.org/confluence/display/solr/Suggester.\n\nVarun Thacker, Areek Zillur: if either of you have a chance, I would appreciate it if you could take a look and let me know if I got anything wrong. If you have edits, feel free to add them as comments to that page and I (or someone) will incorporate them as soon as I can. "
        }
    ]
}