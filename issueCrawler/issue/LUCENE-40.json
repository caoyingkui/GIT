{
    "id": "LUCENE-40",
    "title": "Removing a file from index does not remove all references to file.",
    "details": {
        "labels": "",
        "priority": "Major",
        "components": [
            "core/index"
        ],
        "type": "Bug",
        "fix_versions": [],
        "affect_versions": "1.2",
        "resolution": "Incomplete",
        "status": "Closed"
    },
    "description": "If I walk though a list of files and remove them from \nthe index, it appears as only half of the references are\nreally removed.  \n\nI have included the java class I use to create and update\nthe index below.  If you have any questions, please let me\nknow.  I can also provide the intellij plugin (with \nsource) that does the indexing if you want to use it\nfor debugging.\n\nIn the source below, if I index all the ANT manual API's, and\ndo a search for \"Ant\", I get 531 hits.  After doing the remove\noperation where I remove all the ant manuals docs from the\nindex, I get around 260 hits.  On windows, I sometimes continue\nto get 531 hits.\n\n\nIf this ends up being unreadable...just email me for the file:\n\n/*\n\n\tCreated by IntelliJ IDEA.\n\tUser: rvestal\n\tDate: Jun 11, 2002\n\tTime: 8:52:43 PM\n\tTo change template for new class use\n\tCode Style | Class Templates options (Tools | IDE Options).\n */\npackage org.intellij.plugins.docPlugin.tools.finder;\n\n\n\nimport org.apache.lucene.analysis.standard.StandardAnalyzer;\nimport org.apache.lucene.index.IndexReader;\nimport org.apache.lucene.index.IndexWriter;\nimport org.apache.lucene.store.Directory;\nimport org.apache.lucene.store.FSDirectory;\n\nimport java.io.*;\nimport java.util.Iterator;\nimport java.util.Vector;\n\n\n/**\n\n\tRuns a javadoc indexer on a thread.\n */\npublic class Indexer\n    extends Thread {\n\n\n\n    /** The initiating search pane. **/\n    private IndexerTab mIndexTab;\n\n    /** The vector of files to add to the index **/\n    private Vector mFilesToAdd;\n\n    /** The vector of files to remove from the index **/\n    private Vector mFilesToRemove;\n\n    /** The index dir **/\n    private String mIndexDir;\n\n\n    /**\n\n\tConstructor\n\t@param pane The initiating search pane.\n\t@param filesToAdd The files to add to the index.\n\t@param filesToRemove The files to remove from the index.\n     */\n    public Indexer( IndexerTab pane, Vector filesToAdd,\n                    Vector filesToRemove, String indexDir ) \n{\n        mIndexTab = pane;\n        mFilesToAdd = filesToAdd;\n        mFilesToRemove = filesToRemove;\n        mIndexDir = indexDir;\n    }\n\n\n\n\n    /**\n\n\tIf this thread was constructed using a separate\n\t<code>Runnable</code> run object, then that\n\t<code>Runnable</code> object's <code>run</code> method is called;\n\totherwise, this method does nothing and returns.\n\t<p>\n\tSubclasses of <code>Thread</code> should override this method.\n     */\n    public void run() {\n        File indexDir = new File( mIndexDir );\n        if ( !indexDir.exists() ) \n{\n            indexDir.mkdirs();\n        }\n\n\n\n        removeFiles();\n        addFiles();\n\n        mIndexTab.updateIndexingProgress( mFilesToAdd.size() + \nmFilesToRemove.size() + 3, \"\" );\n        mIndexTab.doneIndexing();\n    }\n\n\n    /**\n\n\tAdd a set of files to the index.\n     */\n    private void addFiles() {\n\n\n\n        IndexWriter writer = null;\n        try {\n            try \n{\n                writer = new IndexWriter( mIndexDir, new StandardAnalyzer(), \nfalse );\n            }\n catch ( FileNotFoundException ex ) \n{\n                writer = new IndexWriter( mIndexDir, new StandardAnalyzer(), \ntrue );\n            }\n\n            for ( int ix = 0; ix < mFilesToAdd.size(); ix++ ) {\n                File file = (File) mFilesToAdd.get( ix );\n                mIndexTab.updateIndexingProgress( ix + mFilesToRemove.size(),\n                                                  formDisplayString( \nfile.getAbsolutePath() ) );\n                writer.addDocument( JavadocIndexerDocument.createDocument( \nfile ) );\n                if ( mIndexTab.isIndexingCanceled() ) \n{\n                    break;\n                }\n            }\n        } catch ( Exception ex ) \n{\n            ex.printStackTrace();\n        } finally {\n            if ( writer != null ) {\n                try {\n                    writer.optimize();\n                    writer.close();\n                } catch ( Exception ex ) {\n                    ex.printStackTrace();\n                }\n            }\n        }\n    }\n\n\n    /**\n     * remove files from the index.\n     *\n     * todo Investigate why this doesn't remove ALL references...seems to only \nremove half.\n     */\n    private void removeFiles() {\n        if ( mFilesToRemove.size() == 0 ) {\n            return;\n        }\n\n        Directory directory = null;\n        IndexReader reader = null;\n        try {\n            directory = FSDirectory.getDirectory( mIndexDir, false );\n            try {\n                reader = IndexReader.open( directory );\n            } catch ( FileNotFoundException ex ) {\n                return;\n            }\n            removeFilesFromReader( reader );\n        } catch ( Exception ex ) {            ex.printStackTrace();        }\n\n        if ( reader != null ) {\n            try \n{\n                reader.close();\n            }\n catch ( IOException e ) \n{\n                e.printStackTrace();\n            }\n        }\n        if ( directory != null ) {\n            try {\n                directory.close();\n            } catch ( Exception e ) {                e.printStackTrace();            }\n        }\n\n    }\n\n\n    /**\n\n\tRemove the files from the reader.\n\t@param reader The index reader\n\t@throws IOException on error\n     */\n    private void removeFilesFromReader( IndexReader reader )\n        throws IOException {\n        int count = 0;\n        for ( Iterator iterator = mFilesToRemove.iterator(); iterator.hasNext\n(); ) {\n            String path = ( (File) iterator.next()).getAbsolutePath();\n\n\n\n            deleteIndiciesForPath( reader, path );\n\n            mIndexTab.updateIndexingProgress( ++count, \"Removing \"\n                                                     + formDisplayString( \npath ) );\n\n            if ( mIndexTab.isIndexingCanceled() ) \n{\n                break;\n            }\n        }\n    }\n\n\n    /**\n\n\tDelete the indicies in the search stuff for a specific file.\n\t@param reader The index reader.\n\t@param path The path to remove from the index\n\t@throws IOException on error\n     */\n    private void deleteIndiciesForPath( IndexReader reader, String path )\n        throws IOException {\n        int numDocs = reader.numDocs();\n        for ( int ix = 0; ix < numDocs; ix++ ) {\n            if ( !reader.isDeleted( ix ) ) \nUnknown macro: {                String docPath = JavadocIndexerDocument.getPath( reader.document( ix ) );                if ( docPath.indexOf( path ) != -1 ) {\n                    reader.delete( ix );\n                    break;\n                }            } \n        }\n    }\n\n\n\n\n    /**\n\n\tForm a display string to pass to the progress dialog.\n\t@param path The path to the file being indexed.\n\t@return A display string for the path.\n     */\n    private String formDisplayString( String path ) {\n        if ( path.length() > 36 ) {\n            int endIndex = path.indexOf( '/', 6 );\n            if ( endIndex == -1 ) \n{\n                endIndex = path.indexOf( '\\\\', 6 );\n            }\n            if ( endIndex != -1 ) \nUnknown macro: {                String newPath = path.substring( 0, endIndex + 1 );                newPath += \"...\";                int lastIndex = path.lastIndexOf( '/', path.length() - 29 );                if ( lastIndex == -1 ) {\n                    lastIndex = path.lastIndexOf( '\\\\', path.length() - 29 );\n                }                if ( lastIndex < 0 ) {\n                    lastIndex = Math.max( 6, path.length() - 29 );\n                }                newPath += path.substring( lastIndex, path.length() );                return newPath;            } \n        }\n        return path;\n    }\n\n\n\n\n}",
    "attachments": {},
    "issue_links": {},
    "comments": [
        {
            "date": "2002-06-17T10:15:57+0000",
            "content": "I think this bug report may be bogus.\nThis would be a very fundamental flaw in Lucene, and we'd hear about it long ago.\nIs it possible that your application is adding files/documents to the Lucene\nindex multiple times?\nPlease provide a simple, standalone java class that demonstrates this problem. \nThe class included in the report is in a named package and I see references to\nsome other classes, like IndexerTab, which are separate classes.\n\nI will leave this bug open for now, but will close it in a few days unless you\ncan replicate this problem with a simple demo class.\n\nThanks! ",
            "author": "Otis Gospodnetic",
            "id": "comment-12321074"
        },
        {
            "date": "2002-06-17T11:02:47+0000",
            "content": "Ok...somewhat bogus it is.  I hadn't done enough analysis (I should know\nbetter).  When writing the sample class for you, the real issue was\nidentified...sorry for the misdirection.  It is either:\n\n1.  I'm using the API incorrectly or\n2.  An IndexReader issue with deleting documents.\n\nI've included the code here that will replicate my issue.  All the\ndocuments are not actually getting deleted because the IndexReader\nsays a document has already been deleted...so the delete will never\nget called for some documents. \n\nThanks!\n\n/*\n\n\tCreated by IntelliJ IDEA.\n\tUser: rvestal\n\tDate: Jun 16, 2002\n\tTime: 10:23:51 PM\n\tTo change template for new class use\n\tCode Style | Class Templates options (Tools | IDE Options).\n */\npackage org.intellij.plugins.docPlugin;\n\n\n\nimport org.apache.lucene.analysis.Analyzer;\nimport org.apache.lucene.analysis.standard.StandardAnalyzer;\nimport org.apache.lucene.document.*;\nimport org.apache.lucene.index.*;\nimport org.apache.lucene.queryParser.QueryParser;\nimport org.apache.lucene.search.*;\nimport org.apache.lucene.store.*;\n\nimport java.io.*;\nimport java.util.Vector;\n\npublic class IndexTest {\n\n    // path to ant 1.4.1 docs\n    private static String mDirToIndex = \"c:/utils/ant/docs/manual/api/\";\n\n    private static String INDEX_DIR = \"indexTest\";\n\n\n    static private void collectFiles( File dir, Vector files ) {\n        File[] children = dir.listFiles();\n        for ( int ix = 0; ix < children.length; ix++ ) {\n            File child = children[ix];\n            if ( child.isDirectory() ) \n{\n                collectFiles( child, files );\n            }\n else \n{\n                files.add( child );\n            }\n        }\n    }\n\n\n    public static void main( String[] args ) {\n        File indexDir = new File( INDEX_DIR );\n        if ( !indexDir.exists() ) \n{\n            indexDir.mkdirs();\n        }\n\n        Vector files = new Vector();\n        collectFiles( new File( mDirToIndex ), files );\n\n        try {\n            IndexWriter writer = new IndexWriter( INDEX_DIR, new \nStandardAnalyzer(), true );\n\n            for ( int ix = 0; ix < files.size(); ix++ ) \n{\n                File file = ( File ) files.get( ix );\n                writer.addDocument( IndexTestDocument.createDocument( file ) );\n            }\n            System.out.println( \"Added: \" + files.size() + \" files.\" );\n\n            writer.optimize();\n            writer.close();\n            writer = null;\n\n            Searcher searcher = new IndexSearcher( INDEX_DIR );\n            Analyzer analyzer = new StandardAnalyzer();\n            Query query = QueryParser.parse( \"Ant\", \"contents\", analyzer );\n\n            Hits hits = searcher.search( query );\n            System.out.println( \"Hits after add: \" + hits.length() );\n            searcher.close();\n\n            Directory directory = FSDirectory.getDirectory( INDEX_DIR, false );\n            IndexReader reader = IndexReader.open( directory );\n\n            int count = 0;\n            for ( int ix = 0; ix < files.size(); ix++ ) {\n                String path = IndexTestDocument.normalizePath( ( ( File ) \nfiles.get( ix ) ).getAbsolutePath().replace( '', '/' ) );\n\n                int numDocs = reader.numDocs();\n                boolean bDeleted = false;\n                for ( int ndx = 0; ndx < numDocs; ndx++ ) {\n                    if ( !reader.isDeleted( ndx ) ) {\n                        String docPath = IndexTestDocument.getPath( \nreader.document( ndx ) );\n                        if ( docPath.equals( path ) ) \n{\n                            count++;\n                            reader.delete( ndx );\n                            bDeleted = true;\n                            break;\n                        }\n                    }\n                }\n                if ( !bDeleted ) {\n                    System.out.println( \"  Not Deleted: \" + path );\n                    for( int ndx = 0; ndx < numDocs; ndx++ ) {\n                        if ( !reader.isDeleted( ndx ) ) \n{\n                            String docPath = IndexTestDocument.getPath( \nreader.document( ndx ) );\n                            System.out.println( \"      path \" + ndx + \": \" + \ndocPath );\n                        }\n                    }\n                }\n            }\n            System.out.println( \"Removed \" + count + \" documents of (\" + \nfiles.size() + \")\" );\n            reader.close();\n\n            searcher = new IndexSearcher( INDEX_DIR );\n            analyzer = new StandardAnalyzer();\n            query = QueryParser.parse( \"Ant\", \"contents\", analyzer );\n\n            hits = searcher.search( query );\n            System.out.println( \"Hits after remove: \" + hits.length() );\n\n        } catch ( Exception ex ) \n{\n            ex.printStackTrace();\n        }\n    }\n\n\n    static class IndexTestDocument {\n\n        static public Document createDocument( File f )\n            throws FileNotFoundException \n{\n            Document doc = new Document();\n            doc.add( Field.Text( \"path\", normalizePath( f.getPath() ) ) );\n            Reader reader = new BufferedReader( new InputStreamReader( new \nFileInputStream( f ) ) );\n            doc.add( Field.Text( \"contents\", reader ) );\n            return doc;\n        }\n\n\n        static public String getPath( Document doc ) \n{\n            return ( String ) doc.get( \"path\" );\n        }\n\n        static public String normalizePath( String path ) {\n            if ( path == null || path.length() == 0 ) \n{\n                return \"\";\n            }\n            path = path.replace( '', '/' );\n            File f = new File( path );\n            if ( f.isDirectory() ) {\n                if ( path.charAt( path.length() - 1 ) != '/' ) \n{\n                    path = path + \"/\";\n                }\n            }\n            return path;\n        }\n    }\n} ",
            "author": "Rick Vestal",
            "id": "comment-12321075"
        },
        {
            "date": "2002-06-17T20:12:36+0000",
            "content": "Your sample code throws a NullPointerException:\njava IndexTest\nException in thread \"main\" java.lang.NullPointerException\n\tat IndexTest.collectFiles(IndexTest.java:23)\n\tat IndexTest.main(IndexTest.java:41)\n\nSince we established that this is not a bug I will close the bug here.\nIf you need more help, please use lucene-user list. ",
            "author": "Otis Gospodnetic",
            "id": "comment-12321076"
        }
    ]
}