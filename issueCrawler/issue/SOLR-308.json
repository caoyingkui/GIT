{
    "id": "SOLR-308",
    "title": "Add a field that generates an unique id when you have none in your data to index",
    "details": {
        "affect_versions": "None",
        "status": "Closed",
        "fix_versions": [
            "1.3"
        ],
        "components": [
            "search"
        ],
        "type": "New Feature",
        "priority": "Minor",
        "labels": "",
        "resolution": "Fixed"
    },
    "description": "This patch adds a field that generates an unique id when you have no unique id in your data you want to index.",
    "attachments": {
        "UUIDField.patch": "https://issues.apache.org/jira/secure/attachment/12362208/UUIDField.patch"
    },
    "issue_links": {},
    "comments": [
        {
            "author": "Erik Hatcher",
            "id": "comment-12513508",
            "date": "2007-07-18T09:52:26+0000",
            "content": "Can the client get the generated id back when adding a document? "
        },
        {
            "author": "Thomas Peuss",
            "id": "comment-12513568",
            "date": "2007-07-18T13:43:15+0000",
            "content": "Well, indirectly yes. It is viewable in the response when you store the field. We use this field because we mainly rely on 3rd party data where we have not much control of the data. "
        },
        {
            "author": "Otis Gospodnetic",
            "id": "comment-12513582",
            "date": "2007-07-18T14:08:04+0000",
            "content": "What type does the id end up being after this?  String? "
        },
        {
            "author": "Hoss Man",
            "id": "comment-12513661",
            "date": "2007-07-18T18:02:06+0000",
            "content": "i'm confused by this issue .. what's the need?\n\nsolr doesn't require that you have a uniqueKey field, so if there isn't a unique id for your data, why add one artificially? "
        },
        {
            "author": "Ryan McKinley",
            "id": "comment-12513702",
            "date": "2007-07-18T19:57:26+0000",
            "content": "If I'm following correct, this is a FieldType that generates a UUID regardless of the input value:\n\n\tpublic Field createField(SchemaField field, String externalVal, float boost) \n{\n\t\t// We ignore the external value and have our own\n\t\treturn super.createField(field, UUID.randomUUID().toString(), boost);\n\t}\n\nWhat is a use case for that? \n\nIf you are looking for something like the sql auto increment, it might be a good candidate for the new fangled 'UpdateRequestProcessor' \u2013 this could check if the input document has a uniqueKey - if not, add one and add the new value to the response. "
        },
        {
            "author": "Thomas Peuss",
            "id": "comment-12513817",
            "date": "2007-07-19T05:53:38+0000",
            "content": "The use case is the following:\n\n\tWe get catalog data from vendors (300+). We have no control about the data.\n\tThe only unique thing is the catalogid, which is of course the same for all rows in one catalog.\n\tIn our webapp we request first only a few fields that are needed for the search result display.\n\tWhen the customer clicks on a product in the search result he gets a detailed page. To get the info from Solr we need a unique id to read the rest of the fields (50+). This id is generated by this code.\n\n\n\nOf course we could add the unique id in a preprocessing step but we wanted to achieve this with Solr alone.\n\nThe update procedure goes like this:\n\n\tDelete all documents with a specific catalogId\n\tInsert the updated catalog data\n\n\n\nSo you see we need this id to find the exact same document we have in the search result. We do nothing more with it.\n\nMaybe I overlooked something and this can be achieved with existing code. Any hint is welcome. "
        },
        {
            "author": "Pieter Berkel",
            "id": "comment-12513891",
            "date": "2007-07-19T13:48:08+0000",
            "content": "From the usage case you have provided, it sounds like the unique id will change every time you delete and re-insert the document.  If this is the case, then perhaps it might be more efficient to use the lucene document id as your unique id value rather than a seperate field?  However, as far as I'm aware, there currently isn't any way to access the lucene doc id from solr (except perhaps the luke request handler)? "
        },
        {
            "author": "Thomas Peuss",
            "id": "comment-12513947",
            "date": "2007-07-19T17:03:24+0000",
            "content": "That would be a good replacement for my problem. From the Lucene docs I see that the document id is 32 bits (int). I don't know if the docid \"wraps around\" when this address space is exhausted (I assume not). Or is the docid field recomputed on \"optimize\"?\n\nI try to add the functionality to see the document id in the response. So for now we can close this issue for now. "
        },
        {
            "author": "Yonik Seeley",
            "id": "comment-12513959",
            "date": "2007-07-19T17:43:59+0000",
            "content": "Lucene docids are transient (they change when the index changes) - they should not be used across different instances of an IndexReader "
        },
        {
            "author": "Ryan McKinley",
            "id": "comment-12513960",
            "date": "2007-07-19T17:58:52+0000",
            "content": "The easiest option is to add a UUID when you index the data.  \n\nOther options would be to make this FieldType a plugin and put it in the 'lib' directory. "
        },
        {
            "author": "Hoss Man",
            "id": "comment-12513972",
            "date": "2007-07-19T18:46:22+0000",
            "content": "I understood your data entry/delete reindexing strategy, but i hadn't considered the use case of doing a query, and then issuing a followup query to get more details about specific items.\n\nAs yonik points out, exposing the internal lucene docid would be a bad idea since it may change every time an IndexReader is opened ... even if hte doc you are interested in is still in the index (ie: hasn't been deleted) other deletions may have changed it's internal id.\n\ni have no objection to adding a FieldType that can generate UUID on demand for use cases like this, but having it ignore the input seems a little sketchy to me.  it seems like a better approach would be to have UUIDFieldType with a toInternal() method that tests it's input for some marker token (like \"NEW\" or \"*\") and if it sees that token, generates a new UUID, otherwise it uses the literal value.  then you can configure the id field with a defaultValue of \"NEW\" in the schema and any doc without an id will get a unique one, but if someone tries to update an existing doc whose id they already know, it will still work as well. "
        },
        {
            "author": "Thomas Peuss",
            "id": "comment-12514154",
            "date": "2007-07-20T08:45:10+0000",
            "content": "Hoss Man: I change the code in the way you described. Thanks for your notes on that. "
        },
        {
            "author": "Thomas Peuss",
            "id": "comment-12514171",
            "date": "2007-07-20T11:06:59+0000",
            "content": "Patch for an UUIDField and associated test. "
        },
        {
            "author": "Thomas Peuss",
            "id": "comment-12514879",
            "date": "2007-07-24T06:58:57+0000",
            "content": "An updated version of the patch. In the XML response the UUIDField is now rendered as <uuid>...</uuid>. "
        },
        {
            "author": "Hoss Man",
            "id": "comment-12516307",
            "date": "2007-07-30T07:44:07+0000",
            "content": "a few misc comments...\n\n1)  ...val.startsWith(\"NEW\")... seems like a bad idea, why not just val.equals(\"NEW\") ?\n\n2) classes like IntField and DateField don't currently do strong parsing validation in the toInternal method, but this UUIDFIeld class does ... should it?\n\n3) should toObject be strongly typed to return UUID ?\n\n4) there shouldn't be new methods in the output writers for this field type ... output writers should only need to know about the most primitive types of data that should be viable regardless of the client language (ie: string, int, float, date, list, etc...)  the UUIDField should just write itself out as a string  (using <str> in the xml response writer) "
        },
        {
            "author": "Thomas Peuss",
            "id": "comment-12516368",
            "date": "2007-07-30T11:31:04+0000",
            "content": "1.) I change it.\n2.) I remove the check. I understand that this has a performance impact.\n3.) I changed it to what DateField and IntField do.\n4.) I remove that as well.\n\nIf we don't do strong parsing we should call this IDField instead of UUIDField.  If we don't enforce that this is an UUID we shouldn't name it like that. What do you think? "
        },
        {
            "author": "Thomas Peuss",
            "id": "comment-12516370",
            "date": "2007-07-30T11:33:21+0000",
            "content": "Changes based on comments... "
        },
        {
            "author": "Thomas Peuss",
            "id": "comment-12516638",
            "date": "2007-07-31T07:46:20+0000",
            "content": "BTW: The DateField does strong parsing of the input... It tries to convert the input value to the internal representation and throws a SolrException when that is not possible... "
        },
        {
            "author": "Thomas Peuss",
            "id": "comment-12516680",
            "date": "2007-07-31T12:00:24+0000",
            "content": "Added missing test class and readded strong checking that the given value is indeed a valid UUID. So this behaves now like DateField. "
        },
        {
            "author": "Hoss Man",
            "id": "comment-12516888",
            "date": "2007-08-01T07:28:21+0000",
            "content": "> BTW: The DateField does strong parsing of the input... It tries to convert the input value to\n> the internal representation and throws a SolrException when that is not possible...\n\n...no, note quite.  DateField.toInternal(String) only does a quick sanity check to see if the string ends in a Z, if it does it assumes it's in the correct date format, and does no parsing \u2013 if it does not end in a Z, then it does DateMathParsing (which may include parsing the date and throwing an exception if that can't be done) ... that parsing is only done if  necessary for the date math.\n\nthat was my point - if the UUIDFIeld class is going to index the UUID value using the orriginal human readable format, then there isn't really any reason to attempt to parse it \u2013 except as a form of validation, i was just raising the question as to whether or not we think it should do that validation.\n\n "
        },
        {
            "author": "Thomas Peuss",
            "id": "comment-12516977",
            "date": "2007-08-01T14:11:21+0000",
            "content": "Changed the input validation to only do basic input validation. We now only check if the thing looks like an UUID. "
        },
        {
            "author": "Thomas Peuss",
            "id": "comment-12516979",
            "date": "2007-08-01T14:17:47+0000",
            "content": "I personally would prefer strong input checking. This avoids problems at search time. Better we find the problem at index time than the customer at search time...  Maybe I am a bit paranoid here. But we get content from many suppliers and the quality is often not that good (commas instead of dots as decimal seperator in floats - even changing from row to row of the catalogue). "
        },
        {
            "author": "Hoss Man",
            "id": "comment-12522403",
            "date": "2007-08-24T07:27:13+0000",
            "content": "Thomas: I understand you concerns, but in the balance of performance vs safety Solr tends to err on the side of performance when dealing with indexing data \u2013 since that comes from a finite number of controlled sources (you may get it from dozens of places, but you must trust them at least a little and have the chance to sanitize their data before deciding to use it) while query inputs are treaty much more delicately since they typically come from much more diverse group of users many of whom you may outright distrust.\n\nthat said, i went ahead and left in the remaining validation you had, although i had to replace the isEmpty() call (Solr still uses Java 1.5)\n\nI also changed the toInternal methods to always lowercase whatever value they get (the hex values need to be case insensitve in case someone tries to query/update using a different case then was orriginally indexed) "
        },
        {
            "author": "Hoss Man",
            "id": "comment-12522405",
            "date": "2007-08-24T07:28:56+0000",
            "content": "Committed revision 569279. "
        },
        {
            "author": "rassen",
            "id": "comment-12595757",
            "date": "2008-05-09T23:52:29+0000",
            "content": "i'm having small question.\nhow to use these files? "
        },
        {
            "author": "Ryan McKinley",
            "id": "comment-12595766",
            "date": "2008-05-10T00:39:41+0000",
            "content": "if you are using trunk (the nightly builds, not 1.2) it is included. "
        },
        {
            "author": "Lance Norskog",
            "id": "comment-12662615",
            "date": "2009-01-10T03:57:00+0000",
            "content": "This field type and its use is not documented in the Wiki: search for 'UUID' finds only custom code in ExtractingRequestHandler.\n "
        },
        {
            "author": "Otis Gospodnetic",
            "id": "comment-12662626",
            "date": "2009-01-10T06:20:51+0000",
            "content": "Lance - anyone can add/modify a Wiki page.  Do you mind adding info about this field type? "
        },
        {
            "author": "Thomas Peuss",
            "id": "comment-12662640",
            "date": "2009-01-10T09:18:30+0000",
            "content": "Some documentation can be found here: http://lucene.apache.org/solr/api/org/apache/solr/schema/UUIDField.html "
        },
        {
            "author": "Thomas Peuss",
            "id": "comment-12662654",
            "date": "2009-01-10T12:35:05+0000",
            "content": "Fields are defined by:\n\n<fieldType name=\"uuid\" class=\"solr.UUIDField\" indexed=\"true\" />\n\nand used by\n\n<field name=\"id\" type=\"uuid\" indexed=\"true\" stored=\"true\" default=\"NEW\"/>\n "
        }
    ]
}