{
    "id": "SOLR-127",
    "title": "Make Solr more friendly to external HTTP caches",
    "details": {
        "affect_versions": "None",
        "status": "Closed",
        "fix_versions": [
            "1.3"
        ],
        "components": [],
        "type": "Wish",
        "priority": "Major",
        "labels": "",
        "resolution": "Fixed"
    },
    "description": "an offhand comment I saw recently reminded me of something that really bugged me about the serach solution i used before Solr \u2013 it didn't play nicely with HTTP caches that might be sitting in front of it.\n\nat the moment, Solr doesn't put in particularly usefull info in the HTTP Response headers to aid in caching (ie: Last-Modified), responds to all HEAD requests with a 400, and doesn't do anything special with If-Modified-Since.\n\nt the very least, we can set a Last-Modified based on when the current IndexReder was open (if not the Date on the IndexReader) and use the same info to determing how to respond to If-Modified-Since requests.\n\n(for the record, i think the reason this hasn't occured to me in the 2+ years i've been using Solr, is because with the internal caching, i've yet to need to put a proxy cache in front of Solr)",
    "attachments": {
        "CacheUnitTest.patch": "https://issues.apache.org/jira/secure/attachment/12374035/CacheUnitTest.patch",
        "HTTPCaching.patch": "https://issues.apache.org/jira/secure/attachment/12365470/HTTPCaching.patch"
    },
    "issue_links": {},
    "comments": [
        {
            "author": "Thomas Peuss",
            "id": "comment-12526133",
            "date": "2007-09-10T11:35:37+0000",
            "content": "Make Solr a bit more friendly for HTTP caches. "
        },
        {
            "author": "Thomas Peuss",
            "id": "comment-12526136",
            "date": "2007-09-10T11:44:17+0000",
            "content": "I have not found out (OK, I tried it only 10 minutes  ) where this HEAD requests get blocked. Should be easy to do if you find the right location.... "
        },
        {
            "author": "Thomas Peuss",
            "id": "comment-12526164",
            "date": "2007-09-10T13:58:12+0000",
            "content": "Solr now responds nicely to HEAD-requests. "
        },
        {
            "author": "Thomas Peuss",
            "id": "comment-12526169",
            "date": "2007-09-10T14:14:26+0000",
            "content": "Some code cleanup and a fixed typo. "
        },
        {
            "author": "Koji Sekiguchi",
            "id": "comment-12527325",
            "date": "2007-09-14T01:46:50+0000",
            "content": "Note that this patch can do much for doing better throughput, but unluckily Solr doesn't take into account in stats (SOLR-176). "
        },
        {
            "author": "Erik Hatcher",
            "id": "comment-12527337",
            "date": "2007-09-14T03:41:40+0000",
            "content": "What about etags?  http://intertwingly.net/blog/2006/06/05/Elevator-Pitch "
        },
        {
            "author": "Thomas Peuss",
            "id": "comment-12527364",
            "date": "2007-09-14T06:09:19+0000",
            "content": "@Erik: Adding Etag support should be not that hard. I have a look into that. As the Etag value I propose a hash of the request URI and the index version.\n\n@Koji: I have a look if I can update the request count for Not-Modified responses. The question there is only if we really want that. The current counter tells us how many requests really reached the search handler. In my opinion that is what I want because the Not-Modified responses put not much pressure on the server. "
        },
        {
            "author": "Thomas Peuss",
            "id": "comment-12527388",
            "date": "2007-09-14T07:41:07+0000",
            "content": "Added Etag support. "
        },
        {
            "author": "Thomas Peuss",
            "id": "comment-12527396",
            "date": "2007-09-14T08:04:17+0000",
            "content": "After reading the W3C docs I have seen that we can calculate the Etags in a much simpler way. "
        },
        {
            "author": "Thomas Peuss",
            "id": "comment-12527483",
            "date": "2007-09-14T12:16:57+0000",
            "content": "Be even more standards compliant. If-Match and If-None-Match headers can appear multiple times. "
        },
        {
            "author": "Hoss Man",
            "id": "comment-12527664",
            "date": "2007-09-15T00:24:54+0000",
            "content": "1) it's not a good idea to assume the indexVersion can be used as a timestamp ... Lucene does not guarantee that.  To be safe we should record the timestamp we opened the index at.  (using the lastModified on files in the Directory is a bad idea as well ... someone could swap out an index with a backup and get \"older\" files that represent a \"newer\" index from Solr's perspective)\n\n1) isn't the header named \"ETag\" (not \"Etag\") ?\n\n2) I'm not an expert on all this new fangled HTTP/1.1 stuff ... but is an ETag based on the URI and the indexVersion/timestamp really that useful?  wouldn't the Last-Modified header in that case be just as useful?  I thought the value add of an ETag was that even if the content has been modified, if that modification results in no real changes, old cached values can still be useful.  with Solr specificly in mind, the index may have changed, but if the results of a query are identicle to the results before the change, those cna have the same ETag right?  wouldn't a hash of the URI and the SolrQueryResponse make more sense in that regards? "
        },
        {
            "author": "Walter Underwood",
            "id": "comment-12527694",
            "date": "2007-09-15T04:38:18+0000",
            "content": "Last-modified does require monotonic time, but ETags are version stamps without any ordering. The indexVersion should be fine for an ETag. "
        },
        {
            "author": "Thomas Peuss",
            "id": "comment-12528002",
            "date": "2007-09-17T09:10:53+0000",
            "content": "1.) I now use the time the reader was opened. But we should be aware of the fact that when we have two servers (for HA reasons for example) this times differ for sure. For clients with ETag support this is no problem because the ETag will be still the same.\n2.) You are right it is ETag. Clients/servers handle the headers case-insensitive. This is why I have not seen that...\n3.) Some clients support only ETag, some support only Last-Modified, many support both. That's why we should support both. And you are right: the ETags can more than we use.\n\nYou spoke about taking the result of a search into account. Maybe we are talking about two different things here. This patch is about getting load off the server. When we want a 100% confident client then we need to take the server response into account. But currently I don't see a big benefit of this and it makes the code much more complex. "
        },
        {
            "author": "Thomas Peuss",
            "id": "comment-12529634",
            "date": "2007-09-22T08:35:27+0000",
            "content": "Changed the behavior to first check for ETag related headers. Clients that support ETags have a greater possibility to have a cache-hit. "
        },
        {
            "author": "Thomas Peuss",
            "id": "comment-12529670",
            "date": "2007-09-22T14:54:50+0000",
            "content": "Some code cleanup and refactoring. "
        },
        {
            "author": "Thomas Peuss",
            "id": "comment-12529819",
            "date": "2007-09-24T10:12:54+0000",
            "content": "Added a unit test for the cache header stuff... "
        },
        {
            "author": "Thomas Peuss",
            "id": "comment-12529822",
            "date": "2007-09-24T10:24:01+0000",
            "content": "Added a unit test to check correct cache header behavior. "
        },
        {
            "author": "Erik Hatcher",
            "id": "comment-12533502",
            "date": "2007-10-09T20:53:52+0000",
            "content": "targeting this for the 1.3 release. "
        },
        {
            "author": "Hoss Man",
            "id": "comment-12535051",
            "date": "2007-10-16T04:04:46+0000",
            "content": "Okay, i've been learning a little more about HTTP Caching, and i looked over the latest patch. a few comments...\n\n\n1) do we really want this in all cases?...\n\n+    resp.setHeader(\"Cache-Control\",\n+        \"max-age=0, must-revalidate\");\n\n...that seems a little harsh.  if we're going to do that it seems like it should be optional.  (NOTE: it's not backwards compatible if people already have caches in front of Solr right now)\n\n\n2) I've been reading about etags ... we need to make sure we don't inadvertently output an etag with \"w/\" in front (indicating it's a week entity tag) ... we should future proof against changes to IndexReader.getVersion() by putting a prefix on the version when making an etag.  also: should we obfuscate the version (ie: hash it) so as not to risk disclosing info to people who shouldn't have it?\n\n\n3) all etags are the same until the reader is reopened ... shouldn't they also hash on the URL? (is there a downside to multiple URLs having the same etag?)\n\n\n4) are these semantics right? send PRECON_FAIL when \"If-None-Match\" tag matches and request is not GET or HEAD? (what about a POSTed query?) ....\n\n+    if(ifNoneMatchList.size()>0 && isMatchingEtag(ifNoneMatchList,etag)) {\n+      if(isGETRequest || isHEADRequest) \n{\n+        sendNotModified(resp);\n+      }\n else \n{\n+        sendPreconditionFailed(resp);\n+      }\n+      return true;\n\n\n5) using SolrIndexSearcher.openTime() as last-modified for query requests makes sense ... put what about updates?  since RequestHandlers don't declare what they are, should we use \"now\" for POSTs and openTime for GET/HEAD ? "
        },
        {
            "author": "Thomas Peuss",
            "id": "comment-12535248",
            "date": "2007-10-16T13:50:04+0000",
            "content": "ad 1.)\nI have thought about that as well. We should make it configurable. But I do not know where the best place is for the configuration.\n\nad 2.)\ngetVersion() delivers a long - how should that ever be converted to w/? According to W3C a weak ETag looks like this: W/\"xyzzy\". We always generate ETags like \"xyzzy\". So no problem here. Even \"W/xyzzy\" would be a strong ETag.\n\nHashing of the version is a good idea. I add that. But be aware that generating a hash consumes a lot of extra CPU cycles...\n\nad 3.)\nAs the answer to a request is always the same when the index is not changed it is OK to have the same ETag for all requests IMHO. The ETag has not to be exclusive per request URL. The ETag only allows the browser to send requests like \"only execute when changed\". And the ETag only changes when the index has changed.\n\nad 4.)\nI have thought about that as well. The problem here is that we have POSTs that change the index and POSTs that do not change the index. The semantics are according to W3C. Here a snippet from http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html (section 14.26):\n\"Instead, if the request method was GET or HEAD, the server SHOULD respond with a 304 (Not Modified) response, including the cache- related header fields (particularly ETag) of one of the entities that matched. For all other request methods, the server MUST respond with a status of 412 (Precondition Failed).\"\n\nThe idea behind that seems to be that POSTs are for changing things. But we can ignore that of course.\n\nad 5.)\nMaybe we should not emit cache related headers for POSTs at all? "
        },
        {
            "author": "Thomas Peuss",
            "id": "comment-12535569",
            "date": "2007-10-17T14:29:09+0000",
            "content": "\n\tIndex version is now an MD5 hash: I am not sure what information we really expose here. It is time consuming to create the hash.\n\tCache-Control HTTP header can now be configured in solr-config.xml:\n  <requestDispatcher handleSelect=\"true\" >\n    <Unable to render embedded object: File (--Make sure your system has some authentication before enabling remote streaming) not found.  -->\n    <requestParsers enableRemoteStreaming=\"false\" multipartUploadLimitInKB=\"2048\" />\n\n\n\n     <httpCacheControlHeader>no-cache, no-store</httpCacheControlHeader>\n\n  </requestDispatcher>\n\nThe default value is no-cache, no-store when the tag is not there for backward compatibility. "
        },
        {
            "author": "Yonik Seeley",
            "id": "comment-12535579",
            "date": "2007-10-17T14:51:17+0000",
            "content": "> Index version is now an MD5 hash: I am not sure what information we really expose here. It is time consuming to create the hash.\n\nI guess the info reveals when the index was created (defaults to current milliseconds, and is incremented by 1 for each new committed change).\n\nBut, doing any sort of hash on this version  number alone isn't really secure since I can guess perhaps within a day of when the index was created, and there are only 84M milliseconds in a day.  Since the algorithm is known, I can try them all if I want.  But really, I don't see the harm in letting someone see the index version either.\n\nIf we want to obfuscate it for some reason, we should just use something simple and fast... "
        },
        {
            "author": "Thomas Peuss",
            "id": "comment-12535611",
            "date": "2007-10-17T16:26:41+0000",
            "content": "We should think about what a bad guy can do with that information: nothing. It is not an id or key that elevates your rights or something like that when you know it.\n\nI would opt for writing out the index version directly as well: it is fast and simple... "
        },
        {
            "author": "Thomas Peuss",
            "id": "comment-12535856",
            "date": "2007-10-18T07:32:34+0000",
            "content": "What do you expect as default behaviour of this patch?\n\n\n\tEmit no cache related headers at all\n\tEmit conservative cache related headers\n\t\n\t\tfor example max-age=0, must-revalidate - this should work with every not completely broken cache implementation without breaking anything (besides  pushing performance because you offload the Solr-server)\n\t\n\t\n\tEmit more \"cachy\" headers\n\t\n\t\tfor example max-age=600\n\t\n\t\n\n "
        },
        {
            "author": "Hoss Man",
            "id": "comment-12536098",
            "date": "2007-10-19T03:44:30+0000",
            "content": "In no particular order...\n\n\nIgnore my question about weak etags (w/), this is what happens when I review patches tired ... i forgot getVersion() returns a long AND i missread how weak etags work.\n\nI wasn't saying that i think we need to do a hash to \"hide\" the version, just pointing out that some people might consider it divulging more info then we should.  if no one else cares, i don't care (especially if it's prohibitively expensive)\n\nI like the idea of not emiting caching headers in response to POST requests ... the RFCs say that POSTs by default aren't cachable right?  that also seems like a reasonable solution to the issues of typical \"/update\" urls all having both identicle etags and urls, as well as \"If-None-Match\" leading to PRECON_FAIL.\n\nHaving explicit config options for the Cache-Control header seems good .. i wonder if we should make it a requestHandler option (instead of a SolrCore option).\n\nIn regard to this comment...\n  \"The default value is no-cache, no-store when the tag is not there for backward compatibility.\"\n...that's not really true.  Total backwards compatibility would be no new headers at all ... if someone has a surgate proxy in front of Solr 1.2, it can use it's own configs or hueristics to decide how long to cache.  as soon as we include Cache-Control header that stops working.\n\nI think the default behavior can be \"conservative\" headers (Last-Modified, ETag,and must-revalidate) that's probably the best thing for new users.   But ideally there should be a way to turn it off completely (it's good to have a mechanism for people upgrading to garuntee they get the same behavior as before\n\n\n "
        },
        {
            "author": "Thomas Peuss",
            "id": "comment-12536225",
            "date": "2007-10-19T14:04:51+0000",
            "content": "Updated patch inspired by Hoss Mans comments.\n\nChanges:\n\n\tCache header settings can now be set per request handler. Omitting the parameters switches off cache header generation (fall back to old behaviour).\n\t\n\t\t<int name=\"httpCacheLivetime\">0</int>: Set \"freshness\" timespan in seconds\n\t\t<bool name=\"httpCacheForceRevalidation\">true</bool>: controls if we emit \"must-revalidate\"\n\t\t<bool name=\"httpCacheForcePrivate\">false</bool>: constrols if we emit \"private\"\n\t\n\t\n\tSome refactoring to make the Filter class smaller\n\tUpdated testcase to check that we do not emit cache headers on POST requests.\n\n "
        },
        {
            "author": "Otis Gospodnetic",
            "id": "comment-12536401",
            "date": "2007-10-20T04:44:44+0000",
            "content": "Thomas, minor comment: httpCacheLivetime --> httpCacheTTL? "
        },
        {
            "author": "Thomas Peuss",
            "id": "comment-12536930",
            "date": "2007-10-23T07:19:26+0000",
            "content": "Updated as Otis suggested. One thing I don't like with this patch that it changes the contract of the interface SolrRequestHandler. Maybe a Solr guru can tell me how I  avoid that.\n\nI need access to the request handlers settings before execution. getParams() does only deliver the parameters that are on the URI before execution... "
        },
        {
            "author": "Thomas Peuss",
            "id": "comment-12548176",
            "date": "2007-12-04T08:57:31+0000",
            "content": "Updated to trunk. Any chance to get this into SVN soon? "
        },
        {
            "author": "Thomas Peuss",
            "id": "comment-12548610",
            "date": "2007-12-05T09:39:31+0000",
            "content": "Minor performance update. "
        },
        {
            "author": "Otis Gospodnetic",
            "id": "comment-12549513",
            "date": "2007-12-07T18:43:57+0000",
            "content": "I gave my vote for this one, but ant test failed for me after I applied this patch:\n\njunit.framework.AssertionFailedError: Unknown request response expected:<0> but was:<400>\n\tat org.apache.solr.servlet.CacheHeaderTest.checkResponseBody(CacheHeaderTest.java:175)\n\tat org.apache.solr.servlet.CacheHeaderTest.doCacheControl(CacheHeaderTest.java:328)\n\tat org.apache.solr.servlet.CacheHeaderTest.testCacheControl(CacheHeaderTest.java:152) "
        },
        {
            "author": "Hoss Man",
            "id": "comment-12549650",
            "date": "2007-12-08T05:25:38+0000",
            "content": "Thomas: I have not looked at any of the patch updates since my last comment, but it is my sincere plan to spend some serious time on this issue this week if possible \u2013 and if not, then starting on Jan2 when i get back from vacation.  (it's on my \"work\" todo list not just my \"spare time apache\" todo list)\n "
        },
        {
            "author": "Thomas Peuss",
            "id": "comment-12549735",
            "date": "2007-12-08T18:33:50+0000",
            "content": "I can reproduce the error. It seems to be caused by the multi-core stuff that has been committed yesterday... "
        },
        {
            "author": "Thomas Peuss",
            "id": "comment-12553272",
            "date": "2007-12-19T09:11:17+0000",
            "content": "Updated to trunk. The test was failing because there was an error in the testcase. "
        },
        {
            "author": "Thomas Peuss",
            "id": "comment-12553918",
            "date": "2007-12-21T10:01:37+0000",
            "content": "Added the request parameter \"httpnocache\" (can be true or false - defaults to false) to emit \"no-cache\" Cache-Control headers for requests you do not want to be cached by shared caches.\n "
        },
        {
            "author": "Thomas Peuss",
            "id": "comment-12553924",
            "date": "2007-12-21T11:15:08+0000",
            "content": "Updated. Even more aggressive no-cache header get emitted when httpnocache=true. "
        },
        {
            "author": "Thomas Peuss",
            "id": "comment-12556599",
            "date": "2008-01-07T15:45:29+0000",
            "content": "\n\tPerformance optimization:\n\t\n\t\tETag is only recalculated when the index changes\n\t\tShorter ETag\n\t\n\t\n\tUpdated to trunk\n\n "
        },
        {
            "author": "Hoss Man",
            "id": "comment-12561844",
            "date": "2008-01-23T22:29:00+0000",
            "content": "this patch is functionally the same as the last patch from Thomas  but updated to work against the HEAD (r614702) without patch warnings. \n\ni'm reviewing the patch in depth now. "
        },
        {
            "author": "Hoss Man",
            "id": "comment-12561920",
            "date": "2008-01-24T02:28:49+0000",
            "content": "Thomas: first off .. thanks a lot for putting so much effort into this.  Looking over your patch, and seeing the hoops you had to jump through to get per request handler configuration, i feel bad for ever even suggesting it.\n\nWe definitely shouldn't make a backwards incompatible change like you needed with the getDefaults() to deal with the caching.  I think for now, we should stick with your earlier approach of putting the configuration in the <requestDispatcher> block ... perhaps down the road we will have an easier mechanism for per-handler overrides (maybe using the new components stuff?) but even if we do, having some default configs in <requestDispatcher> will be good.\n\nI've got a modified version of your patch that moves back in this direction (but keeps some of the other good stuff you've added recently) that i'll attach in a moment.\n\nAt a higher level, i have few broader questions/concerns that we should probably think about...\n\n1) it occurs to me that the etag value needs to include some kind of hashCode for the solrconfig.xml \u2013 otherwise someone could bounce their server (without changing the index) and continue to get identical ETag headers, even if the new config options cause entirely different results to be generated (ie: new default handler params)\n(We probably ought to be including the getVersion() info from both Solr and the specified request handler as well \u2013 just in case they deploy new code that has new behavior without modifying the index, or their configs .. but i'm not really as worried about this ... i'm OK with a FAQ saying you have make a small change to your solrconfig.xml to force new ETags\n\n2) currently, even if the configs say \"don't be cache friendly\" an etag is still computed, and requests are tested for validation headers (it's even possible to get a 304 if you guess the etag or pick a really old If-Modified-Since header) ... this seems like a bad idea (and i believe it violates the RFC) .. so we should make sure no special work is done relating to cache headers if the solrconfig.xml says to disable it completely.\n "
        },
        {
            "author": "Hoss Man",
            "id": "comment-12561921",
            "date": "2008-01-24T02:32:40+0000",
            "content": "revised version of Thomas's most recent patch, that removes the backwards-incompatible changes to SolrRequestHandler by moving all configuration related to caching config options into the <requestDispatcher> block...\n\n\n       <!--\n          Set HTTP caching related parameters (for proxy caches and clients).\n          \n          To get the behaviour of Solr 1.2 (ie: no caching related headers)\n          use the noCachingHeaders=\"true\" option\n        -->\n    <!-- :TODO: it would be nice to mimic the directives of the Cache-Control header more closely -->\n    <httpCaching httpCacheTTL=\"30\"\n                 httpCacheForceRevalidation=\"false\"\n                 httpCacheForcePrivate=\"false\" />\n\n\n\n...as noted in that TODO line, i'd like to rethink what the exact options should be, but that's a minor issue compared to the functionality itself.\n\nNOTE: unit tests currently fail, since caching is now either on or off for the entire server, the test will probably need to be refactored into two separate tests with different configs. "
        },
        {
            "author": "Thomas Peuss",
            "id": "comment-12561974",
            "date": "2008-01-24T08:45:35+0000",
            "content": "\n1) it occurs to me that the etag value needs to include some kind of hashCode for the solrconfig.xml - otherwise someone could bounce their server (without changing the index) and continue to get identical ETag headers, even if the new config options cause entirely different results to be generated (ie: new default handler params)\n(We probably ought to be including the getVersion() info from both Solr and the specified request handler as well - just in case they deploy new code that has new behavior without modifying the index, or their configs .. but i'm not really as worried about this ... i'm OK with a FAQ saying you have make a small change to your solrconfig.xml to force new ETags\n\nGood point. You can get around that problem by using the openTime for the ETags as well.\n\n\n2) currently, even if the configs say \"don't be cache friendly\" an etag is still computed, and requests are tested for validation headers (it's even possible to get a 304 if you guess the etag or pick a really old If-Modified-Since header) ... this seems like a bad idea (and i believe it violates the RFC) .. so we should make sure no special work is done relating to cache headers if the solrconfig.xml says to disable it completely.\n\nTrue. I missed that one.\n\nWhat do you expect from me now? Should I have a look at the testcase? "
        },
        {
            "author": "Hoss Man",
            "id": "comment-12562274",
            "date": "2008-01-24T22:56:10+0000",
            "content": "Good point. You can get around that problem by using the openTime for the ETags as well.\n\nyeah ... ugh ... i'm actually starting to question whether or not openTime is even the right choice for Last-Mod ... you made a really good point before about it causing Last-Mod times to differnet between multiple (identical) slaves, but at least the ETags would be in sync ... if we add openTime to the ETag we lose even that.\n\nmy initial concern about using IndexReader.lastModified for Last-Mod was the case where someone rolls back an index, but that's really the exceptional case ... most people will probably never encounter it (and if they do, they can work around it by \"touching\" the segments file ... or we could have another option for it ... lastModFrom=\"open|disk\" ... what do you think?)\n\nGetting back to the question of the ETag though, i think it would be better to use a hashCode on the config itself ... if the index hasn't changed, and the config hasn't changed restarting Solr shouldn't make the ETag change.\n\nWhat do you expect from me now? Should I have a look at the testcase?\n\n\"expect\" ? ... uh, i have no expectations from you ... Solr is an volunteer project, no one is expected to do anything other then contribute when/where/however they can \n\nseriously though: you've clearly thought about this task more then anyone else at this point, i'm just throwing out ideas and concerns, if you think i'm making stupid suggestions, or over thinking something, or not thinking hard enough about something else let me know.  \n\nFirst and foremost: do you think being able to customize the \"cache awareness\" of Solr on a per request handler basis is important enough that we shouldn't move forward until we figure out a way to make it work, or do you think it's useful to have a single SolrCore wide configuration for this sort of thing?\n\nAssuming we're on the right track, my game plan moving forward is:\n1)  i'm going to startplay around with the config options and the control flow logic to make sure we don't do 304 style validation work when we shouldn't\n2) i suggest we think/discuss the openTime/lastModified and config modified / ETag issues a little more before making any changes there\n3) the tests will need refactored so we have at least 2 variants (\"doing caching right\", not doing caching because we said not to\") ... if you want to take a look at doing that now, that would be great \u2013 particularly since i'm not very familiar with the framework Ryan setup for doing JUnit tests that actually spin up Jetty to do the HTTP layer.\n\n\n "
        },
        {
            "author": "Hoss Man",
            "id": "comment-12562286",
            "date": "2008-01-24T23:09:43+0000",
            "content": "Incidentally, the config syntax i'm thinking might work best is something like...\n\n\n  <requestDispatcher handleSelect=\"true\" >\n       ...\n       <!--\n          Set HTTP caching related parameters (for proxy caches and clients).\n          (These are the defaults)\n    <httpCaching lastModifiedFrom=\"openTime\">\n       <cacheControl max-age=\"30\" must-revalidate=\"\" private=\"Foo\" />\n    </httpCaching>\n    -->\n    <!-- to prevent Solr from doing any HTTP Cache related work uncomment this... -->\n    <!--\n     <httpCaching never304=\"true\" />\n    -->\n    <!-- to prevent Solr work, and to be really unfriendly to caches, uncomment this... -->\n    <!--\n     <httpCaching never304=\"true\">\n       <cacheControl max-age=\"0\" no-cache=\"\" no-store=\"\" must-revalidate=\"\" private=\"Foo\" />\n    </httpCaching>\n    -->\n   ...\n  </requestDispatcher>\n\n\n\n...the idea being that any attribute under <cacheControl> becomes an option in the Cache-Control header .. if it has a non-empty value, then that value is echoed as well.  Expires header will also be output if max-age is specified.\n "
        },
        {
            "author": "Hoss Man",
            "id": "comment-12562319",
            "date": "2008-01-25T00:53:19+0000",
            "content": "checkpoint.\n\nmade the logic changes as discussed ... etag and lastMod calculation will now only happen if needed based on config.  Cache-Control header is always generated according tothe solrconfig.xml.  I also did some method refacotring and renaming to try and make it a little more explicit what was happening where, and fixed two small bugs i found (1: even on HEAD request we need to execute the request because it might fail; 2) catch and ignore IAE when parsing the date conditional headers - ie: a malformed date shouldnt' cause the page to fail)\n\nconfig syntax is the same as the last patch. "
        },
        {
            "author": "Thomas Peuss",
            "id": "comment-12562405",
            "date": "2008-01-25T08:53:48+0000",
            "content": "Getting back to the question of the ETag though, i think it would be better to use a hashCode on the config itself ... if the index hasn't changed, and the config hasn't changed restarting Solr shouldn't make the ETag change.\n\nIt is a good idea to use a hash of the config as well. But we need to write that down somewhere that identical slaves need identical indexes and config files as well to have the same ETag.\n\n\"expect\" ? ... uh, i have no expectations from you ... Solr is an volunteer project, no one is expected to do anything other then contribute when/where/however they can\n\nI know. \"Expect\" might have been the wrong word for that.  I only want to make sure that we do not work on the same stuff. I love the peer review you get with OSS projects.\n\nFirst and foremost: do you think being able to customize the \"cache awareness\" of Solr on a per request handler basis is important enough that we shouldn't move forward until we figure out a way to make it work, or do you think it's useful to have a single SolrCore wide configuration for this sort of thing?\n\nA SolrCore wide config for this is enough IMHO.\n\n\nAssuming we're on the right track, my game plan moving forward is:\n1) i'm going to startplay around with the config options and the control flow logic to make sure we don't do 304 style validation work when we shouldn't\n2) i suggest we think/discuss the openTime/lastModified and config modified / ETag issues a little more before making any changes there\n3) the tests will need refactored so we have at least 2 variants (\"doing caching right\", not doing caching because we said not to\") ... if you want to take a look at doing that now, that would be great - particularly since i'm not very familiar with the framework Ryan setup for doing JUnit tests that actually spin up Jetty to do the HTTP layer.\n\nAd 2.: Whatever we choose: Two things must be linked: changed index and/or changed config must change the Etag and the Last-Modified time (this must be changed on config change as well!). Last-Modified must be the maximum of config file change time and index change time...\nAd 3.: Most of the time I have spent with the unit test was to fiddle out how this Jetty stuff works...  I have a look at this. "
        },
        {
            "author": "Thomas Peuss",
            "id": "comment-12562410",
            "date": "2008-01-25T09:17:00+0000",
            "content": "\n<requestDispatcher handleSelect=\"true\" >\n       ...\n       <!--\n          Set HTTP caching related parameters (for proxy caches and clients).\n          (These are the defaults)\n    <httpCaching lastModifiedFrom=\"openTime\">\n       <cacheControl max-age=\"30\" must-revalidate=\"\" private=\"Foo\" />\n    </httpCaching>\n    -->\n    <!-- to prevent Solr from doing any HTTP Cache related work uncomment this... -->\n    <!--\n     <httpCaching never304=\"true\" />\n    -->\n    <!-- to prevent Solr work, and to be really unfriendly to caches, uncomment this... -->\n    <!--\n     <httpCaching never304=\"true\">\n       <cacheControl max-age=\"0\" no-cache=\"\" no-store=\"\" must-revalidate=\"\" private=\"Foo\" />\n    </httpCaching>\n    -->\n   ...\n  </requestDispatcher>\nOne comment only: change must-revalidate=\"\" to must-revalidate=\"true/false\" . For no-store/no-cache as well. "
        },
        {
            "author": "Thomas Peuss",
            "id": "comment-12562490",
            "date": "2008-01-25T13:13:21+0000",
            "content": "Updated unit test. The tests for cache and no-cache tests have now been split into different files. A final update has to take place when the cache related code is stable. "
        },
        {
            "author": "Hoss Man",
            "id": "comment-12562803",
            "date": "2008-01-26T02:08:27+0000",
            "content": "Ad 2.: Whatever we choose: Two things must be linked: changed index and/or changed config must change the Etag and the Last-Modified \n\nI'm not sure that this is strictly true ... if something changes the Etag, then the Last-Modified should also change, but if the Last-Modified changes the Etag doesn't necessarily have to change.  consider use cases where solrconfig.xml never changes: we can use openTime for Last-Modified (in case we have to rollback to an older index), and indexVersion for the ETag - bouncing the server will change the Last-Mod because a new searcher is opened, but the Etag won't change becuase the index hasn't changed.\n\nhere's what i'm thinking...\n\n\ttwo new options (we can pobably think of better names for these)...\n\t\n\t\tlastModFrom=\"openTime|dirLastMod\" ... default is dirLastMod\n\t\tcacheHeaderSeed=\"[some date format]\" ... default is epoch\n\t\n\t\n\theaders are commuted as...\n\t\n\t\tLast-Modified = the max(lastModFrom, cacheHeaderSeed) ... where lastModFrom is computed using the specified value\n\t\tETag is a hashcode of the indexVersion and cacheHeaderSeed\n\t\n\t\n\tresulting behavior...\n\t\n\t\tUsers who aren't pick get the default where slaves with identical snapshots will have identical Etags and Last-Mod headers.\n\t\tChanging configs by default won't immediately change the Etag or Last-Mod header ... if you've got an index that changes semi regularly you can just touch the index to get new headers, or you can add the cacheHeaderSeed option with a timestamp value to force new headers on startup.\n\t\tif you are supper paranoid about making sure your headers are always a perfect reflection of reality (even if you rollback your index to an older copy) use lastModFrom=\"openTime\" and update the  cacheHeaderSeed option every time you change your config ... downside being that in multi-slave setups every machine will generate a different Last-Mod (but the ETags should be the same)\n\t\n\t\n\n\n\n...thoughts?\n\nOne comment only: change must-revalidate=\"\" to must-revalidate=\"true/false\" . For no-store/no-cache as well.\n\nyeah, that's what i was thinking originally, except i wanted to leave out any special knowledge about what the attributes were (ie: know hardcoded list of directive names) .. any XML attribute in the config would automatically becomes a directive in the header value, if it had a value in the config, itwould have a directive value in the header..\n\n\n<cacheControl max-age=\"23\" no-cache=\"\" no-store=\"\" must-revalidate=\"\" private=\"Foo\" asdf=\"\" qwert=\"666\" />\n...becomes...\nCache-Control: max-age=\"23\", no-cache, must-revalidate, private=\"Foo\", asdf, qwert=\"666\"\n\n\n\n...that way we don't have to worry about any HTTP extensions, people can put anything they freaking want in their Cache-Control header. What i forgot until today though is that the numeric directives in the Cache-Control header aren't suppose to be quoted (ie: max-age=23 ... not max-age=\"23\")  ... so that won't work very easily either.\n\nSo then started thinking maybe we use the named list syntax, and let the data type tell us wether or not the value should be quoted (<str>) or not (<int>) ... but that seems awfully verbose for something this simple ... so now i'm wondering if maybe we should just make it be one big string and use a regex to look for max-age so we can set the Expires header as well.\n\nI'm liking the simple string + regex approach personally.\n "
        },
        {
            "author": "Thomas Peuss",
            "id": "comment-12562848",
            "date": "2008-01-26T11:56:47+0000",
            "content": "The cacheHeaderSeed is a good idea. It is like the version number on DNS zonefile entries. The downside of such a thing is that you have to change it manually (but Solr users are clever guys  ). I would see no special meaning in the seed - just a string that we mix with the version number of the index. The user can choose whatever he wants there as long as he changes it when the config changes substantially. Something like cacheHeaderSeed=\"20080126123300\" should be as good as cacheHeaderSeed=\"version23\". As we are caching the ETag now we can use an MD5 or SHA1 hash for the Etag as well. We simply throw the cacheHeaderSeed and the index version number into the hashing function and Base64-encode the result of the hash. With that we obfuscate the index version as well for the paranoid ones and always have an ETag of the same size independent of the length of the seed. Additionally the Etag changes completely if only one bit has changed. This makes the equals check for the Etag a bit faster as well.\n\nThe problems I see with cacheHeaderVersion beeing a timestamp is that you can really break your caching headers if you put a future time stamp in there. This is not allowed by the RFC. Of course we can check for a future time stamp and give a warning and use the current time instead.\n\nWhen I remember right XML attributes don't need a value. So we can do the following:\n\n<cacheControl max-age=\"23\" no-cache no-store must-revalidate private=\"Foo\" qwert=\"666\" />\n...becomes...\nCache-Control: max-age=\"23\", no-cache, must-revalidate, private=\"Foo\", asdf, qwert=\"666\"\n\n\nBut again a very good idea to be flexible here. But the named list syntax might be easier to handle in the code. A regex solution should work as well (but should fail gracefully with a warning logged to the logfile). max-age is the only value that is of interest for the code. "
        },
        {
            "author": "Hoss Man",
            "id": "comment-12563315",
            "date": "2008-01-28T22:21:02+0000",
            "content": "If we allow cacheHeaderSeed to be an arbitrary string, and only fold it into the ETag then what mechanism do we use to support the use case of lastModFrom=\"dirLastMod\" when we eed the Last-Modified header to change because the solrconfig.xml changed?\n\nThe problems I see with cacheHeaderVersion beeing a timestamp is that you can really break your caching headers if you put a future time stamp in there. This is not allowed by the RFC. Of course we can check for a future time stamp and give a warning and use the current time instead.\n\nRight, but like you say: that's a solvable problem by maxing LastMod out with the current system time.\n\nWhen I remember right XML attributes don't need a value. So we can do the following:\n\nBut we would still have the problem of knowing to output unquoted values for certain directives (max-age, s-maxage, etc...) and quoted values for others.  If we have to hardcoded all the directive names in code, they might as well be separate options.  Taking in a single literal Cache-Control header string and using a regex to pull out the Expires is definitely appealing to me, but ... \n\nA regex solution should work as well (but should fail gracefully with a warning logged to the logfile)\n\n...what kind of failure/warning are you worried about?  I'm assuming that the Cache-Control string will be written verbatim, and if it matches \"\\bmax-age=(\\d+)\" we'll also output an Expires; if the regex doesnt' match, we won't (no warning either way ... it seems perfectly normal for people to have a Cache-Control header without a max-age. "
        },
        {
            "author": "Thomas Peuss",
            "id": "comment-12563896",
            "date": "2008-01-30T08:36:37+0000",
            "content": "What about using the index opening time for last-modified and allow an arbitrary string for the cacheHeaderSeed? The opening time is guaranteed to be greater than both index-last-mod and config-last-mod. When you have a cluster of slaves then their last-mods would differ - but does that really hurt? I think no.\n\nThink of following scenario:\n\n\tSlave 1 has opentime X\n\tSlave 2 has opentime X+2\n\tSlave 3 has opentime X+4\n\n\n\nWhen you have round-robin load balancing all clients sometime in the future hit Slave 3 and save X+4 as last-mod for the request. When they now issue a request with a conditional header (If-Modified-Since X+4) Solr on Slave 2 and 3 would send a 304 (Not-Modified) as well. When the index changes you would get a suboptimal behavior for some time - but the code would be much easier.\n\nThis would allow us to use an arbitrary string in cacheHeaderSeed for the ETags. To put semantics in cacheHeaderSeed is error prone. I don't like that.\n\nI am fine with the regex solution. It is both flexible and easy to code. "
        },
        {
            "author": "Hoss Man",
            "id": "comment-12564228",
            "date": "2008-01-30T23:50:47+0000",
            "content": "When you have a cluster of slaves then their last-mods would differ - but does that really hurt? I think no.\n\nThe funny thing is: that's what i originally thought, and then you got me worried about it : )\n\nI think you are right: but let's at least give people who want to have Last-Mod headers which are in sync across all slaves an option for basing it on the dir.lastModified.  We'll be giving them rope to hang themselves with if they change the cacheHeaderSeed because that will change the ETag without changing the Last-Modified, but it will be soft velvety rope that probably won't hurt since most caches are either going to use the ETag or the Last-Modified \u2013 not both.  (besides: as long as it's documented well, they can always force a new snapshot when they change the cacheHeaderSeed (Hmmm... \"etagSeed\" is better now) so that both headers change consistently.\n\nSo to sum up...\n\n\n\tthree http caching related options...\n\t\n\t\tlastModFrom=\"openTime|dirLastMod\" ... default is openTime\n\t\tetagSeed=\"arbitrary string\" ... default is some constant (ie: \"Solr\")\n\t\tcacheControlHeader=\"arbitrary string\" ... default is NULL\n\t\n\t\n\theaders are commuted as...\n\t\n\t\tLast-Modified = $lastModFrom\n\t\tETag is a hashcode of the indexVersion and $etagSeed\n\t\tCache-Control is $cacheControlHeader if set (otherwise no Cache-Control header)\n\t\tExpires is $now+$maxAge if $maxAge can be found in $cacheControlHeader (otherwise no Expires header)\n\t\n\t\n\tresulting behavior...\n\t\n\t\tDefault behavior (lastModFrom=openTime)...\n\t\t\n\t\t\tSlaves with identical snapshots will have identical Etags and Last-Mod headers that may not be exact but should tend to be close, so only a little extra load around the time of a new snapshot.\n\t\t\tIf you rollback an index to a previous version, you will get a new Last-Mod and ETag headers.\n\t\t\tChanging configs and restarting core won't cause Etag to change, but Last-Mod will because of newly opened Searcher \u2013 If you've got an index that changes semi regularly then the ETag will get updated as soon as a new version gets opened, or you can add the etagSeed option to force new ETag on startup.\n\t\t\n\t\t\n\t\tfor people who really want Last-Mod to always be in sync across all slaves (lastModFrom=dirLastMod)...\n\t\t\n\t\t\tLast-Mod will only ever change when index changes.\n\t\t\tYou probably won't care about ETags, but it will stay consistent until index changes.\n\t\t\tIf you change configs, and you do care about ETag, you could update the etagSeed \u2013 but there's not much point since you'll also need to generate a new snapshot on your master to force a new Last-Mod header to be updated.\n\t\t\n\t\t\n\t\n\t\n\n\n\ndoes that sound good?\n\n(fingers crossed i can bang this out on 2007-01-31 between 13:00-18:00 America/Los_Angeles ... unless you want to beat me to it Thomas : ) ) "
        },
        {
            "author": "Thomas Peuss",
            "id": "comment-12564317",
            "date": "2008-01-31T06:25:47+0000",
            "content": "That sounds like a plan. I love peer-reviews...  "
        },
        {
            "author": "Hoss Man",
            "id": "comment-12564585",
            "date": "2008-02-01T02:04:48+0000",
            "content": "(NOTE: in my last update where I listed the new options, I forgot about the \"never304\" option .. obviously that's still important).\n\nBefore I made any changes, I attempted to merge the previous HTTPCaching.patch with CacheUnitTest.patch, and ran into test failure in NoCacheHeaderTest ... looking at it, i'm not sure what it's expectation was/is (seemed to expect a Cache-Control header even when no caching options were specified in the config) so i just left it alone for now.\n\nI have a new unified patch (code+tests) that does everything we talked about, but there's still some thing that need resolved...\n\n\n\tthe test classes still need some work, both in terms of the current failure mentioned above, and to cover more permutations of options.  When we're all said and done, we'll probably want at least 3 separate sets of test/configs:\n\t\n\t\tdefault, no <httpCaching> section in config at all ... should generate Last-Mod and Etag headers and do validation, stoping/starting port should make Last-Mod change but not ETag.\n\t\tnever304=\"false\", lastModFrom=\"dirLastMod\" ... should generate Last-Mod and Etag headers and do validation, no headers should change if we stop/start the port.\n\t\tnever304=\"true\" ... no Last-Mod of ETag headers, no 304 even if we send crazy old If-Modified-Since\n\t\n\t\n\tthere's also probably some refactoring that can still be done in the tests (i noticed some duplicate code that can be moved up into the Base class)\n\tit occurred to me while adding the etagSeed that right now the etag caching is a singleton, we'll need to make this core-specific (using a WeakHashMap i guess?  i'm not fond of that approach, but these are really tiny pieces of info we are caching)\n\tcalcLastModified and calcEtag currently assume they can get requestDispatcher/httpCaching config options from SolrConfig ... but this need to be reconciled with SOLR-350 where there is a plan to move all requestDispatcher configs to multicore.xml (but i've pointed out in that issue i'm not sure if that is necessary or makes sense.)\n\n\n\nThomas: Can you take a look at the current test failure and help me understand why it's expecting a Cache-Control header?  (if you want to take a stab at expanding the test case permutations too that would be cool)\n\nAnd of course, Thomas (and everyone else), please try out the code changes in the patch and the comments in the example solrconfig.xml and let me know if this looks good. "
        },
        {
            "author": "Thomas Peuss",
            "id": "comment-12564690",
            "date": "2008-02-01T09:08:38+0000",
            "content": "\n\n\tthe test classes still need some work, both in terms of the current failure mentioned above, and to cover more permutations of options. When we're all said and done, we'll probably want at least 3 separate sets of test/configs:\n         1. default, no <httpCaching> section in config at all ... should generate Last-Mod and Etag headers and do validation, stoping/starting port should make Last-Mod change but not ETag.\n         2. never304=\"false\", lastModFrom=\"dirLastMod\" ... should generate Last-Mod and Etag headers and do validation, no headers should change if we stop/start the port.\n         3. never304=\"true\" ... no Last-Mod of ETag headers, no 304 even if we send crazy old If-Modified-Since\n\tthere's also probably some refactoring that can still be done in the tests (i noticed some duplicate code that can be moved up into the Base class)\n\n\n\nI take care of the tests.\n\n\n\n\tit occurred to me while adding the etagSeed that right now the etag caching is a singleton, we'll need to make this core-specific (using a WeakHashMap i guess? i'm not fond of that approach, but these are really tiny pieces of info we are caching)\n\tcalcLastModified and calcEtag currently assume they can get requestDispatcher/httpCaching config options from SolrConfig ... but this need to be reconciled with SOLR-350 where there is a plan to move all requestDispatcher configs to multicore.xml (but i've pointed out in that issue i'm not sure if that is necessary or makes sense.)\n\n\n\nWhen I remember right every core has its own classloader. Then every core has its own set of static fields. This is why real singletons are not that easy to do in Java. "
        },
        {
            "author": "Thomas Peuss",
            "id": "comment-12564769",
            "date": "2008-02-01T13:59:15+0000",
            "content": "Fixing the test cases is not that easy.  There is some caching going on somewhere inside Solr that prevents the second (solrconfig-nocache.xml) from being loaded. Well - it is loaded according to the logfile but Solr still uses the configured parameters from solrconfig.xml.\n\nSo your worries about the caching are sound. The problems appear only at another part of Solr than expected...\n\nI played around with some ClassLoader tricks but that has not helped until now. A solution for the problem would be running this tests with extra processes. "
        },
        {
            "author": "Hoss Man",
            "id": "comment-12564868",
            "date": "2008-02-01T18:45:09+0000",
            "content": "Thomas: each core has it's own classloader for plugins defined in the lib directory of the solr home \u2013 but the \"main\" Solr code (in the solr.war) is loaded by the webapp context classloader \u2013 so static variables in \"core\" solr code really are singletons.\n\nWould that explain the problems you are seeing in the test?  does it relate to the etagCache?  I thought the problem was that even in the \"NoCache\" test it as expecting to see a Cache-Control header even though solrconfig-nocache.xml doesn't have one configured?\n\n(We have several tests that load cores with different configs that currently work, and we've never really noticed any problems like this before ... so i'm hesitant to assume it's unrelated to the patch) "
        },
        {
            "author": "Thomas Peuss",
            "id": "comment-12565081",
            "date": "2008-02-02T16:09:56+0000",
            "content": "Thomas: each core has it's own classloader for plugins defined in the lib directory of the solr home - but the \"main\" Solr code (in the solr.war) is loaded by the webapp context classloader - so static variables in \"core\" solr code really are singletons.\n\nOK. Then we need a \"per-core\" cache. A weak-hashmap would be sufficient to achieve this. You can use the core-name as key for example.\n\nWould that explain the problems you are seeing in the test? does it relate to the etagCache? \n\nI am pretty sure that it does not relate to the etagCache. I think it is some static variable stuff in the SolrConfig parts. I try to track that down tonight when I have put my daughter to bed.\n\nI thought the problem was that even in the \"NoCache\" test it as expecting to see a Cache-Control header even though solrconfig-nocache.xml doesn't have one configured?\n\nThis tests are wrong. You are completely right. The current code should fail in the \"nocache\" scenario. Currently it does not because of the problem I have described.\n\n(We have several tests that load cores with different configs that currently work, and we've never really noticed any problems like this before ... so i'm hesitant to assume it's unrelated to the patch)\n\nBut only one of them (the SolrJ tests) loads the Solr code through Jetty (so it might be a Jetty related problem as well).... All other tests use the Solr code directly. "
        },
        {
            "author": "Thomas Peuss",
            "id": "comment-12565119",
            "date": "2008-02-02T21:54:59+0000",
            "content": "The unit tests work now as expected. The problem described earlier occurred because of different behavior of the normal unit tests and the ones run with Jetty.\n\nPlease be aware of the changes in\n\n\tSolrDispatchFilter.java: the init method has changed\n\tJettySolrRunner.java: additional constructor\n\n\n\nSo we can now go ahead and get this into the codebase...  "
        },
        {
            "author": "Fuad Efendi",
            "id": "comment-12566865",
            "date": "2008-02-08T00:19:50+0000",
            "content": "This is an alternative to initially proposed HTTP-caching, and it is extremely easy to implement:\n\nSimply add request parameter http.header=\"If-Modified-Since: Tue, 05 Feb 2008 03:50:00 GMT\" (better is to use other names, do not use http.header parameter; see below...)\nLet SOLR to respond via standard XML message \"Not Modified\", and avoid using 304 response code\n\nWhat do you think? We can even encapsulate MAX-AGE, EXPIRES, and other useful stuff (like as additional UPDATE-FREQUENCY: 30 days) into XML, and all those staff can depend on internal Lucene statistics (and not on hard-coded values in SOLR-CONFIG).\n\nWe should not use HTTP-Protocol response headers such as 304/400/500 to describe SOLR's external API.\n\nSample: Apache HTTPD front-end, Tomcat (Struts-based middleware), and SOLR (backend). With your initial proposal different users will get different data. Why? Multithreading at Apache HTTPD. At least, there are some possible fluctuations, cache is not shared in some configurations, etc. Each thread may get own copy of \"last-modified\", and different users will see different data. It won't work for most business cases.\n\nWithout HTTP:\n\"is modified?\" \n\"when is next update of BOOKS category?\"\n\n\tall caches around the world have the same timestamp for BOOKS category\n... ... ...\n\n "
        },
        {
            "author": "Fuad Efendi",
            "id": "comment-12566869",
            "date": "2008-02-08T00:43:18+0000",
            "content": "Of course ETag etc. will synchronize caches; but anyway why do we need such features of HTTP specs?\n\nHTTP Caching is widely used to cache responces from HTTP Servers, content (HTML, PDF, JPG, EXE) can be cached at coprorate proxy, and locally in Internet Explorer's internal cache. That is the main idea.\n\nAre SOLR-XML responses roving the world and reaching internal cache of Mozilla Firefox, or corporate caching proxies?\n\n-Not. \n\nClients of SOLR: Middleware. Do they need to act as \"caching-proxy\"? May be.... Just another use case: middleware publishes \"current time\" & \"weather\" together with response from SOLR; middleware wants to cache responses from SOLR and do not rely on requests coming from end users because of frequent weather changes    - it depends on implementation of such middleware, for sure, it will try to cache SolrDocument objects instead of pure XML, and such kind of caching is not HTTP-related.\n\n\n "
        },
        {
            "author": "Thomas Peuss",
            "id": "comment-12566951",
            "date": "2008-02-08T08:25:42+0000",
            "content": "Think of two scenarios:\n\n\tAn AJAXified browser client sending requests to Solr. Caching of unchanged data in the client and corporate caching proxies speeds up things.\n\tA cluster of Solr servers behind a loadbalancer with caching functionality. Middleware sends requests to Solr through the loadbalancer. Repeating requests to unchanged data are responded directly from LB cache without putting load to the Solr servers. This is for example our scenario.\n\n\n\nOur code works fine with BlueCoat Webcache, Apache HTTPD proxy cache, Squid proxy cache and many other solutions because we are following standards here. So I don't really get the point of your comment.\n\nBesides that you can completely disable this HTTP header stuff in solrconfig.xml if you don't want it. "
        },
        {
            "author": "Fuad Efendi",
            "id": "comment-12567064",
            "date": "2008-02-08T15:16:37+0000",
            "content": "I agree.\nCaching Load Balancer between SOLR and APP Servers is excellent idea, and it can be \"black box\" without any knowlege about SOLR API.\nAJAX can use internal cache of web browser; FLEX probably too...\nQuestion: do we need caching of static (non-changed) content from SOLR such as \"400: Query parsing error\"?.. \n "
        },
        {
            "author": "Fuad Efendi",
            "id": "comment-12567067",
            "date": "2008-02-08T15:30:36+0000",
            "content": "In my configuration I do not need SOLR caching at all; but I use HTTP caching more effectively.\n\nHTTPD memory- and disk- cache is used between Client and Middleware. No any caching between Middleware and SOLR. Middleware responds to HTTPD with \"304\" if necessary, with correct Last-Modified etc., and request do not reach SOLR. This caching configuration works fine with AJAX too, without SOLR's caching headers.\n\nI've seen unnecessary extra-work with this implementation... taking long time... and tried to point on some meanings of response codes (for Web). "
        },
        {
            "author": "Walter Underwood",
            "id": "comment-12567068",
            "date": "2008-02-08T15:32:14+0000",
            "content": "Two reasons to do HTTP caching for Solr: First, Solr is HTTP and needs to implement that correctly. Second, caches are much harder to implement and test than the cache information in HTTP. HTTP caches already exist and are well tested, so the implementation cost is zero and deployment is very easy.\n\nThe HTTP spec already covers which responses should be cached.  A 400 response may only be cached if it includes explicit cache control headers which allow that. See RFC 2616.\n\nWe are using a caching load balancer and caching in Apache front ends to Tomcat. We see an increase of more than 2X in the capacity of our search farm.\n\nI would recommend against Solr-specific cache information in the XML part of the responses. Distributed caching is extremely difficult to get right. Around 25% of the HTTP 1.1 spec is devoted to caching and there are still grey areas. "
        },
        {
            "author": "Fuad Efendi",
            "id": "comment-12567072",
            "date": "2008-02-08T15:52:27+0000",
            "content": "Regarding HTTP-Caching-Load-Balancer between SOLR and Middleware:\nYou need to deal with additional internal http-cache at middleware. In most cases Middleware generates content from different sources and can't reroute \"If-Modified-Since\" request to SOLR without internal caching. For instance, if you are using SOLRJ, you have to implement additional cache for SolrDocument...  "
        },
        {
            "author": "Fuad Efendi",
            "id": "comment-12567077",
            "date": "2008-02-08T16:01:57+0000",
            "content": "Thomas, Walter,\n\nFinally I agree, thanks!\n\nMiddleware should not send/reroute \"If-Modified-Since\", and should not implement internal cache (in provided by me \"contr\"-sample): with caching enabled, it will simply retrieve cached content.\n\nI do not agree with 400, it is place for DoS attacks. \"Query parsing error\" should be 200 with caching response codes. Of course, I know RFC 2616.  "
        },
        {
            "author": "Fuad Efendi",
            "id": "comment-12567081",
            "date": "2008-02-08T16:24:40+0000",
            "content": "Fortunately, we are not using 404 trying to retrieve removed document... In initial design (I believe) SOLR developers simply wrapped all exceptions into 400, and \"empty result set\" is not an exception. "
        },
        {
            "author": "Hoss Man",
            "id": "comment-12569123",
            "date": "2008-02-14T22:43:48+0000",
            "content": "checkpoint: unification of the most recent HTTPCaching.patch and Thomas's last CacheUnitTest.patch\n\n(note: Thomas, if we have any more iterations of changes to the patches related to testing, it would probably be better to just keep generating  single unified patch containing everything ... having multiple patches attached to an issue is fine as long s they don't overlap, but it gets really difficult to apply multiple patches when they both add (or modify) the same files)\n\nnext step is some MultiCore aware stuff i mentioned before .. working on that now. "
        },
        {
            "author": "Hoss Man",
            "id": "comment-12569156",
            "date": "2008-02-15T01:19:09+0000",
            "content": "Changes made in this version...\n\n1) refactored etag cache to be core specific.\n\n2) change etag calculation so that (common case) minor incriments in openTime/lastModTime affect the earlier chars of the etag for faster equals comparisons (using Long.reverse)\n\n3) refactor config reading into SolrConfig so they don't happen on every request (the max-age regex was my main concern)\n\n4) refactored a bit more common code into the abstract test base\n\nComments welcome (particularly since the multicore weakref stuff isn't something I've given a huge amount of thought to before).\n\nI haven't done enough manual testing to be satisfied that it's working 100%, but i think everything works as desired.  (I would still like to see more unit tests of the different config variations, but it's not a huge problem or anything ... we've got the 80/20 rule going for us, there's probably other areas of the code that are more deserving of additional tests)\n "
        },
        {
            "author": "Hoss Man",
            "id": "comment-12571221",
            "date": "2008-02-21T22:55:16+0000",
            "content": "Committed revision 630037.\n\nAnd I updated the SolrConfigXml wiki page to mention the new config options.\n\nThank you very much for all your hard work on this Thomas! "
        },
        {
            "author": "Shalin Shekhar Mangar",
            "id": "comment-12579728",
            "date": "2008-03-18T05:28:44+0000",
            "content": "It seems there is no way to disable caching on a per-handler basis. I've read through the comments on this issue but I'm still not convinced as to why we need to enable HTTP Caching by default. The way I see it is that using a HTTP Caching Proxy in front of SOLR is a very rare use case and people using it in their deployments can always go and enable caching in solrconfig. The downside of enabling this by default is that there is no way right now to disable it on a per-handler basis and even if there was a way, everyone would have to explicitly do it in their configuration and is something that we would have to educate users unnecessarily.\n\nOur use case is the SOLR-469 DataImportHandler, which should not have responses cached at any time. But there is no way for me to do it currently. I'm sure there will be other use cases too e.g. SOLR-502 for which partial results are also cached right now.\n\nI appreciate the work you all have put into this issue and all I'm trying to say is that a feature used very rarely should not be enabled by default. I'd like to vote to go back to Solr 1.2 compatibility by default. "
        },
        {
            "author": "Thomas Peuss",
            "id": "comment-12579761",
            "date": "2008-03-18T08:23:29+0000",
            "content": "\nIt seems there is no way to disable caching on a per-handler basis.\nTrue. And we should work to a point where we can configure this per handler.\n\nI've read through the comments on this issue but I'm still not convinced as to why we need to enable HTTP Caching by default. The way I see it is that using a HTTP Caching Proxy in front of SOLR is a very rare use case and people using it in their deployments can always go and enable caching in solrconfig. The downside of enabling this by default is that there is no way right now to disable it on a per-handler basis and even if there was a way, everyone would have to explicitly do it in their configuration and is something that we would have to educate users unnecessarily.\nI have no problem with disabling caching headers by default. We might need a functionality where some back-end module can veto on emitting cache headers or can tell the cache header code to emit cache headers that avoid caching of the response. This is not too hard to implement. I have a look into this tonight. We can simply add two methods to the SolrQueryResponse class (like void setAvoidHTTPCaching(boolean) and boolean isAvoidHTTPCaching() - the default for the value would be false). The update request handlers should set this to true all the time. The partial response stuff can set this to true as well.\n\nAnother way of getting around emitting cache headers on a per request basis is to use POST requests. For POST requests we do not emit cache related headers or  Not Modified responses completely following the W3C specs here.\n\nAnd while thinking about that I realize that we need to extend the tests as well that we make sure that we never emit cache related headers in case of errors.\n\nAnd still you can already disable caching header related functionality by adding\n\n   <httpCaching never304=\"true\">\n\n\nto your solrconfig.xml.\n\nI appreciate the work you all have put into this issue and all I'm trying to say is that a feature used very rarely should not be enabled by default. I'd like to vote to go back to Solr 1.2 compatibility by default.\n\nIn my world caching proxies and loadbalancers are the default. This might influence my view on that stuff.  "
        },
        {
            "author": "Noble Paul",
            "id": "comment-12579767",
            "date": "2008-03-18T08:53:09+0000",
            "content": "If we look at the problem that this feature is trying to solve, only the 'select' handler should need this . So making it 'enabled' by default for all handlers does not serve any purpose.\n\nThis is indeed a useful feature for those who use a caching proxy in front. But those users are educated enough to configure it in solrconfig.xml if they need it .( BTW , We use Solr extensively and we have no caching in front of Solr )\n\n\nIn an ideal situation the 'select' handler must have it enabled by default. \nFor all other handlers keep it off by default and provide an option to enable it (if needed)\n "
        },
        {
            "author": "Thomas Peuss",
            "id": "comment-12579808",
            "date": "2008-03-18T11:23:32+0000",
            "content": "This is indeed a useful feature for those who use a caching proxy in front. But those users are educated enough to configure it in solrconfig.xml if they need it .( BTW , We use Solr extensively and we have no caching in front of Solr )\nTrue. We should disable the cache header stuff by default. Please open a new JIRA issue for that.\n\nIn an ideal situation the 'select' handler must have it enabled by default. For all other handlers keep it off by default and provide an option to enable it (if needed)\nExactly. We need to get a bit more specific here. I have opened SOLR-505 for that. "
        },
        {
            "author": "Shalin Shekhar Mangar",
            "id": "comment-12579812",
            "date": "2008-03-18T11:54:31+0000",
            "content": "I've opened SOLR-506 to have this feature configurable on a per-handler basis.\n\nThanks Thomas for starting SOLR-505, together these two issues should lead to an 'ideal' solution  "
        },
        {
            "author": "Hoss Man",
            "id": "comment-12579953",
            "date": "2008-03-18T17:54:05+0000",
            "content": "For the record: most of this discussion should have happened on the solr-dev list, not in the issue comments ... but i would like to address some points, so I'll do it here since this is where the discussion is.\n\n1) It's true, there is no way to configure caching on a per request handler basis \u2013 if you look at the history of the issue we looked into that but because of the necessary API changes we scaled back the scope of the patch \u2013 it can be done, it just needs more thought into how to do it and people interested in working on it.\n\n2) there is no doubt in my mind that having the cache awareness code on by default is the right approach moving forward.  These options don't cause Solr do do any caching, or to force any external caches to cache the pages \u2013 they only result in Solr behaving correctly according to the HTTP spec sections relating to cache headers:  \n\n\tif a request is made to Solr via an HTTP cache that cache will receive headers it can use to decide if/how-long to cache the response\n\tif Solr receives a request with cache validation information then it responds with a 304\nif you don't want that behavior then either don't access Solr via a cache, or explicitly set the <httpCaching never304=\"true\"> option; but the default behavior for people who are upgrading from 1.2 should be for Solr to emit Correct headers and to respect validation requests.  Requiring Solr users to explicitly turn on an option to get Solr to emit correct Caching headers would be like requiring them to explicitly set an option to get well formed XML instead of invalid XML \u2013 the default should be the one that behaves the most correctly.\n\n\n\nI admit however: this is a notable enough change that it should be mentioned in the \"Upgrading from 1.2\" section of CHANGES.txt \u2013 I will add that.\n\n3) if other pending patches attached to other issues have poor behavior as a result of the caching code, the appropriate place to discuss that is in those issue \u2013 the solution may be to mark those issues dependent on a new issue to add the API hooks for request handlers to suppress caching (that's a good idea in general) but it's also possible that there are better/safer/more-logical solutions specific to those patches ... if the DataImportHandler is having problems because the caching code, i'm guessing it's because people use it to trigger updates using an HTTP GET \u2013 that violates the semantics of GET and making work arounds in the the HttpCaching code to allow for that is a bad idea.\n\n4) saying only the \"/select\" handler should get it's responses cached is missleading \u2013 under Solr 1.3 there won't be anything special about /select ... any handler name can be used for queries, and any handler name can be used for updates ... if you are issuing a request that modifies the index, you should be sending a POST and no caching headers (or validation) will be done by Solr regardless of configuration.\n\nAs I said, discussion about the general topic of HTTP Caching, Solr, and what the defaults should be should really happen on the solr-dev list ... if there are any further comments let's please conduct them there and then open/update whatever issues we need to once a consensus has been reached. "
        },
        {
            "author": "Walter Ferrara",
            "id": "comment-12585557",
            "date": "2008-04-04T14:44:44+0000",
            "content": "Just noticed a small (and functionally irrelevant) typo in solrconfig.xml of the example dir:\n\n    <!-- Set HTTP caching related parameters (for proxy caches and clients).\n          \n         To get the behaviour of Solr 1.2 (ie: no caching related headers)\n         use the never304=\"true\" option and do not specify a value for\n         <cacheControl>\n    -->\n    <!-- <httpCaching never304=\"true\"> -->\n\n\n\nlook at the last line, it should be\n\n    <!-- <httpCaching never304=\"true\"/> -->\n\n\notherwise who uncomment that will get an exception "
        },
        {
            "author": "Hoss Man",
            "id": "comment-12586970",
            "date": "2008-04-08T21:34:14+0000",
            "content": "Just noticed a small (and functionally irrelevant) typo in solrconfig.xml of the example dir:\n\nthat was intentional actually ... if you uncomment that line, you have to comment out the line below it which is an open <httpCaching> tag ... the closing tag is much farther down after the comments and the commented out nested <cacheControl> block.  i figured it would be more obvious for people to deal with just those two lines then to have that never304=\"true\" example be a self closing tag and make people scroll down to find the other close tag to get rid of it. "
        }
    ]
}