{
    "id": "SOLR-350",
    "title": "Manage Multiple SolrCores",
    "details": {
        "affect_versions": "1.3",
        "status": "Closed",
        "fix_versions": [
            "1.3"
        ],
        "components": [],
        "type": "Improvement",
        "priority": "Major",
        "labels": "",
        "resolution": "Fixed"
    },
    "description": "In SOLR-215, we enabled support for more then one SolrCore - but there is no way to use them yet.\n\nWe need to make some interface to manage, register, modify avaliable SolrCores",
    "attachments": {
        "SOLR-350-MultiCore.patch": "https://issues.apache.org/jira/secure/attachment/12365490/SOLR-350-MultiCore.patch",
        "SOLR-350-Naming.patch": "https://issues.apache.org/jira/secure/attachment/12371572/SOLR-350-Naming.patch",
        "solr-350-properties.patch": "https://issues.apache.org/jira/secure/attachment/12386546/solr-350-properties.patch",
        "solr-350.patch": "https://issues.apache.org/jira/secure/attachment/12371433/solr-350.patch",
        "SOLR-350-jsp-fixes.patch": "https://issues.apache.org/jira/secure/attachment/12377590/SOLR-350-jsp-fixes.patch",
        "SOLR-350-RemoveStatic.patch": "https://issues.apache.org/jira/secure/attachment/12378571/SOLR-350-RemoveStatic.patch"
    },
    "issue_links": {},
    "comments": [
        {
            "author": "Ryan McKinley",
            "id": "comment-12526201",
            "date": "2007-09-10T17:41:35+0000",
            "content": "Here is a quick sketch of what I think the multicore management/interface should look like.  \n\nEssentially, it works like this:\n\nA.  If you do nothing, solr keeps working as it is - it has a little extra checking at startup and each requests only makes an extra if( singlecore != null ) call\n\nB. If you put a \"multicore.xml\" file in the startup instanceDir, a multicore registry will be initialized.  Each call to the SolrDispatchFilter will select the core (from a synchronized map).  Using the default core does not require a synchronized map lookup.\n\nIn the attached patch, you select the core from the path:  \n\nhttp://host:port/context/handlerpath \u2013 uses default core\nhttp://host:port/context/@core0/handlerpath \u2013 uses core0\nhttp://host:port/context/@core1/handlerpath \u2013 uses core1\n\nThis assumes handler names will not start with '@'  (perhaps we should make it a requirement that handler names don't start with any punctuation?  this would leave open special characters in the future?)\n\nThis still needs a servlet or request handler to manage core manipulation (load, restart, etc).  Since it handles functions across handlers, it should probably be a servlet, but that makes it difficult to use the wt=json/xml stuff.\n\nNOTE \u2013 the core management stuff is untested, I'm attaching it now because I don't have much time to work on it and hopefully someone else can carry on.  \n\nParts of this patch clean up things from SOLR-215.  Unless there is much movement on this issue, I'd like to commit that part in a few days.\n "
        },
        {
            "author": "Yonik Seeley",
            "id": "comment-12526207",
            "date": "2007-09-10T17:59:11+0000",
            "content": "I assume core management stuff needs to be persistent.... if you add a core via the REST api, and the server restarts, you want it to still be there.  So should multicore.xml be changed and written back in this case? "
        },
        {
            "author": "Ryan McKinley",
            "id": "comment-12526210",
            "date": "2007-09-10T18:24:11+0000",
            "content": "Yes, persistence seems like a good option.  \n\nFor the case where you are updating a live schema it may not make sense though.\n tempCore = load new core\n defaultCore = tempCore  \n (close old core when all requests have finished) "
        },
        {
            "author": "Walter Ferrara",
            "id": "comment-12528372",
            "date": "2007-09-18T12:35:25+0000",
            "content": "In my system (netbeans5.5/java1.6 on winxp), it seems to me that it look for multicore.xml in 2 places, both in solr/multicore.xml and in solr/conf/multicore.xml. (using the example dir, Multicore look for multicore.xml in solr/, while Dispatcher in solr/conf)\n\nIn MultiCore.java, a getCores() \n{ return cores.keySet(); }\n would allow to retrieve all the cores registered in the server. \nThis would allow an handler, for example, to dynamically retrieve all the cores (at least by their names) currently registered (SOLR-215 had this).\n\nHow replication will work with multicores? Every core will have different bin dirs (allowing different settings for each one), or replication binaries will replicate all cores (making replication much easier)?\n\nHope this patch get committed soon.\nHave a nice day. "
        },
        {
            "author": "Stu Hood",
            "id": "comment-12529628",
            "date": "2007-09-22T07:31:24+0000",
            "content": "I feel like the suggested implementation is a re-imagining of the Tomcat Manager REST api (http://tomcat.apache.org/tomcat-6.0-doc/manager-howto.html). The main reason I like the idea of multiple cores in the same instance is to provide tighter integration between them: more like a conventional relational database, with multiple tables that have independent schemas (where Solr core == SQL table). Otherwise, having your servlet container managing the contexts just makes more sense, since that is what it is built for.\n\nAlso, I think the core should be a parameter of the query, so that there is the possibility of querying multiple cores simultaneously. Having a top-level controller managing dispatch to the cores opens up all kinds of possibilities for future expansion, (such as joins between indexes?) and it would make things like federated search much more elegant. SOLR-303 already has a \"shards\" parameter with the same idea behind it: just prefix local cores with the @ symbol, and you are good to go.\n\nLoving the potential here! "
        },
        {
            "author": "Ryan McKinley",
            "id": "comment-12529704",
            "date": "2007-09-22T21:56:17+0000",
            "content": "Updated patch to work with trunk \u2013 in rev 578507, I added the core changes to trunk so this patch can focus on the multicore interface.\n\nStu - I like the idea of looking to the existing API for guidance.  That seems smart.\n\nAgain, I'm not working on this actively, but want to make sure it is easy for someone to pick up. "
        },
        {
            "author": "Ryan McKinley",
            "id": "comment-12531917",
            "date": "2007-10-02T21:25:27+0000",
            "content": "more real example.\n\nThis looks for a 'multicore.xml' in the instancedir and registers different cores if it is present... "
        },
        {
            "author": "Doug Steigerwald",
            "id": "comment-12539352",
            "date": "2007-11-01T12:50:49+0000",
            "content": "Any chance there's going to be support to view the admin interface for each core?  Doesn't seem like it's possible currently.\n\nAlso, the admin interface you do see is for the last core loaded and not the default core in the configuration. "
        },
        {
            "author": "Henri Biestro",
            "id": "comment-12542365",
            "date": "2007-11-14T08:51:54+0000",
            "content": "Ryan - Should solr-409 (aka class loader sharing) become a dependency of this issue and if so what kind of \"link\" should be used to refer to it?\nOr should I fold solr-409 in solr-350 (closing solr-409 in the process)? The \"new\" behavior does not break the current one. "
        },
        {
            "author": "Ryan McKinley",
            "id": "comment-12542447",
            "date": "2007-11-14T12:58:34+0000",
            "content": "For simplicity, I think adding 409 to 350 is a good idea.  I have not looked at 409 yet, but I like Walters suggestion to optionally have a single shared lib across all cores (rather then making each lib dir optionally shared)\n\n<multicore enabled=\"true\" adminpath=\"/admin/multicore\" persistent=\"true\" sharedLibDir=\"lib\">\n   <core name=\"core0\" instanceDir=\"core0\" default=\"true\"/>\n   <core name=\"core1\" instanceDir=\"core1\" />\n</multicore> "
        },
        {
            "author": "Henri Biestro",
            "id": "comment-12542520",
            "date": "2007-11-14T17:35:30+0000",
            "content": "\nWalter's suggestion is already in solr-409 (with libDir attribute name).\n\nI could not verify everything and wanted to be safe so I loaded an updated version of solr-350_409.patch in solr-409.\nThere are some improvements in the admin webapp that is now multi core aware. (ie: you can switch from core to core).\nI also made a small change in Config.java; locateInstanceDir seems to look for sol.solr.home as an environment variable.\n\nI've quickly checked the deployment against the example starting with: java -Dsolr.home=`pwd`/multicore -jar start.jar .\nAs soon as I'm more confident, I'll push the patch over solr-350. "
        },
        {
            "author": "Henri Biestro",
            "id": "comment-12550448",
            "date": "2007-12-11T13:58:53+0000",
            "content": "core can be set as a request parameter ( ?core=corename versus /@corename) "
        },
        {
            "author": "Henri Biestro",
            "id": "comment-12550454",
            "date": "2007-12-11T14:27:48+0000",
            "content": "use a request attribute to pass the core in all pages "
        },
        {
            "author": "Ryan McKinley",
            "id": "comment-12551188",
            "date": "2007-12-13T01:32:52+0000",
            "content": "patch to get rid of the @corename syntax and force things into /corename/handler \n\nAdds 'RENAME' action to rename a core \u2013 \n\nsee:\nhttp://www.nabble.com/purpose-of-MultiCore--22default-22---to14268755.html\nhttp://www.nabble.com/multicore-and-admin-pages--to14268867.html\n\nThis also got rid of the ?core=name syntax for /admin, and makes it work for:\n/corename/admin/xxx.jsp "
        },
        {
            "author": "Henri Biestro",
            "id": "comment-12553696",
            "date": "2007-12-20T15:29:06+0000",
            "content": "updated to implement 'alias' (should be considered draft since there aren't specific unit tests associated yet);\nimplements persistence (added an XmlWriter that might be revisited); all operations that modify the multicore state will rewrite the multicore.xml \n\nAlias feature:\n0 - Name and aliases reside in a common identifier space; one identifier uniquely determines a core (can't have the identifier 'core' used a a name to point to coreA and as an alias to point to coreB)\n1 - One core has one unique immutable name (rename command has been neutralized)\n2 - One core may have many aliases\n3 - There are only 2 admin commands related to aliases:\n   3.1 - alias(core, alias): adds an alias to a core, overriding any existing alias but fails to override a core name.\n   3.2 - unalias(str); if str is a core name identifier, all its aliases get deleted, if str is an alias identifer only that alias gets deleted.\n4 - Core addressing through URLs/API can use either name or alias (although using alias is best practice for common aka non-admin operations) "
        },
        {
            "author": "Henri Biestro",
            "id": "comment-12553750",
            "date": "2007-12-20T18:57:01+0000",
            "content": "simplified code; prepared for createCore "
        },
        {
            "author": "Ryan McKinley",
            "id": "comment-12553754",
            "date": "2007-12-20T19:11:19+0000",
            "content": "I have not looked at the recent patches yet... but I'm still wondering if there is any value to \"alias\" if we have a SWAP command?\n\nhttp://www.nabble.com/purpose-of-MultiCore--22default-22---to14268755.html#a14427376\n\nAliasing has me nervous about the maintining a unique ID and a name - it seems to just lead to a management/clarity problem. "
        },
        {
            "author": "Henri Biestro",
            "id": "comment-12553798",
            "date": "2007-12-20T22:03:34+0000",
            "content": "backup of my local state: added untested code (create core dynamically), still some thinking to be done (using CoreDescriptor as vehicle for multicore serialization in&out?)\n\nAs for the added complexity versus the swap command, I believe the potential functional benefits make it worth it. \nUsing the URL (and not parameters) to carry information is good practice and seems like an appropriate rationale; for instance, using the 'alias' through the URL to map query behaviors (be it, filtered queries, query parsers, etc) would open to easy ways to fit per-user/usage profiles behaviors.\n\nAnd I think we can be informative enough on misconfiguration so users know exactly where the error sit. "
        },
        {
            "author": "Ryan McKinley",
            "id": "comment-12553809",
            "date": "2007-12-20T22:43:15+0000",
            "content": "> (be it, filtered queries, query parsers, etc) would open to easy ways to fit per-user/usage profiles behaviors.\n> \n\nAre you saying there is a big win if you can get stats on:\n http://host/henri/select vs http://host/ryan/select\nwhen 'henri' and 'ryan' are both aliased to 'core1'?  Perhaps?  but mod_rewrite can do that and much much more (if you really wanted to). \n\nWith the alias model, how would you reindex a running core and end up with an identical setup at the end?  Unless I'm missing something, the new core would need a different name (id), and there would be a brief moment where the main core was not avaliable\n\nconsider:\n <core name=\"core0\" alias=\"main\" ... />\n\nand all queries come to solr as:\n http://host/solr/main/...\n\nI would have to run:\n 1. LOAD core1 using same config as core0\n 2. send add commands to core1 \n 3. UNALIAS \"main\" from core0\n (now nothing is available at /main)\n 4. ALIAS \"main\" to core1\n 5. UNLOAD core0\n (now the persisted configuration is different then when we started but should not be) "
        },
        {
            "author": "Henri Biestro",
            "id": "comment-12553882",
            "date": "2007-12-21T06:26:58+0000",
            "content": "If we are making a new index - a new index version-, it can mean the schema and the config can change; I may change my analysis chain or schema but also warming queries, cache set up, etc. The config is thus not necessarily the same.\nI may also want to have the new setup tested by a group of users before I make it available to the whole population;  http://host/productionl versus http://host/stage.  I might even have automated tests that verify that some queries do return some expected documents.\nIf we were to use the 'alias' to map behaviors, it seems more convenient to declare those within Solr than anywhere else; describing that http://host/ryan/select queries on core main with an automated fq author='ryan' should not force mod-rewrite usage imho.\nFinally, the 'alias' command as it stands, allows to redefine an alias (without havng to unalias first) so the sequence would be:\n(considering <core name=\"core,0\" alias=\"main\" ... />)\nLOAD core,1  // which could even be aliased as 'stage' at this time\nsend adds to core,1 // when done, could run verifications on 'stage'\nALIAS core,1 main // 'swap' so to speak, overwrites previous 'main' alias\nUNLOAD core,0 "
        },
        {
            "author": "Ryan McKinley",
            "id": "comment-12553885",
            "date": "2007-12-21T06:57:18+0000",
            "content": "> If we were to use the 'alias' to map behaviors, \n\nhow would an alias map different behaviors?  Alias just offer multiple ways to access the same core and the same behavior.  RequestHandlers don't know what path requested them.\n\nMy point about mod_rewrite was referring to the use case you referred to:  making the log files easier to parse per user.  \n\nRe production and stage, why do you need aliasing for that?  each core has name - when 'stage' is ready \u2013 it can swap with 'production'  \n\n> Finally, the 'alias' command as it stands, allows to redefine an alias (without havng to unalias first) so the sequence would be:\n> (considering <core name=\"core,0\" alias=\"main\" ... />)\n> LOAD core,1  // which could even be aliased as 'stage' at this time\n> send adds to core,1 // when done, could run verifications on 'stage'\n> ALIAS core,1 main // 'swap' so to speak, overwrites previous 'main' alias\n> UNLOAD core,0\n> \n\nso if you serialize at the beginning, you have:\n<core name=\"core,0\" alias=\"main\" ... />\nat the end you have:\n<core name=\"core,1\" alias=\"main\" ... />\n\nif you run that every hour, do you end up with \"core,1000\" or switch between them?  This would require you ask MultiCore, what i the 'id' for the core sitting at 'main' before you can operate on it.  Why add this complexity? "
        },
        {
            "author": "Henri Biestro",
            "id": "comment-12553922",
            "date": "2007-12-21T10:56:08+0000",
            "content": "RequestHandlers do not today know the path that requested them;I was merely proposing a possible functional extension through usage of aliases.\nAs for core names, being able to carry which version/revision of the config/schema is in use is imho not complex and useful to many (using svn/cvs/webdav to store config/schema)\nAnyway, the 'aliases' idea is definitely not something you did find useful enough from the beginning and I'm obviously failing to make the case for it. Alas. "
        },
        {
            "author": "Ryan McKinley",
            "id": "comment-12553983",
            "date": "2007-12-21T18:23:27+0000",
            "content": "\n> RequestHandlers do not today know the path that requested them;\n\naaah \u2013 so if we need it later, we could add aliasing then?\n\n\n> is imho not complex and useful to many (using svn/cvs/webdav to store config/schema)\n\nHow does aliasing change this.  What can you do that you could not do without it?  I store my config/schema in svn and don't have any problems.\n\n\n> Anyway, the 'aliases' idea is definitely not something you did find useful enough from the beginning\n\nIf I understood what you gain, I could be convinced.  Right now I just see it as the need to manage and maintain multiple names+one immutable name without any reason.\n\nPerhaps we can move forward without aliasing, and add it later if we find (and implement) a solid use case for it. "
        },
        {
            "author": "Ryan McKinley",
            "id": "comment-12554022",
            "date": "2007-12-21T20:14:23+0000",
            "content": "Here is a patch that cleans up some naming and implements the SWAP command.\n\nIt does not include the persistence stuff in the latest  solr-350.patch \n\nHenri - how do you feel about committing this, then implementing persistence in a smaller patch? "
        },
        {
            "author": "Henri Biestro",
            "id": "comment-12554045",
            "date": "2007-12-21T21:49:11+0000",
            "content": "SWAP is an important feature to exploit multicore & persistence is not production ready yet, so committing feels like the next logical step .\nRyan, if possible, I'd appreciate and would greatly benefit from a quick/early review of the solr-315.patch peristence & core creation code (XmWriter, CoreDescriptor; keep them or loose them?).\n\nAs an upside on the ALIAS discussion, if & when a use case shows up, I guess we will be ready! "
        },
        {
            "author": "Ryan McKinley",
            "id": "comment-12554053",
            "date": "2007-12-21T22:40:09+0000",
            "content": "just committed SOLR-350-Naming.patch \n\n>\n> Ryan, if possible, I'd appreciate and would greatly benefit from a quick/early review of the solr-315.patch peristence & core creation code (XmWriter, CoreDescriptor; keep them or loose them?).\n>\n\nI gave it a quick look this morning, but did not look too closely because all the 'alias' stuff \n\nXmWriter and CoreDescriptor seem reasonable to me.  The CoreDescriptor could be used to move both Config and Schema away from knowing what file opened them.  Check SOLR-427\n "
        },
        {
            "author": "Henri Biestro",
            "id": "comment-12554085",
            "date": "2007-12-22T06:01:53+0000",
            "content": "On aliases - for completeness - , I had this \"nagging\" thought I was missing something...\nRe-reading Hoss's proposal and crossing that with the 1000 unique names point you made, there is in any case 1000 unique 'instanceDir' that need to be provided; Hoss proposed to use the 'instanceDir' instead of a name and alias that if I'm not mistaken.\nI got side tracked by the fact that the instanceDir could be absolute which would have introduced a deployment host 'hard' dependency and lost the equivalence.\nIf we define an 'instanceRoot' (at the multicore level or at the core level) and make the (core) instanceDir = instanceRoot + '/' + name, the uniqueness of the core name would be put to its initial intended use (instead of just being a by-product of the alias feature). In that case, at least one alias is convenient so we can keep the 'url' constant across index revisions.\nFor instance, if you are using svn, you could have you instanceDir/\n{schema, conf}\n versioned; when you have a new revision ready to go, you copy these over using the instanceDir+\",\"+revision-number and use that as a name (which isn't too bad of a convention).\nAnd then, there are maybe future features that could be added to use aliases for other purpose...\nOh well... "
        },
        {
            "author": "Henri Biestro",
            "id": "comment-12558655",
            "date": "2008-01-14T16:27:06+0000",
            "content": "updated for trunk 611834;\nimproved code related to configuration wrt absolute/relative locations: allows core dataDir/instanceDir to be absolute or relative to multicore (pseudo) instanceDir/dataDir.\nadded a 'dataDir' attribute at the multicore.xml level so that all core data directories can be made relative to it (when they are not absolute).\nAfter much consideration, added CoreDescriptor/XmlWriter classes; the former describe cores (makes it easier to manage/persist cores and eventually extend behavior - variables...), the latter is (an overkill to) persist XML (ala java6 XmlWriter). "
        },
        {
            "author": "Ryan McKinley",
            "id": "comment-12560234",
            "date": "2008-01-18T06:06:47+0000",
            "content": "Hi Henri-\n\nWe're getting there....  but I had trouble applying this patch, can you post a new one with a few changes?\n\n1. can you change your editor settings to use two spaces rather then tabs?  In general, solr code should have two spaces rather then tabs or 4 spaces.\n\n2. To avoid confusion with o.a.s.request.XMLWriter, can we call XmlWriter something else?  XmlWriterHelper? XmlWriterUtils?\n\n3. Can we make XmlWriter a package protected class in o.a.s.core?  This way we don't have to make it part of the public API.  If there is a need for it later, we can easily move it.  Also, if it can be replaced with an off the shelf library, we can do that later without mucking anyone up.\n\nThanks for your work and patience with this! "
        },
        {
            "author": "Henri Biestro",
            "id": "comment-12561635",
            "date": "2008-01-23T11:09:45+0000",
            "content": "changed persistence to use o.a.s.common.util.XML (removed XmlWriter);\nupdated multicore params/solrj to reflect full set of core creation parameters;\nmodified multicore tests to use a clean copy of multicore.xml (multicore-base.xml) before running and made dataDir point to ${CWD}/solr-350 to avoid environment pollution;\n\npatch produced on Solaris 10 by:\nsvn diff --diff-cmd /usr/local/bin/diff -x \"-w -B -b -E -d -N -u\" > ~/solr-350.patch\ncan be applied with:\n/usr/local/bin/patch -u -p 0 < ~/solr-350.patch "
        },
        {
            "author": "Ryan McKinley",
            "id": "comment-12561780",
            "date": "2008-01-23T19:13:49+0000",
            "content": "Looking good.  I took your patch and removed all the 'default' stuff to make it in line with Hoss' observations in:\nhttp://www.nabble.com/Re%3A-purpose-of-MultiCore-%22default%22---p14591921.html\n\nThis adds the dispatcher settings to multicore.xml\n\n<multicore adminPath=\"/admin/multicore\" dataDir=\"alldata\" persistent=\"true\" >\n  <abortOnConfigurationError>true</abortOnConfigurationError>\n  <requestDispatcher handleSelect=\"true\" >\n    <requestParsers enableRemoteStreaming=\"false\" multipartUploadLimitInKB=\"2048\" />\n  </requestDispatcher>\n\n  <core name=\"core0\" instanceDir=\"core0\" default=\"true\"/>\n  <core name=\"core1\" instanceDir=\"core1\"/>\n</multicore>\n\n\n\n\nThe one thing we need to change before commiting is how the test work with multicore-base.xml and multicore.xml \u2013 maybe the 'clean' copy should live in the test files and get copied over on a shutdown hook?  We want to make sure everythign in the /examples directory helps people understand how things work. "
        },
        {
            "author": "Hoss Man",
            "id": "comment-12562834",
            "date": "2008-01-26T07:36:36+0000",
            "content": "hey guys ... i'm catching up on some Jira reading and this comment jumped out at me...\n\nimproved code related to configuration wrt absolute/relative locations: allows core dataDir/instanceDir to be absolute or relative to multicore (pseudo) instanceDir/dataDir.\n\n(i'm guessing that's what the dataDir option in the <multicore/> tag in Ryan's example is for?)\n\nthis seems like a bad idea to me ... violating the principle of least suprise and all.  it will make the behavior of a solrconfig.xml file dependent on whether or not it's being used in a multicore context or not.\n\nI'd like to suggest that an aternate approach would be to generalize the current system property based variable substitution to support arbitrary key=val pairs specified when the SolrCore is constructed...\n\n\n\twe add new syntax to multicore.xml for declaring \"global properties\"\n\tMultiCore converts these global declarations into a SolrParams instance\n\twe also add syntax to multicore.xml for declaring properties specific to a core.\n\twhen MultiCore instantiates a core, it uses DefaultSolrParams to let the specific properties override the global properties and to set a special property containing the name of the core (ie: \"solr.core.name\")\n\tif cloning a core is possible (i can't remember) MultiCore would reuse the SolrParams from the source core, changing only the core name property (solr.core.name)\n\tsystem properties with the same names as properties in multicore.xml would trump anything from the configs (since they are a run time overrides)\n\n\n\n\n<multicore adminPath=\"/admin/multicore\" persistent=\"true\" >\n  <abortOnConfigurationError>true</abortOnConfigurationError>\n  <requestDispatcher handleSelect=\"true\" >\n    <requestParsers enableRemoteStreaming=\"false\" multipartUploadLimitInKB=\"2048\" />\n  </requestDispatcher>\n  <property name=\"alldata.dir\">/my/solr/basedir</property>\n  <property name=\"magicnumber\">32</property>\n\n  <!-- core0 gets props above, any other props in it's configs must come from system props -->\n  <core name=\"core0\" instanceDir=\"core0\" />\n  <core name=\"core1\" instanceDir=\"core1\">\n     <property name=\"dataDir\">foo</property>\n  </core>\n  <core name=\"core111\" instanceDir=\"core1\"><!-- note same instanceDir as above-->\n     <!-- can reuse exact same instance dir as another core ${solr.core.name} will be differnet -->\n     <property name=\"dataDir\">bar</property>\n     <!-- and now ${dataDir} will be different too -->\n  </core>\n</multicore>\n\n\nThis would not only give us the ability to have a common ${alldata.dir} for all cores, but also an easy way to reuse the same solrconfig.xml for multiple cores and still get subtle changes in behavior \u2013 all while making it transparent what any one solrconfig.xml will do.\n\nSuper powerful \u2013 and (i think) pretty easy to implement... a new optional SolrParams arg to the SolrCore, SolrConfig, and Config constructors, and DOMUtil.substituteSystemProperties plus some code in MultiCore to create the SolrParams (hmm,  DOMUtil doesn't have a very friendly method for that yet, not that big a deal though)\n\nwhat do you think? "
        },
        {
            "author": "Hoss Man",
            "id": "comment-12562835",
            "date": "2008-01-26T07:51:41+0000",
            "content": "Actually, one more unrelated comment...\n\nLooking good. I took your patch and removed all the 'default' stuff to make it in line with Hoss' observations in:\n\n...i know i suggested moving anything related to the entire solr server into multicore.xml, but i've been looking at SolrDispatchFilter lately because of SOLR-127 and i'm starting to wonder if the <requestDispatcher/> config options really need to be webapp wide.  \n\nThey are (currently) only used to construct a protected instance of SolrRequestParsers in SolrDispatchFilter.init, but that SolrRequestParsers is only needed in the doFilter method once we've already figured out what core we're using ... it's a fairly light weight class, so why not construct a new one in each call to doFilter (after we've determined the correct core) and leave those options core specific?\n\n(not to mention the HTTP caching options SOLR-127 is probably going to add to  <requestDispatcher/>)\n\n...\n\n\nAnd while i'm thinking about it ... what does abortOnConfigurationError=true mean in a multicore world when someone attempts to dynamicly load a core with a config error?  \n\nCurrently SolrDispatchFilter only looks at that setting on init ... is MultiCore goung to start checking it after each LOAD core action?  will it cause the whole server to stop accepting requests or just do something special for that one core?\n "
        },
        {
            "author": "Henri Biestro",
            "id": "comment-12563346",
            "date": "2008-01-29T00:01:10+0000",
            "content": "Regarding introducing variables, this is tempting but this looks like a rather important feature for a rather limited need. Plus it could be argued that it increases the element of surprise or at least the potential for side effects.\nIf a solrconfig/schema refers to a variable that can be superseded in a multicore.xml, the behavior of a core is explictly dependant on whether it is loaded in a multicore configuration of not. I agree that being explicit rather than implicit is better but this does modify behavior even deeper nevertheless.\n\nThe door that variable introduction would open seems much wider than the functional hole is; the original \"breach\" was needed for the shared class loader, a common dataDir root is adressing the good practise to segregate data from configuration. We could introduce a configDir/schemaDir at multicore level to adress sharing config/schema sharing - although using multiple cores is usually related to different config/schema so reusing/sharing them does not look like a must-have feature.\n\nThe multicore dataDir attributes is a default directory/roots that can be overriden by core definitions, the current convention is really limited in its effects to what's needed. Variables and the huge functional potential of a whole environment defined within Solr seem way beyond the current use-cases; if we follow the precedent of \"alias vs swap\", we should retain the idea but wait till more needs emerge before implementing it, shouldn't we? \n\n\n\n "
        },
        {
            "author": "Hoss Man",
            "id": "comment-12564212",
            "date": "2008-01-30T23:16:49+0000",
            "content": "I agree generalizing variables is somewhat significant, and a larger scope then just what's being talked about here \u2013 perhaps that's part of the disconnect ... I'm taking it as a given that it's a problem that needs to be solved before multicores can really be useful \u2013 so if we have to solve that problem, and that solution can also solve the common dataDir problem, let's not have an alternate solution to hte dataDir problem that is \"non transparent\" to people reading the configs.\n\n(my assumption being based on the impression that we can't really support a lot of the use cases people have talked about without having at a minimum a way to know use the \"name\" of the current core as a variable in the configs  \u2013  postCommit hooks being one example of a place where this info will be crucial) \n\nIn a nutshell: if we know we are going to need variables, then instead of introducing a new <multicore dataDir=\"...\"> option now (which if used changes the meaning of the <dataDir/>) let's solve the broader problem of passing arbitrary variables to a SolrCore.  we can still commit all of the other stuff you guys have been working on, lets just set the dataDir issue aside until we add the variable support.\n\nBUT!!! part of your comment has me worried that i'm misunderstanding how <multicore dataDir=\"...\"> works, you just said...\n\nThe multicore dataDir attributes is a default directory/roots that can be overriden by core definitions\n\n...how can it be overridden?  My understanding based on your early comment was that <multicore dataDir=\"...\"> was the directory that the <dataDir>...</dataDir> options in each solrconfig.xml would be relative to ...do you mean that in the multicore.xml file, each <core/> can have a dataDir option? ... if so that doesn't really solve the concern I have: people should be able to read a solrconfig.xml and understand when there are outside inflluences on that config...\n\nPlus it could be argued that it increases the element of surprise or at least the potential for side effects.\nIf a solrconfig/schema refers to a variable that can be superseded in a multicore.xml, the behavior of a core is explictly dependant on whether it is loaded in a multicore configuration of not. I agree that being explicit rather than implicit is better but this does modify behavior even deeper nevertheless.\n\nI disagree ... it's true that using a \"variables\" approach the evaluation of a solrconfig.xml would be dependent on the environment it's run in (ie: is there a multicore.xml? are variables set in it? are any system properties set?) but the evaluation of solrconfog.xml is already dependent on it's environment  (ie: what is the solr home? are any system properties set?) ...  my point is that when a human is reading a config with variables in it, it is crystal clear that there is an environmental factor that will affect the behavior.  If a person reads a solrconfig.xml that contains this line...\n\n<dataDir>${my.special.dir}/data</dataDir>\n\n\n...then it's very obvious that the location of the data will depends on the environment the core is run in (in which \"my.special.dir\" must be set, either as a system property or as a multicore.xml variable \u2013 the point being it's an known external factor).  The approach you guys have been talking about though (assuming i'm understanding it correctly) would take away that transparency \u2013 people could look at a solrconfig.xml that looks like this...\n\n<dataDir>data</dataDir>\n\n...and that that could mean anything depending on whether or not this solrconfig.xml is running in a multicore setup or not. "
        },
        {
            "author": "Henri Biestro",
            "id": "comment-12564457",
            "date": "2008-01-31T18:56:58+0000",
            "content": "\nI'm confused and dont see the dataDir element parsing you are referring to in solrconfig.xml; my current understanding is that the dataDir is deduced from the instance dir if not specified explicitly at core construction time. Are you proposing to add it (and/or instanceDir) to solrconfig.xml?\n\nAnyway, the current patch code allows both dataDir & instanceDir to be specified as multicore & core attributes (and everything related to file/directory locations is contained within multicore.xml); it treats absolute directory specifications (ie starting with '/') as such, core specification having precedence over multicore.\nIf the core specified instanceDir is absolute, it is used as is and the dataDir is made relative to it if not absolute.\nOtherwise, the instanceDir is relative to the multicore instanceDir; If the core specified dataDir is absolute, it is used as such otherwise the core dataDir is relative to the multicore dataDir.\nWhen left unspecified, everything behaves relative to the multicore implied instanceDir or as current defaults.\n\nIf you still find this is a bad solution, I'm confident you & Ryan will agree on the good one; just let me know, I'll (try to) code it (if you want). "
        },
        {
            "author": "Ryan McKinley",
            "id": "comment-12565138",
            "date": "2008-02-03T03:09:51+0000",
            "content": "Apologies for the lack of input, I've been too sick to follow this thread.\n\nHenri - the <dataDir> element is in solrconfig.xml \u2013 check the example config, it lists:\n\n <dataDir>${solr.data.dir:./solr/data}</dataDir>\n\n\n\nI'm a bit torn on the proper direction from here - the flexibility of setting the dataDir from multicore.xml is really nice, it makes it really easy to share all the same configs, but change the data directory.  However, if the dataDir is set in solrconfig,xml, what about the existing <datadir> within solrconfig.xml?\n\nThe properties/variables solution seems interesting, but more then I think we need to take on right now.\n\nI'll post an updated patch that removes all dataDir configuration and then we can work from there. "
        },
        {
            "author": "Ryan McKinley",
            "id": "comment-12565139",
            "date": "2008-02-03T03:13:00+0000",
            "content": "Updated patch that removes dataDir configuration.  This also puts the requestParser configuration back within each core.  Creating a new RequestParser is not a lightweight operation, so creating one for each request does not seem like a good idea.  This keeps a WeakHashMap<SolrCore,RequestParser>  "
        },
        {
            "author": "Hoss Man",
            "id": "comment-12566421",
            "date": "2008-02-07T01:04:53+0000",
            "content": "just to clarify, i still haven't looked at the patch closely (I trust Ryan/Henri's judgment on bulk of the multicore implementation ... i mainly just want to sanity cehck the concepts and configs) ... but I have just a few follow up questions/clarifications about some of the issues i mentioned before...\n\na) by \"requestParser configuration back within each core\" you mean all of the <requestDispatcher> configuration, correct?  (currently requestParser and handleSelect ... likely to be httpCaching as well) i mainly just want to be sure that moving forward we think it makes sense for each solrconfig.xml to have it's own <requestDispatcher> section containing info on how the SolrDispatchFilter should deal with requests for the core using that config.\n\nb) (constructing a) SolrRequestParsers instance seems pretty lightweight to me ... is there any think specific you're worried about that i'm not noticing?\n\nc) should i open a separate issue for dealing with generalizing variables (and note that corename and dataDir are two prime use cases) ?  it seems like that can definitely be dealt with after the bulk of the stuff in this issue is committed.\n\nd) anyone have any thoughts regarding my question about \"abortOnConfigurationError\" and what it should mean when dealing with dynamically loaded cores (i'm pretty sure right now it's ignored for any dynamically loaded cores ... i'm just wondering if that's what we want it to do) "
        },
        {
            "author": "Henri Biestro",
            "id": "comment-12568992",
            "date": "2008-02-14T16:43:19+0000",
            "content": "Regarding c/variables/properties, imho we can definitely tackle the bulk of it in here, no need for another issue yet.\n\nOn that topic, one small nag regarding multicore.xml serialization; do we want multicore.xml serialization to retain expressions if any (ie serailize them back as expressions) or not? Seems like it would be convenient to be able to distribute the same multicore.xml across several hosts - which may have different envs.\nAs of now, we do expand all expressions before parsing resource files; if multicore.xml uses expressions based on environment variables, these will be expanded before we even have a chance to see them which precludes being able to write them back.\nSince we will have to serialize variables in multicore.xml, one workaround would be for users to declare local variables for each env based expressions (as multicore \"global\" properties) and only use those locals (keeping those definitions before expansion that is). Parsing multicore.xml would make one pass before expansion to extract the 'multicore/property' & 'core/property' raw expressions, then expand the whole.\n(implementation/self note: MultiCore & CoreDescriptor need to be able to define/serialize properties).\n\nWould this be ok / needed? Thoughts ? "
        },
        {
            "author": "Ryan McKinley",
            "id": "comment-12569018",
            "date": "2008-02-14T17:37:32+0000",
            "content": "\n> Regarding c/variables/properties, imho we can definitely tackle the bulk of it in here, no need for another issue yet.\n> \n\nI think we should try to wrap up thins without properties, then open a new issue for them.  They are functionally different enough.  As a note, I'm using this multicore patch with system variables for the data path in each solrconfig.xml \u2013 this gives the same behavior you were looking for.  <dataDir>${solr.data}/corename/</dataDir>\n\nIn my view the one thing we need to fix before getting this patch commited is the returning results for unloaded cores...\nhttp://www.nabble.com/Multicore---Querying-unloaded-core-returns-results-from-default-td15469303.html "
        },
        {
            "author": "Henri Biestro",
            "id": "comment-12569146",
            "date": "2008-02-15T00:27:41+0000",
            "content": "We need a way to define a global data root without having to define a system env variable; can't we at least reintroduce the dataDir as a multicore attribute?\nThe previous patch version went too far and was ignoring the solrconfig.xml dataDir specification, but having no way to describe where all data go easily is really too inconvenient.\nCan't we find something acceptable in between ?\nStrawman solution would be, if dataDir is not specified in solrconfig.xml, use the previous patch code ?\nHopefully more acceptable, only provide a minimum set of variables with no possibility to define any for now ? The env would only contain 'solr.multicore.\n{home,data}\n' and for each core,'solr.multicore.core.instance' (I'm reluctant to expose 'sol.multicore.core.name', explanation follows...)\n\nThis would not preclude extending variables later and would not delay solr-350 by much now.\n\nWe used <dataDir>${solr.data}/corename/</dataDir> to illustrate the variable solution but I grow feeling uneasy seeing the core name as a variable part of a path (explicit or implicit): if we issue a SWAP command, how do we end up in a proper state when we stop/start the container without swapping the directory contents as well ?\n\nMy rationale is that the instanceDir is really what physically identifies a core in a persistent manner wrt SWAP/stop/start; when we specify a data root, the data directory should somehow depend on the instanceDir as well.\nFor instance, with <core name=\"books\" instanceDir=\"books,0'.../> and <core name=\"books-dev\" instanceDir=\"books,1\".../> ; even if both use the same data root '/solr/data', the 'books' core will use '/solr/data/books,0/' as dataDir and 'books-dev' will use '/solr/data/books,1'.\nWhen we swap('books', 'books-dev') , everything is still ok; 'books' now refers to_'/solr/data/books,1'_ and books-dev refers to '/solr/data/books,0/' . If we stop/start the container, since nothing physically persistent depended on the name, variable substitution (or implicit expansion) can not interfere.\nIf we are using the core name to build data directories, issuing swap is likely to break something...\n\nPlease correct me if I'm deeply misunderstanding something... "
        },
        {
            "author": "Otis Gospodnetic",
            "id": "comment-12571282",
            "date": "2008-02-22T05:55:42+0000",
            "content": "I haven't followed the patches, and I quickly read through the last month's worth of comments here.  One thing that Hoss said caught my attention:\n\n\"...easy way to reuse the same solrconfig.xml for multiple cores and still\nget subtle changes in behavior - all while making it transparent what\nany one solrconfig.xml will do...\"\n\nPlease count this as my +1 for this.\nYes, one use case is that each core is unique and thus needs unique configs, but I also have a concrete use case where all cores are identical as far as the configs go, all that needs to be different is the data directory where the index lives.  In this case, it would be ideal if one could have a single copy of the schema.xml and solrconfig.xml, and specify core-specific settings (e.g. data/index dir) in multicore.xml.\n\nIt would be even better if configs for cores were not all in a single/monolithic file - imagine a situation where you have thousands or even tends of thousands of indices and you add a few hundred or a few thousand new ones every day, throughout the day.  You could certainly regenerate the whole multicore.xml file every time a new index is added, but it would be much more efficient to generate just the descriptor for that single new index that was just created, and tell Solr - \"hey, look here, there is a new core/index you need to be aware of\".  Perhaps one way to deal with this is to expose an API (URL) to send such a \"hey, look here....\" message to Solr, and let Solr periodically write out multicore.xml to disk. "
        },
        {
            "author": "Henri Biestro",
            "id": "comment-12572080",
            "date": "2008-02-25T13:28:07+0000",
            "content": "Otis, reading your requirements, I'd be considering using a Solr core (the \"metacore\") to handle an indexed version of multicore.xml; if you have a few thousands indices, it might be convenient to use queries in some occasions to select/retrieve/operate on one/many of them.\nThe xml version of the multicore persistent file could be written at application/multicore shutdown and the Lucene based one could be recreated at application/multicore startup; creating a new index would just induce creating a new document in the multicore core (and in fact all CRUD operations could be handled that way) and we'd benefit from Solr autocommit feature & al, tackling your functional requirements reusing well-known capabilities & code.\nThis also removes the \"hack\" loop used to find a core to work with when issuing a multicore/admin request (and the getDefaultCore call). Got a patch running for this now if this seems interesting.\n\n\nOn configuring easily the data/index dir from multicore.xml, it seems we all agree that variables definitions should be able to allow just that; the non-extensible version of the feature (see previous comment)- where we dont allow the user to augment the environment but only expose 'solr.multicore.*'- did not trigger any comment yet, Otis/Hoss/Ryan what do you think of it ? "
        },
        {
            "author": "Ryan McKinley",
            "id": "comment-12573101",
            "date": "2008-02-27T23:26:45+0000",
            "content": "Updated patch for /trunk and fixed the dispatcher problem.\n\nI think this is ready to commit \u2013 we can address the variable/config/data issue in a different issue or smaller patches.\n\n\n\nIn reply to Hoss Feb 06\n\na) yes \u2013 each core keeps the <requestDispatcher> settings from solrconfig.xml\n\nb) Creating a SolrRequestparsers is not super lightweight \u2013 it has 3 xpath queires on config, then builds a map and puts 5 things in it.  That seems like a lot to add to every request rather then saving it at the beginning\n\nc) yes - we should open a seperate issue for variables\n\nd) \"abortOnConfigurationError\" should probably be renamed \"abortOnStartupConfigurationError\" \u2013 once the app is running, it does not (nor do i think it should) quit working if something loads incorrectly.\n\nre 1000s of cores\n\nNote that you don't have to use the xml multicore management stuff.  If MultiCore support is enabled before the SolrRequestDispatcher init() method, it will use that directly.  You can load cores from SQL or whereever and put them into the MultiCore registry.  (i am doing just this in one project) "
        },
        {
            "author": "Henri Biestro",
            "id": "comment-12573338",
            "date": "2008-02-28T16:06:53+0000",
            "content": "A new version attempting to make it easier to derive from MultiCore (and associated classes - SolrDispatchFilter, MultiCoreHandler).\nThis breaks the API (MultiCore.getInstance is removed) but a SolrMultiCore class is added to allow a smooth transition.\nSolrDispatchFilter logic has been reworked to reduce the number of 'return;' points and to be more lenient & let other filters handle more things when possible.\nOne caveat, patch does not apply cleanly on MultiCore.java; the .rej is not too complex (now that I'm not in a rush), the beginning of the class def gets rejected. "
        },
        {
            "author": "Henri Biestro",
            "id": "comment-12574122",
            "date": "2008-03-01T16:12:56+0000",
            "content": "Despite many tries, can't get this patch to apply without reject on MultiCore.java - still with the same block to apply manually. This latest version just introduces more comments and 2/3 more methods have been marked protected.\nRyan, I guess that if you dont like this version, you should just commit yours which is in any case a step forward from the current trunk. "
        },
        {
            "author": "Yonik Seeley",
            "id": "comment-12574658",
            "date": "2008-03-03T18:40:45+0000",
            "content": "> I think this is ready to commit - we can address the variable/config/data issue in a different issue or smaller patches.\n+1 "
        },
        {
            "author": "Ryan McKinley",
            "id": "comment-12574839",
            "date": "2008-03-04T04:08:02+0000",
            "content": "Henri \u2013 i just the previous patch.  If you make another smaller one, i'll review and commit quickly.\nThanks for all your work on this! "
        },
        {
            "author": "Henri Biestro",
            "id": "comment-12574982",
            "date": "2008-03-04T13:12:56+0000",
            "content": "Updated patch to current trunk.\n\nRemoves the static singleton from Multicore (& moves it to SolrMulticore), updated classes that depended upon it, makes Multicore/SolrDispatchFilter easily derivable.\nSolrDispatchFilter logic is more lenient and will let the filter chain handle urls that can't be dealt with.\n\nProduced on Ubuntu 7.10 by:\nsvn diff --diff-cmd /usr/bin/diff -x \"-w -B -b -E -d -N -u\" > /tmp/solr-350.patch\nSuccessfully applied with no rejects with:\npatch -u -p 0 < /tmp/solr-350.patch "
        },
        {
            "author": "Henri Biestro",
            "id": "comment-12575369",
            "date": "2008-03-05T14:35:47+0000",
            "content": "simplified the MultiCore singleton handling (aka SolrMultiCore.getInstance is lazily loading) but kept SolrDispatchFilter/MultiCore/MultiCoreHandler derivable. "
        },
        {
            "author": "Shalin Shekhar Mangar",
            "id": "comment-12577346",
            "date": "2008-03-11T09:30:03+0000",
            "content": "Since the MultiCore#getRegistry does not exist anymore after the commit of this patch, a couple of JSPs do not work. \n\nI've changed those JSPs to use SolrMultiCore#getInstance method instead. This patch contains those changes. "
        },
        {
            "author": "Shalin Shekhar Mangar",
            "id": "comment-12577350",
            "date": "2008-03-11T09:38:07+0000",
            "content": "I missed a couple of files when creating the last patch. This contains all the modified JSPs. The svn stat is as follows:\n\nM      src\\webapp\\resources\\index.jsp\nM      src\\webapp\\resources\\admin\\logging.jsp\nM      src\\webapp\\resources\\admin\\raw-schema.jsp\nM      src\\webapp\\resources\\admin\\ping.jsp\nM      src\\webapp\\resources\\admin\\threaddump.jsp\nM      src\\webapp\\resources\\admin\\index.jsp "
        },
        {
            "author": "Walter Ferrara",
            "id": "comment-12577421",
            "date": "2008-03-11T12:16:12+0000",
            "content": "It's been a while since I had a look at this patch, and things seems to have changed a bit meanwhile \u2013 but it looks strange that the only way to access the cores registry inside a solr istance relay on a deprecated class, org.apache.solr.core.SolrMultiCore. I noticed Henri mention that the SolrMultiCore singleton \"is added to allow a smooth transition\", but...\nIf there is no another way to achieve the same result bypassing org.apache.solr.core.SolrMultiCore, that class should not be marked as deprecated. Or that deprecation has to be read as \"in the final solr 1.3 just use SolrMultiCore and ignore the warning, but remember that in the next version, the 2.0, things will change\"? "
        },
        {
            "author": "Henri Biestro",
            "id": "comment-12577434",
            "date": "2008-03-11T13:11:20+0000",
            "content": "Ryan: thanks for the commit.\n\nShalin: thanks a lot for the JSP fix, my bad. Thinking of it, it might be possible to put the Multicore instance as a request attribute from the filter code & let JSP consume it this way rather than using SolrMultiCore. I'll look into it.\n\nWalter: yes, you are correct, things will most likely change in 2.0. We want MultiCore to be derivable and we dont want core core to consider MultiCore to be a singleton; however, we do not feel current needs require the class to be configurable (yet). May be o.a.s.servlet. would be/have been a better package for SolrMultiCore to make this easier. Sorry for the confusion. "
        },
        {
            "author": "Yonik Seeley",
            "id": "comment-12577439",
            "date": "2008-03-11T13:26:13+0000",
            "content": "Thanks Shalin, I just committed your JSP fixes (after converting the patch from UTF-16 to UTF-8  "
        },
        {
            "author": "Ryan McKinley",
            "id": "comment-12581961",
            "date": "2008-03-25T14:35:23+0000",
            "content": "remove SolrMultiCore references from JSP "
        },
        {
            "author": "Erik Hatcher",
            "id": "comment-12581972",
            "date": "2008-03-25T14:53:35+0000",
            "content": "The RemoveStatic patch looks good, Ryan.  +1 "
        },
        {
            "author": "Markus Mautner",
            "id": "comment-12609944",
            "date": "2008-07-02T14:51:01+0000",
            "content": "MultiCore persistence is broken.\n\nmulticore/@sharedLib gets written as multicore/@libDir, so loading the multicore configuration after saving will fail. "
        },
        {
            "author": "Ryan McKinley",
            "id": "comment-12609968",
            "date": "2008-07-02T16:16:16+0000",
            "content": "thanks for finding this Markus!\nfixed in rev 673430 "
        },
        {
            "author": "Ryan McKinley",
            "id": "comment-12614337",
            "date": "2008-07-17T13:53:09+0000",
            "content": "it looks like dataDir option was removed from CoreDescriptor.  Was there a reason for this?  Can multicore.xml manage the data directories?\n\nhttp://wiki.apache.org/solr/MultiCore#head-2696b6ae9766aa312580b5014f6c8f659a2c1bea\n\nI think we should return that configuration. "
        },
        {
            "author": "Henri Biestro",
            "id": "comment-12614422",
            "date": "2008-07-17T16:33:46+0000",
            "content": "Looks like this was removed around 02/Feb/08 from one of your comments  ; the dataDir can be set in solrconfig.xml so configuring it through multicore.xml was considered a dangerous feature.\nAnd I agree we should enhance the configuration behaviors.\n\nSince we are in the functional vicinity, the \"2008-01-23 03:09 AM\"  version of the patch allowed (at least MulitCore.create(...)) the following:\nMake the instanceDir relative to the multicore instanceDir if not absolute\nMake the dataDir relative to the multicore dataDir if not absolute\nJust in case...\n "
        },
        {
            "author": "Henri Biestro",
            "id": "comment-12615311",
            "date": "2008-07-21T17:14:33+0000",
            "content": "This patch (solr-350-properties.patch) implements 'properties' as specified by HossMan. \n\nsee solr-646 "
        }
    ]
}