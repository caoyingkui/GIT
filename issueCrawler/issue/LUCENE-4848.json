{
    "id": "LUCENE-4848",
    "title": "Fix Directory implementations to use NIO2 APIs",
    "details": {
        "components": [],
        "fix_versions": [
            "4.8",
            "6.0"
        ],
        "affect_versions": "6.0",
        "priority": "Minor",
        "labels": "",
        "type": "Task",
        "resolution": "Fixed",
        "status": "Resolved"
    },
    "description": "I have implemented 3 Directory subclasses using NIO2 API's (available on JDK7).  These may be suitable for inclusion in a Lucene contrib module.\n\nSee the mailing list at http://lucene.markmail.org/thread/lrv7miivzmjm3ml5 for more details about this code and the advantages it provides.\n\nThe code is attached as a zip to this issue.  I'll be happy to make any changes requested.  I've included some minimal smoke tests, but any help in how to use the normal Lucene tests to perform more thorough testing would be appreciated.",
    "attachments": {
        "LUCENE-4848.patch": "https://issues.apache.org/jira/secure/attachment/12574354/LUCENE-4848.patch",
        "jdk7directory.zip": "https://issues.apache.org/jira/secure/attachment/12574101/jdk7directory.zip",
        "LUCENE-4848-MMapDirectory.patch": "https://issues.apache.org/jira/secure/attachment/12574344/LUCENE-4848-MMapDirectory.patch",
        "LUCENE-4848.patch.txt": "https://issues.apache.org/jira/secure/attachment/12574537/LUCENE-4848.patch.txt"
    },
    "issue_links": {},
    "comments": [
        {
            "date": "2013-03-18T08:11:06+0000",
            "content": "Hi Michael,\nthank you very much for the directory implementations.\n\nI already thought about that a while before, but I was not aware, that the WindowsFileChannelFactory (http://www.docjar.com/html/api/sun/nio/fs/WindowsChannelFactory.java.html) automatically passes FILE_SHARE_DELETE by default to the windows open syscall. So this is indeed an improvement, because it allows to delete files that are opened like that. I have not yet verified this, but I trust you and will take it under consideration. But be warned: FILE_SHARE_DELETE does not completely emulate delete-after-last-close semantics from POSIX. It looks like the file keeps valid and disappears from the directory, but in contrast to POSIX, you cannot delete the directory the file is in, nor can you create a new file with the same name as the still open, but deleted one. This should not be an issue for Lucene, as it never recreates files with the same name which it keept open before.\n\nAbout your classes in general. The new directory implementation (the Async one), could go into Lucene 5.0, once we moved to Java 7, so this would be a start in the direction on doing the move. We had a discussion on the mailinglist and all committers +1.\n\nAbout the NIOFSDirectory and MMapDirectory: Those are 100% clones of the originals and we dont want to have 100% clones of same classes in Lucene core, so I would restructure them. The good thing here is: The really only change in those clones is the part that opens a FileChannel from a file name. And that involves only 3 calls to Java 7 APIs. My idea was to simply insert that code (using reflection for Lucene 4.x into the original MMapDirectory and NIOFSDirectory) into a helper function for opening (File in, FileChannel out) that creates a RAF on Java 6 and directly allocates FileChannel on Java 7 - Problem solved. Introducting new Java 7 symbols like \"Path\" into Lucene makes no sense at the moment, so its hidden as implementation detail.\n\nI will provide a patch for NIOFS and MMap later.\n\nThanks in any case, this issue brought me to the right track of maybe solving the delete on windows problem - I am still not sure if this really helps and does not break the semantics Lucene expects from the underlying FS. ",
            "author": "Uwe Schindler",
            "id": "comment-13604932"
        },
        {
            "date": "2013-03-18T08:18:29+0000",
            "content": "These may be suitable for inclusion in a Lucene contrib module.\n\nThere are no more cntrib modules and we want all normal modules use the same JDK version, as we had major problems for the release manager to build and test the realease when multiple JDK versions are involved. So this can only go into Lucene 5.0 (which will use Java 7). Parts of if MMap and NIOFS changes may go into Lucene 4, too - as the changes are minimal and could be solved by reflection (see above). ",
            "author": "Uwe Schindler",
            "id": "comment-13604935"
        },
        {
            "date": "2013-03-18T10:01:57+0000",
            "content": "Hi Michael, one request to you:\n\nWould it be possible to create a patch that does not add new classes prefixed with \"JDK7\" (which should be \"Java7\" btw), but instead directly modify the existing classes in Lucene 5 (aka trunk)? Of course the new Async variant would be a new class, but for includion in Lucene 5, a real patch without code duplication would be fine. And please try to keep the \"logic\" changes as minimal as possible in the existing classes.\n\nI am working on MMapDirectory at the moment to make a patch that also works with Lucene 4 using reflection. ",
            "author": "Uwe Schindler",
            "id": "comment-13604972"
        },
        {
            "date": "2013-03-18T10:53:23+0000",
            "content": "No problem, I'll produce a patch against trunk that just changes the existing directory implementations as little as possible.\n\nTwo questions:\n1.)  Since this changes the file writing behavior for NIOFSDirectory and MMapDirectory (writes can now throw a ClosedChannelException if the thread is interrupted, where I believe they couldn't before) should the changes be controllable via a flag?  Or should I just not change how writes are done for these two classes (since it shouldn't be necessary to delete a file while it is open for write, only if it is open read)\n\n2.)  I was using a Path instead of a File internally to represent the directory location.  This is somewhat nice in that it works with the Java 7 pluggable filesystems implementation (i.e. to zip up an index one could just use the zip filesystem provider with a directory and then do a Directory.copyTo).  I assume you want to not add a dependency on using a Path since that would change the return type of FSDirectory.getDirectory()? ",
            "author": "Michael Poindexter",
            "id": "comment-13605005"
        },
        {
            "date": "2013-03-18T11:03:56+0000",
            "content": "About 2: I am fine with using Path. When we are on Java 7, Path is fine to hold the pointer to the directory. Of course FSDirectory could add another ctor, but not replace the File-based ones. I think you current code does the right thing.\n\nAbout writing: I know, you changed the whole FSDirectory base class to use Channel. Maybe keep the base class mostly as it is (with a generic \"descriptor parameter\", that can be a RAF or Channel). I would prefer to make writing for now use the RAF as before, but provide a channel-based impl, too?\n\nAbout 1: The problem with interruptions is a bigger one - we should avoid that any Directory implementation in Lucene is reacting to interruptions and produce failures. We had lots of bug reports (regards a bug in Sun's original implementation, that auto-closed a channel when interrupted). So in general, interrupted file io in lucene should be repeated.\n\nI will now setup Java 7 build for trunk and after short confirmation from the mailing lists, I will move Lucene trunk's build to require Java 7! ",
            "author": "Uwe Schindler",
            "id": "comment-13605015"
        },
        {
            "date": "2013-03-18T11:23:24+0000",
            "content": "OK, I will use Path, and produce 2 IndexInputs, one that uses a RAF (used by default), and another that uses a Channel that share most of their code (I will just do one super class with hooks for every place that depends on the actual \"descriptor parameter\" and two subclasses).\n\nI'll see if there is existing code in 5.x that is calling FSDirectory.getDirectory() that depends on that being a File.  If so, I will not change it to return a Path, but rather introduce a new method getDirectoryPath().\n\nI think it's not a bug that the channel is auto-closed when interrupted, but rather documented behavior (in InterruptibleChannel).  Not trying to nitpick, but just point out that this behavior is unlikely to change in the future since it's how it's intended to work.\n\nWe could pretty easily retry when we get a ClosedByInterruptException, but do you want that to happen as part of this patch or as another issue?  I think maybe that should go in as a separate patch since I think to make it work properly you would have to make FSIndexInput.clone() open a new FileChannel (essentially duplicating the file descriptor per-thread...that way when the descriptor is closed due to an interrupt you only have to worry about reopening that thread's FD, not all threads sharing the same FD). ",
            "author": "Michael Poindexter",
            "id": "comment-13605027"
        },
        {
            "date": "2013-03-18T11:47:48+0000",
            "content": "\nWe could pretty easily retry when we get a ClosedByInterruptException, but do you want that to happen as part of this patch or as another issue?\n\nplease no! ",
            "author": "Robert Muir",
            "id": "comment-13605034"
        },
        {
            "date": "2013-03-18T11:49:48+0000",
            "content": "Same here. In my opinion writing should use RAF as this is most compatible. ",
            "author": "Uwe Schindler",
            "id": "comment-13605037"
        },
        {
            "date": "2013-03-18T11:52:54+0000",
            "content": "I think maybe that should go in as a separate patch since I think to make it work properly you would have to make FSIndexInput.clone() open a new FileChannel (essentially duplicating the file descriptor per-thread...that way when the descriptor is closed due to an interrupt you only have to worry about reopening that thread's FD, not all threads sharing the same FD).\n\nWe cannot do this, as Lucene never closes clones. This would be the grave for file handles! Lucene would eat up all file handles in milliseconds  ",
            "author": "Uwe Schindler",
            "id": "comment-13605038"
        },
        {
            "date": "2013-03-18T12:07:15+0000",
            "content": "That would be bad   I was under the impression that clones were actually closed, but the close method just checked if it was a clone and if so didn't actually do anything.  Thanks for pointing this out.  \n\nIn that case there's really not much that can be done to avoid ClosedByInterruptExceptions.  We have one FD that's shared across threads, the JDK closed it, and it we were to open a new one there's no place to release the resource.  IMO, this would indicate that perhaps clones should in fact be closed, but I don't know enough about why they are not to have a good opinion  ",
            "author": "Michael Poindexter",
            "id": "comment-13605047"
        },
        {
            "date": "2013-03-18T12:12:52+0000",
            "content": "I would be against it myself. It seems users cannot even manage open/close on IndexReader and IndexWriter today. So its too much that they would have to close() scorers, docsenum, and so on.\n\nPersonally i'm not worried about ClosedByInterruptExceptions: just dont interrupt threads doing searches. I'm also not willing to pay the cost of additional file handles if i'm not interrupt()'ing...why should i?\n\nBut to me this is all unrelated to this issue, its been discussed over and over elsewhere and the problem already exists today. ",
            "author": "Robert Muir",
            "id": "comment-13605049"
        },
        {
            "date": "2013-03-18T12:13:25+0000",
            "content": "You see.\n\nSo I wait for a minimal patch! I just want as a first step:\n\n\tminimal changes (no changes at all to SimpleFSDir)\n\tMMapDir changes are the simpliest\n\tNIOFSDir need more changes, because it curretntly relies on FSDir's stupid RAF (Robert Muir already has a patch to not rely on RAF in NIOFSDir already), have to lookup the issue\n\tOnly use Path in the impl details for now -> more changes should be separate!\n\tAdd a separate new class for the fake-ASYNC one\n\n ",
            "author": "Uwe Schindler",
            "id": "comment-13605051"
        },
        {
            "date": "2013-03-19T12:52:53+0000",
            "content": "For demonstartation puposes, I attached the simple patch for MMapDirectory that uses the new StandardOpenMode and FileChannel.open() provided by Java 7. I did not yet really test the deletion of open files on windows, but all tests pass (as they should).\n\nIt would also be interesting if this patch maybe solves the ClosedChannelException problem on interrupt? The time window in MMap is very short that the bug can happen (only after opening the channel, while mmap is doing its work before the channel is closed).\n\nAs you see, the Path API of Java 7 is not yet exposed to the public API. The whole code is still working with java.io.File, only when opening the channel it calls File.toPath(). \n\nMichael Poindexter: We should do the same and no other changes in NIO. Just move away from RAF and use FileChannel. ",
            "author": "Uwe Schindler",
            "id": "comment-13606294"
        },
        {
            "date": "2013-03-19T14:32:09+0000",
            "content": "\nFor demonstartation puposes, I attached the simple patch for MMapDirectory that uses the new StandardOpenMode and FileChannel.open() provided by Java 7. I did not yet really test the deletion of open files on windows, but all tests pass (as they should).\n\nThis patch looks great! ",
            "author": "Robert Muir",
            "id": "comment-13606368"
        },
        {
            "date": "2013-03-19T15:51:13+0000",
            "content": "Thanks for the demonstration Uwe!  It was very helpful as I misunderstood our earlier conversation and was attempting to change the internals of FSDirectory to use Path (instead of File) while keeping the public interface the same (actually, I was done, but waiting for the tests to run before attaching the patch, so your timing was perfect  )\n\nI've attached a patch in the same spirit as your MMapDirectory patch that makes some minor changes to FSDirectory to allow different FSIndexInput and FSIndexOutput subclasses that use different methods of accessing the file (i.e. RandomAccessFile vs. FileChannel).  It updates MMapDirectory, SimpleFSDirectory and NIOFSDirectory to use appropriate subclasses, and adds a new AsyncFSDirectory class. ",
            "author": "Michael Poindexter",
            "id": "comment-13606427"
        },
        {
            "date": "2013-03-19T16:00:19+0000",
            "content": "Thanks for the demonstration Uwe! It was very helpful as I misunderstood our earlier conversation and was attempting to change the internals of FSDirectory to use Path (instead of File) while keeping the public interface the same (actually, I was done, but waiting for the tests to run before attaching the patch, so your timing was perfect )\n\nWe can move to Path later, but before doing that we should get this in as a first step. This issue is unrelated.\n\nI just skimmed your patch, this looks quite good. I have to look closer into it, will report back later. I have seen that you almost completely reused my patch - thanks! But you used try-with-resources to open,mmap,close the channel - nice!\n\nTo run all Lucene+SOLR tests with a specific directory implementation use e.g.: \"ant test -Dtests.directory=MMapDirectory\", otheriwse Lucene uses in most cases RAMDirectory and only rarely other ones. By that you should also be able to test your new directory (it might be needed that you add a hook for instantiating it inside LuceneTestCase where -Dtests.directory is parsed). ",
            "author": "Uwe Schindler",
            "id": "comment-13606439"
        },
        {
            "date": "2013-03-19T16:05:49+0000",
            "content": "One small thing: The protected method FSIndexInput#length() does not need the generic FD, it should be parameterless? The FD is known to the subclass, isnt it? ",
            "author": "Uwe Schindler",
            "id": "comment-13606443"
        },
        {
            "date": "2013-03-19T16:22:43+0000",
            "content": "One small thing: The protected method FSIndexInput#length() does not need the generic FD, it should be parameterless? The FD is known to the subclass, isnt it?\n\n2 reasons not to:\n1.) I think there is already a parameterless length() method that behaves slightly differently.  This length(T) is intended to extract the full length from the file accessor, while length() returns the configured length of the slice.\n2.) It is called from the constructor, so it might be considered bad practice to access member variables since that can be error prone.\n\nIt might be good to rename this to fileLength(T) or something similar. ",
            "author": "Michael Poindexter",
            "id": "comment-13606462"
        },
        {
            "date": "2013-03-19T16:29:15+0000",
            "content": "It would also be interesting if this patch maybe solves the ClosedChannelException problem on interrupt? The time window in MMap is very short that the bug can happen (only after opening the channel, while mmap is doing its work before the channel is closed).\n\nI don't think this will change the behavior much at all.  Before the patch the channel was only open briefly (just long enough to do the map()), and after the change it is the same. ",
            "author": "Michael Poindexter",
            "id": "comment-13606474"
        },
        {
            "date": "2013-03-19T16:30:19+0000",
            "content": "I like this patch, thanks Michael! ",
            "author": "Robert Muir",
            "id": "comment-13606475"
        },
        {
            "date": "2013-03-19T21:34:21+0000",
            "content": "Hi Michael,\n\nyour new Directory does not pass any test:\n\nant test -Dtests.directory=AsyncFSDirectory\n\n\n\nThis fails with crazy errors. One of them is that it complains about zombie threads (the Lucene test framework does not allow that threads not seen before are running after a test has finished). I think it might be caused by some thread created when the executor=null? But this is not the only error, there are more test failures. Just try it out.\n ",
            "author": "Uwe Schindler",
            "id": "comment-13606862"
        },
        {
            "date": "2013-03-19T21:47:58+0000",
            "content": "Here a modified patch with some fixes (still does not pass tests), but:\n\n\n\trenamed the length() method and made it package-protected like the other one that checks FD validity. This method is implementation dependent and should be hidden from public use\n\tmade the new AsyncFSDirectory be used by tests. To fully test it, you still have to pass -Dtests.directory\n\n\n\nThe Channel-based FSIndexOutput is currently unused! ",
            "author": "Uwe Schindler",
            "id": "comment-13606880"
        },
        {
            "date": "2013-03-19T21:55:16+0000",
            "content": "There is one other problem, caused by the 2 new abstract methods in the base class: the check for FS validity is package proetcted and is only used by Lucene tests. If somebody from outside Lucene code wants to implement a custom FSIndexOutput, it is impossible because the package proetcted abstract methods. Previously this was not a problem, as the method had a method body and the compiler was happy.\n\nIn my opinion, we should also remove the fileLength(FD) method and simply require the file size to be passed in ctor. ",
            "author": "Uwe Schindler",
            "id": "comment-13606891"
        },
        {
            "date": "2013-03-19T22:17:13+0000",
            "content": "I'll run the tests tonight with -Dtests.directory for the new directory, I didn't know how to do it before.  I think the threads thing is actually the JRE...if you pass null for the executor it means to use the default system thread pool the JRE creates for IO notifications.  I'm guessing it is lazily created and the test framework detects and flags this.  I'll simply create and use an executor explicitly for the test cases so that there is thread pool that can be cleaned up.\n\nI know the channel based FSIndexOutput is unused.  I can remove it if you'd like, but I wanted to put it in based on our previous conversation simply in case it made sense at some point to use an IndexOuput that did not lock files for delete.\n\nRegarding the 2 new abstract methods in the base class:  I'm fine with making the length be passed in the constructor, which leaves isFDValid().  This was why I had initially made the length method be protected instead of packaged private:  so that subclasses could be created outside of the o.a.l.store package.  I'd like to just change isFDValid() to be protected.  If I do that it will be visible to subclasses and the package, but not publicly available, sound OK? ",
            "author": "Michael Poindexter",
            "id": "comment-13606920"
        },
        {
            "date": "2013-03-20T07:16:53+0000",
            "content": "New version of patch.  Changes:\n\n\tFSIndexInput length moved to constructor and fileLength() method removed\n\tTest harness fixed to account for threads created by JRE causing unit tests to fail.\n\n ",
            "author": "Michael Poindexter",
            "id": "comment-13607354"
        },
        {
            "date": "2013-03-20T07:19:36+0000",
            "content": "I tried to pass a fixed executor to AsyncFSDirectory to solve the test failures, but it seems that the JRE always ends up starting new threads anyway, causing the test suite to fail.  I added some logic to LuceneTestCase to ignore these system created threads, and the tests seem to pass. ",
            "author": "Michael Poindexter",
            "id": "comment-13607357"
        },
        {
            "date": "2013-03-20T10:24:16+0000",
            "content": "Hi Michael, Uwe pinged me about the problem with async background threads. I'll take a look at your patch later today, ok? ",
            "author": "Dawid Weiss",
            "id": "comment-13607476"
        },
        {
            "date": "2013-03-20T10:58:58+0000",
            "content": "Hi Michael,\nin my previous patch I also added the new Directory implementation into the list of FSDirectories to be used randomly while testing (when tests.directory is not given). This is missing in the latest patch. It should simply be added to the list in LuceneTestCase.java:\n\n\n   private static final List<String> FS_DIRECTORIES = Arrays.asList(\n     \"SimpleFSDirectory\",\n     \"NIOFSDirectory\",\n-    \"MMapDirectory\"\n+    \"MMapDirectory\",\n+    \"AsyncFSDirectory\"\n   );\n\n\n\nI was not able to validate the thread exclusion lists, but Dawid will do this. Maybe he has an easier solutions, to me it looks too complicated. ",
            "author": "Uwe Schindler",
            "id": "comment-13607506"
        },
        {
            "date": "2013-03-20T11:03:05+0000",
            "content": "Regarding the 2 new abstract methods in the base class: I'm fine with making the length be passed in the constructor, which leaves isFDValid(). This was why I had initially made the length method be protected instead of packaged private: so that subclasses could be created outside of the o.a.l.store package. I'd like to just change isFDValid() to be protected. If I do that it will be visible to subclasses and the package, but not publicly available, sound OK?\n\nprotected is the wrong access flag. Protected should only be used for methods that should be overridded in subclasses, but never called from outside! I would make the isFDValid() method public to be consistent and mark it as @lucene.internal in javadocs. ",
            "author": "Uwe Schindler",
            "id": "comment-13607507"
        },
        {
            "date": "2013-03-20T11:10:41+0000",
            "content": "I don't agree with Uwe. Please dont make methods like isFDValid() public here! Protected is ok. ",
            "author": "Robert Muir",
            "id": "comment-13607512"
        },
        {
            "date": "2013-03-20T11:16:58+0000",
            "content": "Sorry I disagree. Protected is the wrong access flag, protected is only to be used for methods that are called from the class itsself and not from anywhere else. And it does not hide the method from the javadocs, so it stays \"public\" but with incorrect acess flag. It must be ideally package-private for tests, or @lucene.internal and public (or removed at all).  ",
            "author": "Uwe Schindler",
            "id": "comment-13607515"
        },
        {
            "date": "2013-03-20T11:21:01+0000",
            "content": "\nSorry I disagree. Protected is the wrong access flag, protected is only to be used for methods that are called from the class itsself and not from anywhere else.\n\nApparently the java language specification also disagrees with you  ",
            "author": "Robert Muir",
            "id": "comment-13607518"
        },
        {
            "date": "2013-03-20T11:23:04+0000",
            "content": "Uwe here you can find a description of the access flags:\nhttp://docs.oracle.com/javase/tutorial/java/javaOO/accesscontrol.html ",
            "author": "Robert Muir",
            "id": "comment-13607520"
        },
        {
            "date": "2013-03-20T11:34:15+0000",
            "content": "Robert I know those flags, my complaint was not that its not working or inconsistent. The problem with using protected is that its used in a \"logically inconsistent way\". In common Java usage, methods are made protected if they are implementations to be implemented in subclasses of a general contract that is only called from the (e.g. final) code in the superclass itsself. Protected methods should never-ever called from outside the class. Its just working from the same package, but thats a well-known design issue in Java (there are tons of blogs about that).\n\nThe protected access flag works around the problem we have, thats true, but it makes the method \"public\" (in visibility) and thats my problem. So in any case it must get a @lucene.internal. ",
            "author": "Uwe Schindler",
            "id": "comment-13607526"
        },
        {
            "date": "2013-03-20T11:37:04+0000",
            "content": "\nProtected methods should never-ever called from outside the class. Its just working from the same package, but thats a well-known design issue in Java (there are tons of blogs about that).\n\nI don't agree with that (and could care less about such blogs).\n\n\nSo in any case it must get a @lucene.internal.\n\nYes it should. but it must not be public. ",
            "author": "Robert Muir",
            "id": "comment-13607529"
        },
        {
            "date": "2013-03-20T12:08:49+0000",
            "content": "I digged around, because I dont want to make this method visible at all. I found out:\nThis method is only used from TestCompoundFile and this test only uses SimpleFSDirectory. In my opinion, its completely bogus. To fix the visibility issue:\n\n\tthe isFDValid() method should be package-protected\n\tit should only exist in SimpleFSDirIndexInput, not in the abstract base class\nIf its in the base class every implementor has to implement it just for a stupid test that only works with SimpleFSDir. So this must be fixed. Just move it to SimpleFSDir or maybe we remove this method completely and fix the test.\n\n ",
            "author": "Uwe Schindler",
            "id": "comment-13607538"
        },
        {
            "date": "2013-03-20T12:14:12+0000",
            "content": "Attached is a patch that fixes the visibility issue. The method is just on SimpleFSDir to make TestCompouundDirectory happy.\n\nThe patch still does not pass the test suite because of AsyncFSDir daemon threads. ",
            "author": "Uwe Schindler",
            "id": "comment-13607541"
        },
        {
            "date": "2013-03-20T12:29:14+0000",
            "content": "\nThe patch still does not pass the test suite because of AsyncFSDir daemon threads.\n\nMaybe this new directory should be spun off into a separate issue? Do we have any idea how it performs on different operating systems? Should it be in core lucene? Can we nuke WindowsDirectory? I just want to understand the benefits, because it seems it does an async IO request but then blocks on the future to return back. so this seems no different than sync io to me. Besides, the rest of this patch is plenty for one issue since its the .store API (we need to proceed with caution).\n ",
            "author": "Robert Muir",
            "id": "comment-13607546"
        },
        {
            "date": "2013-03-20T12:43:25+0000",
            "content": "Ok, so indeed background async io threads are a bit of a mess. The system threadpool is not marked with anything that would facilitate its filtering so a stack trace analysis is needed, which this patch does.\n\nI opted not to override the default thread factory because it's never known when this thread factory will be constructed (it may be initialized before LuceneTestCase is instantiated) and, more importantly, I think we shouldn't be messing with the VM we're running on unless we really don't have a choice.\n\nIt should bounce a few jenkins machines to see if we have some leaks on other vendor VMs. ",
            "author": "Dawid Weiss",
            "id": "comment-13607556"
        },
        {
            "date": "2013-03-20T12:49:05+0000",
            "content": "Robert: I agree. I will split the patch and provide one on this thread only with the refactoring done in the already-existing directories.\n\nThe thing with windows was that the RAF-based file channel had the problem of some kind of synchronization internally in Sun's implementation. We should validate with the new and patched NIOFSDirectory if this is still the case with the completely different FileChannel (it is different class, different FileDescriptor-type,...) implementation returned by FileChannel.open(). If this new implementation fixes the old Sun Micrososystems synchronization issues in NIO v1, we can mark NIOFSDirectory working correctly in Windows with Lucene trunk / Java 7 and we are fine. So we need to benchmark this.\n\nI dont really like the AsyncFSDirectory, because it looks like a \"workaround\". If NIOFSDir is now working on windows, we don't need it. ",
            "author": "Uwe Schindler",
            "id": "comment-13607560"
        },
        {
            "date": "2013-03-20T13:07:27+0000",
            "content": "in my previous patch I also added the new Directory implementation into the list of FSDirectories to be used randomly while testing (when tests.directory is not given). This is missing in the latest patch. It should simply be added to the list in LuceneTestCase.java:\n\nI actually removed it on purpose for now.  I wanted the changes to LuceneTestCase to be as uninvasive as possible, so I do some work to poke at the thread pool only if AsyncFSDirectory is selected as test.directory.  Given that, I didn't want for it to be randomly selected.\n\nIf its in the base class every implementor has to implement it just for a stupid test that only works with SimpleFSDir. So this must be fixed. Just move it to SimpleFSDir or maybe we remove this method completely and fix the test.\n\nSounds good to me!\n\nMaybe this new directory should be spun off into a separate issue? Do we have any idea how it performs on different operating systems? Should it be in core lucene? Can we nuke WindowsDirectory? I just want to understand the benefits, because it seems it does an async IO request but then blocks on the future to return back. so this seems no different than sync io to me. Besides, the rest of this patch is plenty for one issue since its the .store API (we need to proceed with caution).\n\nYou are right, it is no different than sync IO in the end.  It's really only useful on Windows where it will use IO completion ports which means there is no need to synchronize on the file position (like java does for FileChannel, or Lucene does internally for SimpleFSDirectory).  On at least Linux/BSD/Mac the Sun JDK will just do what basically FileChannel does anyway and incur the additional overhead of notifying a future, so it's unlikely to be useful there unless one is highly concerned about the Thread.interrupt thing.\n\nIf you want to spin it off I'm fine with that, it's no problem for me to split the patch, let me know if everyone thinks that's a good idea. \n\nI opted not to override the default thread factory because it's never known when this thread factory will be constructed (it may be initialized before LuceneTestCase is instantiated) and, more importantly, I think we shouldn't be messing with the VM we're running on unless we really don't have a choice.\n\nI agree!  If there is a better way I am all ears.  I couldn't find any other way to mark the threads as ignorable (the Sun JRE at least doesn't name them in any useful way, and they have no property that could be looked up).  We can't even figure out from looking at their stacks where they come from since they are just from a generic Executor.\n\nI think as gross as it is it should be fairly safe to set the default thread factory in LuceneTestCase.  It should work across different vendor VM's since it is documented as part of the public Java API (see http://docs.oracle.com/javase/7/docs/api/java/nio/channels/AsynchronousChannelGroup.html).  You are right that it could have been initialized before LuceneTestCase is run, but I think that's not a problem.  The two cases here are:\n1.) Someone already did asynch io causing the pool to be created before LuceneTestCase.  The tests should pass since the threads exist beforehand.\n2.) Nobody has done async io yet in our VM (the likely case).  We'll create the threads using a special name that says to ignore them.\n ",
            "author": "Michael Poindexter",
            "id": "comment-13607577"
        },
        {
            "date": "2013-03-20T13:08:55+0000",
            "content": "Here is the simpliest patch, fixing the current directory implementations to use the new FileChannels. No other changes at all.\n\nWe should benchmark the \"fixed\" NIOFSDirectory on windows to check, if the locking issues still exist.\n\nIf we want to add AsyncFSDirectory again, we should do this only next to WindowsDirectory in the misc module.\n\nI will now test this patch and plan to commit it as a first step. ",
            "author": "Uwe Schindler",
            "id": "comment-13607579"
        },
        {
            "date": "2013-03-20T13:15:12+0000",
            "content": "I opted not to override the default thread factory because it's never known when this thread factory will be constructed (it may be initialized before LuceneTestCase is instantiated) and, more importantly, I think we shouldn't be messing with the VM we're running on unless we really don't have a choice.\n\nI looked at the patch you uploaded Dawid, and I think it will only work on Windows.  That IOCP class is only used on that platform.  On *nix platforms there's really nothing in the stack that can distinguish these threads...hence the ThreadFactory  ",
            "author": "Michael Poindexter",
            "id": "comment-13607582"
        },
        {
            "date": "2013-03-20T13:17:50+0000",
            "content": "We can't even figure out from looking at their stacks where they come from since they are just from a generic Executor.\n\nI think we can safely ignore those that spin inside the internal loop \u2013 see my patch. I know the sysprop is documented in the contract but if we don't have to I'd rather not substitute the defaults. This has an additional benefit that we'll see how other vendors implement these \n\nI'm not saying your patch was wrong or anything, I'm just opting for \"ignoring\" instead of \"manipulating to work\" strategy. \n\nSomeone already did asynch io causing the pool to be created before LuceneTestCase. The tests should pass since the threads exist beforehand.\n\nThis depends on which threadpool is actually used for the default. By default (from what I can see in JDK code) these threads are not eagerly allocated so it'd still result in thread leaks because there would be more threads upon leaving the test case than there were when it was started. Like I said, it's not the main reason I would like to keep it defensive and filter rather than substitute the default factory.\n\nDawid ",
            "author": "Dawid Weiss",
            "id": "comment-13607585"
        },
        {
            "date": "2013-03-20T13:19:58+0000",
            "content": "Can you post a stack trace from linux, for example? I'm on windows right now. If it's a thread pool those workers need to be idle somewhere, right? ",
            "author": "Dawid Weiss",
            "id": "comment-13607587"
        },
        {
            "date": "2013-03-20T13:21:06+0000",
            "content": "We should move the AsyncFSDirectory issue to a separate issue. Robert and I only want to get the fixes for the already existing directories into the core. The other stuff should be a new issue. I hope that makes not too much work. I already uploaded a new patch, with only fixing the existing directories. ",
            "author": "Uwe Schindler",
            "id": "comment-13607589"
        },
        {
            "date": "2013-03-20T13:22:45+0000",
            "content": "Oh, one more thing \u2013 I debated a bit about whether we could just make the \"default\" executor inside asyncdirectory not the system-default one. Then the problem of detecting these would pretty much go away because we could use whatever the hell we wanted.\n\nThe downside is that we'd have to mimic what the std library does anyway. ",
            "author": "Dawid Weiss",
            "id": "comment-13607593"
        },
        {
            "date": "2013-03-20T13:24:22+0000",
            "content": "We should benchmark the \"fixed\" NIOFSDirectory on windows to check, if the locking issues still exist.\n\nIm fairly certain they will since it's basically a Windows API issue.  In the Windows API one there is no call to read at a given position without doing a seek unless you are doing overlapped IO (hence asynchronous).  Since there's only one FD shared across threads with the NIOFSDirectory it will have to synchronize on it.  The bug mentioned in the NIOFSDirectory javadoc actually suggests to use the AsynchronousFileChannel on Windows to work around the internal synchronization issue \n\nIf we want to add AsyncFSDirectory again, we should do this only next to WindowsDirectory in the misc module.\n\nDoesn't matter to me where it lives. ",
            "author": "Michael Poindexter",
            "id": "comment-13607595"
        },
        {
            "date": "2013-03-20T13:29:15+0000",
            "content": "Can you post a stack trace from linux, for example? I'm on windows right now. If it's a thread pool those workers need to be idle somewhere, right?\n\nHere's a stack from a Mac.  There's really nothing to distinguish it from any other thread pool.\n\n\"LUCENETESTIGNORED\" daemon prio=5 tid=0x00007f95bccfd000 nid=0x5503 waiting on condition [0x0000000113a10000]\n   java.lang.Thread.State: TIMED_WAITING (parking)\n\tat sun.misc.Unsafe.park(Native Method)\n\n\tparking to wait for  <0x00000007e8da1468> (a java.util.concurrent.SynchronousQueue$TransferStack)\n\tat java.util.concurrent.locks.LockSupport.parkNanos(LockSupport.java:226)\n\tat java.util.concurrent.SynchronousQueue$TransferStack.awaitFulfill(SynchronousQueue.java:460)\n\tat java.util.concurrent.SynchronousQueue$TransferStack.transfer(SynchronousQueue.java:359)\n\tat java.util.concurrent.SynchronousQueue.poll(SynchronousQueue.java:942)\n\tat java.util.concurrent.ThreadPoolExecutor.getTask(ThreadPoolExecutor.java:1043)\n\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1103)\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:603)\n\tat java.lang.Thread.run(Thread.java:722)\n\n\n\nOh, one more thing \u2013 I debated a bit about whether we could just make the \"default\" executor inside asyncdirectory not the system-default one. Then the problem of detecting these would pretty much go away because we could use whatever the hell we wanted.\n\nYes, this was actually my first approach.  At least on Mac the JRE creates some threads for it's own use in spite of this. ",
            "author": "Michael Poindexter",
            "id": "comment-13607600"
        },
        {
            "date": "2013-03-20T13:33:27+0000",
            "content": "Have you looked at WindowsDirectory.cpp in the \"misc\" module? It does overlapped IO but still in sync. ",
            "author": "Uwe Schindler",
            "id": "comment-13607603"
        },
        {
            "date": "2013-03-20T13:35:51+0000",
            "content": "Yep, ok I get you. They are all daemon threads, so we could just ignore these. But there were a good few cases when daemon threads were forked that led to discovering odd causes so I'd rather keep those.\n\nSeems like there's no other way indeed. I still have a suggestion of keeping the static initializer but moving the common code to that \"quick patch\" class to keep it in a single location. You can also detect those threads by returning a thread class that implements some internal interface, doesn't have to be by-name (and I'd actually name them legibly: \"asyncio-%d\" or something).  ",
            "author": "Dawid Weiss",
            "id": "comment-13607604"
        },
        {
            "date": "2013-03-20T13:41:54+0000",
            "content": "Have you looked at WindowsDirectory.cpp in the \"misc\" module? It does overlapped IO but still in sync.\n\nYep, I looked at it.  I don't know about anyone else, but I strongly prefer not to use native code if I can help it (makes deployment more of a pain since you need the right binary for your architecture, possibility of native resource leaks that are hard to debug).  If there exists a Java API I'd much rather use that. ",
            "author": "Michael Poindexter",
            "id": "comment-13607609"
        },
        {
            "date": "2013-03-20T13:44:58+0000",
            "content": "Seems like there's no other way indeed. I still have a suggestion of keeping the static initializer but moving the common code to that \"quick patch\" class to keep it in a single location. You can also detect those threads by returning a thread class that implements some internal interface, doesn't have to be by-name (and I'd actually name them legibly: \"asyncio-%d\" or something). \n\nOK, will do it this way.  I thought it was more clear to name it separately since the \"quick patch\" thing implied that it was some sort of temporary fix.  Since Uwe and Robert want to split this issue I'll do it in a patch on that issue when it gets created.  Thanks for looking at this! ",
            "author": "Michael Poindexter",
            "id": "comment-13607611"
        },
        {
            "date": "2013-03-20T13:47:22+0000",
            "content": "\nYep, I looked at it. I don't know about anyone else, but I strongly prefer not to use native code if I can help it (makes deployment more of a pain since you need the right binary for your architecture, possibility of native resource leaks that are hard to debug). If there exists a Java API I'd much rather use that.\n\nExactly: thats why if this AsyncDirectory that waits doesn't have too much overhead, it would be a nice replacement for that jni crap.\n\nBut we can probably get all of this in lucene faster if we break the issue up a little bit  ",
            "author": "Robert Muir",
            "id": "comment-13607612"
        },
        {
            "date": "2013-03-20T13:54:57+0000",
            "content": "As Robert said: I uploaded the minimal patch with everything except AsyncFSDir. We should just check on this issue, it it is ok and create a new issue named \"AsyncFSDir\" that only handles the daemon threads and discusses the directory implementation. ",
            "author": "Uwe Schindler",
            "id": "comment-13607619"
        },
        {
            "date": "2013-03-20T14:11:27+0000",
            "content": "After reviewing the patch, my main concern is the generics on FSIndexInput.\n\nThis thing really buys us very little... and adding a generic parameter makes it not worth the trouble IMO.\nSo maybe we should just nuke this thing completely and let NIO and SimpleFS just be their own thing.\n\n(I caused the current situation, but i at least argue its an improvement over NIOFS extends SimpleFS, which is how it was before). ",
            "author": "Robert Muir",
            "id": "comment-13607632"
        },
        {
            "date": "2013-03-20T14:36:32+0000",
            "content": "So maybe we should just nuke this thing completely and let NIO and SimpleFS just be their own thing.\n\nI had the same idea, let's do this! Its easy to do. The abstract FSIndexInput just adds some close and filesize stuff that could leave in each class. The generics also have a backside: a CAST on every access. I know newer JVMs are optimizing that away, but its bad ptractice on inner loops (like synthetic accessor methods caused by private inner classes). ",
            "author": "Uwe Schindler",
            "id": "comment-13607652"
        },
        {
            "date": "2013-03-20T17:15:30+0000",
            "content": "New version of patch:\n-Doesn't include AsyncFSDirectory\n-Removes FSIndexInput and instead NIOFSDirectory and SimpleFSDirectory both have direct subclasses of BufferedIndexInput\n-Doesn't use a generic for the FSIndexOutput.  I still use a subclass to supply a concrete implementation.\n-Doesn't change anything in the test framework ",
            "author": "Michael Poindexter",
            "id": "comment-13607873"
        },
        {
            "date": "2013-03-20T18:30:31+0000",
            "content": "Your patch again introduces code I already removed (the channel based indexoutput was removed, too, also the useess abstract base class)! Have you looked at my patch and used it as basis? If we want a channel based-IndexOutput then it has nothing to do with the base class, should be in e.g. NIOFSIndexOutput. This is also a separate issue.\n\nI will now upload a patch again! When you make further changes, please always use the latest oatch with a clean checkout! ",
            "author": "Uwe Schindler",
            "id": "comment-13607969"
        },
        {
            "date": "2013-03-20T18:37:10+0000",
            "content": "Patch restoring the state and splitting the IndexInputs of SimpleFS and NIOFS. ",
            "author": "Uwe Schindler",
            "id": "comment-13607980"
        },
        {
            "date": "2013-03-20T18:41:28+0000",
            "content": "I did use your patch as a basis.  The latest version of my patch removes the channel based indexoutput, but I kept the base class split (but changed it to not use generics).  As the code is (without a base class for FSIndexOutput) there is no possibility to use any alternate implementation of FSIndexOutput in a subclass that does not use a RandomAccessFile.  The AsyncFSDirectory was using an alternate output so I wanted to preserve its ability to do that.  Sorry if I should not have done that. ",
            "author": "Michael Poindexter",
            "id": "comment-13607985"
        },
        {
            "date": "2013-03-20T19:04:44+0000",
            "content": "AsyncFSDirectory does not need an async output. In Lucene we are fine to use RandomAccessFile to write as this is never done from several thraeds. Writing an index is always a sequential operation, theoretically an OutputStream would be enough (but we still have to seek sometimes, so this is not completely true). So a channel based FSIndexOutput is not needed, we can stick with the one that already exists. And because of this I removed the split.\n\nI opened a new issue for AsyncFS: LUCENE-4864 ",
            "author": "Uwe Schindler",
            "id": "comment-13608021"
        },
        {
            "date": "2013-03-20T19:06:38+0000",
            "content": "As the code is (without a base class for FSIndexOutput) there is no possibility to use any alternate implementation of FSIndexOutput in a subclass that does not use a RandomAccessFile\n\nIf you want one (but you don't, see above), just extend BufferedIndexOutput. This is the same problem like a not really needed base class for NIO/Simple. ",
            "author": "Uwe Schindler",
            "id": "comment-13608027"
        },
        {
            "date": "2013-03-20T19:14:25+0000",
            "content": "AsyncFSDirectory does not need an async output. In Lucene we are fine to use RandomAccessFile to write as this is never done from several thraeds. Writing an index is always a sequential operation, theoretically an OutputStream would be enough (but we still have to seek sometimes, so this is not completely true). So a channel based FSIndexOutput is not needed, we can stick with the one that already exists. And because of this I removed the split.\n\nFair enough.  I was trying to preserve the ability for AsyncFSOutput to write to a Path in the future (and for Path based access there is not necessarily a File on disk to open a RAF from...it could be a zip filesystem for example).  Unfortunately you can't just extend BufferedIndexOutput if you wanted to do this.  There's a hook in the close() method of FSIndexOutput that calls parent.onIndexOutputClosed(this).  onIndexOutputClosed only accepts a FSIndexOutput, not a BufferedIndexOutput.\n\nIt really doesn't matter I guess, but I think to allow for extenders the subclassable FSIndexOutut would be nice. ",
            "author": "Michael Poindexter",
            "id": "comment-13608041"
        },
        {
            "date": "2013-03-21T09:44:47+0000",
            "content": "There's a hook in the close() method of FSIndexOutput that calls parent.onIndexOutputClosed(this). onIndexOutputClosed only accepts a FSIndexOutput, not a BufferedIndexOutput.\n\nThis is not optimal, I would like to change this. I have no idea for which reason this was added. FSDirectory should only expect a IndexOutput subclass and not add magic here. We can fix this in the future, but thats also a separate issue. So I would like to keep FSIndexOutput unchanged. I think the callback with onIndexOutputClosed is also for testing purposes, I will review the backgrounds.\n\nI would like to commt the latest patch I upped and then upload a new patch with your AsyncFS (again, only the IndexInput part) to the new issue. ",
            "author": "Uwe Schindler",
            "id": "comment-13608790"
        },
        {
            "date": "2013-03-21T10:05:04+0000",
            "content": "The attached patch fixes the problem with stale files. The protected method should not take FSIndexOutput (this especially adds a synthetic accessor method). Instead onClosedIndexOutput simply gets the file name. I also added documentation.\n\nYou can now add your own BufferedIndexOutput subclass (e.g. in NIOFSDir based on channels) and just have to take care on calling the protected method (which I dont really like..., it may cause bugs if you dont take care of that - I would like to have some automatism).\n\nI think the new patch is ready. ",
            "author": "Uwe Schindler",
            "id": "comment-13608804"
        },
        {
            "date": "2013-03-21T10:15:23+0000",
            "content": "The previous patch had wrong isClone in NIOFS. ",
            "author": "Uwe Schindler",
            "id": "comment-13608807"
        },
        {
            "date": "2013-03-21T18:11:00+0000",
            "content": "I finally did some tests before committing:\n\n\tIt is possible with NIOFSDirectory to open an IndexReader and after that remove all files in Windows. The IndexReader is still working as it should. This mimics POSIX behaviour, so Lucene can get rid of files earlier when NIOFS is used.\n\tWith MMapDirectory, the file channel also has delete allowed, but the windows documentation explicitly says: http://msdn.microsoft.com/en-us/library/aa363915%28v=VS.85%29.aspx that mmapped files cannot be deleted (the documentation is a bit unclear, but the \"OR\" states both possibilities):\n\n\n\n\nThe DeleteFile function fails if an application attempts to delete a file that has other handles open for normal I/O or as a memory-mapped file (FILE_SHARE_DELETE must have been specified when other handles were opened).\nThe DeleteFile function marks a file for deletion on close. Therefore, the file deletion does not occur until the last handle to the file is closed. Subsequent calls to CreateFile to open the file fail with ERROR_ACCESS_DENIED.\n\nI will commit this now. ",
            "author": "Uwe Schindler",
            "id": "comment-13609242"
        },
        {
            "date": "2013-03-21T18:25:56+0000",
            "content": "Thanks Michael! Let's move on to AsyncFSDirectory ",
            "author": "Uwe Schindler",
            "id": "comment-13609264"
        },
        {
            "date": "2013-03-21T18:35:19+0000",
            "content": "[trunk commit] Uwe Schindler\nhttp://svn.apache.org/viewvc?view=revision&revision=1459437\n\nLUCENE-4848: Use Java 7 NIO2-FileChannel instead of RandomAccessFile for NIOFSDirectory and MMapDirectory ",
            "author": "Commit Tag Bot",
            "id": "comment-13609282"
        }
    ]
}