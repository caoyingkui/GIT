{
    "id": "LUCENE-6656",
    "title": "StandardTokenizer.close() can leave the object in an uncloseable state",
    "details": {
        "resolution": "Unresolved",
        "affect_versions": "4.10.4,                                            5.1",
        "components": [],
        "labels": "",
        "fix_versions": [],
        "priority": "Major",
        "status": "Open",
        "type": "Bug"
    },
    "description": "The following pair of tests shows that if a reader throws IOException from the close() method, StandardTokenizer is left in an inconsistent state where it thinks you didn't call close on the tokeniser, even though you did. To make matters worse, it holds onto the reader so that any subsequent attempts to close the tokeniser will also fail.\n\nPossible workarounds:\n  1. Don't reuse tokenisers.\n  2. Still reuse tokenisers, but if close() throws anything, discard that tokeniser and create a new one.\n  3. Wrap every reader you pass in to ensure that close() can't throw an exception.\n\nCode follows:\n\n\npublic class TestStandardTokenizerCloseIssue {\n    @Test\n    public void testStreamReuse() throws Exception\n    {\n        // Attempts to verify that consumeAndClose itself is not broken.\n        try (Tokenizer stream = new StandardTokenizer())\n        {\n            stream.setReader(new StringReader(\"reader #1\"));\n            assertThat(consumeAndClose(stream), contains(\"reader\", \"1\"));\n\n            stream.setReader(new StringReader(\"reader 2\"));\n            assertThat(consumeAndClose(stream), contains(\"reader\", \"2\"));\n        }\n    }\n\n    @Test\n    public void testStreamReuseAfterFailure() throws Exception {\n        class FailingReader extends Reader {\n            @Override\n            public int read(@NotNull char[] buffer, int off, int len)\n                    throws IOException {\n                throw new IOException(\"Synthetic exception\");\n            }\n\n            @Override\n            public void close() throws IOException {\n                throw new IOException(\"Synthetic exception\");\n            }\n        }\n\n        // Simulating sharing the instance inside some factory.\n        try (Tokenizer stream = new StandardTokenizer()) {\n\n            try {\n                stream.setReader(new FailingReader());\n                consumeAndClose(stream);\n                fail(\"Expected IOException\");\n            } catch (IOException e) {\n                // Expected\n            }\n\n            stream.setReader(new StringReader(\"working reader\"));\n\n            // Test fails here - even though the consumeAndClose above\n            // did close the tokeniser, the tokeniser didn't clear its reference to\n            // the reader.\n            assertThat(consumeAndClose(stream), contains(\"working\", \"reader\"));\n        }\n    }\n\n    // Attempts to implement the correct workflow for consuming a\n    // TokenStream.\n    private List<String> consumeAndClose(TokenStream stream)\n            throws Exception {\n        ImmutableList.Builder<String> tokens = ImmutableList.builder();\n\n        //The consumer calls reset().\n        stream.reset();\n        try {\n            // The consumer retrieves attributes from the stream and stores\n            // local references to all attributes it wants to access.\n            CharTermAttribute termAttribute =\n                stream.getAttribute(CharTermAttribute.class);\n            // The consumer calls incrementToken() until it returns false\n            // consuming the attributes after each call.\n            while (stream.incrementToken()) {\n                tokens.add(termAttribute.toString());\n            }\n            // The consumer calls end() so that any end-of-stream operations\n            // can be performed.\n            stream.end();\n        } finally {\n            // The consumer calls close() to release any resource when finished\n            // using the TokenStream.\n            stream.close();\n        }\n\n        return tokens.build();\n    }\n}\n\n\n\nOriginally discovered on 4.10.4. Code has been ported to work on 5.1 since initially created and sooner or later I'll get to test 5.2.1, but I don't see anyone else having reported a similar issue yet, so I'm guessing it won't be fixed yet.",
    "attachments": {},
    "issue_links": {},
    "comments": []
}