{
    "id": "LUCENE-5168",
    "title": "ByteSliceReader assert trips with 32-bit oracle 1.7.0_25 + G1GC",
    "details": {
        "components": [],
        "fix_versions": [],
        "affect_versions": "None",
        "priority": "Major",
        "labels": "",
        "type": "Bug",
        "resolution": "Fixed",
        "status": "Resolved"
    },
    "description": "This assertion trips (sometimes from different tests), if you run the highlighting tests on branch_4x with r1512807.\n\nIt reproduces about half the time, always only with 32bit + G1GC (other combinations do not seem to trip it, i didnt try looping or anything really though).\n\n\nrmuir@beast:~/workspace/branch_4x$ svn up -r 1512807\nrmuir@beast:~/workspace/branch_4x$ ant clean\nrmuir@beast:~/workspace/branch_4x$ rm -rf .caches #this is important,\notherwise master seed does not work!\nrmuir@beast:~/workspace/branch_4x/lucene/highlighter$ ant test\n-Dtests.jvms=2 -Dtests.seed=EBBFA6F4E80A7365 -Dargs=\"-server\n-XX:+UseG1GC\"\n\n\n\nOriginally showed up like this:\n\nBuild: http://jenkins.thetaphi.de/job/Lucene-Solr-4.x-Linux/6874/\nJava: 32bit/jdk1.7.0_25 -server -XX:+UseG1GC\n\n1 tests failed.\nREGRESSION:  org.apache.lucene.search.postingshighlight.TestPostingsHighlighter.testUserFailedToIndexOffsets\n\nError Message:\n\n\nStack Trace:\njava.lang.AssertionError\n        at __randomizedtesting.SeedInfo.seed([EBBFA6F4E80A7365:1FBF811885F2D611]:0)\n        at org.apache.lucene.index.ByteSliceReader.readByte(ByteSliceReader.java:73)\n        at org.apache.lucene.store.DataInput.readVInt(DataInput.java:108)\n        at org.apache.lucene.index.FreqProxTermsWriterPerField.flush(FreqProxTermsWriterPerField.java:453)\n        at org.apache.lucene.index.FreqProxTermsWriter.flush(FreqProxTermsWriter.java:85)\n        at org.apache.lucene.index.TermsHash.flush(TermsHash.java:116)\n        at org.apache.lucene.index.DocInverter.flush(DocInverter.java:53)\n        at org.apache.lucene.index.DocFieldProcessor.flush(DocFieldProcessor.java:81)\n        at org.apache.lucene.index.DocumentsWriterPerThread.flush(DocumentsWriterPerThread.java:501)",
    "attachments": {
        "log.0086": "https://issues.apache.org/jira/secure/attachment/12598385/log.0086",
        "java8-windows-4x-3075-console.txt": "https://issues.apache.org/jira/secure/attachment/12597976/java8-windows-4x-3075-console.txt",
        "log.0025": "https://issues.apache.org/jira/secure/attachment/12598382/log.0025",
        "log.0100": "https://issues.apache.org/jira/secure/attachment/12598386/log.0100",
        "log.0042": "https://issues.apache.org/jira/secure/attachment/12598383/log.0042",
        "log.0078": "https://issues.apache.org/jira/secure/attachment/12598384/log.0078"
    },
    "issue_links": {},
    "comments": [
        {
            "date": "2013-08-12T20:37:55+0000",
            "content": "I also cannot make this fail if I add -Xint or -Xbatch ",
            "author": "Robert Muir",
            "id": "comment-13737314"
        },
        {
            "date": "2013-08-13T06:34:35+0000",
            "content": "Very likely a compiler bug. It'd be best to run with tests.jvms=1, pass -XX:+PrintCompilation -XX:+PrintAssembly (requires hsdis) and capture two logs \u2013 one for a failing run and one for a passing run. Then it's all about inspecting the assembly output via diff \u2013 this would narrow down the scope of looking for the faulty jit optimization. Can't do it today but if anybody beats me to it I'm interested in what you can find out!  ",
            "author": "Dawid Weiss",
            "id": "comment-13737898"
        },
        {
            "date": "2013-08-14T06:28:01+0000",
            "content": "I've sent an e-mail to hotspot dev asking for some guidance in how we can try to provide more insight to them. We'll see what they say. ",
            "author": "Dawid Weiss",
            "id": "comment-13739284"
        },
        {
            "date": "2013-08-14T13:54:22+0000",
            "content": "I can reproduce this occasionally on Windows (32 bit JVM). I'm trying to find a more repeatable and simpler test sequence than two JVMs. Will report my findings if I have anything to share. ",
            "author": "Dawid Weiss",
            "id": "comment-13739678"
        },
        {
            "date": "2013-08-14T14:14:16+0000",
            "content": "Uploading the failure from jenkins last night (java8/windows, in TestFSTs, but same ByteSliceReader assert).\n\nIt looks like that one may have only one jvm but a very long path of tests, so I'm not sure its easier... but I didnt want to lose the jenkins log in case we need it. ",
            "author": "Robert Muir",
            "id": "comment-13739696"
        },
        {
            "date": "2013-08-14T14:20:39+0000",
            "content": "I'm gonna add my own paranoid theory here, there is no factual basis behind it:\n\nMaybe the bug is miscompilation of DataInput.readVInt() triggered recently by things like randomizing NIOFS buffer size (LUCENE-5161) or something like that.\n\nWe had jvms like 1.7.0_25 running in jenkins all summer long and just after we commit those test changes this weekend this has happened twice out of nowhere.\nAlso, there has just been jvm bug after jvm bug affecting this method before: I am not sure if its really safe to encode variable length integers in the java programming language  ",
            "author": "Robert Muir",
            "id": "comment-13739701"
        },
        {
            "date": "2013-08-14T18:26:46+0000",
            "content": "I have ran highlighter tests a 1000 times, each time with a different seed and not using caches (to keep the suite ordering constant).\n\nThe tests failed only once but this seed reproduces nearly always (passed once in 24 runs on my machine).\n\nant test -Dtests.seed=74EC023C3CFBCA38 -Dtests.jvms=1 -Dtests.dynamicAssignmentRatio=0 -Dargs=\"-server -XX:+UseG1GC\"\n\n\n\nInterestingly, different actual tests fail, but they nearly always do. I have something to work with now. ",
            "author": "Dawid Weiss",
            "id": "comment-13740008"
        },
        {
            "date": "2013-08-14T20:02:09+0000",
            "content": "I get identical assembly for ByteSliceReader.readByte for a test that passes and for the one that doesn't. Odd. I also changed the assertion to read:\n\nassert !eof() : \"Foo? \" + (upto + bufferOffset) + \" == \" +endIndex;\n\n\n\nand for the failed run I indeed get:\n\n Throwable #1: java.lang.AssertionError: Foo? 233 == 233\n\n\n\nMaybe there's something that affects the Java side of this (and it's not a JVM bug, only unpredictable/ concurrency-sensitive test?) I'll continue looking tomorrow. ",
            "author": "Dawid Weiss",
            "id": "comment-13740108"
        },
        {
            "date": "2013-08-14T20:04:31+0000",
            "content": "Hmm... from a quick look it does look like it's trying to read a vint past eof... ",
            "author": "Dawid Weiss",
            "id": "comment-13740111"
        },
        {
            "date": "2013-08-15T04:00:09+0000",
            "content": "\nMaybe there's something that affects the Java side of this (and it's not a JVM bug, only unpredictable/ concurrency-sensitive test?) I'll continue looking tomorrow.\n\nThere isnt anything concurrency sensitive about the tests failing here.\n\nThese tests such as TestPostingsHighlighter.testUserFailedToIndexOffsets that are failing are very very simple and index one or two documents with static content. They are not unpredictable, there is no concurrency.\n\nThe fact that different tests are failing each time with the same master seed depending on when compilation/gc happens and that it only fails with -XX+UseG1GC on 32-bit without -Xint or -Xbatch makes it crystal clear its a jvm bug. ",
            "author": "Robert Muir",
            "id": "comment-13740651"
        },
        {
            "date": "2013-08-15T04:33:34+0000",
            "content": "It seems to be enough to just exclude this one method to prevent this from tripping: \n\n-XX:CompileCommand=exclude,org/apache/lucene/index/ByteSliceReader,nextSlice ",
            "author": "Robert Muir",
            "id": "comment-13740667"
        },
        {
            "date": "2013-08-15T09:21:13+0000",
            "content": "Yeah, I agree. It isn't a trivial single-method issue though. nextSlice is indeed the problem, but it's inlined heavily in a number of places (and probably optimized wherever it's inlined). I've experimented with the following:\n\n\t\"-XX:-Inline\" - no errors\n\texcluding the \"parent\" method from compilation (which seems to be the root of the problem): org/apache/lucene/index/FreqProxTermsWriterPerField,flush - no errors\n\t\"-XX:-DoEscapeAnalysis\" - preventing escape analysis - no errors\n\tenforcing value flush in ByteSliceReader.nextSlice by modifying:\n\nbuffer  = pool.buffers[bufferUpto];\nupto = nextIndex & ByteBlockPool.BYTE_BLOCK_MASK;\n\n\nto\n\nbuffer  = pool.buffers[bufferUpto];\nfoo = upto = nextIndex & ByteBlockPool.BYTE_BLOCK_MASK;\n\n\nwhere foo is defined as a static field with no other accesses:\n\nstatic int foo;\n\n\nThis also results in no errors.\n\n\n\nI also dumped the generated assembly for the flush() method (you have to dump the parent method because of the inlines) but it's huge and, sigh, it's sometimes different even for two runs with identical options. I'm guessing parallel compilation tasks hit different stats and hence the difference. ",
            "author": "Dawid Weiss",
            "id": "comment-13740829"
        },
        {
            "date": "2013-08-15T09:34:22+0000",
            "content": "I am glad it is not DataInput#readVInt()  ",
            "author": "Uwe Schindler",
            "id": "comment-13740832"
        },
        {
            "date": "2013-08-15T09:48:04+0000",
            "content": "Don't be so sure.  FreqProxTermsWriterPerField::flush inlines half of the world (and is compiled multiple times, in fact). readVInt is in fact inlined there (but it doesn't seem to be the root of the problem to me).\n\n   8206 1158             org.apache.lucene.index.FreqProxTermsWriterPerField::flush (1207 bytes)\n                            @ 4   org.apache.lucene.index.FieldInfo::isIndexed (5 bytes)   inline (hot)\n                            @ 16   org.apache.lucene.codecs.perfield.PerFieldPostingsFormat$FieldsWriter::addField (327 bytes)   too big\n                            @ 16   org.apache.lucene.codecs.BlockTreeTermsWriter::addField (53 bytes)   too big\n                            @ 23   org.apache.lucene.codecs.BlockTreeTermsWriter$TermsWriter::getComparator (4 bytes)   inline (hot)\n                            @ 23   org.apache.lucene.codecs.blockterms.BlockTermsWriter$TermsWriter::getComparator (4 bytes)   inline (hot)\n                              @ 0   org.apache.lucene.util.BytesRef::getUTF8SortedAsUnicodeComparator (4 bytes)   inline (hot)\n                              @ 0   org.apache.lucene.util.BytesRef::getUTF8SortedAsUnicodeComparator (4 bytes)   inline (hot)\n                            @ 32   org.apache.lucene.index.FieldInfo::getIndexOptions (5 bytes)   inline (hot)\n                            @ 61   java.lang.Enum::compareTo (44 bytes)   too big\n                            @ 79   java.lang.Enum::compareTo (44 bytes)   too big\n                            @ 97   java.lang.Enum::compareTo (44 bytes)   too big\n                            @ 238   java.util.HashMap::size (5 bytes)   inline (hot)\n                            @ 267   org.apache.lucene.index.TermsHashPerField::sortPostings (9 bytes)   executed < MinInliningThreshold times\n                            @ 279   org.apache.lucene.util.BytesRefHash::size (5 bytes)   inline (hot)\n                            @ 288   org.apache.lucene.util.BytesRef::<init> (8 bytes)   inline (hot)\n                              @ 4   org.apache.lucene.util.BytesRef::<init> (9 bytes)   inline (hot)\n                                @ 5   org.apache.lucene.util.BytesRef::<init> (41 bytes)   inline (hot)\n                                  @ 1   java.lang.Object::<init> (1 bytes)   inline (hot)\n                                  @ 26   org.apache.lucene.util.BytesRef::isValid (329 bytes)   hot method too big\n                            @ 309   org.apache.lucene.index.ByteSliceReader::<init> (5 bytes)   inline (hot)\n                              @ 1   org.apache.lucene.store.DataInput::<init> (5 bytes)   inline (hot)\n                                @ 1   java.lang.Object::<init> (1 bytes)   inline (hot)\n                            @ 318   org.apache.lucene.index.ByteSliceReader::<init> (5 bytes)   inline (hot)\n                              @ 1   org.apache.lucene.store.DataInput::<init> (5 bytes)   inline (hot)\n                                @ 1   java.lang.Object::<init> (1 bytes)   inline (hot)\n                            @ 331   org.apache.lucene.index.SegmentInfo::getDocCount (23 bytes)   inline (hot)\n                            @ 334   org.apache.lucene.util.FixedBitSet::<init> (29 bytes)   inline (hot)\n                              @ 1   org.apache.lucene.search.DocIdSet::<init> (5 bytes)   inline (hot)\n                                @ 1   java.lang.Object::<init> (1 bytes)   inline (hot)\n                              @ 11   org.apache.lucene.util.FixedBitSet::bits2words (17 bytes)   inline (hot)\n                            @ 350   org.apache.lucene.index.Term::<init> (13 bytes)   inline (hot)\n                              @ 6   org.apache.lucene.util.BytesRef::<init> (8 bytes)   inline (hot)\n                                @ 4   org.apache.lucene.util.BytesRef::<init> (9 bytes)   inline (hot)\n                                  @ 5   org.apache.lucene.util.BytesRef::<init> (41 bytes)   inline (hot)\n                                    @ 1   java.lang.Object::<init> (1 bytes)   inline (hot)\n                                    @ 26   org.apache.lucene.util.BytesRef::isValid (329 bytes)   hot method too big\n                              @ 9   org.apache.lucene.index.Term::<init> (15 bytes)   inline (hot)\n                                @ 1   java.lang.Object::<init> (1 bytes)   inline (hot)\n                            @ 393   org.apache.lucene.util.ByteBlockPool::setBytesRef (107 bytes)   inline (hot)\n                            @ 405   org.apache.lucene.index.TermsHashPerField::initReader (87 bytes)   inline (hot)\n                              @ 83   org.apache.lucene.index.ByteSliceReader::init (153 bytes)   inline (hot)\n                            @ 427   org.apache.lucene.index.TermsHashPerField::initReader (87 bytes)   inline (hot)\n                              @ 83   org.apache.lucene.index.ByteSliceReader::init (153 bytes)   inline (hot)\n                            @ 434   org.apache.lucene.codecs.BlockTreeTermsWriter$TermsWriter::startTerm (18 bytes)   inline (hot)\n                            @ 434   org.apache.lucene.codecs.blockterms.BlockTermsWriter$TermsWriter::startTerm (12 bytes)   executed < MinInliningThreshold times\n                            @ 500   org.apache.lucene.index.ByteSliceReader::eof (52 bytes)   inline (hot)\n                            @ 1154   org.apache.lucene.codecs.TermStats::<init> (15 bytes)   inline (hot)\n                              @ 1   java.lang.Object::<init> (1 bytes)   inline (hot)\n                            @ 1157   org.apache.lucene.codecs.BlockTreeTermsWriter$TermsWriter::finishTerm (87 bytes)   inline (hot)\n                            @ 1157   org.apache.lucene.codecs.blockterms.BlockTermsWriter$TermsWriter::finishTerm (203 bytes)   executed < MinInliningThreshold times\n                              @ 30   org.apache.lucene.util.fst.Util::toIntsRef (55 bytes)   already compiled into a medium method\n                              @ 37   org.apache.lucene.util.fst.NoOutputs::getNoOutput (4 bytes)   inline (hot)\n                              @ 40   org.apache.lucene.util.fst.Builder::add (767 bytes)   already compiled into a medium method\n                              @ 52   org.apache.lucene.util.BytesRef::deepCopyOf (15 bytes)   inline (hot)\n                                @ 4   org.apache.lucene.util.BytesRef::<init> (8 bytes)   inline (hot)\n                                  @ 4   org.apache.lucene.util.BytesRef::<init> (9 bytes)   inline (hot)\n                                    @ 5   org.apache.lucene.util.BytesRef::<init> (41 bytes)   inline (hot)\n                                      @ 1   java.lang.Object::<init> (1 bytes)   inline (hot)\n                                      @ 26   org.apache.lucene.util.BytesRef::isValid (329 bytes)   hot method too big\n                                @ 10   org.apache.lucene.util.BytesRef::copyBytes (64 bytes)   inline (hot)\n                                  @ 52   java.lang.System::arraycopy (0 bytes)   (intrinsic)\n                              @ 56   org.apache.lucene.codecs.BlockTreeTermsWriter$PendingTerm::<init> (16 bytes)   inline (hot)\n                                @ 2   org.apache.lucene.codecs.BlockTreeTermsWriter$PendingEntry::<init> (10 bytes)   inline (hot)\n                                  @ 1   java.lang.Object::<init> (1 bytes)   inline (hot)\n                            @ 563   org.apache.lucene.store.DataInput::readVInt (114 bytes)   inline (hot)\n                              @ 1   org.apache.lucene.index.ByteSliceReader::readByte (78 bytes)   inline (hot)\n                                @ 7   org.apache.lucene.index.ByteSliceReader::eof (52 bytes)   inline (hot)\n                                @ 58   org.apache.lucene.index.ByteSliceReader::nextSlice (198 bytes)   inline (hot)\n                              @ 17   org.apache.lucene.index.ByteSliceReader::readByte (78 bytes)   inline (hot)\n                                @ 7   org.apache.lucene.index.ByteSliceReader::eof (52 bytes)   inline (hot)\n                                @ 58   org.apache.lucene.index.ByteSliceReader::nextSlice (198 bytes)   inline (hot)\n                              @ 38   org.apache.lucene.index.ByteSliceReader::readByte (78 bytes)   inline (hot)\n                                @ 7   org.apache.lucene.index.ByteSliceReader::eof (52 bytes)   inline (hot)\n                                @ 58   org.apache.lucene.index.ByteSliceReader::nextSlice (198 bytes)   inline (hot)\n                              @ 59   org.apache.lucene.index.ByteSliceReader::readByte (78 bytes)   inline (hot)\n                                @ 7   org.apache.lucene.index.ByteSliceReader::eof (52 bytes)   inline (hot)\n                                @ 58   org.apache.lucene.index.ByteSliceReader::nextSlice (198 bytes)   inline (hot)\n                              @ 80   org.apache.lucene.index.ByteSliceReader::readByte (78 bytes)   inline (hot)\n                                @ 7   org.apache.lucene.index.ByteSliceReader::eof (52 bytes)   inline (hot)\n                                @ 58   org.apache.lucene.index.ByteSliceReader::nextSlice (198 bytes)   inline (hot)\n                            @ 610   org.apache.lucene.store.DataInput::readVInt (114 bytes)   inline (hot)\n                              @ 1   org.apache.lucene.index.ByteSliceReader::readByte (78 bytes)   inline (hot)\n                                @ 7   org.apache.lucene.index.ByteSliceReader::eof (52 bytes)   inline (hot)\n                                @ 58   org.apache.lucene.index.ByteSliceReader::nextSlice (198 bytes)   inline (hot)\n                              @ 17   org.apache.lucene.index.ByteSliceReader::readByte (78 bytes)   inline (hot)\n                                @ 7   org.apache.lucene.index.ByteSliceReader::eof (52 bytes)   inline (hot)\n                                @ 58   org.apache.lucene.index.ByteSliceReader::nextSlice (198 bytes)   inline (hot)\n                              @ 38   org.apache.lucene.index.ByteSliceReader::readByte (78 bytes)   inline (hot)\n                                @ 7   org.apache.lucene.index.ByteSliceReader::eof (52 bytes)   inline (hot)\n                                @ 58   org.apache.lucene.index.ByteSliceReader::nextSlice (198 bytes)   inline (hot)\n                              @ 59   org.apache.lucene.index.ByteSliceReader::readByte (78 bytes)   inline (hot)\n                                @ 7   org.apache.lucene.index.ByteSliceReader::eof (52 bytes)   inline (hot)\n                                @ 58   org.apache.lucene.index.ByteSliceReader::nextSlice (198 bytes)   inline (hot)\n                              @ 80   org.apache.lucene.index.ByteSliceReader::readByte (78 bytes)   inline (hot)\n                                @ 7   org.apache.lucene.index.ByteSliceReader::eof (52 bytes)   inline (hot)\n                                @ 58   org.apache.lucene.index.ByteSliceReader::nextSlice (198 bytes)   inline (hot)\n                            @ 657   org.apache.lucene.index.SegmentInfo::getDocCount (23 bytes)   inline (hot)\n                            @ 710   org.apache.lucene.util.FixedBitSet::set (84 bytes)   inline (hot)\n                            @ 728   org.apache.lucene.codecs.lucene41.Lucene41PostingsWriter::startDoc (242 bytes)   inline (hot)\n                              @ 43   org.apache.lucene.codecs.lucene41.Lucene41SkipWriter::bufferSkip (45 bytes)   too big\n                              @ 197   org.apache.lucene.codecs.lucene41.ForUtil::writeBlock (168 bytes)   too big\n                              @ 223   org.apache.lucene.codecs.lucene41.ForUtil::writeBlock (168 bytes)   too big\n                            @ 763   org.apache.lucene.index.SegmentInfo::getDocCount (23 bytes)   call site not reached\n                            @ 848   org.apache.lucene.store.DataInput::readVInt (114 bytes)   inline (hot)\n                              @ 1   org.apache.lucene.index.ByteSliceReader::readByte (78 bytes)   inline (hot)\n                                @ 7   org.apache.lucene.index.ByteSliceReader::eof (52 bytes)   inline (hot)\n                                @ 58   org.apache.lucene.index.ByteSliceReader::nextSlice (198 bytes)   inline (hot)\n                              @ 17   org.apache.lucene.index.ByteSliceReader::readByte (78 bytes)   inline (hot)\n                                @ 7   org.apache.lucene.index.ByteSliceReader::eof (52 bytes)   inline (hot)\n                                @ 58   org.apache.lucene.index.ByteSliceReader::nextSlice (198 bytes)   inline (hot)\n                              @ 38   org.apache.lucene.index.ByteSliceReader::readByte (78 bytes)   inline (hot)\n                                @ 7   org.apache.lucene.index.ByteSliceReader::eof (52 bytes)   inline (hot)\n                                @ 58   org.apache.lucene.index.ByteSliceReader::nextSlice (198 bytes)   inline (hot)\n                              @ 59   org.apache.lucene.index.ByteSliceReader::readByte (78 bytes)   inline (hot)\n                                @ 7   org.apache.lucene.index.ByteSliceReader::eof (52 bytes)   inline (hot)\n                                @ 58   org.apache.lucene.index.ByteSliceReader::nextSlice (198 bytes)   inline (hot)\n                              @ 80   org.apache.lucene.index.ByteSliceReader::readByte (78 bytes)   inline (hot)\n                                @ 7   org.apache.lucene.index.ByteSliceReader::eof (52 bytes)   inline (hot)\n                                @ 58   org.apache.lucene.index.ByteSliceReader::nextSlice (198 bytes)   inline (hot)\n                            @ 871   org.apache.lucene.store.DataInput::readVInt (114 bytes)   size > DesiredMethodLimit\n                            @ 888   org.apache.lucene.util.BytesRef::<init> (8 bytes)   size > DesiredMethodLimit\n                            @ 927   org.apache.lucene.util.BytesRef::grow (34 bytes)   size > DesiredMethodLimit\n                            @ 942   org.apache.lucene.index.ByteSliceReader::readBytes (84 bytes)   size > DesiredMethodLimit\n                            @ 975   org.apache.lucene.store.DataInput::readVInt (114 bytes)   size > DesiredMethodLimit\n                            @ 985   org.apache.lucene.store.DataInput::readVInt (114 bytes)   size > DesiredMethodLimit\n                            @ 1077   org.apache.lucene.codecs.lucene41.Lucene41PostingsWriter::addPosition (367 bytes)   size > DesiredMethodLimit\n                            @ 1125   org.apache.lucene.codecs.lucene41.Lucene41PostingsWriter::finishDoc (76 bytes)   size > DesiredMethodLimit\n                            @ 1200   org.apache.lucene.util.FixedBitSet::cardinality (15 bytes)   size > DesiredMethodLimit\n                            @ 1203   org.apache.lucene.codecs.BlockTreeTermsWriter$TermsWriter::finish (354 bytes)   size > DesiredMethodLimit\n                            @ 1203   org.apache.lucene.codecs.blockterms.BlockTermsWriter$TermsWriter::finish (101 bytes)   size > DesiredMethodLimit\n   8223 1154   size: 40468 time: 71 inlined: 3341 bytes \n\n ",
            "author": "Dawid Weiss",
            "id": "comment-13740840"
        },
        {
            "date": "2013-08-15T10:02:05+0000",
            "content": "What happens if you make \"upto\" volatile? I assume the same happens like with the static dummy field.\n\nMaybe for now we use the static field \"hack\". I don't think this causes performance trouble. We can add a good comment and once the bug is fixed in JDK we can remove it in 5 years or so \n\nTo me it looks like we hit this bug more often because of optimized tests that seem to run this method more often. This is a good sign, we are improving our tests!  ",
            "author": "Uwe Schindler",
            "id": "comment-13740847"
        },
        {
            "date": "2013-08-15T10:09:10+0000",
            "content": "Yeah... we could temporarily commit the static field \"hack\" and at least see if this proves me wrong (perhaps it just happens to work for this particular seed but will fail elsewhere). ",
            "author": "Dawid Weiss",
            "id": "comment-13740851"
        },
        {
            "date": "2013-08-15T13:48:56+0000",
            "content": "I've built a fastdebug binary of openjdk 1.8 (top of the master branch). Retrying my 1000-random seed sample right now (1.7's seed doesn't reproduce on my fresh-from-the-oven binary, so perhaps it's been fixed in between). ",
            "author": "Dawid Weiss",
            "id": "comment-13740969"
        },
        {
            "date": "2013-08-16T06:22:40+0000",
            "content": "I can reproduce the issue on a different scenario too (core tests) so it's quite definitely a compiler bug lurking somewhere.\n\n   [junit4] ERROR   0.00s | TestSimpleExplanations (suite) <<<\n   [junit4]    > Throwable #1: java.lang.AssertionError\n   [junit4]    > \tat __randomizedtesting.SeedInfo.seed([8C5A2DB2970990FA]:0)\n   [junit4]    > \tat org.apache.lucene.index.FreqProxTermsWriterPerField.flush(FreqProxTermsWriterPerField.java:457)\n   [junit4]    > \tat org.apache.lucene.index.FreqProxTermsWriter.flush(FreqProxTermsWriter.java:85)\n   [junit4]    > \tat org.apache.lucene.index.TermsHash.flush(TermsHash.java:116)\n   [junit4]    > \tat org.apache.lucene.index.DocInverter.flush(DocInverter.java:53)\n   [junit4]    > \tat org.apache.lucene.index.DocFieldProcessor.flush(DocFieldProcessor.java:81)\n   [junit4]    > \tat org.apache.lucene.index.DocumentsWriterPerThread.flush(DocumentsWriterPerThread.java:501)\n   [junit4]    > \tat org.apache.lucene.index.DocumentsWriter.doFlush(DocumentsWriter.java:478)\n   [junit4]    > \tat org.apache.lucene.index.DocumentsWriter.flushAllThreads(DocumentsWriter.java:615)\n   [junit4]    > \tat org.apache.lucene.index.IndexWriter.getReader(IndexWriter.java:365)\n   [junit4]    > \tat org.apache.lucene.index.RandomIndexWriter.getReader(RandomIndexWriter.java:307)\n   [junit4]    > \tat org.apache.lucene.index.RandomIndexWriter.getReader(RandomIndexWriter.java:249)\n   [junit4]    > \tat org.apache.lucene.search.TestExplanations.beforeClassTestExplanations(TestExplanations.java:82)\n   [junit4]    > \tat java.lang.Thread.run(Thread.java:724)Throwable #2: java.lang.NullPointerException\n   [junit4]    > \tat __randomizedtesting.SeedInfo.seed([8C5A2DB2970990FA]:0)\n   [junit4]    > \tat org.apache.lucene.search.TestExplanations.afterClassTestExplanations(TestExplanations.java:63)\n   [junit4]    > \tat java.lang.Thread.run(Thread.java:724)\n   [junit4] Completed in 0.06s, 0 tests, 1 failure, 1 error <<< FAILURES!\n\n\n\nFive failures out of a hundred full runs of lucene's core tests. So it's not a frequent thing, but it does happen. Java 1.8 b102, 32-bit (Windows). ",
            "author": "Dawid Weiss",
            "id": "comment-13741968"
        },
        {
            "date": "2013-08-16T07:15:40+0000",
            "content": "Failed logs from 1.8b102 runs. ",
            "author": "Dawid Weiss",
            "id": "comment-13741997"
        },
        {
            "date": "2013-08-16T08:04:03+0000",
            "content": "This issue also affects 1.7.0_21-b11 (32 bit). ",
            "author": "Dawid Weiss",
            "id": "comment-13742015"
        },
        {
            "date": "2013-08-16T14:06:14+0000",
            "content": "Out of curiosity, were those failures also with G1GC? ",
            "author": "Robert Muir",
            "id": "comment-13742233"
        },
        {
            "date": "2013-08-16T14:14:02+0000",
            "content": "Yes. This just has to be complex though because it's not just GC-related. Disabling escape analysis also makes the tests pass, so does removing inlining.\n\nI managed to find a reproducible scenario under 1.8 (fastdebug) which is great because now I can dump the assembly. It's still terribly large...\n\nAnyway, the blame still seems to point to readvint  Really, not joking. I added a sysout in \n\nfinal int code = freq.readVInt();\n\n\nthis is consistent when the test passes but when it fails you get a difference:\n\n// normal run\ncode::0 true\ncode::4 true\ncode::2 true\n\n// error run\ncode::0 true\ncode::3 true\ncode::4 true\n\n\n ",
            "author": "Dawid Weiss",
            "id": "comment-13742243"
        },
        {
            "date": "2013-08-26T07:47:22+0000",
            "content": "Just a quick update that I'm still on this issue, trying to figure out which exact hotspot optimization is causing it. The problem is somewhere on the intersection of G1GC, escape analysis and C2 optimizations. I have a reproducible scenario (although very large, unfortunately) which definitely misses a variable update. ByteSliceReader's readByte\n\n  @Override\n  public byte readByte() {\n    assert !eof();\n    assert upto <= limit;\n    if (upto == limit) {\n      nextSlice();\n    }\n    return buffer[upto++];\n  }\n\n\n\nthe increment in buffer[upto++] is skipped, resulting in havoc later on that eventually leads to an assertion in FreqProxTermsWriterPerField.flush. This assertion is a follow-up of incorrectly read/ interpreted input stream's data.\n\nThe \"workarounds\" like declaring upto volatile are not worth the gains. Once I know which exact VM bug this is we can decide what to do with it \u2013 I'd go back to Yonik (or Robert's?) suggestion of trying to probe the VM we're running on and if it matches any of the blacklisted versions, emitting a big red warning saying the execution is unsafe. Or throwing an exception and allowing a system-property override switch that has to be manually provided (so that whoever still decides to run under such a VM knows what they're doing). ",
            "author": "Dawid Weiss",
            "id": "comment-13749887"
        },
        {
            "date": "2013-08-26T21:06:21+0000",
            "content": "I am curious if this could be related to HotSpot bug ID 8023472, which was a C2 crash triggered only with G1, seen specifically with Lucene and elasticsearch. There was a fix http://hg.openjdk.java.net/hsx/hotspot-comp/hotspot/rev/b17d8f6d9ed7 pushed recently to hotspot-comp. If you can build the latest from http://hg.openjdk.java.net/hsx/hotspot-comp/ it might be worthwhile to see if you can still reproduce.\n\nSee http://markmail.org/message/gsd3e3de33cmmrq4 and http://markmail.org/message/efqfncdegiwloudf for more discussion. ",
            "author": "David Schlosnagle",
            "id": "comment-13750550"
        },
        {
            "date": "2013-08-27T07:19:23+0000",
            "content": "Thanks David. I did notice that bug and did test with it. Doesn't help though \u2013 the problem is still in there. It's a lot of fun debugging. Like trying to fight the uncertainty principle \u2013 you can see something is wrong but whenever you're trying to put a finger on it (by adding something that would help you in debugging) it's gone and everything is back to normal.  ",
            "author": "Dawid Weiss",
            "id": "comment-13751042"
        },
        {
            "date": "2013-09-02T09:42:18+0000",
            "content": "There is definietely a bug in the VM lurking somewhere. I've traced the problematic loop and it's a mess \u2013 readVInt gets inlined twice and updates to upto don't propagate, resulting in general havoc later on and an assertion. More details here.\n\nhttp://mail.openjdk.java.net/pipermail/hotspot-dev/2013-September/010692.html\n\nI don't know of any sensible workaround other than -XX:-DoEscapeAnalysis (which helps but slows things down considerably). And I don't see the link to G1GC but I have very little idea of internal C2/opto workings in hotspot \u2013 fingers crossed for the hotspot folks to find out where the core of the problem is.\n ",
            "author": "Dawid Weiss",
            "id": "comment-13755991"
        },
        {
            "date": "2013-09-10T10:36:47+0000",
            "content": "Ha! Found the regression commit that introduced this problem in hotspot history! \nhttp://mail.openjdk.java.net/pipermail/hotspot-compiler-dev/2013-September/011648.html\n\nLet's see if Vladimir can come up with what wrong is actually happening  ",
            "author": "Dawid Weiss",
            "id": "comment-13762930"
        },
        {
            "date": "2013-11-25T08:23:30+0000",
            "content": "I just checked with jdk-8-ea-bin-b116-linux-i586-14_nov_2013.tar.gz and this issue seems to be still valid.\n\n> svn info\nURL: https://svn.apache.org/repos/asf/lucene/dev/branches/branch_4x/lucene/highlighter\nRepository Root: https://svn.apache.org/repos/asf\nRevision: 1512807\n\n> uname -a\nLinux dweiss-ubuntu9 2.6.28-11-generic #42-Ubuntu SMP Fri Apr 17 01:57:59 UTC 2009 i686 GNU/Linux\n\n> cd lucene/highlighter\n> for i in `seq 1 100`; do ant test -Dtests.failfast=true -Dtests.seed=CF -Dtests.jvms=1 -Dtests.dynamicAssignmentRatio=0 -Dargs=\"-server -XX:+UseG1GC -XX:-TieredCompilation -Xbatch -XX:CICompilerCount=1\"; done\n\n\n\nThe above leaves me about 1 failure in 5 runs. \n\n   [junit4] Suite: org.apache.lucene.search.postingshighlight.TestPostingsHighlighter\n   [junit4]   2> NOTE: reproduce with: ant test  -Dtestcase=TestPostingsHighlighter -Dtests.method=testMulti\nplePassages -Dtests.seed=CF -Dtests.slow=true -Dtests.locale=sk -Dtests.timezone=America/Whitehorse -Dtests.\nfile.encoding=US-ASCII\n   [junit4] FAILURE 0.11s | TestPostingsHighlighter.testMultiplePassages <<<\n   [junit4]    > Throwable #1: java.lang.AssertionError\n   [junit4]    >        at __randomizedtesting.SeedInfo.seed([CF:3191CE42818D1FA]:0)\n   [junit4]    >        at org.apache.lucene.index.ByteSliceReader.readByte(ByteSliceReader.java:73)\n   [junit4]    >        at org.apache.lucene.store.DataInput.readVInt(DataInput.java:108)\n   [junit4]    >        at org.apache.lucene.index.FreqProxTermsWriterPerField.flush(FreqProxTermsWriterPerF\nield.java:453)\n   [junit4]    >        at org.apache.lucene.index.FreqProxTermsWriter.flush(FreqProxTermsWriter.java:85)\n   [junit4]    >        at org.apache.lucene.index.TermsHash.flush(TermsHash.java:116)\n   [junit4]    >        at org.apache.lucene.index.DocInverter.flush(DocInverter.java:53)\n   [junit4]    >        at org.apache.lucene.index.DocFieldProcessor.flush(DocFieldProcessor.java:81)\n   [junit4]    >        at org.apache.lucene.index.DocumentsWriterPerThread.flush(DocumentsWriterPerThread.j\nava:501)\n   [junit4]    >        at org.apache.lucene.index.DocumentsWriter.doFlush(DocumentsWriter.java:478)\n   [junit4]    >        at org.apache.lucene.index.DocumentsWriter.flushAllThreads(DocumentsWriter.java:615)\n   [junit4]    >        at org.apache.lucene.index.IndexWriter.prepareCommitInternal(IndexWriter.java:2760)\n   [junit4]    >        at org.apache.lucene.index.IndexWriter.commitInternal(IndexWriter.java:2909)\n   [junit4]    >        at org.apache.lucene.index.IndexWriter.commit(IndexWriter.java:2884)\n   [junit4]    >        at org.apache.lucene.index.RandomIndexWriter.getReader(RandomIndexWriter.java:312)\n   [junit4]    >        at org.apache.lucene.index.RandomIndexWriter.getReader(RandomIndexWriter.java:249)\n   [junit4]    >        at org.apache.lucene.search.postingshighlight.TestPostingsHighlighter.testMultiplePa\nssages(TestPostingsHighlighter.java:257)\n   [junit4]    >        at java.lang.Thread.run(Thread.java:744)\n\n ",
            "author": "Dawid Weiss",
            "id": "comment-13831264"
        },
        {
            "date": "2014-03-25T23:17:49+0000",
            "content": "Vladmir Kozlov opened a new OpenJDK issue, including comments from here:\nhttps://bugs.openjdk.java.net/browse/JDK-8038348 ",
            "author": "Uwe Schindler",
            "id": "comment-13947322"
        },
        {
            "date": "2014-03-29T20:37:09+0000",
            "content": "Just a quick update \u2013 the problem is still there, just checked with:\n\n1) the most recent official 1.7:\n\nJava(TM) SE Runtime Environment (build 1.7.0_51-b13); \nJava HotSpot(TM) Server VM (build 24.51-b03, mixed mode)\n\n2) the most recent official 1.8:\n\nJava(TM) SE Runtime Environment (build 1.8.0-b132)\nJava HotSpot(TM) Server VM (build 25.0-b70, mixed mode)\n\nand they both fail on the impossible assertion.\n\n  [junit4]    > Throwable #1: java.lang.AssertionError\n   [junit4]    > \tat __randomizedtesting.SeedInfo.seed([CF:9F36A99E987A1F00]:0)\n   [junit4]    > \tat org.apache.lucene.index.FreqProxTermsWriterPerField.flush(FreqProxTermsWriterPerField.java:457)\n   [junit4]    > \tat org.apache.lucene.index.FreqProxTermsWriter.flush(FreqProxTermsWriter.java:85)\n   [junit4]    > \tat org.apache.lucene.index.TermsHash.flush(TermsHash.java:116)\n   [junit4]    > \tat org.apache.lucene.index.DocInverter.flush(DocInverter.java:53)\n...\n\n\n\nThis reproduces for me solidly on a historic version of branch 4.x:\n\nURL: https://svn.apache.org/repos/asf/lucene/dev/branches/branch_4x/lucene/highlighter\nRevision: 1512807\n\n\n\nBut since hotspot is still broken somewhere I assume the same bug may result in other odd surprises, even if Mike spaghettified (yes, my own invention but I just verified and it's actually a true word http://en.wikipedia.org/wiki/Spaghettification) the code a bit to dodge the problem. ",
            "author": "Dawid Weiss",
            "id": "comment-13954432"
        },
        {
            "date": "2014-05-22T08:43:59+0000",
            "content": "Looks like the G1GC bug is still there in jdk1.8.0_05 (we just had a fail last night). ",
            "author": "Michael McCandless",
            "id": "comment-14005730"
        },
        {
            "date": "2014-05-22T09:01:00+0000",
            "content": "I'm quite sure it's still there. I am in touch with Vladimir Kozlov but it's just next to impossible to actually tell why or where the miscompilation happens. ",
            "author": "Dawid Weiss",
            "id": "comment-14005745"
        },
        {
            "date": "2014-05-22T09:29:06+0000",
            "content": "I don't think this is closely related to G1GC. It looks more that G1GC happily triggers this bug in this special case. ",
            "author": "Uwe Schindler",
            "id": "comment-14005783"
        },
        {
            "date": "2014-05-22T09:32:59+0000",
            "content": "Very likely it's a combination of environment settings. G1GC, escape analysis \u2013 all these have to be turned on for the \"reproducible\" scenario I have in my VM and keep as a reference of this bug. The problem still manifests itself only in about 30-50% of executions, so there is also a race condition there somewhere. ",
            "author": "Dawid Weiss",
            "id": "comment-14005785"
        },
        {
            "date": "2015-03-03T03:57:12+0000",
            "content": "Michael McCandless hey! Could you please advise whenever you are running on 32bit or 64bit?\n\nWe're on 1.8,0_20 64 bit and not sure whenever it's worth to use G1. ",
            "author": "Petro Semeniuk",
            "id": "comment-14344469"
        },
        {
            "date": "2015-03-03T07:47:17+0000",
            "content": "G1GC causes intermittent crashes in Lucene/ Solr tests. We don't know why. The crashes are hard or impossible to reproduce (and if they are reproducible, they're not easy to fix at hotspot level). I wouldn't use it in production. ",
            "author": "Dawid Weiss",
            "id": "comment-14344694"
        },
        {
            "date": "2016-10-11T19:53:53+0000",
            "content": "Has anything happened with this in the intervening year and a half? ",
            "author": "Brian McCallister",
            "id": "comment-15566407"
        },
        {
            "date": "2016-10-12T12:58:51+0000",
            "content": "No, not much. I still have a virtualmachine where I used to reproduce this, but it'd require an update to the most recent openjdk, recompilation and some sweat to reproduce the original issue (it wasn't always reproducible). ",
            "author": "Dawid Weiss",
            "id": "comment-15568644"
        },
        {
            "date": "2016-10-12T18:00:56+0000",
            "content": "Sorry, Robert updated me here \u2013 this bug has been fixed by Tobias Hartmann, see here:\nhttps://bugs.openjdk.java.net/browse/JDK-8038348 ",
            "author": "Dawid Weiss",
            "id": "comment-15569422"
        },
        {
            "date": "2016-10-12T18:01:21+0000",
            "content": "Fixed in https://bugs.openjdk.java.net/browse/JDK-8038348 ",
            "author": "Dawid Weiss",
            "id": "comment-15569423"
        },
        {
            "date": "2016-10-12T18:35:28+0000",
            "content": "Thanks Robert Muir for the update. Great news  ",
            "author": "Uwe Schindler",
            "id": "comment-15569520"
        },
        {
            "date": "2016-10-12T18:37:59+0000",
            "content": "BTW, JDK 9 b138 is already in the Policeman Jenkins beer brewery (https://www.facebook.com/ThetaPh1/posts/1547975418562090 => this bug was fixed in b137): https://jenkins.thetaphi.de/job/Lucene-Solr-master-Linux/ ",
            "author": "Uwe Schindler",
            "id": "comment-15569525"
        },
        {
            "date": "2016-10-12T19:26:32+0000",
            "content": "Uwe Schindler I tried to click on your FB link but it's broken  ",
            "author": "Michael McCandless",
            "id": "comment-15569652"
        },
        {
            "date": "2016-10-12T20:02:09+0000",
            "content": "I think you need Facebook account. Was a post by Robert \ud83d\ude06 ",
            "author": "Uwe Schindler",
            "id": "comment-15569730"
        },
        {
            "date": "2016-10-14T12:56:15+0000",
            "content": "OK indeed the link works once I logged into FB, something I try not to do very often   Robert Muir you should make this important FB post world readable! ",
            "author": "Michael McCandless",
            "id": "comment-15575257"
        }
    ]
}