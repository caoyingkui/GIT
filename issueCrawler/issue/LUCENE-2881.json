{
    "id": "LUCENE-2881",
    "title": "Track FieldInfo per segment instead of per-IW-session",
    "details": {
        "labels": "",
        "priority": "Major",
        "components": [],
        "type": "Improvement",
        "fix_versions": [
            "4.0-ALPHA",
            "Realtime Branch",
            "CSF branch"
        ],
        "affect_versions": "4.0-ALPHA,                                            Realtime Branch,                                            CSF branch",
        "resolution": "Fixed",
        "status": "Closed"
    },
    "description": "Currently FieldInfo is tracked per IW session to guarantee consistent global field-naming / ordering. IW carries FI instances over from previous segments which also carries over field properties like isIndexed etc. While having consistent field ordering per IW session appears to be important due to bulk merging stored fields etc. carrying over other properties might become problematic with Lucene's Codec support.  Codecs that rely on consistent properties in FI will fail if FI properties are carried over.\n\nThe DocValuesCodec (DocValuesBranch) for instance writes files per segment and field (using the field id within the file name). Yet, if a segment has no DocValues indexed in a particular segment but a previous segment in the same IW session had DocValues, FieldInfo#docValues will be true  since those values are reused from previous segments. \n\nWe already work around this \"limitation\" in SegmentInfo with properties like hasVectors or hasProx which is really something we should manage per Codec & Segment. Ideally FieldInfo would be managed per Segment and Codec such that its properties are valid per segment. It also seems to be necessary to bind FieldInfoS to SegmentInfo logically since its really just per segment metadata.",
    "attachments": {
        "LUCENE-2881.patch": "https://issues.apache.org/jira/secure/attachment/12472310/LUCENE-2881.patch",
        "lucene-2881.patch": "https://issues.apache.org/jira/secure/attachment/12470580/lucene-2881.patch"
    },
    "issue_links": {},
    "comments": [
        {
            "date": "2011-01-24T16:02:14+0000",
            "content": "It also seems to be necessary to bind FieldInfoS to SegmentInfo logically since its really just per segment metadata.\n\nYeah, I was going to do this in the realtime branch, because I don't think we can get DWPTs working correctly without SegmentInfos having private FIs.  ",
            "author": "Michael Busch",
            "id": "comment-12985759"
        },
        {
            "date": "2011-01-24T17:48:22+0000",
            "content": "Yeah, I was going to do this in the realtime branch, because I don't think we can get DWPTs working correctly without SegmentInfos having private FIs.\ni think we should do that on trunk and then merge to RT - do you have time to work on this soon? ",
            "author": "Simon Willnauer",
            "id": "comment-12985844"
        },
        {
            "date": "2011-01-24T18:01:26+0000",
            "content": "It would probably make sense to have a new class (maybe an extension of SegmentInfo) for in-memory (not-yet-flushed) segments that references the corresponding FieldInfos and SegmentDeletes.  That'd be better I think that adding another map SegmentInfo -> FieldInfos and we could then also remove the SegmentInfo -> SegmentDeletes map (in BufferedDeletes). ",
            "author": "Michael Busch",
            "id": "comment-12985852"
        },
        {
            "date": "2011-01-24T18:03:08+0000",
            "content": "i think we should do that on trunk and then merge to RT - do you have time to work on this soon?\n\nYeah I agree.  Hmm maybe I can spend some hours tonight on this, otherwise I don't think I'll have much time before Thursday. ",
            "author": "Michael Busch",
            "id": "comment-12985853"
        },
        {
            "date": "2011-01-24T20:14:52+0000",
            "content": "Yeah I agree. Hmm maybe I can spend some hours tonight on this, otherwise I don't think I'll have much time before Thursday.\nMichael, if you start something I can work on it tomorrow for a while too. That way we can get it in quickly   ",
            "author": "Simon Willnauer",
            "id": "comment-12985959"
        },
        {
            "date": "2011-02-08T10:25:15+0000",
            "content": "\n\tCreates for every segment a new FieldInfos\n\tChanges FieldInfos, so that the FieldInfo numbers within a single FieldInfos don't have to be contiguous - this allows using the same numbering as the previous segment(s), even if not all fields are present in the new segment\n\tAdds a global fieldName -> fieldNumber map;  if possible when a new field is added to a FieldInfo it tries to use an already assigned number for that field\n\n\n\nAll tests pass.  Though I need to verify if the global map works correctly (it'd probably be good to add a test for that).  Also it'd be nice to remove hasVectors and hasProx from SegmentInfo, but we could also do that in a separate issue.  ",
            "author": "Michael Busch",
            "id": "comment-12991886"
        },
        {
            "date": "2011-02-08T16:43:49+0000",
            "content": "Michael, this looks very good!\n\n\nAll tests pass. Though I need to verify if the global map works correctly (it'd probably be good to add a test for that). Also it'd be nice to remove hasVectors and hasProx from SegmentInfo, but we could also do that in a separate issue.\nI agree we should make FieldInfos a member of SegmentInfo and remove the hasVectors / hasProx an push them down. I tried to apply this patch to the DocValues branch but I didn't get very far - I haven't merged for a while that killed me ;( \nI need to push that to after my vacation. I really hoped that I can get further but it didn't work out ;( ",
            "author": "Simon Willnauer",
            "id": "comment-12992038"
        },
        {
            "date": "2011-02-08T20:10:22+0000",
            "content": "New patch that removes the tracking of 'hasVectors' and 'hasProx' in SegmentInfo.  Instead SegmentInfo now has a reference to its corresponding FieldInfos.  \n\nFor backwards-compatibility reasons we can't completely remove the hasVectors and hasProx bytes from the serialized SegmentInfo yet.  Eg. if someone uses addIndexes(Directory...) to add external old pre-4.0 segments to a new index, we \"upgrade\" the SegmentInfo to the latest version.  However, we don't modify the FieldInfos of that segment, instead we just copy it over to the new dir.  So the hasVector and hasProx bits in the FieldInfos might not be accurate and we have to keep those bits in the SegmentInfo instead.  Not an ideal solution, but we can remove it entirely in Lucene 5.0 .  The alternative would be to\nrewrite the FieldInfos instead of just copying the files, but then we have to rewrite the cfs files.\n\nAll core & contrib tests pass. ",
            "author": "Michael Busch",
            "id": "comment-12992150"
        },
        {
            "date": "2011-02-08T20:22:45+0000",
            "content": "\nNew patch that removes the tracking of 'hasVectors' and 'hasProx' in SegmentInfo. Instead SegmentInfo now has a reference to its corresponding FieldInfos.\n\nWow! nice work Michael! I like how you preserve bw compat in SegmentInfo and FieldInfos is now bound to SegmentInfo - yay! this solves two problems at once for DocValues branch.\n\nThe alternative would be to rewrite the FieldInfos instead of just copying the files, but then we have to rewrite the cfs files.\n\nI think  copying over is fine. Ideally we will move all those boolean etc to the codec level so that we don't need that at all. Once stored fields and vectors are written by the codec we can push all that into PreFlex codec (maybe!?) and get rid of the bw compat code.\n\nI think you should commit that patch. I'll port to docvalues and run some tests that rely on this issue. ",
            "author": "Simon Willnauer",
            "id": "comment-12992156"
        },
        {
            "date": "2011-02-08T20:54:45+0000",
            "content": "I gave the patch another glance - here are a couple of very minor comments:\n\n\n\tmaybe we should return Iterable<FieldInfo> from FieldInfos#getFieldInfoIterator() this would make the iteration syntactically more javaish\n\n \n\nfor (FieldInfo info : getFieldInfoIterator()) {\n  // do something with it\n}\n\n\n\n\n\n\n\n\tIf we return Iterable<FieldInfo> should we name it getFieldInfos?\n\tMaybe we can simply implement Iterable<FieldInfo>?\n\tMaybe we can rename SI#clearFilesCache() to SI#clearCache() or simply SI#clear() this would make thing less coupled to the SI internal cache but rather something that is called to clear internal state after flush?\n\n ",
            "author": "Simon Willnauer",
            "id": "comment-12992174"
        },
        {
            "date": "2011-02-08T20:55:27+0000",
            "content": "Thanks for reviewing!\n\nI think you should commit that patch. I'll port to docvalues and run some tests that rely on this issue.\n\nI just want to add another tests for the global fieldname->number map, after that I think it'll be ready to commit.  Will do that tonight  ",
            "author": "Michael Busch",
            "id": "comment-12992175"
        },
        {
            "date": "2011-02-09T06:48:46+0000",
            "content": "Maybe we can simply implement Iterable<FieldInfo>?\n\ngood idea - done.\n\n\nMaybe we can rename SI#clearFilesCache()\n\nActually I renamed it intentionally, because all this method does is really clearing the files cache.  SI has a separate reset() method for resetting its state entirely. ",
            "author": "Michael Busch",
            "id": "comment-12992340"
        },
        {
            "date": "2011-02-09T06:52:34+0000",
            "content": "New patch that adds a new junit for testing that field numbering is consistent across segments.  It tests two cases: 1) one IW is used to write two segments; 2) two IWs are used to write two segments.  \nAnd it also tests that addIndexes(Directory...) doesn't mess up the field numbering of the external segment.\n\nAll tests pass.  I'll commit this in a day or two if nobody objects. ",
            "author": "Michael Busch",
            "id": "comment-12992342"
        },
        {
            "date": "2011-02-09T08:25:05+0000",
            "content": "All tests pass. I'll commit this in a day or two if nobody objects.\n\n+1 ",
            "author": "Simon Willnauer",
            "id": "comment-12992382"
        },
        {
            "date": "2011-02-09T13:37:30+0000",
            "content": "I just integrated this patch to the docvalues branch! It works like a charm! Nice work Michael, this brings docValues a huge step closer. All tests pass which failed before, FieldInfo is reliable now! ",
            "author": "Simon Willnauer",
            "id": "comment-12992476"
        },
        {
            "date": "2011-02-09T15:14:39+0000",
            "content": "Awesome, thanks for letting me know!  I hope I'll be able to say the same about the RT branch after I tried it there...  ",
            "author": "Michael Busch",
            "id": "comment-12992524"
        },
        {
            "date": "2011-02-09T20:44:40+0000",
            "content": "I actually have some intermitted failures on docvalues which seem to be caused by some mixed up codec IDs. I found one which fixed most of the cases in FieldInfo#clone() where the codec ID is lost. But there must be some other situation where the codec ID gets mixed up. I will be AFK for 10 days at least so I have to leave you alone with that. Seems that we need a test for that though. The docValues test bring that up quickly  ",
            "author": "Simon Willnauer",
            "id": "comment-12992707"
        },
        {
            "date": "2011-02-16T07:26:05+0000",
            "content": "I fixed a bug in FieldInfos that could lead to wrong field numbers, that might have been related to the wrong behavior you're seeing, Simon.\n\nAbout codecIds:  I made the fix to FieldInfo.clone() to set the codecId on the clone.  I also made FieldInfo.codecId private and added getter and setter.  The setter checks whether the new value for codecId is different from the previous one, and throws in exception in that case (unless it was set to the default 0 before, which I think means Preflex codec).\n\nAll tests pass.  Please let me know if that fixes your problem.  If not then you should at least see the new exception that I added, which might make debugging easier. ",
            "author": "Michael Busch",
            "id": "comment-12995201"
        },
        {
            "date": "2011-02-20T11:32:47+0000",
            "content": "I fixed a bug in FieldInfos that could lead to wrong field numbers, that might have been related to the wrong behavior you're seeing, Simon\n\nah that could be the reason. I will need to patch my branch again to see if your patch helps. Will do tomorrow.\n\n\nAbout codecIds: I made the fix to FieldInfo.clone() to set the codecId on the clone. I also made FieldInfo.codecId private and added getter and setter. The setter checks whether the new value for codecId is different from the previous one, and throws in exception in that case (unless it was set to the default 0 before, which I think means Preflex codec).\n\nThe clone issue seems to be fixed in your latest patch. While the setter seems kind of wrong. Lemme explain how that numbering works. If you create a SI for a flushed segment SegmentCodecs creates an ordinal for each codec and sets it to the corresponding fields. The ordinal (codecID) is the array index in the SegmentCodec's Codec array which holds the codec instance used for that field. So codecID = 0 is a valid value for segments having PreFlex or a >= 4.0 codec. But if we open a segment that is pre-flex there will only be one codec for the entire segment with codecID=0, thats why this is assigned. (Note: I need to document this where its set!) I think we should initialize the codecID with a different value and replace the this.codecId != 0 check with something like this.codecId != -1. Maybe we should just use an assert here instead of an exception, this is somewhat internal though.\n\n\nAll tests pass. Please let me know if that fixes your problem. If not then you should at least see the new exception that I added, which might make debugging easier.\n\nWill do tomorrow! What exactly was the problem with the previous patch beside the codecID clone issue? ",
            "author": "Simon Willnauer",
            "id": "comment-12997129"
        },
        {
            "date": "2011-02-21T01:27:43+0000",
            "content": "I think we should initialize the codecID with a different value and replace the this.codecId != 0 check with something like this.codecId != -1.\n\nYeah, I had the same though.  I changed it to use -1 and use an assert now instead of throwing the exception.\n(will post the new patch shortly)\n\nWhat exactly was the problem with the previous patch beside the codecID clone issue?\n\nNot sure if that's what caused your codecID issues, but the previous patch had a problem with assigning field numbers.  It could happen that a global number for a FieldInfo was acquired, but that number wasn't available anymore in the local FieldInfos.  I think this would be quite rare, but now I'm preventing this from happening. ",
            "author": "Michael Busch",
            "id": "comment-12997252"
        },
        {
            "date": "2011-02-21T01:29:34+0000",
            "content": "\n\tUses -1 now as initial value for codecID.\n\tupdated to current trunk\n\n\n\nLet me know if it works without problems now in the doc values branch, Simon! ",
            "author": "Michael Busch",
            "id": "comment-12997253"
        },
        {
            "date": "2011-02-21T17:18:37+0000",
            "content": "Uses -1 now as initial value for codecID.\nalright that looks good!\n\nLet me know if it works without problems now in the doc values branch, Simon!\nthis looks good now. I think we need to add a CHANGES.TXT entry for this issue since it changes the runtime behavior. +1 to commit Nice work! ",
            "author": "Simon Willnauer",
            "id": "comment-12997475"
        },
        {
            "date": "2011-02-21T18:55:26+0000",
            "content": "Committed revision 1073110.\n\nThanks for reviewing the patch, Simon! ",
            "author": "Michael Busch",
            "id": "comment-12997522"
        },
        {
            "date": "2011-02-26T17:50:21+0000",
            "content": "One question: we seem to have lost DocFieldProcessorPerThread.trimFields?\n\nIf an app indexes docs where each doc has different fields... does this mean we are not going to reclaim the DFPPerField for the fields that are no longer seen after flushing?  Ie, would it be a memory leak?  Somewhere we have a test case for this I think. ",
            "author": "Michael McCandless",
            "id": "comment-12999809"
        },
        {
            "date": "2011-02-26T21:56:21+0000",
            "content": "One question: we seem to have lost DocFieldProcessorPerThread.trimFields?\n\nI actually renamed it to doAfterFlush().  It now resets the whole hashmap in DocFieldProcessorPerThread, because we don't want to carry over any field settings into the next segment anymore with per-segment FieldInfos.  I think this should be fine? ",
            "author": "Michael Busch",
            "id": "comment-12999848"
        },
        {
            "date": "2011-02-27T10:54:40+0000",
            "content": "I actually renamed it to doAfterFlush(). It now resets the whole hashmap in DocFieldProcessorPerThread, because we don't want to carry over any field settings into the next segment anymore with per-segment FieldInfos. I think this should be fine?\n\nAhh, good, I think you're right!  I missed that we clear this on flush. ",
            "author": "Michael McCandless",
            "id": "comment-12999928"
        },
        {
            "date": "2011-02-28T07:30:17+0000",
            "content": "I mentioned on dev that assigning the same field number across segments is best effort now and wanted to explain in greater detail here how it works:\n\nThere is now a global fieldName <-> fieldNumber bi-map in FieldInfos, which contains all fieldName/number pairs seen in a IndexWriter session.  It is passed into each new FieldInfos that is created in the same IndexWriter session.\n\nAlso, when a new IndexWriter is opened, the FieldInfos of all segments are read and the global map created - this is tested in a new unit test this issue adds.\n\nA FieldInfos has in addition to the reference to the global map also a \"private\" map, which holds all FieldInfo objects that belong to the corresponding segment (remember there's now a 1-1 mapping SegmentInfo->FieldInfos).  \n\nNow the fieldNumber assignment strategy works as follows:  If a new FI is added to FieldInfos, the global map is checked for the number of that field.  If the field name hasn't been seen before, the smallest number available in the local map is picked (to keep the numbers dense).  \nOtherwise, if we have seen the field before, the global number is used.  The problem now might be, that the global number might already be taken in the local FieldInfos.  In this case the global and local numbers for the same fieldName would differ.  This is not a problem in terms of correctness, but could prevent that field from being efficiently bulk-merged.\n\nWith DocumentsWriterPerThreads (DWPTs) in mind I don't see how we could guarantee consistent field numbering across DWPTs, that's why I implemented it in this \"best effort\" way.\n\nHere's an example on how we can get into a situation where a field would get different numbers in different segments:\nsegment_1 has fields A and B, therefore these mappings A -> 1, B -> 2.\nNow in segment_2 the first field we add is C, which hasn't been seen ever before, so we pick locally number 1 for it.  Then we add the next document which has field A, but since number 1 is already taken, it would get a different number than in segment_1.  This means A would not get bulk merged.\n\nHmm, after writing this example down I'm realizing that it would be better to just always pick the next available global field number for a new field, then, at least until we get DWPTs, we should never get different numbers across segments, I think?  The disadvantage would be that FieldInfos could have \"gaps\" in the numbers.  I implemented the current approach because I wanted to avoid those gaps, but having them would probably not be a big deal? ",
            "author": "Michael Busch",
            "id": "comment-13000153"
        },
        {
            "date": "2011-02-28T08:53:18+0000",
            "content": "Thanks for the clarification, michael!\n\n... the smallest number available in the local map is picked (to keep the numbers dense). ...\nOh man I was not aware of this. I got totally confused... see next comment\n\n\nHmm, after writing this example down I'm realizing that it would be better to just always pick the next available global field number for a new field, then, at least until we get DWPTs, we should never get different numbers across segments, I think? The disadvantage would be that FieldInfos could have \"gaps\" in the numbers. I implemented the current approach because I wanted to avoid those gaps, but having them would probably not be a big deal?\n\nThis is how I thought it works but I obviously got confused by global vs. local this is also why I had trouble to understand how that failure could ever have happened. But after looking at the code again this makes sense  I don't see any problems in FieldInfo number gaps. this should work just fine and guarantee the bulk copy just for now at least.\n ",
            "author": "Simon Willnauer",
            "id": "comment-13000180"
        },
        {
            "date": "2011-02-28T09:24:26+0000",
            "content": "Reopening to make the described improvement that ensures consistent field numbers. ",
            "author": "Michael Busch",
            "id": "comment-13000184"
        },
        {
            "date": "2011-02-28T09:26:00+0000",
            "content": "I don't see any problems in FieldInfo number gaps. this should work just fine and guarantee the bulk copy just for now at least.\n\nI was thinking that we probably write field numbers as VInts in a lot of places, and it would therefore be less efficient to have gaps... but this is probably negligible. ",
            "author": "Michael Busch",
            "id": "comment-13000185"
        },
        {
            "date": "2011-02-28T11:15:54+0000",
            "content": "This was an impressive change   Not only did we shift FieldInfos under SegmentInfo, we also fixed a given FieldInfos to allow for sparse mapping (ie, it only contains certain field numbers).  Various places previously assumed this was a dense mapping.\n\nI think even in the DWPT case we should try to assign consistent field numbers?  I'm already worried enough about the possible perf hit DWPT will put on normal indexing and the NRT case, since it basically pushes merging out from RAM and onto the \"normal\" more costly disk based merging.  If we also suddenly risk these merges not being bulk merges, that's even worse.\n\nCan't we sync globally on the assignment of field name -> number (the global map lookup)?  And FieldInfos per-DWPT would share the same global map.  Wouldn't that keep us consistent in the DWPT case? ",
            "author": "Michael McCandless",
            "id": "comment-13000229"
        },
        {
            "date": "2011-02-28T18:04:14+0000",
            "content": "Can't we sync globally on the assignment of field name -> number (the global map lookup)?  And FieldInfos per-DWPT would share the same global map.  Wouldn't that keep us consistent in the DWPT case?\n\n\nYes.  The global map is already shared across DWPTs and the lookup is synchronized on the global map.  I think if we change the logic to always pick the next available global number we would increase the likelihood that fields get bulk-merged.\n\nIt can't be perfect though, because e.g. if you use addIndexes() to add an external segment that has a different field number assignment.  That's why we definitely have to keep the code that can fallback to  a different local number if it's not possible to use the global number in a segment.  But I agree that we should optimize for the \"normal\" indexing case.  And it seems like we all agree that field number gaps are fine. ",
            "author": "Michael Busch",
            "id": "comment-13000438"
        },
        {
            "date": "2011-02-28T22:39:09+0000",
            "content": "For the record, robert reverted the changes made by this issue since we have been experiencing a fair bit of problems lately. \n\neventually reproducible with:\n\nant test -Dtestcase=SimpleFacetsTest -Dtestmethod=testFacetSingleValued -Dtests.seed=-4971136915249645135:5200209917417531291 -Dtests.multiplier=3\n\nant test -Dtestcase=SimpleFacetsTest -Dtestmethod=testFacetSingleValuedFcs -Dtests.seed=-4971136915249645135:-3738166620811568832 -Dtests.multiplier=3\n\nant test -Dtestcase=SimpleFacetsTest -Dtestmethod=testFacetPrefixMultiValued -Dtests.seed=-4971136915249645135:4594369826150277150 -Dtests.multiplier=3\n\nant test -Dtestcase=SimpleFacetsTest -Dtestmethod=testFacetPrefixSingleValued -Dtests.seed=-4971136915249645135:-7702531001769827248 -Dtests.multiplier=3\n\nant test -Dtestcase=SimpleFacetsTest -Dtestmethod=testFacetPrefixSingleValuedFcs -Dtests.seed=-4971136915249645135:698398490325732548 -Dtests.multiplier=3\n\n\n\n\nI found the problem causing this where certain field numbers got mixed up when the FieldInfos get build initially in IndexWriter and a segment is loaded first which had gaps in its field numbering. \nFieldInfos is ignoring the FieldInfo's number if the FieldInfo does not exist yet and tries to assigne a new \"local\" field number. But if the next available field number x while the actual FI's number was > x+1 the new added FI will be set to x instead.\n\nin other words, lets say we have 2 segments:\n\n seg1 : { fields : [(a:0, c:2)] } \n seg2 : { fields : [(a:0, b:1, c:2)] } \n\n\nif we load seg1's FI we end up with \n\n\nfields : [(a:0, c:1)] \n\n\nthen we add seg2's FI's and end up with \n\n\nfields : [(a:0, c:1, b:2)] \n\n\nthis will also explain the TestNRTThreads.testNRTThreads failure where bulkMerge could not be applied due to different field numbers across segments.\n\nI will upload a patch tomorrow. ",
            "author": "Simon Willnauer",
            "id": "comment-13000581"
        },
        {
            "date": "2011-03-01T14:11:31+0000",
            "content": "Here is an updated patch against trunk that fixes the problems we had with SimpleFacetsTest. \nI added a testcase that triggered anyNonBulkMerges to be false as well as field number to be mixed up across segments. This patch also tracks the fieldNumbers globally within a IW session.\n\nI have been running tests with while(true) \n{ ant clean test }\n on a top level directory without any failure for 12 hours now. Aside of that the testcase I added failed reliably with the previous version and it explains all failures we have see so far especially the one with NRTThreads. ",
            "author": "Simon Willnauer",
            "id": "comment-13000885"
        },
        {
            "date": "2011-03-01T18:33:59+0000",
            "content": "Unfortunately, I'm still seeing the assert trip (that there are no non-bulk merges) in TestNRTThreads.  Took beast a while to repro but eventually it did...\n\nI'm also seeing this in TestIndexWriterExceptions:\n\n\nNOTE: reproduce with: ant test -Dtestcase=TestIndexWriterExceptions -Dtestmethod=testDocumentsWriterExceptions -Dtests.seed=-1056365072156857559:-3700694839465596125\n\n\nThere was 1 failure:\n1) testDocumentsWriterExceptions(org.apache.lucene.index.TestIndexWriterExceptions)\njava.io.FileNotFoundException: _1.tvx\n\tat org.apache.lucene.store.RAMDirectory.fileLength(RAMDirectory.java:147)\n\tat org.apache.lucene.store.MockDirectoryWrapper.fileLength(MockDirectoryWrapper.java:524)\n\tat org.apache.lucene.index.SegmentInfo.sizeInBytes(SegmentInfo.java:290)\n\tat org.apache.lucene.index.LogMergePolicy.sizeBytes(LogMergePolicy.java:211)\n\tat org.apache.lucene.index.LogByteSizeMergePolicy.size(LogByteSizeMergePolicy.java:45)\n\tat org.apache.lucene.index.LogMergePolicy.useCompoundFile(LogMergePolicy.java:165)\n\tat org.apache.lucene.index.DocumentsWriter.flush(DocumentsWriter.java:629)\n\tat org.apache.lucene.index.IndexWriter.doFlush(IndexWriter.java:2538)\n\tat org.apache.lucene.index.IndexWriter.flush(IndexWriter.java:2503)\n\tat org.apache.lucene.index.IndexWriter.closeInternal(IndexWriter.java:1077)\n\tat org.apache.lucene.index.IndexWriter.close(IndexWriter.java:1041)\n\tat org.apache.lucene.index.IndexWriter.close(IndexWriter.java:1005)\n\tat org.apache.lucene.index.TestIndexWriterExceptions.testDocumentsWriterExceptions(TestIndexWriterExceptions.java:565)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)\n\tat java.lang.reflect.Method.invoke(Method.java:597)\n\tat org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:44)\n\tat org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:15)\n\tat org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:41)\n\tat org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:20)\n\tat org.junit.rules.TestWatchman$1.evaluate(TestWatchman.java:48)\n\tat org.junit.internal.runners.statements.RunBefores.evaluate(RunBefores.java:28)\n\tat org.junit.internal.runners.statements.RunAfters.evaluate(RunAfters.java:31)\n\tat org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:76)\n\tat org.apache.lucene.util.LuceneTestCase$LuceneTestCaseRunner.runChild(LuceneTestCase.java:1213)\n\tat org.apache.lucene.util.LuceneTestCase$LuceneTestCaseRunner.runChild(LuceneTestCase.java:1145)\n\tat org.junit.runners.ParentRunner$3.run(ParentRunner.java:193)\n\tat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:52)\n\tat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:191)\n\tat org.junit.runners.ParentRunner.access$000(ParentRunner.java:42)\n\tat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:184)\n\tat org.junit.internal.runners.statements.RunBefores.evaluate(RunBefores.java:28)\n\tat org.junit.internal.runners.statements.RunAfters.evaluate(RunAfters.java:31)\n\tat org.junit.runners.ParentRunner.run(ParentRunner.java:236)\n\tat org.junit.runners.Suite.runChild(Suite.java:128)\n\tat org.junit.runners.Suite.runChild(Suite.java:24)\n\tat org.junit.runners.ParentRunner$3.run(ParentRunner.java:193)\n\tat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:52)\n\tat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:191)\n\tat org.junit.runners.ParentRunner.access$000(ParentRunner.java:42)\n\tat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:184)\n\tat org.junit.runners.ParentRunner.run(ParentRunner.java:236)\n\tat org.junit.runner.JUnitCore.run(JUnitCore.java:157)\n\tat org.junit.runner.JUnitCore.run(JUnitCore.java:136)\n\tat org.junit.runner.JUnitCore.run(JUnitCore.java:117)\n\tat org.junit.runner.JUnitCore.runMain(JUnitCore.java:98)\n\tat org.junit.runner.JUnitCore.runMainAndExit(JUnitCore.java:53)\n\tat org.junit.runner.JUnitCore.main(JUnitCore.java:45)\n\nFAILURES!!!\n\n\n\nThe failure reproduces for me (with the above seed)... ",
            "author": "Michael McCandless",
            "id": "comment-13001009"
        },
        {
            "date": "2011-03-01T18:38:36+0000",
            "content": "Also, I think we should understand why Solr's SimpleFacetsTest failed from the previous patch and hopefully make a standalone test showing the problem (and that we fixed it!). ",
            "author": "Michael McCandless",
            "id": "comment-13001010"
        },
        {
            "date": "2011-03-01T18:41:02+0000",
            "content": "\nThis is a big patch!  Some comments...:\n\n\n\tDo we even use FieldInfos.add(Document)?  Maybe we can remove\n    it...\n\n\n\n\n\tFieldNumberBiMap.addOrGet doesn't need to take the FieldInfoBiMap?\n    (It's an unused param).\n\n\n\n\n\tWhy create the FieldInfoBiMap class?  Ie, why not \"merge\" that\n    back into FieldInfos itself (like it used to be)?  (I understand\n    why we need FieldNumberBiMap \u2013 so we can share a single instance\n    across FieldInfos).\n\n\n\n\n\tWe mix up autoboxing then unboxing, eg\n    FieldInfos.addOrUpdateInternal takes int preferredFieldNumber,\n    which is boxed when calling localFieldInfos.nextFieldNumber, then\n    manually unboxed on calling globalFieldNumbers.addOrGet.\n\n\n\n\n\tOn working with a pre-4.0 index that has non-congruent assignments\n    across segments... I fear we may not necessarily ever \"stabilize\" on\n    a fixed global name/number bimap, because we re-compute this map\n    on every IW init?  Ie, when you first open 4.0 IW on pre-4.0\n    index, you'll compute a certain global map, and write new segs\n    with those bindings.  But say some fields differed in their\n    assignment... but then some of those conflicting segs are merged.\n    Later, when you open the IW again, you'll get a different global\n    map?  And write new segments conflicting with the previous new\n    segments you had written?\n\n\n\n\n\tThe fact that SegmentInfo.clearFilesCache is now a public API and\n    consumer is responsible for knowing when to call this\n    is... spooky.  Previously this cache was a fully private thing (ie\n    invalidated whenever a change was made to the SegmentInfo).  But I\n    don't see any way around it; since we now embed a FieldInfos and\n    that FieldInfos (hasVectors) could change... maybe, whenever we\n    call this method, add a comment explaining why?\n\n\n\n\n\tIt makes me nervous that the API that's allowed to pick a new\n    field number (FieldInfo.addInternal) is the same API that used\n    when reading a FieldInfos from _X.fnm (when we better not pick a\n    different field number!).  In theory of course those\n    field numbers will never conflict and we'll always get our\n    preferred field number... but still.  Maybe add an assert in\n    FieldInfos.read() verifying we always get that field number?\n\n\n\n\n\tThe call to localFieldInfos.setIfNotSet in FieldInfos.addInternal\n    makes me nervous... is it actually possible for it to already be\n    set, to a conflicting binding?  Shouldn't it always match? (Ie,\n    above, in addOrUpdateInternal, we just consulted the global map to\n    get the binding).  Can't we assert the global binding is either\n    not present (and we add it) or if it is present it \"matches\"?\n\n\n\n\n\tWhy do we have FieldInfos.clearVectors?  Nobody should call\n    that...?\n\n\n\n\n\tIt's not great that we open then close the CFS reader inside\n    SegmentInfo, just to read the FieldInfos.  Ie, this means on\n    opening an SR we will open this CFS reader twice... it also means\n    that opening a SegmentInfos is quite a bit more costly than it\n    used to be.  EG creating an IW must now go and open/close a CFS reader\n    per-segment... not sure what we can really do about that\n    though... maybe, we should store the FieldInfos inside the\n    segments file?  Hmmm....\n\n\n\n\n\tShouldn't IndexWriter.getFieldInfos(SegmentInfo) use the\n    SegmentInfo's fieldInfos rather than loading it again from the\n    directory...?\n\n\n\nIndentation is also off in various places, for us lonely people who\nstill use Emacs  ",
            "author": "Michael McCandless",
            "id": "comment-13001011"
        },
        {
            "date": "2011-03-02T00:47:11+0000",
            "content": "maybe, we should store the FieldInfos inside the segments file? Hmmm....\n\nI had the same thought while adding the ref to FieldInfos to SegmentInfo.  Actually this is probably the right thing to do.  At the same time we could switch to a human-readable format \n\n\nI fear we may not necessarily ever \"stabilize\" on a fixed global name/number bimap, because we re-compute this map on every IW init?\n\nWe could also store the global map on disk?  addIndexes() would have to ignore the global map from the external index(es).\n ",
            "author": "Michael Busch",
            "id": "comment-13001214"
        },
        {
            "date": "2011-03-02T11:08:14+0000",
            "content": "I had the same thought while adding the ref to FieldInfos to SegmentInfo. Actually this is probably the right thing to do. At the same time we could switch to a human-readable format \n\nHuman-readable format would be sweet \n\nThough I'm still generally nervous that this means just opening the segments file will become quite a bit more costly.  Apps that have many fields will be especially penalized, though, apps really should not be creating so many fields.\n\nWe could also store the global map on disk?\n\nThat's an interesting idea?  That'd ensure stability on the bindings, even for pre-4.0 indices.  This way a pre-4.0 index would gradually work itself towards being fully consistent...\n\naddIndexes() would have to ignore the global map from the external index(es).\n\nWell, addIndexes(IR[]) would get fully remapped to the correct bindings?  (since it's a real merge).\n\nBut, yes, addIndexes(Dir[]) would not \u2013 they are just file-copied.  Hmm, they'd also presumably have a different global map, so if we stored the index global map in the Directory, how would we resolve conflicts on the incoming addIndexes...?  I guess the local mapping for the incoming segments would override the global one, on conflict. ",
            "author": "Michael McCandless",
            "id": "comment-13001372"
        },
        {
            "date": "2011-03-02T15:02:10+0000",
            "content": "w.r.t. storing FielInfos in the segments file - don't we get some consistency benefit from the segments file being small (i.e. it's all in one disk block so it either gets written in it's entirety or not, and readers will see all of it, or not)? ",
            "author": "Yonik Seeley",
            "id": "comment-13001443"
        },
        {
            "date": "2011-03-02T18:43:10+0000",
            "content": "\nUnfortunately, I'm still seeing the assert trip (that there are no non-bulk merges) in TestNRTThreads. Took beast a while to repro but eventually it did...\n\nthis is a problem we have seen before. This is an exception where we write a single doc segment and fail inverting the doc after FI has been updated. Since hasVectors has been moved to FI out of SI this is inconsistent and the TV tries to open the files since hasVectors is true. \n\nThis is also why buschmi added clearVectors (just as a workaround afaik)\n\nAlso, I think we should understand why Solr's SimpleFacetsTest failed from the previous patch and hopefully make a standalone test showing the problem (and that we fixed it!).\n\nman I still try to trigger it in isolation but I can spend too much time on that right now. Got sucked into Tiered Flushing \n\nAbout the other comments (the big bulletpoint list) - in the meanwhile I think we should split this up in several smaller issues. \n\n\tstart with resetting the FI after flush to make the flags consistent for each segment\n\tmove FIs into SI with hasVectors etc still in SI\n\tfactor hasVectors out of SI into FI\n\tintroduce a global field num map (maybe on realtime first?) and / or store global map\n\t...\nWe can still use this patch as a PoC does that make sense?\n\n\n ",
            "author": "Simon Willnauer",
            "id": "comment-13001534"
        },
        {
            "date": "2011-03-02T20:09:23+0000",
            "content": "\nw.r.t. storing FielInfos in the segments file - don't we get some consistency benefit from the segments file being small (i.e. it's all in one disk block so it either gets written in it's entirety or not, and readers will see all of it, or not)?\n\nI think we have three options here:\n1) Store FIs inside of compound file (current patch)\n2) Store FIs in SI\n3) Store FIs in own file outside of compound file\n\nEach has disadvantages:\n\n1) more expensive to open SegmentInfos, as it now has to open cfs files to load FIs\n2) SI files becomes bigger\n3) one more file descriptor per segment - but can be closed as soon as FIs was read into memory ",
            "author": "Michael Busch",
            "id": "comment-13001590"
        },
        {
            "date": "2011-03-17T14:53:40+0000",
            "content": "Attached next iteration.\n\n\n\tmerged FieldInfoBiMap into FieldInfos\n\tfixed AutoBoxing issues\n\treverted the deprecation of SegmentInfo#hasVector / hasProx since they where causing many failures due to missing files on exceptions. This also allowed me to make SegmentInfo.clearFilesCache private again.\n*the FieldInfoBiMap now asserts that if you add a field via setIfNotSet that if either the number or the name exists they are the same as in the mapping.\n\tadded lazy loading of FieldInfos in SegmentInfo to prevent opening the CFS file while opening SegmentInfo. SR#CoreReader now passes in the already opened CFSReader to load the FieldInfos\n\twhen we open a IW we load the BiMap directly from the SegmentInfos\n\n\n\n\n\tSegmentInfos now owns the FieldInfoBiMap and writes the map upon commit into an additional .fnx file outside of the CFS file. The SegmentInfos persist the bimap only if it has changed otherwise references the previously written map.\n\n\n\nI still have one nocommit since I want to add more tests for the persisted global map. Beside that all tests pass and I would appreciate a review though.\nMike would you be so kind and let beast break it?\n ",
            "author": "Simon Willnauer",
            "id": "comment-13007938"
        },
        {
            "date": "2011-03-17T20:34:00+0000",
            "content": "Mike would you be so kind and let beast break it?\n\nBeast ran Lucene's core+contrib tests 398 times!\n\nThere was one failure, but I suspect it's unrelated.  I'll open a separate issue... ",
            "author": "Michael McCandless",
            "id": "comment-13008116"
        },
        {
            "date": "2011-03-18T08:58:49+0000",
            "content": "Beast ran Lucene's core+contrib tests 398 times!\n\nawesome. Thanks for letting it chew on that patch for a while. \n\nI added more tests to ensure field numbers are stable and some jdoc comments to package private apis. This patch also (hopefully) solves all indentation issues.\n ",
            "author": "Simon Willnauer",
            "id": "comment-13008375"
        },
        {
            "date": "2011-03-18T17:29:52+0000",
            "content": "Patch looks much better \u2013 I think it's close!  Comments:\n\n\n\tI think we should put header (id + version, ie\n    CodecUtil.write/readHeader) on fnx file?\n\n\n\n\n\tWhen does FieldNumberBiMap init from another...?  (We have ctor\n    that takes a FieldNumberBiMap in... but I don't see who uses\n    that).\n\n\n\n\n\tWho uses BiMap.entries()?  Looks like just for testing?  Can you\n    add comment saying \"just for testing..\"?\n\n\n\n\n\tFieldInfos ctor that loads from index file name but makes a new\n    bimap seems spooky...?  Is this only used by tests now...?\n\n\n\n\n\tThe passed in \"version\" to SIS.readGlobalFieldMap is unused\n\n\n\n\n\tI'm a little worried that we name the new file _X.fnx, because it\n    will appear that this file 'belongs' to segment X, which is\n    dangerous because in some recovery cases we will remove all\n    files associated w/ a given segment (ie, _X.*).  Maybe, we can\n    name it without the leading _?  Ie, 0.fnx, 1.fnx, etc.?\n\n\n\n\n\tIn IW.getGlobalFieldNumberMap... shouldn't that \"legacy\" logic be\n    moved inside SegmentInfos?  Ie it's a bit weird now how we first\n    pull an (empty) biMap from the legacy SegmentInfos then we go and\n    populate it ourselves...?  Then we don't need this method in IW\n    (we just ask the SIS for the bimap).\n\n\n\n\n\tShould FieldInfo.putInternal(FieldInfo) assert that the global\n    bimap \"matches\"?  (Ie, it makes no effort to update the global\n    bimap).\n\n\n\n\n\tThe addition of \"si.hasProx = hasProx\" in SegmentInfo.clone isn't\n    needed; we pass hasProx to the ctor of that si.\n\n\n\n\n\tWhy do we default SegmentInfos.format now...?  Seems spooky?\n\n\n\n\n\tIn SegmentInfos.rollbackCommit shouldn't we set the\n    pendingMapVersion to -1?\n\n\n\nShould we backport this to 3.x (after sufficient aging)? ",
            "author": "Michael McCandless",
            "id": "comment-13008530"
        },
        {
            "date": "2011-03-18T18:02:19+0000",
            "content": "\nI think we should put header (id + version, ie\nCodecUtil.write/readHeader) on fnx file?\nman, I told myself to add it about 10 times during that patch \n\nWhen does FieldNumberBiMap init from another...? \nah legacy\n\n\nI'm a little worried that we name the new file _X.fnx, because it\nwill appear that this file 'belongs' to segment X, which is\ndangerous because in some recovery cases we will remove all\nfiles associated w/ a given segment (ie, _X.*). Maybe, we can\nname it without the leading _? Ie, 0.fnx, 1.fnx, etc.?\nright, good catch! that we can simple remove and then it should be clear that its not a file belonging to a certain segment\n\nIn IW.getGlobalFieldNumberMap... shouldn't that \"legacy\" logic be....\nyeah thats is where is should be though. I will move it in.\n\nThe addition of \"si.hasProx = hasProx\" in SegmentInfo.clone isn't...\ntrue I will remove\nWhy do we default SegmentInfos.format now...? Seems spooky?\nthis hasn't been used in SIS before so I think it didn't matter before.\nYet, I check the format in files() so if you create the SIS without reading it its set to 0. I can certainly make that work with default to 0 but it seemed just natural to have it assigned the current_format. I think its fine....\n\nIn SegmentInfos.rollbackCommit shouldn't we set the pendingMapVersion to -1\nah good catch! thanks\n\nI will fix those issues and upload another patch. Thanks mike for reviewing!!!!\n ",
            "author": "Simon Willnauer",
            "id": "comment-13008550"
        },
        {
            "date": "2011-03-18T18:03:29+0000",
            "content": "Should we backport this to 3.x (after sufficient aging)?\nI think we should let it bake in first though. Maybe we can also factor out the hasVectors in another issues and then backport both once they have been random-tested for a little while. ",
            "author": "Simon Willnauer",
            "id": "comment-13008552"
        },
        {
            "date": "2011-03-19T14:34:28+0000",
            "content": "\nWhy do we default SegmentInfos.format now...? Seems spooky?\n\nthis hasn't been used in SIS before so I think it didn't matter before.\nYet, I check the format in files() so if you create the SIS without reading it its set to 0. I can certainly make that work with default to 0 but it seemed just natural to have it assigned the current_format. I think its fine....\n\nAhh, I see: it's for the case where we make a new SIS() in RAM, because we'll now look @ the format in files().  OK this sounds right then.\n\n\nShould we backport this to 3.x (after sufficient aging)?\n\nI think we should let it bake in first though. Maybe we can also factor out the hasVectors in another issues and then backport both once they have been random-tested for a little while.\n\nDefinitely let it bake!\n\nAlso, I have lots of pending backports to 3.2... which this patch likely overlaps on, so we should try to do them \"in order\" to reduce conflicts I think. ",
            "author": "Michael McCandless",
            "id": "comment-13008777"
        },
        {
            "date": "2011-03-19T14:36:29+0000",
            "content": "Hmm, but: if we open a pre-4.0 SIS, make changes, write a new SIS (commit), do we change that new instance's format to 4.0 (in RAM)?  Ie, so that files() is correct...? ",
            "author": "Michael McCandless",
            "id": "comment-13008778"
        },
        {
            "date": "2011-03-20T08:46:26+0000",
            "content": "if we open a pre-4.0 SIS, make changes, write a new SIS (commit), do we change that new instance's format to 4.0 (in RAM)? Ie, so that files() is correct...?\n\nhmm actually we don't while the DefaultSIWriter changes it upon write which is not reflected to ram. We might should do that either before we write in DSIWriter. The other thing is that we should carry over the format from the oldSegment in the case we open a specific commit point. I will write a test first that hopefully triggers a fail and fix that accordingly. ",
            "author": "Simon Willnauer",
            "id": "comment-13008892"
        },
        {
            "date": "2011-03-21T13:28:08+0000",
            "content": "next iteration, I think we are ready to commit here. I added a couple of testcases regarding the fnx file and made sure they get deleted accordingly even if we fail with Exceptions during prepareCommit & finishCommit. Moved the BW-Compat code for building the initial global map to SegmentInfos and cleaned up assertions in FieldInfos (also added the suggested assertion to FIs#putInternal). To prevent that we miss a fnx file if we open an old index, write the fnx file and keep that SIS in memory with format set to some old version I removed the check if we are on 4.0 index but used the latestGlobalFieldNumberVersion which is kept consistent and only include the file if its not set to 0.\n\nI run whileTrue tests on this patch now for a while and things are looking good from my side. Mike if you have time let beast chew it again. If its fine I will commit tomorrow. ",
            "author": "Simon Willnauer",
            "id": "comment-13009122"
        },
        {
            "date": "2011-03-21T20:07:00+0000",
            "content": "OK beast chewed on this for a few hours \u2013 ran all (Lucene + Solr)\ntests 144 times.\n\nThe UIMAUpdateRequestProcessorTest had a number of failures, but I\nsuspect they are unrelated. (They could also be due to how I run the\ntest \u2013 I'm using the python runner from luceneutil).\n\nSo I think it's good!  I'll review the patch one more time... ",
            "author": "Michael McCandless",
            "id": "comment-13009340"
        },
        {
            "date": "2011-03-22T09:59:26+0000",
            "content": "Patch looks great!  Only a few things:\n\n\n\tWe still need a header (id + version) on the fnx file?\n\n\n\n\n\tFieldInfos ctor that loads from index file name but makes a new\n    bimap seems spooky...? Is this only used by tests now...?\n\n\n\n\n\tCan you add a comment where we create the N.fnx name, explaining\n    why it has no leading _?  (ie, because it's not a per-segment\n    file, but rather a global file, shared by multiple segments)\n\n\n\n\n\tIn CHANGES entry, persistend is mis-spelled (need to drop the n);\n    also remove the _ from _X.fnx, and add . after \"successful commit\".\n\n ",
            "author": "Michael McCandless",
            "id": "comment-13009599"
        },
        {
            "date": "2011-03-22T10:48:55+0000",
            "content": "We still need a header (id + version) on the fnx file?\nits there I guess you got the wrong patch.\n\n\nFieldInfos ctor that loads from index file name but makes a new\nbimap seems spooky...? Is this only used by tests now...?\n\nWell this on is only for the read case where we open a FIS. Yet, we need to do this since we store a fnx file per SIS and upon IW#addIndexed(Directory) we could have a FIS that has field number different to the global map. This is fine as long as we don't seed the FIS on read. I will open another issue to make this case more efficient and assert that the FIS is read-only once we created the FIS from a directory.\n\nI fixed all the remaining issues and will go ahead and commit now. Thanks mike ",
            "author": "Simon Willnauer",
            "id": "comment-13009610"
        },
        {
            "date": "2011-03-22T17:06:57+0000",
            "content": "Committed to trunk - I will keep this open until RT and docvalues have synced up with it. ",
            "author": "Simon Willnauer",
            "id": "comment-13009718"
        },
        {
            "date": "2011-03-30T13:37:10+0000",
            "content": "merged to docvalues and realtime branch. ",
            "author": "Simon Willnauer",
            "id": "comment-13012954"
        }
    ]
}