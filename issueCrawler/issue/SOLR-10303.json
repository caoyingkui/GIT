{
    "id": "SOLR-10303",
    "title": "Add date/time Stream Evaluators",
    "details": {
        "labels": "",
        "priority": "Major",
        "components": [],
        "type": "New Feature",
        "fix_versions": [
            "6.6",
            "7.0"
        ],
        "affect_versions": "None",
        "resolution": "Resolved",
        "status": "Closed"
    },
    "description": "This ticket will add Stream Evaluators that extract date/time values from a Solr date field. The following Evaluators will be supported:\n\nhour (date)\nminute (date)\nmonth (date) \nmonthname(date) \nquarter(date) \nsecond (date)\nyear(date)\n\nSyntax:\n\n\nselect(id,\n       year(recdate) as year,\n       month(recdate) as month,\n       day(recdate) as day,\n       search(logs, q=\"blah\", fl=\"id, recdate\", sort=\"recdate asc\", qt=\"/export\"))",
    "attachments": {},
    "issue_links": {},
    "comments": [
        {
            "date": "2017-03-17T13:12:13+0000",
            "content": "I started working on this.  With support for:\n\nyear, month, day, dayofyear, dayofquarter, hour, minute, quarter, week, second, epoch\n\n\nInitially supporting a String field but I am hoping to add Date, Instant support.\nhttps://github.com/covolution/lucene-solr/tree/SOLR-10303 ",
            "author": "Gethin James",
            "id": "comment-15929941"
        },
        {
            "date": "2017-03-17T13:26:00+0000",
            "content": "Can we call this a DatePartEvaluator?\n\nThis seems to only work on field values (via the field name). There'll need to be support for acting on the results of other evaluators. ",
            "author": "Dennis Gove",
            "id": "comment-15929963"
        },
        {
            "date": "2017-03-17T16:19:46+0000",
            "content": "I renamed the evaluator as suggested and added support for Instant, Date, LocalDateTime.  \n\nI was wondering if there's an advantage to extending NumberEvaluator rather than SimpleEvaluator?  The code currently extends NumberEvaluator, hence only returns number, but this ticket mentions a \"monthname\" function; that suggests a need for a Locale and a return type of String. Possibly that's a different function? ",
            "author": "Gethin James",
            "id": "comment-15930237"
        },
        {
            "date": "2017-03-17T17:19:44+0000",
            "content": "Adding a patch file or would you prefer a pull request? ",
            "author": "Gethin James",
            "id": "comment-15930332"
        },
        {
            "date": "2017-03-20T03:48:35+0000",
            "content": "For the function names, any concern with using pascal casing for dayOfYear, dayOfMonth? That will be consistent with other multi-word cases in streaming. ",
            "author": "Dennis Gove",
            "id": "comment-15932130"
        },
        {
            "date": "2017-03-20T16:36:37+0000",
            "content": "GitHub user covolution opened a pull request:\n\n    https://github.com/apache/lucene-solr/pull/171\n\n    SOLR-10303\n\n    Adding date/time Stream Evaluators for year, month, day, dayOfYear, dayOfQuarter, hour, minute, quarter, week, second, epoch.\n\nYou can merge this pull request into a Git repository by running:\n\n    $ git pull https://github.com/covolution/lucene-solr SOLR-10303\n\nAlternatively you can review and apply these changes as the patch at:\n\n    https://github.com/apache/lucene-solr/pull/171.patch\n\nTo close this pull request, make a commit to your master/trunk branch\nwith (at least) the following in the commit message:\n\n    This closes #171\n\n\n\n ",
            "author": "ASF GitHub Bot",
            "id": "comment-15932996"
        },
        {
            "date": "2017-03-20T17:12:18+0000",
            "content": "We could do with some documentation! Here is a start:\n\nDate functions\nDate Stream Evaluators can be used to evaluate the date part of other field values in a tuple. Supported data types are String in the ISO_INSTANT date format, Instant, java.util.Date, LocalDateTime or an instance of TemporalAccessor.\n\neg.\n\nyear(fieldA)  //where fieldA is a field with a String in the ISO_INSTANT date format\nmonth(fieldA)\nhour(fieldA)\n\n\n\n\n\tyear - The year part of a date\n\tmonth - The month of the year\n\tday - The day of the month\n\tdayOfYear - The day of the year\n\tdayOfQuarter - The day of the quarter\n\thour - hour of the day, from 0 to 23.\n\tminute - minute of the hour\n\tquarter - quarter of the year\n\tweek -  Iso standard week of a year, 1 to 53 weeks.\n\tsecond - second of the minute\n\tepoch - number of milliseconds from the epoch\n\n ",
            "author": "Gethin James",
            "id": "comment-15933087"
        },
        {
            "date": "2017-04-03T22:31:49+0000",
            "content": "I really like the design of this. A couple things to think about:\n\n1) We could create the concept of a TupleContext, which the SelectStream passes to each evaluator. This will allow us to share LocalDateTime instances across date/time evaluators. The logic would be: check to see if the LocalDateTime for a specific field is already in the TupleContext, and use it rather then parsing a new Instant. The SelectStream would clear the TupleContext after each Tuple is read. This will speed up selects that call multiple date evaluators on the same field:\n\n\nselect(expr,\n          year(field1) as year,\n          month(field1) as month,\n          day(field1) as day)\n\n\n\nAlternatively we could create a TimeContext which would only be passed to DateTimeEvalutors, which wouldn't mean changing all the Evaluators to accept a TupleContext.\n\n2) I think we only need to support two formats to parse from: the date string format and the Long epoch time.  ",
            "author": "Joel Bernstein",
            "id": "comment-15954260"
        },
        {
            "date": "2017-04-05T14:19:21+0000",
            "content": "1) I like the idea of a TupleContext which the SelectStream can pass along.  Are you thinking that should be done as part of this ticket?  Currently the implementation just acts on tuple evaluations so there is nothing specific for SelectStream.\n2) The current implementation support a variety of types: String, Instant, Date, TemporalAccessor.  Its missing long support so I can add that. ",
            "author": "Gethin James",
            "id": "comment-15956929"
        },
        {
            "date": "2017-04-05T14:32:00+0000",
            "content": "In case you missed them, I added comments to the PR at https://github.com/apache/lucene-solr/pull/171 ",
            "author": "Dennis Gove",
            "id": "comment-15956946"
        },
        {
            "date": "2017-04-05T19:50:06+0000",
            "content": "Sorry, I can't find any comments on the pull request. ",
            "author": "Gethin James",
            "id": "comment-15957531"
        },
        {
            "date": "2017-04-05T19:53:04+0000",
            "content": "Github user dennisgove commented on a diff in the pull request:\n\n    https://github.com/apache/lucene-solr/pull/171#discussion_r107802207\n\n    \u2014 Diff: solr/core/src/java/org/apache/solr/handler/StreamHandler.java \u2014\n    @@ -199,10 +200,16 @@ public void inform(SolrCore core) {\n           .withFunctionName(\"mult\", MultiplyEvaluator.class)\n           .withFunctionName(\"sub\", SubtractEvaluator.class)\n           .withFunctionName(\"log\", NaturalLogEvaluator.class)\n    +\n           // Conditional Stream Evaluators\n           .withFunctionName(\"if\", IfThenElseEvaluator.class)\n           ;\n\n    +      // Date evaluators\n    \u2014 End diff \u2013\n\n    I'm not a huge fan of using the same class to handle multiple functions. There are places where we use the class to find the function name and if > 1 functions are mapped to a class then these lookups no longer work.\n\n    See [this](https://github.com/dennisgove/lucene-solr/blob/master/solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/expr/StreamFactory.java#L397) for where it wouldn't work. ",
            "author": "ASF GitHub Bot",
            "id": "comment-15957533"
        },
        {
            "date": "2017-04-05T19:53:04+0000",
            "content": "Github user dennisgove commented on a diff in the pull request:\n\n    https://github.com/apache/lucene-solr/pull/171#discussion_r107804517\n\n    \u2014 Diff: solr/solrj/src/java/org/apache/solr/client/solrj/io/eval/DatePartEvaluator.java \u2014\n    @@ -0,0 +1,169 @@\n    +/*\n    + * Licensed to the Apache Software Foundation (ASF) under one or more\n    + * contributor license agreements.  See the NOTICE file distributed with\n    + * this work for additional information regarding copyright ownership.\n    + * The ASF licenses this file to You under the Apache License, Version 2.0\n    + * (the \"License\"); you may not use this file except in compliance with\n    + * the License.  You may obtain a copy of the License at\n    + *\n    + *     http://www.apache.org/licenses/LICENSE-2.0\n    + *\n    + * Unless required by applicable law or agreed to in writing, software\n    + * distributed under the License is distributed on an \"AS IS\" BASIS,\n    + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    + * See the License for the specific language governing permissions and\n    + * limitations under the License.\n    + */\n    +\n    +package org.apache.solr.client.solrj.io.eval;\n    +\n    +import java.io.IOException;\n    +import java.time.Instant;\n    +import java.time.LocalDateTime;\n    +import java.time.ZoneOffset;\n    +import java.time.format.DateTimeParseException;\n    +import java.time.temporal.ChronoField;\n    +import java.time.temporal.IsoFields;\n    +import java.time.temporal.TemporalAccessor;\n    +import java.time.temporal.UnsupportedTemporalTypeException;\n    +import java.util.Arrays;\n    +import java.util.Date;\n    +import java.util.Locale;\n    +\n    +import org.apache.solr.client.solrj.io.Tuple;\n    +import org.apache.solr.client.solrj.io.stream.expr.Explanation;\n    +import org.apache.solr.client.solrj.io.stream.expr.StreamExpression;\n    +import org.apache.solr.client.solrj.io.stream.expr.StreamExpressionParameter;\n    +import org.apache.solr.client.solrj.io.stream.expr.StreamFactory;\n    +\n    +/**\n    + * Provides numeric Date/Time stream evaluators\n    + */\n    +public class DatePartEvaluator extends NumberEvaluator {\n    +\n    +  public enum FUNCTION \n{year, month, day, dayOfYear, dayOfQuarter, hour, minute, quarter, week, second, epoch}\n    +\n    +  private final FUNCTION function;\n    +\n    +  public DatePartEvaluator(StreamExpression expression, StreamFactory factory) throws IOException {\n    +    super(expression, factory);\n    +\n    +    String functionName = expression.getFunctionName();\n    +\n    +    try \n{\n    +      this.function = FUNCTION.valueOf(functionName);\n    +    }\n catch (IllegalArgumentException e) \n{\n    +      throw new IOException(String.format(Locale.ROOT, \"Invalid date expression %s - expecting one of %s\", functionName, Arrays.toString(FUNCTION.values())));\n    +    }\n    +\n    +    if (1 != subEvaluators.size()) \n{\n    +      throw new IOException(String.format(Locale.ROOT, \"Invalid expression %s - expecting one value but found %d\", expression, subEvaluators.size()));\n    +    }\n    +  }\n    +\n    +  @Override\n    +  public Number evaluate(Tuple tuple) throws IOException {\n    +\n    +    Instant instant = null;\n    +    TemporalAccessor date = null;\n    +\n    +    //First evaluate the parameter\n    +    StreamEvaluator streamEvaluator = subEvaluators.get(0);\n    +    Object tupleValue = streamEvaluator.evaluate(tuple);\n    +\n    +    if (tupleValue == null) return null;\n    +\n    +    if (tupleValue instanceof String) \n{\n    +      instant = getInstant((String) tupleValue);\n    +    }\n else if (tupleValue instanceof Instant) \n{\n    +      instant = (Instant) tupleValue;\n    +    }\n else if (tupleValue instanceof Date) \n{\n    +      instant = ((Date) tupleValue).toInstant();\n    +    }\n else if (tupleValue instanceof TemporalAccessor) \n{\n    +      date = ((TemporalAccessor) tupleValue);\n    +    }\n    +\n    +    if (instant != null) {\n    +      if (function.equals(FUNCTION.epoch)) return instant.toEpochMilli();\n    \u2014 End diff \u2013\n\n    Even in a case like this, why not pass the instant down to the `private evaluate(Instant)` function. That way all the real decisions are made there. ",
            "author": "ASF GitHub Bot",
            "id": "comment-15957534"
        },
        {
            "date": "2017-04-05T19:53:04+0000",
            "content": "Github user dennisgove commented on a diff in the pull request:\n\n    https://github.com/apache/lucene-solr/pull/171#discussion_r107805373\n\n    \u2014 Diff: solr/solrj/src/java/org/apache/solr/client/solrj/io/eval/DatePartEvaluator.java \u2014\n    @@ -0,0 +1,169 @@\n    +/*\n    + * Licensed to the Apache Software Foundation (ASF) under one or more\n    + * contributor license agreements.  See the NOTICE file distributed with\n    + * this work for additional information regarding copyright ownership.\n    + * The ASF licenses this file to You under the Apache License, Version 2.0\n    + * (the \"License\"); you may not use this file except in compliance with\n    + * the License.  You may obtain a copy of the License at\n    + *\n    + *     http://www.apache.org/licenses/LICENSE-2.0\n    + *\n    + * Unless required by applicable law or agreed to in writing, software\n    + * distributed under the License is distributed on an \"AS IS\" BASIS,\n    + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    + * See the License for the specific language governing permissions and\n    + * limitations under the License.\n    + */\n    +\n    +package org.apache.solr.client.solrj.io.eval;\n    +\n    +import java.io.IOException;\n    +import java.time.Instant;\n    +import java.time.LocalDateTime;\n    +import java.time.ZoneOffset;\n    +import java.time.format.DateTimeParseException;\n    +import java.time.temporal.ChronoField;\n    +import java.time.temporal.IsoFields;\n    +import java.time.temporal.TemporalAccessor;\n    +import java.time.temporal.UnsupportedTemporalTypeException;\n    +import java.util.Arrays;\n    +import java.util.Date;\n    +import java.util.Locale;\n    +\n    +import org.apache.solr.client.solrj.io.Tuple;\n    +import org.apache.solr.client.solrj.io.stream.expr.Explanation;\n    +import org.apache.solr.client.solrj.io.stream.expr.StreamExpression;\n    +import org.apache.solr.client.solrj.io.stream.expr.StreamExpressionParameter;\n    +import org.apache.solr.client.solrj.io.stream.expr.StreamFactory;\n    +\n    +/**\n    + * Provides numeric Date/Time stream evaluators\n    + */\n    +public class DatePartEvaluator extends NumberEvaluator {\n    +\n    +  public enum FUNCTION \n{year, month, day, dayOfYear, dayOfQuarter, hour, minute, quarter, week, second, epoch}\n    +\n    +  private final FUNCTION function;\n    +\n    +  public DatePartEvaluator(StreamExpression expression, StreamFactory factory) throws IOException {\n    +    super(expression, factory);\n    +\n    +    String functionName = expression.getFunctionName();\n    +\n    +    try \n{\n    +      this.function = FUNCTION.valueOf(functionName);\n    +    }\n catch (IllegalArgumentException e) \n{\n    +      throw new IOException(String.format(Locale.ROOT, \"Invalid date expression %s - expecting one of %s\", functionName, Arrays.toString(FUNCTION.values())));\n    +    }\n    +\n    +    if (1 != subEvaluators.size()) \n{\n    +      throw new IOException(String.format(Locale.ROOT, \"Invalid expression %s - expecting one value but found %d\", expression, subEvaluators.size()));\n    +    }\n    +  }\n    +\n    +  @Override\n    +  public Number evaluate(Tuple tuple) throws IOException {\n    +\n    +    Instant instant = null;\n    +    TemporalAccessor date = null;\n    +\n    +    //First evaluate the parameter\n    +    StreamEvaluator streamEvaluator = subEvaluators.get(0);\n    +    Object tupleValue = streamEvaluator.evaluate(tuple);\n    +\n    +    if (tupleValue == null) return null;\n    +\n    +    if (tupleValue instanceof String) \n{\n    +      instant = getInstant((String) tupleValue);\n    +    }\n else if (tupleValue instanceof Instant) \n{\n    +      instant = (Instant) tupleValue;\n    +    }\n else if (tupleValue instanceof Date) \n{\n    +      instant = ((Date) tupleValue).toInstant();\n    +    }\n else if (tupleValue instanceof TemporalAccessor) \n{\n    +      date = ((TemporalAccessor) tupleValue);\n    +    }\n    +\n    +    if (instant != null) \n{\n    +      if (function.equals(FUNCTION.epoch)) return instant.toEpochMilli();\n    +      date = LocalDateTime.ofInstant(instant, ZoneOffset.UTC);\n    +    }\n    +\n    +    if (date != null) \n{\n    +      return evaluate(date);\n    +    }\n    +\n    +    throw new IOException(String.format(Locale.ROOT, \"Invalid parameter %s - The parameter must be a string formatted ISO_INSTANT or of type Instant,Date or LocalDateTime.\", String.valueOf(tupleValue)));\n    +  }\n    +\n    +  private Instant getInstant(String dateStr) throws IOException {\n    +\n    +    if (dateStr != null && !dateStr.isEmpty()) {\n    +      try \n{\n    +        return Instant.parse(dateStr);\n    +      }\n catch (DateTimeParseException e) \n{\n    +        throw new IOException(String.format(Locale.ROOT, \"Invalid parameter %s - The String must be formatted in the ISO_INSTANT date format.\", dateStr));\n    +      }\n    +    }\n    +    return null;\n    +  }\n    +\n    +  /**\n    +   * Evaluate the date based on the specified function\n    +   *\n    +   * @param date\n    +   * @return the evaluated value\n    +   */\n    +  private Number evaluate(TemporalAccessor date) throws IOException {\n    \u2014 End diff \u2013\n\n    If you were to break this class into multiple (one for each evaluator) then this function should def exist in a parent class so keep the logic in a singular place.\n\n    The way I could see the hierarchy working is something like this\n    ```\n    ComplexEvaluator\n      TemporalEvaluator\n         YearEvaluator\n         MonthOfYearEvaluator\n         DayOfMonthEvalator\n         DayNameEvaluator\n         ....\n    ```\n\n    Basically, if some evaluator extends NumberEvaluator then that means this evaluator works over numbers, not that it returns a number. In a sense, when the sub-evaluators are executed they need to return something that is a Number. Following that logic, these evaluators work over temporal objects, so they extend TemporalEvaluator.\n\n    They can return whatever type they need to (String, Number, etc...) but they must have a temporal value to work from. ",
            "author": "ASF GitHub Bot",
            "id": "comment-15957535"
        },
        {
            "date": "2017-04-05T19:53:04+0000",
            "content": "Github user dennisgove commented on a diff in the pull request:\n\n    https://github.com/apache/lucene-solr/pull/171#discussion_r107804393\n\n    \u2014 Diff: solr/solrj/src/java/org/apache/solr/client/solrj/io/eval/DatePartEvaluator.java \u2014\n    @@ -0,0 +1,169 @@\n    +/*\n    + * Licensed to the Apache Software Foundation (ASF) under one or more\n    + * contributor license agreements.  See the NOTICE file distributed with\n    + * this work for additional information regarding copyright ownership.\n    + * The ASF licenses this file to You under the Apache License, Version 2.0\n    + * (the \"License\"); you may not use this file except in compliance with\n    + * the License.  You may obtain a copy of the License at\n    + *\n    + *     http://www.apache.org/licenses/LICENSE-2.0\n    + *\n    + * Unless required by applicable law or agreed to in writing, software\n    + * distributed under the License is distributed on an \"AS IS\" BASIS,\n    + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    + * See the License for the specific language governing permissions and\n    + * limitations under the License.\n    + */\n    +\n    +package org.apache.solr.client.solrj.io.eval;\n    +\n    +import java.io.IOException;\n    +import java.time.Instant;\n    +import java.time.LocalDateTime;\n    +import java.time.ZoneOffset;\n    +import java.time.format.DateTimeParseException;\n    +import java.time.temporal.ChronoField;\n    +import java.time.temporal.IsoFields;\n    +import java.time.temporal.TemporalAccessor;\n    +import java.time.temporal.UnsupportedTemporalTypeException;\n    +import java.util.Arrays;\n    +import java.util.Date;\n    +import java.util.Locale;\n    +\n    +import org.apache.solr.client.solrj.io.Tuple;\n    +import org.apache.solr.client.solrj.io.stream.expr.Explanation;\n    +import org.apache.solr.client.solrj.io.stream.expr.StreamExpression;\n    +import org.apache.solr.client.solrj.io.stream.expr.StreamExpressionParameter;\n    +import org.apache.solr.client.solrj.io.stream.expr.StreamFactory;\n    +\n    +/**\n    + * Provides numeric Date/Time stream evaluators\n    + */\n    +public class DatePartEvaluator extends NumberEvaluator {\n    +\n    +  public enum FUNCTION \n{year, month, day, dayOfYear, dayOfQuarter, hour, minute, quarter, week, second, epoch}\n    +\n    +  private final FUNCTION function;\n    +\n    +  public DatePartEvaluator(StreamExpression expression, StreamFactory factory) throws IOException {\n    +    super(expression, factory);\n    +\n    +    String functionName = expression.getFunctionName();\n    +\n    +    try \n{\n    +      this.function = FUNCTION.valueOf(functionName);\n    +    }\n catch (IllegalArgumentException e) \n{\n    +      throw new IOException(String.format(Locale.ROOT, \"Invalid date expression %s - expecting one of %s\", functionName, Arrays.toString(FUNCTION.values())));\n    +    }\n    +\n    +    if (1 != subEvaluators.size()) \n{\n    +      throw new IOException(String.format(Locale.ROOT, \"Invalid expression %s - expecting one value but found %d\", expression, subEvaluators.size()));\n    +    }\n    +  }\n    +\n    +  @Override\n    +  public Number evaluate(Tuple tuple) throws IOException {\n    +\n    +    Instant instant = null;\n    +    TemporalAccessor date = null;\n    +\n    +    //First evaluate the parameter\n    +    StreamEvaluator streamEvaluator = subEvaluators.get(0);\n    +    Object tupleValue = streamEvaluator.evaluate(tuple);\n    +\n    +    if (tupleValue == null) return null;\n    +\n    +    if (tupleValue instanceof String) \n{\n    +      instant = getInstant((String) tupleValue);\n    +    }\n else if (tupleValue instanceof Instant) \n{\n    +      instant = (Instant) tupleValue;\n    +    }\n else if (tupleValue instanceof Date) \n{\n    +      instant = ((Date) tupleValue).toInstant();\n    +    }\n else if (tupleValue instanceof TemporalAccessor) \n{\n    +      date = ((TemporalAccessor) tupleValue);\n    +    }\n    +\n    +    if (instant != null) {\n    \u2014 End diff \u2013\n\n    I'd rather see this continue to act on an Instant instead of a Date. If the value is a TemporalAccessor (above if statement) you can convert that into an Instant. ",
            "author": "ASF GitHub Bot",
            "id": "comment-15957536"
        },
        {
            "date": "2017-04-05T19:54:46+0000",
            "content": "Gethin James I'm sorry. I forgot to submit the review on Github. ",
            "author": "Dennis Gove",
            "id": "comment-15957541"
        },
        {
            "date": "2017-04-06T08:41:40+0000",
            "content": "Github user covolution commented on a diff in the pull request:\n\n    https://github.com/apache/lucene-solr/pull/171#discussion_r110107074\n\n    \u2014 Diff: solr/core/src/java/org/apache/solr/handler/StreamHandler.java \u2014\n    @@ -199,10 +200,16 @@ public void inform(SolrCore core) {\n           .withFunctionName(\"mult\", MultiplyEvaluator.class)\n           .withFunctionName(\"sub\", SubtractEvaluator.class)\n           .withFunctionName(\"log\", NaturalLogEvaluator.class)\n    +\n           // Conditional Stream Evaluators\n           .withFunctionName(\"if\", IfThenElseEvaluator.class)\n           ;\n\n    +      // Date evaluators\n    \u2014 End diff \u2013\n\n    I figured using one class (< 170 lines) to implement 11 date functions was preferable to lots of little classes.  Now I know there's an assumption that 1 class = 1 function, I can re-factor to add all the extra classes. ",
            "author": "ASF GitHub Bot",
            "id": "comment-15958565"
        },
        {
            "date": "2017-04-06T08:42:10+0000",
            "content": "Github user covolution commented on a diff in the pull request:\n\n    https://github.com/apache/lucene-solr/pull/171#discussion_r110107181\n\n    \u2014 Diff: solr/solrj/src/java/org/apache/solr/client/solrj/io/eval/DatePartEvaluator.java \u2014\n    @@ -0,0 +1,169 @@\n    +/*\n    + * Licensed to the Apache Software Foundation (ASF) under one or more\n    + * contributor license agreements.  See the NOTICE file distributed with\n    + * this work for additional information regarding copyright ownership.\n    + * The ASF licenses this file to You under the Apache License, Version 2.0\n    + * (the \"License\"); you may not use this file except in compliance with\n    + * the License.  You may obtain a copy of the License at\n    + *\n    + *     http://www.apache.org/licenses/LICENSE-2.0\n    + *\n    + * Unless required by applicable law or agreed to in writing, software\n    + * distributed under the License is distributed on an \"AS IS\" BASIS,\n    + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    + * See the License for the specific language governing permissions and\n    + * limitations under the License.\n    + */\n    +\n    +package org.apache.solr.client.solrj.io.eval;\n    +\n    +import java.io.IOException;\n    +import java.time.Instant;\n    +import java.time.LocalDateTime;\n    +import java.time.ZoneOffset;\n    +import java.time.format.DateTimeParseException;\n    +import java.time.temporal.ChronoField;\n    +import java.time.temporal.IsoFields;\n    +import java.time.temporal.TemporalAccessor;\n    +import java.time.temporal.UnsupportedTemporalTypeException;\n    +import java.util.Arrays;\n    +import java.util.Date;\n    +import java.util.Locale;\n    +\n    +import org.apache.solr.client.solrj.io.Tuple;\n    +import org.apache.solr.client.solrj.io.stream.expr.Explanation;\n    +import org.apache.solr.client.solrj.io.stream.expr.StreamExpression;\n    +import org.apache.solr.client.solrj.io.stream.expr.StreamExpressionParameter;\n    +import org.apache.solr.client.solrj.io.stream.expr.StreamFactory;\n    +\n    +/**\n    + * Provides numeric Date/Time stream evaluators\n    + */\n    +public class DatePartEvaluator extends NumberEvaluator {\n    +\n    +  public enum FUNCTION \n{year, month, day, dayOfYear, dayOfQuarter, hour, minute, quarter, week, second, epoch}\n    +\n    +  private final FUNCTION function;\n    +\n    +  public DatePartEvaluator(StreamExpression expression, StreamFactory factory) throws IOException {\n    +    super(expression, factory);\n    +\n    +    String functionName = expression.getFunctionName();\n    +\n    +    try \n{\n    +      this.function = FUNCTION.valueOf(functionName);\n    +    }\n catch (IllegalArgumentException e) \n{\n    +      throw new IOException(String.format(Locale.ROOT, \"Invalid date expression %s - expecting one of %s\", functionName, Arrays.toString(FUNCTION.values())));\n    +    }\n    +\n    +    if (1 != subEvaluators.size()) \n{\n    +      throw new IOException(String.format(Locale.ROOT, \"Invalid expression %s - expecting one value but found %d\", expression, subEvaluators.size()));\n    +    }\n    +  }\n    +\n    +  @Override\n    +  public Number evaluate(Tuple tuple) throws IOException {\n    +\n    +    Instant instant = null;\n    +    TemporalAccessor date = null;\n    +\n    +    //First evaluate the parameter\n    +    StreamEvaluator streamEvaluator = subEvaluators.get(0);\n    +    Object tupleValue = streamEvaluator.evaluate(tuple);\n    +\n    +    if (tupleValue == null) return null;\n    +\n    +    if (tupleValue instanceof String) \n{\n    +      instant = getInstant((String) tupleValue);\n    +    }\n else if (tupleValue instanceof Instant) \n{\n    +      instant = (Instant) tupleValue;\n    +    }\n else if (tupleValue instanceof Date) \n{\n    +      instant = ((Date) tupleValue).toInstant();\n    +    }\n else if (tupleValue instanceof TemporalAccessor) \n{\n    +      date = ((TemporalAccessor) tupleValue);\n    +    }\n    +\n    +    if (instant != null) {\n    \u2014 End diff \u2013\n\n    Instant does not work with human units of time(eg. year, month, or day), a timezone is required. So I am converting it to a LocalDateTime using ZoneOffset.UTC. ",
            "author": "ASF GitHub Bot",
            "id": "comment-15958567"
        },
        {
            "date": "2017-04-06T08:42:31+0000",
            "content": "Github user covolution commented on a diff in the pull request:\n\n    https://github.com/apache/lucene-solr/pull/171#discussion_r110107246\n\n    \u2014 Diff: solr/solrj/src/java/org/apache/solr/client/solrj/io/eval/DatePartEvaluator.java \u2014\n    @@ -0,0 +1,169 @@\n    +/*\n    + * Licensed to the Apache Software Foundation (ASF) under one or more\n    + * contributor license agreements.  See the NOTICE file distributed with\n    + * this work for additional information regarding copyright ownership.\n    + * The ASF licenses this file to You under the Apache License, Version 2.0\n    + * (the \"License\"); you may not use this file except in compliance with\n    + * the License.  You may obtain a copy of the License at\n    + *\n    + *     http://www.apache.org/licenses/LICENSE-2.0\n    + *\n    + * Unless required by applicable law or agreed to in writing, software\n    + * distributed under the License is distributed on an \"AS IS\" BASIS,\n    + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    + * See the License for the specific language governing permissions and\n    + * limitations under the License.\n    + */\n    +\n    +package org.apache.solr.client.solrj.io.eval;\n    +\n    +import java.io.IOException;\n    +import java.time.Instant;\n    +import java.time.LocalDateTime;\n    +import java.time.ZoneOffset;\n    +import java.time.format.DateTimeParseException;\n    +import java.time.temporal.ChronoField;\n    +import java.time.temporal.IsoFields;\n    +import java.time.temporal.TemporalAccessor;\n    +import java.time.temporal.UnsupportedTemporalTypeException;\n    +import java.util.Arrays;\n    +import java.util.Date;\n    +import java.util.Locale;\n    +\n    +import org.apache.solr.client.solrj.io.Tuple;\n    +import org.apache.solr.client.solrj.io.stream.expr.Explanation;\n    +import org.apache.solr.client.solrj.io.stream.expr.StreamExpression;\n    +import org.apache.solr.client.solrj.io.stream.expr.StreamExpressionParameter;\n    +import org.apache.solr.client.solrj.io.stream.expr.StreamFactory;\n    +\n    +/**\n    + * Provides numeric Date/Time stream evaluators\n    + */\n    +public class DatePartEvaluator extends NumberEvaluator {\n    +\n    +  public enum FUNCTION \n{year, month, day, dayOfYear, dayOfQuarter, hour, minute, quarter, week, second, epoch}\n    +\n    +  private final FUNCTION function;\n    +\n    +  public DatePartEvaluator(StreamExpression expression, StreamFactory factory) throws IOException {\n    +    super(expression, factory);\n    +\n    +    String functionName = expression.getFunctionName();\n    +\n    +    try \n{\n    +      this.function = FUNCTION.valueOf(functionName);\n    +    }\n catch (IllegalArgumentException e) \n{\n    +      throw new IOException(String.format(Locale.ROOT, \"Invalid date expression %s - expecting one of %s\", functionName, Arrays.toString(FUNCTION.values())));\n    +    }\n    +\n    +    if (1 != subEvaluators.size()) \n{\n    +      throw new IOException(String.format(Locale.ROOT, \"Invalid expression %s - expecting one value but found %d\", expression, subEvaluators.size()));\n    +    }\n    +  }\n    +\n    +  @Override\n    +  public Number evaluate(Tuple tuple) throws IOException {\n    +\n    +    Instant instant = null;\n    +    TemporalAccessor date = null;\n    +\n    +    //First evaluate the parameter\n    +    StreamEvaluator streamEvaluator = subEvaluators.get(0);\n    +    Object tupleValue = streamEvaluator.evaluate(tuple);\n    +\n    +    if (tupleValue == null) return null;\n    +\n    +    if (tupleValue instanceof String) \n{\n    +      instant = getInstant((String) tupleValue);\n    +    }\n else if (tupleValue instanceof Instant) \n{\n    +      instant = (Instant) tupleValue;\n    +    }\n else if (tupleValue instanceof Date) \n{\n    +      instant = ((Date) tupleValue).toInstant();\n    +    }\n else if (tupleValue instanceof TemporalAccessor) \n{\n    +      date = ((TemporalAccessor) tupleValue);\n    +    }\n    +\n    +    if (instant != null) {\n    +      if (function.equals(FUNCTION.epoch)) return instant.toEpochMilli();\n    \u2014 End diff \u2013\n\n    This is an optimization to avoid creating a Date object unnecessarily. ",
            "author": "ASF GitHub Bot",
            "id": "comment-15958568"
        },
        {
            "date": "2017-04-06T08:43:28+0000",
            "content": "Github user covolution commented on a diff in the pull request:\n\n    https://github.com/apache/lucene-solr/pull/171#discussion_r110107409\n\n    \u2014 Diff: solr/solrj/src/java/org/apache/solr/client/solrj/io/eval/DatePartEvaluator.java \u2014\n    @@ -0,0 +1,169 @@\n    +/*\n    + * Licensed to the Apache Software Foundation (ASF) under one or more\n    + * contributor license agreements.  See the NOTICE file distributed with\n    + * this work for additional information regarding copyright ownership.\n    + * The ASF licenses this file to You under the Apache License, Version 2.0\n    + * (the \"License\"); you may not use this file except in compliance with\n    + * the License.  You may obtain a copy of the License at\n    + *\n    + *     http://www.apache.org/licenses/LICENSE-2.0\n    + *\n    + * Unless required by applicable law or agreed to in writing, software\n    + * distributed under the License is distributed on an \"AS IS\" BASIS,\n    + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    + * See the License for the specific language governing permissions and\n    + * limitations under the License.\n    + */\n    +\n    +package org.apache.solr.client.solrj.io.eval;\n    +\n    +import java.io.IOException;\n    +import java.time.Instant;\n    +import java.time.LocalDateTime;\n    +import java.time.ZoneOffset;\n    +import java.time.format.DateTimeParseException;\n    +import java.time.temporal.ChronoField;\n    +import java.time.temporal.IsoFields;\n    +import java.time.temporal.TemporalAccessor;\n    +import java.time.temporal.UnsupportedTemporalTypeException;\n    +import java.util.Arrays;\n    +import java.util.Date;\n    +import java.util.Locale;\n    +\n    +import org.apache.solr.client.solrj.io.Tuple;\n    +import org.apache.solr.client.solrj.io.stream.expr.Explanation;\n    +import org.apache.solr.client.solrj.io.stream.expr.StreamExpression;\n    +import org.apache.solr.client.solrj.io.stream.expr.StreamExpressionParameter;\n    +import org.apache.solr.client.solrj.io.stream.expr.StreamFactory;\n    +\n    +/**\n    + * Provides numeric Date/Time stream evaluators\n    + */\n    +public class DatePartEvaluator extends NumberEvaluator {\n    +\n    +  public enum FUNCTION \n{year, month, day, dayOfYear, dayOfQuarter, hour, minute, quarter, week, second, epoch}\n    +\n    +  private final FUNCTION function;\n    +\n    +  public DatePartEvaluator(StreamExpression expression, StreamFactory factory) throws IOException {\n    +    super(expression, factory);\n    +\n    +    String functionName = expression.getFunctionName();\n    +\n    +    try \n{\n    +      this.function = FUNCTION.valueOf(functionName);\n    +    }\n catch (IllegalArgumentException e) \n{\n    +      throw new IOException(String.format(Locale.ROOT, \"Invalid date expression %s - expecting one of %s\", functionName, Arrays.toString(FUNCTION.values())));\n    +    }\n    +\n    +    if (1 != subEvaluators.size()) \n{\n    +      throw new IOException(String.format(Locale.ROOT, \"Invalid expression %s - expecting one value but found %d\", expression, subEvaluators.size()));\n    +    }\n    +  }\n    +\n    +  @Override\n    +  public Number evaluate(Tuple tuple) throws IOException {\n    +\n    +    Instant instant = null;\n    +    TemporalAccessor date = null;\n    +\n    +    //First evaluate the parameter\n    +    StreamEvaluator streamEvaluator = subEvaluators.get(0);\n    +    Object tupleValue = streamEvaluator.evaluate(tuple);\n    +\n    +    if (tupleValue == null) return null;\n    +\n    +    if (tupleValue instanceof String) \n{\n    +      instant = getInstant((String) tupleValue);\n    +    }\n else if (tupleValue instanceof Instant) \n{\n    +      instant = (Instant) tupleValue;\n    +    }\n else if (tupleValue instanceof Date) \n{\n    +      instant = ((Date) tupleValue).toInstant();\n    +    }\n else if (tupleValue instanceof TemporalAccessor) \n{\n    +      date = ((TemporalAccessor) tupleValue);\n    +    }\n    +\n    +    if (instant != null) \n{\n    +      if (function.equals(FUNCTION.epoch)) return instant.toEpochMilli();\n    +      date = LocalDateTime.ofInstant(instant, ZoneOffset.UTC);\n    +    }\n    +\n    +    if (date != null) \n{\n    +      return evaluate(date);\n    +    }\n    +\n    +    throw new IOException(String.format(Locale.ROOT, \"Invalid parameter %s - The parameter must be a string formatted ISO_INSTANT or of type Instant,Date or LocalDateTime.\", String.valueOf(tupleValue)));\n    +  }\n    +\n    +  private Instant getInstant(String dateStr) throws IOException {\n    +\n    +    if (dateStr != null && !dateStr.isEmpty()) {\n    +      try \n{\n    +        return Instant.parse(dateStr);\n    +      }\n catch (DateTimeParseException e) \n{\n    +        throw new IOException(String.format(Locale.ROOT, \"Invalid parameter %s - The String must be formatted in the ISO_INSTANT date format.\", dateStr));\n    +      }\n    +    }\n    +    return null;\n    +  }\n    +\n    +  /**\n    +   * Evaluate the date based on the specified function\n    +   *\n    +   * @param date\n    +   * @return the evaluated value\n    +   */\n    +  private Number evaluate(TemporalAccessor date) throws IOException {\n    \u2014 End diff \u2013\n\n    I will start working on the new design. ",
            "author": "ASF GitHub Bot",
            "id": "comment-15958570"
        },
        {
            "date": "2017-04-06T10:22:09+0000",
            "content": "Github user dennisgove commented on a diff in the pull request:\n\n    https://github.com/apache/lucene-solr/pull/171#discussion_r110127292\n\n    \u2014 Diff: solr/core/src/java/org/apache/solr/handler/StreamHandler.java \u2014\n    @@ -199,10 +200,16 @@ public void inform(SolrCore core) {\n           .withFunctionName(\"mult\", MultiplyEvaluator.class)\n           .withFunctionName(\"sub\", SubtractEvaluator.class)\n           .withFunctionName(\"log\", NaturalLogEvaluator.class)\n    +\n           // Conditional Stream Evaluators\n           .withFunctionName(\"if\", IfThenElseEvaluator.class)\n           ;\n\n    +      // Date evaluators\n    \u2014 End diff \u2013\n\n    Yeah, I agree - maybe we should take a look at that assumption of 1 class == 1 function and re-evaluate if there's a better way. ",
            "author": "ASF GitHub Bot",
            "id": "comment-15958704"
        },
        {
            "date": "2017-04-06T14:26:32+0000",
            "content": "Github user dennisgove commented on the issue:\n\n    https://github.com/apache/lucene-solr/pull/171\n\n    I think this all looks good. ",
            "author": "ASF GitHub Bot",
            "id": "comment-15959004"
        },
        {
            "date": "2017-04-06T14:48:19+0000",
            "content": "Github user dennisgove commented on the issue:\n\n    https://github.com/apache/lucene-solr/pull/171\n\n    I noticed that solr/solrj/src/java/org/apache/solr/client/solrj/io/eval/DatePartEvaluator.java is still part of the PR. Is that intentional? ",
            "author": "ASF GitHub Bot",
            "id": "comment-15959032"
        },
        {
            "date": "2017-04-06T15:30:12+0000",
            "content": "Github user covolution commented on the issue:\n\n    https://github.com/apache/lucene-solr/pull/171\n\n    Yes, I had some minor commits (including the delete) I hadn't pushed.  It up to date now. ",
            "author": "ASF GitHub Bot",
            "id": "comment-15959098"
        },
        {
            "date": "2017-04-06T19:13:57+0000",
            "content": "Github user dennisgove commented on a diff in the pull request:\n\n    https://github.com/apache/lucene-solr/pull/171#discussion_r110244491\n\n    \u2014 Diff: solr/core/src/java/org/apache/solr/handler/StreamHandler.java \u2014\n    @@ -191,7 +237,20 @@ public void inform(SolrCore core) {\n           .withFunctionName(\"lteq\", LessThanEqualToEvaluator.class)\n           .withFunctionName(\"not\", NotEvaluator.class)\n           .withFunctionName(\"or\", OrEvaluator.class)\n\n\t    +\n    +      // Date Time Evaluators\n    +      .withFunctionName(TemporalEvaluatorYear.FUNCTION_NAME, TemporalEvaluatorYear.class)\n\t\n\t\t\n\t\t\n\t\t\tEnd diff \u2013\n\t\t\n\t\t\n\t\n\t\n\n\n\n    I'm having trouble making up my mind about this use of the FUNCTION_NAME static property. For a while I've been considering moving the function name into the implementing class (like you've done here) but I haven't been able to convince myself that it is inherently better. I'd like to discuss it though, so I'll list my reasons both for and against.\n\n    1. Function names were originally assigned in a single place, the StreamHandler, to allow for easy overrides via the config file (eg. using business specific logic for an innerJoin you could override the assignment of `innerJoin` to your own class via the config file). Having the assignments in a single place made this easier.\n\n    2. Having assignments in a single place makes it easy to see what the full list of available function names is. Among other things, this has helped prevent me from accidentally using an already used function name for a different class.\n\n    3. Function names are now being assigned in at least 3 places ([StreamHandler](https://github.com/dennisgove/lucene-solr/blob/master/solr/core/src/java/org/apache/solr/handler/StreamHandler.java), [GraphHandler](https://github.com/dennisgove/lucene-solr/blob/master/solr/core/src/java/org/apache/solr/handler/GraphHandler.java), and [SolrTable](https://github.com/dennisgove/lucene-solr/blob/master/solr/core/src/java/org/apache/solr/handler/sql/SolrTable.java)) so all the benefits of a single assignment is somewhat out the window.\n\n    4. By assigning the function names in the implementing class, we no longer need to rely on the StreamFactory for knowing what the assigned function name for a class is. This means we can use the function name in more logging and error messages where a StreamFactory instance may not be readily available. \n\n    5. It will still be possible for people to override the default assigned function names and classes, but the logic that currently does that will have to be carefully changed to ensure full backward compatibility.\n\n    I'm in favor of making this change, but it's larger than something that should probably be done in this PR. \n\n    @joel-bernstein, @covolution - your thoughts? ",
            "author": "ASF GitHub Bot",
            "id": "comment-15959557"
        },
        {
            "date": "2017-04-07T09:05:46+0000",
            "content": "Github user covolution commented on a diff in the pull request:\n\n    https://github.com/apache/lucene-solr/pull/171#discussion_r110346756\n\n    \u2014 Diff: solr/core/src/java/org/apache/solr/handler/StreamHandler.java \u2014\n    @@ -191,7 +237,20 @@ public void inform(SolrCore core) {\n           .withFunctionName(\"lteq\", LessThanEqualToEvaluator.class)\n           .withFunctionName(\"not\", NotEvaluator.class)\n           .withFunctionName(\"or\", OrEvaluator.class)\n\n\t    +\n    +      // Date Time Evaluators\n    +      .withFunctionName(TemporalEvaluatorYear.FUNCTION_NAME, TemporalEvaluatorYear.class)\n\t\n\t\t\n\t\t\n\t\t\tEnd diff \u2013\n\t\t\n\t\t\n\t\n\t\n\n\n\n    I agree with what you are saying. Its a tricky question.\n\n    The function definitions in StreamHandler are all static, there are no class instances.  This makes sense if a factory is creating them.  If we went for an instance method on an implementation class then that wouldn't really work.  (It would allow us to have multiple implementations in the same class though)!\n\n    So instances vs static is a bit of a problem. I like that you can also use aliases at the moment so wouldn't want to lose that. Are function classes being created on-demand, per request?\n\n    If we keep with the static implementation, perhaps we can use an interface called FunctionNames to put all the string constants?  It would be one central definition list for StreamHandler, GraphHandler and SolrTable.  Function implementation classes could still reference the FunctionNames in their implementation.\n ",
            "author": "ASF GitHub Bot",
            "id": "comment-15960524"
        },
        {
            "date": "2017-04-12T18:36:09+0000",
            "content": "Github user dennisgove commented on a diff in the pull request:\n\n    https://github.com/apache/lucene-solr/pull/171#discussion_r111227848\n\n    \u2014 Diff: solr/core/src/java/org/apache/solr/handler/StreamHandler.java \u2014\n    @@ -191,7 +237,20 @@ public void inform(SolrCore core) {\n           .withFunctionName(\"lteq\", LessThanEqualToEvaluator.class)\n           .withFunctionName(\"not\", NotEvaluator.class)\n           .withFunctionName(\"or\", OrEvaluator.class)\n\n\t    +\n    +      // Date Time Evaluators\n    +      .withFunctionName(TemporalEvaluatorYear.FUNCTION_NAME, TemporalEvaluatorYear.class)\n\t\n\t\t\n\t\t\n\t\t\tEnd diff \u2013\n\t\t\n\t\t\n\t\n\t\n\n\n\n    I'd like to approach this in a separate ticket. Would it be alright if we change the use of TemporalEvaluatorYear.FUNCTION_NAME to \"year\" in the call to `withFunctionName` for now? ",
            "author": "ASF GitHub Bot",
            "id": "comment-15966373"
        },
        {
            "date": "2017-04-12T18:39:13+0000",
            "content": "Github user joel-bernstein commented on the issue:\n\n    https://github.com/apache/lucene-solr/pull/171\n\n    Hi @dennisgove,\n\n    I've been working with this ticket today. I'm commit it to master so you and I can make changes more easily to it. I also introduced the concept of a TupleContext in this ticket which may need some re-working. When we feel it's ready we can backport. ",
            "author": "ASF GitHub Bot",
            "id": "comment-15966375"
        },
        {
            "date": "2017-04-12T18:40:17+0000",
            "content": "Github user dennisgove commented on the issue:\n\n    https://github.com/apache/lucene-solr/pull/171\n\n    Sounds good to me. I like the work that was done here. ",
            "author": "ASF GitHub Bot",
            "id": "comment-15966377"
        },
        {
            "date": "2017-04-12T18:41:38+0000",
            "content": "Github user joel-bernstein commented on the issue:\n\n    https://github.com/apache/lucene-solr/pull/171\n\n    Ok great. Just running the test suite now... ",
            "author": "ASF GitHub Bot",
            "id": "comment-15966378"
        },
        {
            "date": "2017-04-12T19:14:58+0000",
            "content": "Commit c3d205cdccf1175d9960723d0fe4e0d4391dff11 in lucene-solr's branch refs/heads/master from Gethin James\n[ https://git-wip-us.apache.org/repos/asf?p=lucene-solr.git;h=c3d205c ]\n\nSOLR-10303:  Switching from the fieldName param to subEvaluators ",
            "author": "ASF subversion and git services",
            "id": "comment-15966427"
        },
        {
            "date": "2017-04-12T19:15:00+0000",
            "content": "Commit cf14b4be034975417bbdc1185b5aef392c00ae91 in lucene-solr's branch refs/heads/master from Gethin James\n[ https://git-wip-us.apache.org/repos/asf?p=lucene-solr.git;h=cf14b4b ]\n\nSOLR-10303:  Supporting epoch for LocalDateTime ",
            "author": "ASF subversion and git services",
            "id": "comment-15966428"
        },
        {
            "date": "2017-04-12T19:15:04+0000",
            "content": "Commit c6fbb27376d7ac53e149da2e420bb81bdb2513be in lucene-solr's branch refs/heads/master from Gethin James\n[ https://git-wip-us.apache.org/repos/asf?p=lucene-solr.git;h=c6fbb27 ]\n\nSOLR-10303:  Supporting more datatypes via a TemporalAccessor ",
            "author": "ASF subversion and git services",
            "id": "comment-15966429"
        },
        {
            "date": "2017-04-12T19:15:08+0000",
            "content": "Commit b314bc67764131bb677f25d98212577182af0b1e in lucene-solr's branch refs/heads/master from Gethin James\n[ https://git-wip-us.apache.org/repos/asf?p=lucene-solr.git;h=b314bc6 ]\n\nSOLR-10303:  Switched to pascal casing ",
            "author": "ASF subversion and git services",
            "id": "comment-15966430"
        },
        {
            "date": "2017-04-12T19:15:11+0000",
            "content": "Commit d70fc967d44fd0a7e3706707479853dfd43ea908 in lucene-solr's branch refs/heads/master from Gethin James\n[ https://git-wip-us.apache.org/repos/asf?p=lucene-solr.git;h=d70fc96 ]\n\nSOLR-10303:  Refactored to multiple TemporalEvaluator classes based on feedback ",
            "author": "ASF subversion and git services",
            "id": "comment-15966431"
        },
        {
            "date": "2017-04-12T19:15:15+0000",
            "content": "Commit 1c333c79d0cd3d94e85222030788bf5597732f2c in lucene-solr's branch refs/heads/master from Gethin James\n[ https://git-wip-us.apache.org/repos/asf?p=lucene-solr.git;h=1c333c7 ]\n\nSOLR-10303:  Removing the unused class, replaced by TemporalEvaluator ",
            "author": "ASF subversion and git services",
            "id": "comment-15966432"
        },
        {
            "date": "2017-04-12T19:15:19+0000",
            "content": "Commit 8642ed9f88e2c8667ff80835b2b3b632786884ab in lucene-solr's branch refs/heads/master from Gethin James\n[ https://git-wip-us.apache.org/repos/asf?p=lucene-solr.git;h=8642ed9 ]\n\nSOLR-10303:  Error message formatting for TemporalEvaluator ",
            "author": "ASF subversion and git services",
            "id": "comment-15966433"
        },
        {
            "date": "2017-04-12T19:15:22+0000",
            "content": "Commit b78a270c9d3f0040325bbe4eb044384173bff963 in lucene-solr's branch refs/heads/master from Gethin James\n[ https://git-wip-us.apache.org/repos/asf?p=lucene-solr.git;h=b78a270 ]\n\nSOLR-10303:  Removing the unused class DatePartEvaluator from the test ",
            "author": "ASF subversion and git services",
            "id": "comment-15966434"
        },
        {
            "date": "2017-04-12T19:15:26+0000",
            "content": "Commit 5e403647de109685cbfc0c81943ae9e79638348f in lucene-solr's branch refs/heads/master from Joel Bernstein\n[ https://git-wip-us.apache.org/repos/asf?p=lucene-solr.git;h=5e40364 ]\n\nSOLR-10303: Add the tuple context to avoid creating multiple LocalDateTime instances for the same Tuple ",
            "author": "ASF subversion and git services",
            "id": "comment-15966435"
        },
        {
            "date": "2017-04-12T19:15:29+0000",
            "content": "Commit 0bcd88b181b3f9d927ae5507b700321eb6e68af6 in lucene-solr's branch refs/heads/master from Joel Bernstein\n[ https://git-wip-us.apache.org/repos/asf?p=lucene-solr.git;h=0bcd88b ]\n\nSOLR-10303: Fix precommit ",
            "author": "ASF subversion and git services",
            "id": "comment-15966437"
        },
        {
            "date": "2017-04-12T19:20:06+0000",
            "content": "Dennis Gove, it's all committed now. Feel free to change things around. Let me know when you've finished I can do the backport. ",
            "author": "Joel Bernstein",
            "id": "comment-15966442"
        },
        {
            "date": "2017-04-18T15:48:32+0000",
            "content": "Github user covolution commented on the issue:\n\n    https://github.com/apache/lucene-solr/pull/171\n\n    Changes merged into master ",
            "author": "ASF GitHub Bot",
            "id": "comment-15972944"
        },
        {
            "date": "2017-04-18T15:48:34+0000",
            "content": "Github user covolution closed the pull request at:\n\n    https://github.com/apache/lucene-solr/pull/171 ",
            "author": "ASF GitHub Bot",
            "id": "comment-15972946"
        },
        {
            "date": "2017-05-05T17:14:32+0000",
            "content": "Commit 867e81672a42f2a202382367e0e546947a5e4946 in lucene-solr's branch refs/heads/master from Joel Bernstein\n[ https://git-wip-us.apache.org/repos/asf?p=lucene-solr.git;h=867e816 ]\n\nSOLR-10303: Update CHANGES.txt ",
            "author": "ASF subversion and git services",
            "id": "comment-15998594"
        },
        {
            "date": "2017-05-05T17:17:13+0000",
            "content": "Commit eefd18553e765b62591a707cb8c049e2fa7b4573 in lucene-solr's branch refs/heads/branch_6x from Joel Bernstein\n[ https://git-wip-us.apache.org/repos/asf?p=lucene-solr.git;h=eefd185 ]\n\nSOLR-10303: Update CHANGES.txt ",
            "author": "ASF subversion and git services",
            "id": "comment-15998600"
        },
        {
            "date": "2017-05-05T17:18:33+0000",
            "content": "Closing this ticket out as it is now backported for 6.6. Thanks Gethin James! ",
            "author": "Joel Bernstein",
            "id": "comment-15998602"
        }
    ]
}