{
    "id": "SOLR-10840",
    "title": "Random Index Corruption during bulk indexing",
    "details": {
        "labels": "",
        "priority": "Major",
        "components": [
            "update"
        ],
        "type": "Bug",
        "fix_versions": [],
        "affect_versions": "6.3,                                            6.5.1",
        "resolution": "Cannot Reproduce",
        "status": "Resolved"
    },
    "description": "I'm seeing a randomly occuring Index Corruption exception during a Solr  data ingest. This can occur anywhere during the 7-8 hours our ingests take. I'm initially submitting this as a Solr bug as this is the envioronment I'm using, but it does look as though the error is occurring in Lucene code.\n\nSome background:\n\n    AWS EC2 server running CentOS 7\n    java.\u200bruntime.\u200bversion: 1.8.0_131-b11  (also occurred with 1.8.0_45).\n    Solr 6.3.0 (have also seen it with Solr 6.5.1). It did not happen with Solr 5.4 9which i can't go back to). Oddly enough, I ran Solr 6.3.0 unvenetfully for several weeks before this problem first occurred.\n    Standalone  (non cloud) environment.\n\n    Our indexing subsystem is a complex Python script which creates multiple indexing subprocesses in order to make use of multiple cores. Each subprocess reads records from a MySQL database, does  some significant preprocessing and sends a batch of documents (defaults to 500) to the Solr update handler (using the Python 'scorched' module). Each content source (there are 5-6) requires a separate instantiation of the script, and these wrapped in a Bash script to run serially.\n\n    When the exception occurs, we always see something like the following in the solr.log\n\n    ERROR - 2017-06-06 14:37:34.639; [   x:stresstest1] org.apache.solr.common.SolrException; org.apache.solr.common.SolrException: Exception writing document id med-27840-00384802 to the index; possible analysis error.\n    at org.apache.solr.update.DirectUpdateHandler2.addDoc(DirectUpdateHandler2.java:178\n    ...\n    Caused by: org.apache.lucene.store.AlreadyClosedException: this IndexWriter is closed\n    at org.apache.lucene.index.IndexWriter.ensureOpen(IndexWriter.java:740)\n    at org.apache.lucene.index.IndexWriter.ensureOpen(IndexWriter.java:754)\n    at org.apache.lucene.index.IndexWriter.updateDocument(IndexWriter.java:1558)\n    at org.apache.solr.update.DirectUpdateHandler2.doNormalUpdate(DirectUpdateHandler2.java:279)\n    at org.apache.solr.update.DirectUpdateHandler2.addDoc0(DirectUpdateHandler2.java:211)\n    at org.apache.solr.update.DirectUpdateHandler2.addDoc(DirectUpdateHandler2.java:166)\n    ... 42 more\nCaused by: java.io.EOFException: read past EOF: MMapIndexInput(path=\"/indexes/solrindexes/stresstest1/index/_441.nvm\")\n    at org.apache.lucene.store.ByteBufferIndexInput.readByte(ByteBufferIndexInput.java:75)\n    at org.apache.lucene.store.BufferedChecksumIndexInput.readByte(BufferedChecksumIndexInput.java:41)\n    at org.apache.lucene.store.DataInput.readInt(DataInput.java:101)\n        at org.apache.lucene.codecs.CodecUtil.checkHeader(CodecUtil.java:194)\n    at org.apache.lucene.codecs.CodecUtil.checkIndexHeader(CodecUtil.java:255)\n    at org.apache.lucene.codecs.lucene53.Lucene53NormsProducer.<init>(Lucene53NormsProducer.java:58)\n    at org.apache.lucene.codecs.lucene53.Lucene53NormsFormat.normsProducer(Lucene53NormsFormat.java:82)\n    at org.apache.lucene.index.SegmentCoreReaders.<init>(SegmentCoreReaders.java:113)\n    at org.apache.lucene.index.SegmentReader.<init>(SegmentReader.java:74)\n    at org.apache.lucene.index.ReadersAndUpdates.getReader(ReadersAndUpdates.java:145)\n    at org.apache.lucene.index.BufferedUpdatesStream$SegmentState.<init>(BufferedUpdatesStream.java:384)\n    at org.apache.lucene.index.BufferedUpdatesStream.openSegmentStates(BufferedUpdatesStream.java:416)\n    at org.apache.lucene.index.BufferedUpdatesStream.applyDeletesAndUpdates(BufferedUpdatesStream.java:261)\n    at org.apache.lucene.index.IndexWriter._mergeInit(IndexWriter.java:4068)\n    at org.apache.lucene.index.IndexWriter.mergeInit(IndexWriter.java:4026)\n    at org.apache.lucene.index.IndexWriter.merge(IndexWriter.java:3880)\n    at org.apache.lucene.index.ConcurrentMergeScheduler.doMerge(ConcurrentMergeScheduler.java:588)\n    at org.apache.lucene.index.ConcurrentMergeScheduler$MergeThread.run(ConcurrentMergeScheduler.java:626)\n    Suppressed: org.apache.lucene.index.CorruptIndexException: checksum status indeterminate: remaining=0, please run checkindex for more details (resource=BufferedChecksumIndexInput(MMapIndexInput(path=\"/indexes/solrindexes/stresstest1/index/_441.nvm\")))\n        at org.apache.lucene.codecs.CodecUtil.checkFooter(CodecUtil.java:451)\n        at org.apache.lucene.codecs.lucene53.Lucene53NormsProducer.<init>(Lucene53NormsProducer.java:63)\n        ... 12 more\n\n    This is usually followed in very short order by similar exceptions  as other UpdateHandler threads hit the same IOException.\n\n    I've also seenwhat I assume is a related error during autocommits-\n\nINFO  - 2017-05-30 18:01:35.264; [   x:build0530] org.apache.solr.update.DirectUpdateHandler2; start commit\n{,optimize=false,openSearcher=true,waitSearcher=true,expungeDeletes=false,softCommit=true,prepareCommit=false}\nERROR - 2017-05-30 18:01:36.884; [   x:build0530] org.apache.solr.common.SolrException; auto commit error...:org.apache.solr.common.SolrException: Error opening new searcher\n    at org.apache.solr.core.SolrCore.openNewSearcher(SolrCore.java:1820)\n    at org.apache.solr.core.SolrCore.getSearcher(SolrCore.java:1931)\n    at org.apache.solr.update.DirectUpdateHandler2.commit(DirectUpdateHandler2.java:630)\n    at org.apache.solr.update.CommitTracker.run(CommitTracker.java:217)\n    at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\n    at java.util.concurrent.FutureTask.run(FutureTask.java:266)\n    at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:180)\n    at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:293)\n    at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)\n    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)\n    at java.lang.Thread.run(Thread.java:748)\nCaused by: org.apache.lucene.index.CorruptIndexException: codec footer mismatch (file truncated?): actual footer=-2060254071 vs expected footer=-1071082520 (resource=BufferedChecksumIndexInput(MMapIndexInput(path=\"/indexes/solrindexes/build0530/index/_15w_Lucene50_0.tip\")))\n    at org.apache.lucene.codecs.CodecUtil.validateFooter(CodecUtil.java:499)\n    at org.apache.lucene.codecs.CodecUtil.checkFooter(CodecUtil.java:411)\n    at org.apache.lucene.codecs.CodecUtil.checksumEntireFile(CodecUtil.java:520)\n    at org.apache.lucene.codecs.blocktree.BlockTreeTermsReader.<init>(BlockTreeTermsReader.java:178)\n    at org.apache.lucene.codecs.lucene50.Lucene50PostingsFormat.fieldsProducer(Lucene50PostingsFormat.java:445)\n    at org.apache.lucene.codecs.perfield.PerFieldPostingsFormat$FieldsReader.<init>(PerFieldPostingsFormat.java:292)\n    at org.apache.lucene.codecs.perfield.PerFieldPostingsFormat.fieldsProducer(PerFieldPostingsFormat.java:372)\n    at org.apache.lucene.index.SegmentCoreReaders.<init>(SegmentCoreReaders.java:106)\n    at org.apache.lucene.index.SegmentReader.<init>(SegmentReader.java:74)\n    at org.apache.lucene.index.ReadersAndUpdates.getReader(ReadersAndUpdates.java:145)\n    at org.apache.lucene.index.BufferedUpdatesStream$SegmentState.<init>(BufferedUpdatesStream.java:384)\n    at org.apache.lucene.index.BufferedUpdatesStream.openSegmentStates(BufferedUpdatesStream.java:416)\n    at org.apache.lucene.index.BufferedUpdatesStream.applyDeletesAndUpdates(BufferedUpdatesStream.java:261)\n    at org.apache.lucene.index.IndexWriter.applyAllDeletesAndUpdates(IndexWriter.java:3413)\n    at org.apache.lucene.index.IndexWriter.maybeApplyDeletes(IndexWriter.java:3399)\n    at org.apache.lucene.index.IndexWriter.getReader(IndexWriter.java:454)\n    at org.apache.lucene.index.StandardDirectoryReader.doOpenFromWriter(StandardDirectoryReader.java:291)\n    at org.apache.lucene.index.StandardDirectoryReader.doOpenIfChanged(StandardDirectoryReader.java:276)\n    at org.apache.lucene.index.DirectoryReader.openIfChanged(DirectoryReader.java:235)\n    at org.apache.solr.core.SolrCore.openNewSearcher(SolrCore.java:1731)\n    ... 10 more\n\n\n    Other Observations:\n\n        It's not assocciated with a specific Lucene index file type (the 'read past EOF' has been reported on .fnm, .nvm, .tip. .si, .dvm files)\n        I've configured merges to use the LogByteSizeMergePolicyFactory and TieredMergePolicyFactory, and I see the failure with either.\n        The file system (~600gb) is never more than 50% full so disk space is not an issue\n        I've seen this occur with indexes on both ext4 and xfs file systems (which have been fsck'ed /repaired, and we're not seeing any hardware problems reported in the system logs). These file systems are all SSDs.\n        Solr is started with a 5Gb heap and I haven't seen heap usage > 3gb; also, there is no concurrent query activity during the indexing process.\n        I can recover from this error by unloading the core, running fixindex (whixch reports no errors), reloading the core, and continuing indexing from a checkpoint in the indexing script. \n\n    I've created a test rig (in Python) which can be run independently of our environment and workflow, and have managed to get this to throw the exception (the first stack trace above is from a run with that).\n\n    My semi-informed guess is that this is due to a race condition between segment merges and index updates...",
    "attachments": {},
    "issue_links": {},
    "comments": [
        {
            "date": "2017-11-09T15:03:37+0000",
            "content": "After moving our production Solr server to a new AWS instance, the problem disappeared. Heaven knows why. ",
            "author": "Simon Rosenthal",
            "id": "comment-16245785"
        }
    ]
}