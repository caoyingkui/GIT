{
    "id": "SOLR-11391",
    "title": "JoinQParser for non point fields should use the GraphTermsCollector",
    "details": {
        "labels": "",
        "priority": "Major",
        "components": [],
        "type": "Bug",
        "fix_versions": [],
        "affect_versions": "None",
        "resolution": "Unresolved",
        "status": "Open"
    },
    "description": "The Join Query Parser uses the GraphPointsCollector for point fields. \n\nFor non point fields if we use the GraphTermsCollector instead of the current algorithm I am seeing quite a bit of performance gains.\n\nI'm going to attach a quick patch which I cooked up , making sure TestJoin and TestCloudJSONFacetJoinDomain passed. \n\nMore tests, benchmarking and code cleanup to follow",
    "attachments": {
        "SOLR-11391.patch": "https://issues.apache.org/jira/secure/attachment/12888602/SOLR-11391.patch"
    },
    "issue_links": {},
    "comments": [
        {
            "date": "2017-09-23T01:12:42+0000",
            "content": "Very quick benchmarks on my local machine with master\n\nI indexed 3M documents. The cardinality of VIN_s/VIN_i is 1.5M ( 2 values for each unique VIN )\n\n3M matches\n{!join from=VIN_s to=VIN_s cache=false}*:*  : 2 seconds\n{!graph from=VIN_s to=VIN_s cache=false}*:*  : 4 seconds\n\n\n\n2M matches\n{!join from=VIN_s to=VIN_s cache=false}VIN_i:[0 TO  2000000]  : 1.8 seconds\n{!graph from=VIN_s to=VIN_s cache=false}VIN_i:[0 TO  2000000] : 4 seconds\n\n\n\n1M matches\n{!join from=VIN_s to=VIN_s cache=false}VIN_i:[0 TO  1000000]  : 1.4 seconds\n{!graph from=VIN_s to=VIN_s cache=false}VIN_i:[0 TO  1000000] : 2.9 seconds\n\n\n\n500k matches\n{!join from=VIN_s to=VIN_s cache=false}VIN_i:[0 TO  500000]  : 1 seconds\n{!graph from=VIN_s to=VIN_s cache=false}VIN_i:[0 TO 500000] : 1.2\n\n\n\n250k matches\n{!join from=VIN_s to=VIN_s cache=false}VIN_i:[0 TO  250000]  : .9seconds\n{!graph from=VIN_s to=VIN_s cache=false}VIN_i:[0 TO 250000] :  .6seconds\n\n\n\n\n10k matches\n{!join from=VIN_s to=VIN_s cache=false}VIN_i:[0 TO  10000]  : .7seconds\n{!graph from=VIN_s to=VIN_s cache=false}VIN_i:[0 TO 10000] :  .03\n\n\n\nSo we might want to keep a threshold and use the appropriate algorithm.  ",
            "author": "Varun Thacker",
            "id": "comment-16177410"
        },
        {
            "date": "2017-09-23T15:54:04+0000",
            "content": "Yeah, the threshold should be some function of field cardinality in conjunction with domain size.\nWe also need to use the term enum (join) method when the from field doesn't have docvalues. ",
            "author": "Yonik Seeley",
            "id": "comment-16177858"
        },
        {
            "date": "2017-09-26T19:51:12+0000",
            "content": "Updated patch.\n\nAll tests pass. The approach currently taken is if the domain filter matches less than 100k docs then we use the graph collector otherwise we use the terms enum approach.\n\nI'd like to see if it's possible to estimate based on cardinality as well\n\nTODOs:\n\n\tExplore cardinality based decision making as well\n\tShould we allow users to explicitly choose the approach from the JSON Facet Domain switch feature?\n\tThe Join Q Parser now exposes a \"useGraph\" param. Should we expose it ?\n\n\n ",
            "author": "Varun Thacker",
            "id": "comment-16181446"
        },
        {
            "date": "2017-09-26T20:25:11+0000",
            "content": "Explore cardinality based decision making as well\n\nTo choose a graph collector we know that the \"from\" field must have doc-values. So we could use the doc-values API to get the cardinality. I'll do a small benchmark to see how much overhead does it add.  ",
            "author": "Varun Thacker",
            "id": "comment-16181508"
        },
        {
            "date": "2017-09-26T20:56:19+0000",
            "content": "Patch which adds estimation based on cardinality as well. \n\nThe lookup is slow the first time when doc-values haven't been loaded up. \n\n{[cardinality < 1000}} : The 1000 number is a guess. Inputs welcome as to what a good threshold should be . \n\nWe can make use cardinality based estimation when users are using joins directly as well.  ",
            "author": "Varun Thacker",
            "id": "comment-16181559"
        },
        {
            "date": "2017-09-26T21:22:38+0000",
            "content": "The Join Q Parser now exposes a \"useGraph\" param. Should we expose it ?\n\nNo... it's a internal historical detail that is subject to change and doesn't communicate anything important.\nIf we do expose a \"method\" param for join, it should have something to do with the algorithm being used.\nWe could reuse some of the names that faceting uses:\n\n\t\"enum\" for enumerating over indexed terms and checking each term for an intersection with the domain.  O(field_cardinality)\n\t\"dv\" for doc values - for every document in the domain, we look up it's values O(n_documents_in_domain)\nI'm not sure if those are the best names or not... but you get the idea.\n\n ",
            "author": "Yonik Seeley",
            "id": "comment-16181604"
        },
        {
            "date": "2017-09-26T23:27:56+0000",
            "content": "Updated patch folding in Yonik's suggestions.\n\nThe Join Query parser exposes a method param. \n\nJSON Facet Domain also makes uses of it . If the method is not specified it uses the defaults ",
            "author": "Varun Thacker",
            "id": "comment-16181743"
        },
        {
            "date": "2017-09-27T00:16:30+0000",
            "content": "Updated patch with randomization in the method used in TestJoin ",
            "author": "Varun Thacker",
            "id": "comment-16181777"
        },
        {
            "date": "2017-09-27T04:14:42+0000",
            "content": "Method randomization to TestCloudJSONFacetJoinDomain also ",
            "author": "Varun Thacker",
            "id": "comment-16181951"
        },
        {
            "date": "2017-09-27T21:51:38+0000",
            "content": "\nMy review below on the latest patch.  In general I'm very confused about why/how the \"join method\" (used in the facet domain) seems to be choosen based on the \"facet method\" (for the field faceting) ... i don't really understand why those 2 things should be connected in any way, and none of the comments so far in this issue seems to suggest that should (or needs to) be any connection between them \u2013 other then yonik's suggestion that they should use similar vocabulary (enum, dv, etc...)\n\nI suspect this is a logic mistake in the design, and that the intent was to add a \"method\" option on the \"join domain\" just like a \"method\" param was added to the \"join parser\" ?\n\nIn any case, here's all of my feedback as is...\n\n\n\tJoinQParserPlugin\n\t\n\t\tboolean useGraphCollector\n\t\t\n\t\t\tseems like an enum would be better given local param isn't just true/false\n\t\t\tespecially if we anticipate that there may be more \"methods\" down the road\n\t\t\tif nothing else: it would make the code easier to read & understand (especially when the helper method gets used by the facet code, see comments below)\n\t\t\n\t\t\n\t\tAFAICT: \"method\" is now the first param that JoinQParserPlugin supports that ScoreJoinQParserPlugin does not support\n\t\t\n\t\t\twhich means that the parse() and parseJoin() methods need to be refactored to give a clear error if someone tries to combine the \"score\" param with a \"method\" param. (before this parser delegates to ScoreJoinQParserPlugin\n\t\t\n\t\t\n\t\n\t\n\n\n\n\n\tJoinQuery\n\t\n\t\tI'm confused about the isPointField() points code path...\n\t\t\n\t\t\t\"if points, then use GraphPointsCollector\" ... even if false==useGraphCollector ?\n\t\t\tif that's inentional, then shouldn't param validation (in JoinQParserPlugin) reject any explicit method=enum for points fields?\n\t\t\n\t\t\n\t\texecuteJoinQuery\n\t\t\n\t\t\tneeds jdocs\n\t\t\tmodifies the List<Query> domainFilters passed by caller\n\t\t\t\n\t\t\t\twill be problematic if caller is reusing the same domainFilters for multiple JoinQueries\n\t\t\t\tjdocs (all the way up) should either be very clear about this, or JoinQuery should make a defensive copy\n\t\t\t\toff the top of my head: i have no idea if any of the existing (caller) code (in FacetProcessor) may be sharing the qlist across multiple facets/code-paths\n\t\t\t\n\t\t\t\n\t\t\t//TODO: is it okay to cache this? I guess we were previously caching as well?\n\t\t\t\n\t\t\t\tAFAICT from the existing code: No, it was not cached (code uses getDocSetNC)\n\t\t\t\tin current patch, copy/past comment says \"don't cache the resulting docSet\" but then calls getDocSet() ... which does cache. So either comment needs fixed, or method needs changed.\n\t\t\t\n\t\t\t\n\t\t\n\t\t\n\t\n\t\n\n\n\n\n\tSolrIndexSearcher.getCardinalityForDVField\n\t\n\t\tneeds jdocs\n\t\tis this really the \"cardinality\" ???\n\t\t\n\t\t\tit looks like it's actually the sum of the cardinalities across all segments (not the same when terms exist in multiple segments)\n\t\t\n\t\t\n\t\tperhaps (in general) a better approach then looking at an absolute cardinality/docs threshold of 1000 / 100,000 would be to look at the aproximate ratio of field cardinality to docCount?\n\t\t\n\t\t\tthat could be computed per segment, and then aproximated over all segments\n\t\t\t\n\t\t\t\tie: ( sum of (seg_cardinality/seg_doccount) for all segments ) / num_segments\n\t\t\t\n\t\t\t\n\t\t\t(obviously this wouldn't make sense as a generic SolrIndexSearcher helper method, just something that occured to me in the context of reviewing this method)\n\t\t\n\t\t\n\t\n\t\n\n\n\n\n\tFacetProcessor.handleJoinField\n\t\n\t\tjdocs need updated to explain return value\n\t\tsince semantics have changed such that method assumes it won't be called if null==freq.domain.joinField method should start with an assert to that effect (and have jdocs noting it)\n\t\n\t\n\n\n\n\n\tFacetProcessor.chooseCollector\n\t\n\t\tneeds jdocs\n\t\tshouldn't this name be something more specific to the fact that it's choosing the join domain collector?  AFAICT it has nothing to do with any other type of facet processing collector\n\t\t\n\t\t\tin general, all this code seems like it belongs in the JoinField class?\n\t\t\t\n\t\t\t\tNote the existing comments in createDomainQuery \u2013 the same rationale seems applicable here.\n\t\t\t\n\t\t\t\n\t\t\n\t\t\n\t\tin general, i'm confused as to the intent of this code ... why are we choosing a (\"method\" / \"boolean useGraphCollector\") for the JoinQuery that will power the domain based on the \"method\" used by the FacetField itself? ... those seem completely orthoginal\n\t\t\n\t\t\tis this all a mistake?  Was the intent to add an optional \"method\" option to the \"join\" domain specified by the request?\n\t\t\tif this code is intentional (ie: if we really are intentionally choosing the join collector based on the term FacetMethod) then:\n\t\t\tthis should be extensively explained in the comments\n\t\t\tthe code/comments should more completely handle the various FacetMethod enum options available\n\t\t\t\n\t\t\t\tExample: code currently returns false immediately for FacetMethod.ENUM, but not for FacetMethod.STREAM which is (IIUC) functionally equivilent???\n\t\t\t\n\t\t\t\n\t\t\n\t\t\n\t\tagain: using an enum (in JoinQParser) to indicate the type of join collector (might) make this method a lot easier to read and a lot less brittle\n\t\t\n\t\t\t(depending on what the goal actually is ... if nothing else it would help clarify the distinction between when the FacetMethod is relevant vs when the \"JoinMethod\" is relevant )\n\t\t\n\t\t\n\t\twhat are the cases where this catch (IOException e) block may trigger?\n\t\t\n\t\t\tWhy is that a simple \"return false\" instead of rethrowing???\n\t\t\n\t\t\n\t\twhy is the hueristic logic (for choosing hte collector based on cardinality and/or numDocs) in this method, instead of in a JoinQParserPlugin helper method?\n\t\t\n\t\t\twouldn't the same hueristic logic be useful for when a user does a \"{!join}\" query w/o a \"method\" param?\n\t\t\n\t\t\n\t\n\t\n\n\n\n\n\tFacetProcessor.handleBlockJoin\n\t\n\t\tsince semantics have changed such that method assumes it won't be called if !(freq.domain.toChildren || freq.domain.toParent) method should start with an assert to that effect (and have jdocs noting it)\n\t\tacceptDocs initialization could be heavily simplified with terinary op...\n\t\t\n\t\t\tDocSet acceptDocs = (null == qlist) ? fcontext.searcher.getLiveDocs() : fcontext.searcher.getDocSet(qlist);\n\t\t\n\t\t\n\t\n\t\n\n\n\n\n\tGraphEdgeCollector & GraphTermsCollector\n\t\n\t\tnow that these classes are public, they should definitely get some javadocs\n\t\n\t\n\n\n\n\n\tschema12.xml & TestJoin\n\t\n\t\trather then adding a new special sys prop just for this test, it seems a lot more straight forward to add some new field/dynamicField declarations that explicitly set docValues=true/false\n\t\tthat would also allow the test methods to be refactored, so that a single test class run could test both the enum & dv methods against diff fields as needed (ie: paramaterize the meat of the tests)\n\t\t\n\t\t\trandomly only testing one each time is far from ideal.\n\t\t\tthe pattern used for points/tries isn't ment to be an example to follow when dealing with a \"choice\" in a test \u2013 it was a path of last resort for retrofiting hundreds of pre-existing tests knowing that one of those \"choices\" was going to be immediately deprecated and phased out.\n\t\t\n\t\t\n\t\tTestJoin should also have some \"test the error code/msg\" checks that asking for a particular method fails with an expected error message for all the potential error paths.\n\t\t\n\t\t\thaving non-randomized types will make this much easier to add.\n\t\t\n\t\t\n\t\n\t\n\n\n\n\n\tTestCloudJSONFacetJoinDomain\n\t\n\t\tsee comments above regarding my confusion about conflating the TermFacet \"method\" with the \"method\" used by the \"join\" domain\n\t\t\n\t\t\tmore on this as it pertains to randomized testing below...\n\t\t\n\t\t\n\t\tbuildRandomFacets\n\t\t\n\t\t\tin general i don't really understand these changes...\n\t\t\t\n\t\t\t\tit seems like you are randomizing the facet method based entirely on the properties of the random domain .... but it should be possible to randomize the method param entirely independently (from specifics of the domain) and across all possible values of the FacetMethod enum\n\t\t\t\tthe only possible restrictions the \"TermFacet.method\" randomization logic (in this test) should place on what method it chooses should be based on the \"TermFacet.field\" (not the \"JoinDomain.from\" field) if and only if we know that it's an \"error\" to request a certain type of FacetMethod for a certain type/properties of the \"facet field\"\n\t\t\t\tif there are in fact some join (domain) code paths that may be invalid with the \"graphCollector?\" value chosen automatically by some \"facet method\" options (depend on the various field types/properties) then that should be considered a bug in the \"chooseCollector()\" code and fixed \u2013 it should not cause the client to get an error (that would needs to be worked around in this test by only picking certain \"TermFacet.method\" values based on if/when a JoinDomain uses certain types of fields)\n\t\t\t\n\t\t\t\n\t\t\tregardless of intent: in at least some situations, the \"TermFacet.method\" variable should be randomized to \"null\" to test the default hueristics.\n\t\t\n\t\t\n\t\tJoinDomain\n\t\t\n\t\t\tif we are in fact adding a \"join: { method: foo, ... }\" type \"JoinDomain.method\" option to the code, then it should be accounted for in the test model here, and randomized.\n\t\t\tThis should be completley independently from any FacetField.method randomization\n\t\t\n\t\t\n\t\ttestBespoke\n\t\t\n\t\t\tplease add some simple sanity checks of the new TermFacet \"method\" option\n\t\t\tand, perhaps, some testing of a distinct JoinDomain \"method\" (if that is being added)\n\t\t\n\t\t\n\t\n\t\n\n ",
            "author": "Hoss Man",
            "id": "comment-16183317"
        },
        {
            "date": "2017-10-04T01:24:02+0000",
            "content": "Thanks Hoss for the great feedback!\n\nThis patch addresses all but one your concerns. \n\nOnly the last point about the testing in TestCloudJSONFacetJoinDomain that needs to be addressed. I will tackle that tomorrow and also fold in the new updated test once SOLR-11372 has been committed.  ",
            "author": "Varun Thacker",
            "id": "comment-16190641"
        },
        {
            "date": "2017-10-04T04:02:48+0000",
            "content": "Epic code review Hoss    Nice work Varun \u2013 I'm looking forward to this.  ",
            "author": "David Smiley",
            "id": "comment-16190765"
        },
        {
            "date": "2017-10-04T17:02:16+0000",
            "content": "small update to the patch. Still need to address the last comment ",
            "author": "Varun Thacker",
            "id": "comment-16191572"
        },
        {
            "date": "2017-10-04T17:19:42+0000",
            "content": "reviewing varun's latest patch now ... here's a quick updated version to get it to compile (after the SOLR-11372 tweaks i just committed) ",
            "author": "Hoss Man",
            "id": "comment-16191604"
        },
        {
            "date": "2017-10-04T20:23:02+0000",
            "content": "Here is another datapoint with a test set to tune NUM_DOCS_THRESHOLD\n\nIndexed 33M documents in a single shard collection\n\ndoc_type_s:X AND year:2007 matches 240397 documents . \n\n\nThe following queries matches 673000 documents\n\n{!join to=join_key from=join_key cache=false}(doc_type_s:X AND year:2007)\n \n\n\nmethod=enum executes in 8 seconds and method=dv executes in 2 seconds .   ",
            "author": "Varun Thacker",
            "id": "comment-16191976"
        },
        {
            "date": "2017-10-05T02:28:21+0000",
            "content": "\nComments on latest patch (broader thoughts below)...\n\n\n\tJoinQParserPlugin.java\n\t\n\t\tchooseJoinMethod\n\t\t\n\t\t\tjavadocs should be valid html, docs need to come before @param, etc...\n\t\t\tIIUC, you've deleted the only code path that will give the user an error if the field points==true but docValues==false\n\t\t\t\n\t\t\t\tvalidateJoinMethod will fail if the user explicitly asks for ENUM, but here in this method you'll attempt to use ENUM if the user sends method=null|SMART\n\t\t\t\n\t\t\t\n\t\t\ttreating \"!= -1\" as magic is dangerous, what if some code accidently passes -2? ... \"< 0\" is safer\n\t\t\t\n\t\t\t\teither that or assert -1 <= domainSize\n\t\t\t\n\t\t\t\n\t\t\tif we just want the LeafReaderContext then why ask for getSlowAtomicReader() ? why not just use searcher.getLeafContexts() ?\n\t\t\tsumRatio = + segmentCardinality / segmentDocs; ... 100% certain that should be +=\n\t\t\tthe existence of the += typo plus the \"pick ENUM for poins w/o docValues w/o error\" mentioned above tells me this method should most certainly have some very targeted unit tests\n\t\t\t\n\t\t\t\tthere should most certianly be a unit test of this specific method that asserts it gets ENUM back for some fields and DV back for others based on the individual segments\n\t\t\t\tideally, instead of needing to actaully build up tones of large indexes for this, this helper method should be refactored to take in some arrays of the data \u2013 ie: chooseJoinMethod(SolrIndexSearcher, SchemaField, int) should delegate to some chooseJoinMethodByDvStats(long[] numDocsPerLeaf, long[] cardinalityPerLeaf) that we have direct unit tests for\n\t\t\t\n\t\t\t\n\t\t\n\t\t\n\t\tJoinQuery\n\t\t\n\t\t\tconstructor still needs jdocs\n\t\t\t\n\t\t\t\tin particular needs to point out that if domainFilters != null it will have elements added to it when query is exececuted\n\t\t\t\t(either that, or refactor the defensive copy down from createJoinQuery)\n\t\t\t\n\t\t\t\n\t\t\ttoString should definitely use the method in it's output\n\t\t\thashCode and equals currently don't consider method or domainFilters in processing\n\t\t\t\n\t\t\t\tshould diff method values make 2 JoinQuery objects not-equals?  what about SMART values? ... not sure.\n\t\t\t\tdifferent domainFilters should definitely make 2 JoinQuery objects not-equals, othewise we're going to get weird caching behavior \u2013 but this raises interesting questions about what happens when the JoinMethod type doesn't even support/use the domainFilters ... then should 2 JoinQuery objects be considered equal?\n\t\t\t\tno matter what, these questions make it clear we should add some more robust equal/not-equal checks for the join parser (and using createJoinQuery with diff domainFilters)\n\t\t\t\n\t\t\t\n\t\t\twe should probably call method = chooseJoinMethod before validateJoinMethod(...) to help ensure we never intorduce bugs that cause our hueristic to pick broken options for the specified field\n\t\t\t\n\t\t\t\tideally this code path would/should even catch/retrow the SolrException and wrap it in a \"code is broken, please file a bug\" if the original method was SMART\n\t\t\t\teither that, or just refactor validateJoinMethod and chooseJoinMethod into a single method that: 1) if SMART, attempts to narrow down by field props or error if nothing legal; 2) if still options, pick based on field stats.\n\t\t\t\teither way, doing this choosing & validating should be done as early as possible \u2013 why not put it in the JoinQueryWeight constructor instead of in the JoinQueryWeight.getDocSet() method ?\n\t\t\t\t\n\t\t\t\t\tthen we could also set the \"actual\" method in the dbg info created by JoinQueryWeight.scorer()\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tactually \u2013 what would probably be best is if the JoinQuery constructor rejected null or SMART as input values, and required the caller to call thes new merged \"choose+validate helper\" (both the JoinQParser.parse() method and the facet code using {{createJoinQuery() are garunteed to have access the the neccessary SolrIndexSearcher) to resolve the user specified \"method\" into an \"executable\" method.  That way the JoinQuery constructor could explicitly set this.domainFilters=null unless the method supported them (which would simplify the questions about how hashCode and equals() should work.\n\t\t\t\n\t\t\t\n\t\t\n\t\t\n\t\tvalidateJoinMethod\n\t\t\n\t\t\tonce points is checked, why is there redundent nested if check for isPointField() ?\n\t\t\n\t\t\n\t\texecuteJoinQuery\n\t\t\n\t\t\tjdocs still need to mention this method modifies domainFilters\n\t\t\t\n\t\t\t\tor better still: preserve the original domainFilter passed by the client all the way into the JoinQuery and assign to this.domainFilters (which should be final), but only make a copy here inside executeJoinQuery (to add the uncachedJoinQ to) and then let the copy by GCed after the toSearcher.getDocSet(...); call ... which would also help simplify the issues/risks/confusion as far as the hashCode and equals methods are concerned with domainFilter\n\t\t\t\n\t\t\t\n\t\t\twhy the redunent DocSet result = ...; return result; (in two places) ? ... why not just \"return ...}}\n\t\t\n\t\t\n\t\tgetDocSetEnumerate\n\t\t\n\t\t\tif this method only works with JoinMethod.ENUM there should be an assert to that effect\n\t\t\tif this method ignores domainFilters then there should be an assert that it's null\n\t\t\t(both of these will help protect us from developer mistakes down the road)\n\t\t\n\t\t\n\t\n\t\n\n\n\n\n\tTestCloudJSONFacetJoinDomain.java\n\t\n\t\tJoinDomain\n\t\t\n\t\t\tjdocs need updated\n\t\t\tconstructor should probably assert null != from || null == method ... it will only confuse people (and future devs if there is a \"method\" specified even when there is no join and we're just filtering.\n\t\t\n\t\t\n\t\tbuildRandomDomain()\n\t\t\n\t\t\twe should randomize both null and \"smart\" values to test all the code paths (as things stand right now, we're never exercising the \"hueristic\" logic in these randomized tests\n\t\t\tif from is null, method should always be be null ... otherwise it could easily confuse people 9see above suggestion about adding assertion to the JoinDomain constructor)\n\t\t\t\n\t\t\t\tprobably best to start with null as the default, if from is non-null randomly set to \"smart\" sometimes, and/or randomly set to \"dv\" or \"enum\" if and only if we can tell from the field info that one of those options will be supported\n\t\t\t\n\t\t\t\n\t\t\n\t\t\n\t\tapplyDomainToQuery\n\t\t\n\t\t\tI notice that you did not modify this method to use the new method option on the {!join} query when verifying the facet results ... i'm not sure if that was intentional, but i think it's a good idea to leave the code the way it is in the current patch\n\t\t\tthis way, even as we randomize the method in the facet join domain, we verify the results using whatever the default (implicit) algorithm is for the join query\n\t\t\ti do think however, that \"this method\" (applyDomainToQuery)  should be updated with an explicit comment pointing out that we are explicitly ignoring this.method for this reason\n\t\t\n\t\t\n\t\n\t\n\n\n\n\n\n\tTestJoin.java\n\t\n\t\trunWithMethod + testJoin\n\t\t\n\t\t\tin the event of failure, our test coverage will be a lot better if you just put each call to runWithMethod in it's own public void test* method\n\t\t\t\n\t\t\t\tExample: \n\npublic void testBasicJoinUsingEnum() { runWithMethod(\"enum\"); }\n\n\n\t\t\t\tthat way if someone breaks something only in the DV code path, it will be really obvious if the enum test still passes \u2013 but if noth tests fail, we'll know it's in the common code\n\t\t\t\n\t\t\t\n\t\t\tlikewise, there should probably be versions that calls runWithMethod(\"smart\"); and runWithMethod(null)'\n\t\t\tbetter still: runWithMethod could be made a lot more robust by adding a String joinFieldSuffix option instead of picking the field names based on the method arg \u2013 and then we could test all the permutations that are expected to be valid: \n\npublic void testBasicJoinEnum() { runWithMethod(\"enum\", \"_s\"); }\npublic void testBasicJoinDV() { runWithMethod(\"dv\", \"_ds\"); }\npublic void testBasicJoinEnumDVField() { runWithMethod(\"enum\", \"_ds\"); }\npublic void testBasicJoinHueristicDVField() { runWithMethod(null, \"_ds\"); }\npublic void testBasicJoinHueristicNoDVField() { runWithMethod(null, \"_s\"); }\n\n\n\t\t\n\t\t\n\t\trunWithMethod + error handling\n\t\t\n\t\t\tdocs 14 & 15 + the error handling checks for a missmatch between the method type and the field options don't seem like they belong in this method at all\n\t\t\t\n\t\t\t\tthese types of assertions should be refactored into their method\n\t\t\t\tassertions of error messages should either use assertQEx(...) or Exception e = expectThrows(... (followed by assertions on the e to check it's message, type, etc...)\n\t\t\t\t\n\t\t\t\t\tin particular it makes no sense to use assetJQ with an \"expected\" pattern match on the response ( numFound=3 + list of sorted docs) if the actual expectation is a thrown exception.\n\t\t\t\t\n\t\t\t\t\n\t\t\t\twe also seem to be missing a check for the case of someone requesting method=enum on a (non-points) field w/ indexed=false docValues=true ?\n\t\t\t\n\t\t\t\n\t\t\n\t\t\n\t\ttestRandomJoin\n\t\t\n\t\t\twe should just remove the dead code (ie: /* disable matching incompatible fields ...\n\t\t\tSystem.getProperty(\"solr.tests.numeric.dv\") ... replace with Boolean.getBoolean(NUMERIC_POINTS_SYSPROP)\n\t\t\t\n\t\t\t\tin general this special case is weird & confusing an desrves a comment (why is groupNumber==1 special?)\n\t\t\t\n\t\t\t\n\t\t\tthis method should be also be randomly specifying method=\"smart\" and \"null|no method\" (where no method localparam is specified at all)\n\t\t\n\t\t\n\t\n\t\n\n\n\n\n\tGraphTermsCollector.java\n\t\n\t\tthe class javadocs should give some information about the specifics of how it extends the abstract base class \u2013 not just link to it.\n\t\n\t\n\n\n\n\n\tFacetRequest.java\n\t\n\t\tcreateDomainQuery\n\t\t\n\t\t\tI see once this method is called why it takes in a JoinMethod instead of using this.method but at first glance it's entirely unclear \u2013 some docs/comments explaing will save other devs a lot of confusion down the road\n\t\t\n\t\t\n\t\n\t\n\n\n\n\n\tFacetProcessor.java\n\t\n\t\thandleJoinField\n\t\t\n\t\t\tprevious comment still applies....\nsince semantics have changed such that method assumes it won't be called if null==freq.domain.joinField method should start with an assert to that effect (and have jdocs noting it)\n\t\t\tthe previously mentioned suggestion to merge chooseJoinMethod with validateJoinMethod would help simplify this method a fair bit\n\t\t\tThe more this patch evolves, and the more i think about it, the less comfortable i am with the brittle assumptions the FacetProcessor code has to make about if/when the qlist/domainFilters will be used.\n\t\t\t\n\t\t\t\tright now it's if (method == JoinMethod.DV) but what if other methods are added later?\n\t\t\t\tat a minimum we could add boolean getFiltersSupported() property to JoinMethod ... but what would SMART return?  (maybe throw an IllegalStateException?)\n\t\t\t\tmore broad picture thoughts on this below....\n\t\t\t\n\t\t\t\n\t\t\n\t\t\n\t\thandleBlockJoin\n\t\t\n\t\t\tprevious comment still applies...\nsince semantics have changed such that method assumes it won't be called if !(freq.domain.toChildren || freq.domain.toParent) method should start with an assert to that effect (and have jdocs noting it)\n\t\t\tthere's a subtle change here (maybe it was in the last patch and i missed it) in the freq.domain.toChildren that i'm not clear on...\n\t\t\t\n\t\t\t\tpreviuosly, appliedFilters = true; was only set if we had a filter ... now it's set (for the toChildren case) regardless of wether there is a filter\n\t\t\t\tis this intentional? if so, then can't we just: refactor away both the boolean appliedFilters and DocSet result variables; make both code paths assign directly to fcontext.base ; make both bode paths return true or return false (respectively)\n\t\t\t\n\t\t\t\n\t\t\n\t\t\n\t\n\t\n\n\n\n\n\tother-parsers.adoc\n\t\n\t\tit doesn't really make sense to mention that score doesn't support method before we've even explained what method is\n\t\t\n\t\t\ti would suggest that instead, it would make more sense to include an info (or warning) box in the \"Join Parser Execution\" section pointing out that specifying a method is incompatible with specifying a score mode\n\t\t\n\t\t\n\t\tthe list of supported methods should include \"smart\" and it should note that this is the default method if non is specified\n\t\n\t\n\n\n\n\n\n\nAs mentioned above, I have some concerns about how FacetProcessor has to make some assumptions about if/when the filters are being handled by the JoinQuery and when the facet code has to handle them itself.  This also relates to the questions about wether or not 2 JoinQuery objects should be considered \"equals\" from a caching perspective if they have different domainFilters but method==enum so those filters aren't used anyway.\n\nI really think that at a broader level we need to take 1 of 2 paths here...\n\n\n\tA\n\t\n\t\tadd a property to the JoinMethod indicating if it supports domainFilters,\n\t\t\n\t\t\ton SMART this property should throw illegal state exception\n\t\t\n\t\t\n\t\tforce JoinQuery \"creators\" to pass in a \"non-SMART\" (non-null) JoinMethod when building the JoinQueries so the constuctor can definitively throw an exception if null!=domainFilters but the method doesn't support them.\n\t\t\n\t\t\tgive callers a public method to \"choose\" a non-SMART JoinMethod given the user's original input, the schema, and the index searcher \u2013 so they can know if/when it's legal to pass in domainFilters, or when they must pass null\n\t\t\tthis way the FacetProcessor code doesn't have to make assumptions \u2013 it knows exactly when it did/didn't pass qlist vs null to createDomainQuery(...)\n\t\t\n\t\t\n\t\n\t\n\n\n\n\n\tB\n\t\n\t\tmake JoinQuery public & abstract\n\t\trefactor 2 diff concrete subclasses: one for TermEnum and one for DV\n\t\tonly the DV based class should have a constructor that takes in domainFilters\n\t\tneither concrete subclass should know anything about JoinMethod \u2013 that should be handled by the helper code in JoinQParserPlugin\n\t\tchange the return type of JoinQParserPlugin.chooseJoinMethod to be JoinQuery\n\t\tadd a List JoinQuery.getNestedFilters() method to JoinQuery that normally returns null, but the DV subclass returns it's domainFilters\n\t\tthis way the FacetProcessor code doesn't have to make assumptions \u2013 it can ask the JoinQuery it gets back from createDomainQuery(...) wether it has any nested filters or not\n\t\n\t\n\n\n\n\n...I don't know if i have a strong preferece between A or B.  What do other folkss think? ",
            "author": "Hoss Man",
            "id": "comment-16192388"
        },
        {
            "date": "2017-12-13T06:15:20+0000",
            "content": "A WIP addressing some of the feedback from Hoss. \n\nI found a few spare hours so I worked on this. I plan on spending a couple of days towards the end of the year addressing all the feedback ",
            "author": "Varun Thacker",
            "id": "comment-16288767"
        },
        {
            "date": "2018-06-21T11:55:32+0000",
            "content": "Finally getting back to this. It's been a while but here's what I am thinking\u00a0\n\n\"JoinQParser for non point fields should use the GraphTermsCollector\" - Stick to this Jira description. So shorten the scope here and just work on the JoinQParser part\u00a0\n\nThen in a followup Jira work on making JSON Facets take advantage of this.\u00a0\n\nI'll address Hoss's feedback in my next patch\u00a0\n\n\u00a0 ",
            "author": "Varun Thacker",
            "id": "comment-16519267"
        }
    ]
}