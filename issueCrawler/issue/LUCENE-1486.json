{
    "id": "LUCENE-1486",
    "title": "Wildcards, ORs etc inside Phrase queries",
    "details": {
        "labels": "",
        "priority": "Minor",
        "components": [
            "core/queryparser"
        ],
        "type": "Improvement",
        "fix_versions": [
            "4.8"
        ],
        "affect_versions": "2.4",
        "resolution": "Fixed",
        "status": "Closed"
    },
    "description": "An extension to the default QueryParser that overrides the parsing of PhraseQueries to allow more complex syntax e.g. wildcards in phrase queries.\n\nThe implementation feels a little hacky - this is arguably better handled in QueryParser itself. This works as a proof of concept  for much of the query parser syntax. Examples from the Junit test include:\n\n\t\tcheckMatches(\"\\\"j*   smyth~\\\"\", \"1,2\"); //wildcards and fuzzies are OK in phrases\n\t\tcheckMatches(\"\\\"(jo* -john)  smith\\\"\", \"2\"); // boolean logic works\n\t\tcheckMatches(\"\\\"jo*  smith\\\"~2\", \"1,2,3\"); // position logic works.\n\n\t\tcheckBadQuery(\"\\\"jo*  id:1 smith\\\"\"); //mixing fields in a phrase is bad\n\t\tcheckBadQuery(\"\\\"jo* \\\"smith\\\" \\\"\"); //phrases inside phrases is bad\n\t\tcheckBadQuery(\"\\\"jo* [sma TO smZ]\\\" \\\"\"); //range queries inside phrases not supported\n\nCode plus Junit test to follow...",
    "attachments": {
        "LUCENE-1486.patch": "https://issues.apache.org/jira/secure/attachment/12410682/LUCENE-1486.patch",
        "TestComplexPhraseQuery.java": "https://issues.apache.org/jira/secure/attachment/12401246/TestComplexPhraseQuery.java",
        "junit_complex_phrase_qp_07_21_2009.patch": "https://issues.apache.org/jira/secure/attachment/12414166/junit_complex_phrase_qp_07_21_2009.patch",
        "ComplexPhraseQueryParser.java": "https://issues.apache.org/jira/secure/attachment/12401245/ComplexPhraseQueryParser.java",
        "Lucene-1486 non default field.patch": "https://issues.apache.org/jira/secure/attachment/12414443/Lucene-1486%20non%20default%20field.patch",
        "junit_complex_phrase_qp_07_22_2009.patch": "https://issues.apache.org/jira/secure/attachment/12414217/junit_complex_phrase_qp_07_22_2009.patch"
    },
    "issue_links": {},
    "comments": [
        {
            "date": "2008-12-10T18:19:51+0000",
            "content": "Junit test ",
            "author": "Mark Harwood",
            "id": "comment-12655300"
        },
        {
            "date": "2008-12-10T18:20:23+0000",
            "content": "QueryParser extension ",
            "author": "Mark Harwood",
            "id": "comment-12655301"
        },
        {
            "date": "2008-12-11T14:34:37+0000",
            "content": "Added tests for range queries and plain PhraseQueries ",
            "author": "Mark Harwood",
            "id": "comment-12655664"
        },
        {
            "date": "2008-12-11T14:35:20+0000",
            "content": "Fixed bug with plain phrase query, added support for range queries ",
            "author": "Mark Harwood",
            "id": "comment-12655665"
        },
        {
            "date": "2008-12-12T10:45:09+0000",
            "content": "(Added 2.9 fix version in addition to 2.4.1). ",
            "author": "Michael McCandless",
            "id": "comment-12655966"
        },
        {
            "date": "2008-12-12T15:23:04+0000",
            "content": "Added support for \"Nots\" in phrase queries e.g. \"-not interested\" ",
            "author": "Mark Harwood",
            "id": "comment-12656034"
        },
        {
            "date": "2008-12-12T15:23:22+0000",
            "content": "More tests for Nots ",
            "author": "Mark Harwood",
            "id": "comment-12656035"
        },
        {
            "date": "2009-03-02T15:17:06+0000",
            "content": "Updated to cater for phrase clauses that produce no matches ",
            "author": "Mark Harwood",
            "id": "comment-12678015"
        },
        {
            "date": "2009-03-02T15:18:09+0000",
            "content": "Updated Junit test to test for phrases with clauses that produce no matches ",
            "author": "Mark Harwood",
            "id": "comment-12678017"
        },
        {
            "date": "2009-06-11T02:25:35+0000",
            "content": "What do you think about this for 2.9 Mark H?\n\nThe implementation feels a little hacky - this is arguably better handled in QueryParser itself. This works as a proof of concept for much of the query parser syntax.\n\nThat leads me to think we might want to push to 3.0? Or have you moved beyond that with all of these updates? ",
            "author": "Mark Miller",
            "id": "comment-12718281"
        },
        {
            "date": "2009-06-11T18:11:32+0000",
            "content": "Perhaps \"hacky\" was too strong a word. I think it's a reasonable approach to handling the complexity involved in this logic. \n\nA colleague of mine has this running in production on a big installation with lots of users ",
            "author": "Mark Harwood",
            "id": "comment-12718573"
        },
        {
            "date": "2009-06-13T09:48:53+0000",
            "content": "Is there some reason not to include this in QueryParser instead?  Ie, it accepts a superset of QueryParser's current syntax? ",
            "author": "Michael McCandless",
            "id": "comment-12719105"
        },
        {
            "date": "2009-06-13T11:58:23+0000",
            "content": "The primary reason (and perhaps not a particularly good one) was I didn't want to wade around in the Javacc syntax of the .jj file that generates the QueryParser and the required extensions could be made in a subclass.\n\nAlso there is invariably a performance hit for supporting things like wildcards in phrase queries so rather than adding another \"off by default\" flag in the main parser  and conditional logic to test if \"wildcards etc in phrases\" are allowed, the subclass could be seen as a specialised extension that is to be used by those that understand the trade-offs between functionality and performance.  \n\nI can sympathise with the purist approach of having all parser syntax defined in Javacc though. ",
            "author": "Mark Harwood",
            "id": "comment-12719115"
        },
        {
            "date": "2009-06-15T16:52:47+0000",
            "content": "Should this go in contrib rather than core? That seems to have been the approach so far, any reason to vary it up here?\n\nWell, actually, looks like I see the multi field parser in core. Makes sense to put subclasses there I guess.\n\nYou think this is ready to commit Mark? If so, I should be able to review it (unless you want to commit it yourself). ",
            "author": "Mark Miller",
            "id": "comment-12719639"
        },
        {
            "date": "2009-06-15T17:00:37+0000",
            "content": "Reformatted to lucene formatting, removed author tag, removed a couple unused fields, changed to patch format\n\nTests don't pass because it doesnt work quite correctly with the new constantscore multi term queries yet. ",
            "author": "Mark Miller",
            "id": "comment-12719644"
        },
        {
            "date": "2009-06-24T19:30:33+0000",
            "content": "Hey Mark, this doesn't work correctly with the new constant score mode. I'm hesitant to put something in core that only works with boolean expansion.\n\nI'm not sure what needs to be done (I started and realized my interest wasn't high enough). Could you update this? Otherwise I'm tempted to push off to 3.0...\n\nUnless another brave soul steps of course. Or I may jump back in - my brain is fickle. ",
            "author": "Mark Miller",
            "id": "comment-12723699"
        },
        {
            "date": "2009-06-24T21:05:57+0000",
            "content": "Added fix for ConstantScoreQuery changes ",
            "author": "Mark Harwood",
            "id": "comment-12723737"
        },
        {
            "date": "2009-06-24T21:12:38+0000",
            "content": "The fix was relatively straight-forward from what I could see. Just temporarily unset the QueryParser's ConstantScoreRewrite mode when performing the pass that is just evaluating query elements inside phrase queries. These clauses need to resolve to traditional BooleanQuery-full-of-termQueries in order that they can be inspected and rewritten as Span equivalents for complex phrases.\n\nShould do the job.\n\nCheers\nMark\n(Been far too busy with other things and missing getting my hands dirty here with Lucene!) ",
            "author": "Mark Harwood",
            "id": "comment-12723742"
        },
        {
            "date": "2009-06-24T21:25:08+0000",
            "content": "Figured thats all it would take. I just was feeling a bit too lazy to try and understand the whole class after I put it up in front of me for a few seconds  Figured I'd try and pawn off a piece. I made some adjustments to the patch last time, but they were basically cosmetic.\n\nLooks like I didnt escape much work this time though - I'll review and commit shortly.\n\nThanks a lot. ",
            "author": "Mark Miller",
            "id": "comment-12723747"
        },
        {
            "date": "2009-07-06T17:03:06+0000",
            "content": "Whoops - almost let some 1.5 slip by:  throw new IllegalArgumentException(pe.getMessage(), pe) is not in 1.4.\n\nLast patch. I'll commit later today. ",
            "author": "Mark Miller",
            "id": "comment-12727622"
        },
        {
            "date": "2009-07-06T18:37:06+0000",
            "content": "Hi Mark,\nMind if I try committing this patch?\nI've just switched from PC to Mac and my dev environment is all changed (Subclipse vs TortoiseSvn etc) and I wouldn't mind checking my config and commit rights still work in this new environment.\nIf anyone has any  mac/subclipse-related \"gotchas\" I should be aware of, do let me know. \n\nCheers\nMark ",
            "author": "Mark Harwood",
            "id": "comment-12727685"
        },
        {
            "date": "2009-07-06T18:47:18+0000",
            "content": "Please, by all means !  ",
            "author": "Mark Miller",
            "id": "comment-12727692"
        },
        {
            "date": "2009-07-06T19:41:11+0000",
            "content": "Committed in 791579 -  http://svn.apache.org/viewvc?rev=791579&view=rev ",
            "author": "Mark Harwood",
            "id": "comment-12727726"
        },
        {
            "date": "2009-07-21T23:18:08+0000",
            "content": "Hi,\n\nI'm trying to understand what kind of syntax this query parser supports. I read the code and it does not say much. Is there any documentation (wiki, javadoc, etc) that specifies the syntax? Because it's not clear for me.\n\nThanks in advance,\nAdriano Crestani Campos ",
            "author": "Adriano Crestani",
            "id": "comment-12733889"
        },
        {
            "date": "2009-07-21T23:21:33+0000",
            "content": "You might check the test class - it has a few basic examples. Its not much different than whats posted in the summary:\n\nJust experiment.\n\n+    checkMatches(\"\\\"john smith\\\"\", \"1\"); // Simple multi-term still works\n+    checkMatches(\"\\\"j*   smyth~\\\"\", \"1,2\"); // wildcards and fuzzies are OK in\n+    // phrases\n+    checkMatches(\"\\\"(jo* -john)  smith\\\"\", \"2\"); // boolean logic works\n+    checkMatches(\"\\\"jo*  smith\\\"~2\", \"1,2,3\"); // position logic works.\n+    checkMatches(\"\\\"jo* [sma TO smZ]\\\" \", \"1,2\"); // range queries supported\n+    checkMatches(\"\\\"john\\\"\", \"1,3\"); // Simple single-term still works\n+    checkMatches(\"\\\"(john OR johathon)  smith\\\"\", \"1,2\"); // boolean logic with\n+    // brackets works.\n+    checkMatches(\"\\\"(jo* -john) smyth~\\\"\", \"2\"); // boolean logic with\n+    // brackets works.\n+\n+    // checkMatches(\"\\\"john -percival\\\"\", \"1\"); // not logic doesn't work\n+    // currently .\n+\n+    checkMatches(\"\\\"john  nosuchword*\\\"\", \"\"); // phrases with clauses producing\n+    // empty sets\n+\n+    checkBadQuery(\"\\\"jo*  id:1 smith\\\"\"); // mixing fields in a phrase is bad\n+    checkBadQuery(\"\\\"jo* \\\"smith\\\" \\\"\"); // phrases inside phrases is bad ",
            "author": "Mark Miller",
            "id": "comment-12733893"
        },
        {
            "date": "2009-07-22T00:25:25+0000",
            "content": "Thanks for the quick response Mark!\n\nOK, I'm trying now to figure out what is supported reading the junits only, and I ran into some issues:\n\nWhat do you mean on the last check by phrase inside phrase, I don't see any phrase inside a phrase (I'm not sure either what it would be, because there is no open and close phrase delimiter), all I see is a phrase <\"jo*\">, followed by a term <smith> and an empty phrase <\" \">. And the check passes because the query parser throws an exception complaning about the empty phrase, it seems to not be supported. I just changed the empty phrase to a valid phrase and the query works (failing the test case). But as I said, I'm not sure what you were exactly trying to do there, could you give me more explation about that?\n\nI'm also getting a java.util.ConcurrentModificationException when I type an escaped double quotes inside phrases. So, I suppose it's not supported, but shouldn't it throw a better exception?\n\nI also have an issue with the parse exceptions, if it comes from inside a phrase, it does not tell the correct position in the query string. I think it considers the beginning of the phrase as the beginning of the query and it only prints the phrase that contains the problem.\n\nI'm attaching some changes I did in the TestComplexPhraseQuery junit that shows these problems I'm getting, I think it's easier to understand if you read and run it.\n\nSorry for so many questions, but I'm just trying to understand what exactly this query parser supports or not.\n\nThanks,\nAdriano Crestani Campos ",
            "author": "Adriano Crestani",
            "id": "comment-12733917"
        },
        {
            "date": "2009-07-22T01:11:34+0000",
            "content": "You may have to wait for the author, Mark Harwood to respond. I just reviewed the issue. A couple points though:\n\nWhat do you mean on the last check by phrase inside phrase, I don't see any phrase inside a phrase (I'm not sure either what it would be, because there is no open and close phrase delimiter), all I see is a phrase <\"jo*\">, followed by a term <smith> and an empty phrase <\" \">\n\nIts kind of a phrase within a phrase (though the \"smith\" phrase could be turned into a term query) - unescaped: \"jo* \"smith\"\" - the full thing is phrase one, and smith is the inner phrase (though yes, only a term in the phrase).\n\nIf Mark Harwood doesn't have time to answer soon, I'll dig in more and respond to your other questions/comments. ",
            "author": "Mark Miller",
            "id": "comment-12733933"
        },
        {
            "date": "2009-07-22T01:25:20+0000",
            "content": "Looking at the problems Adriano is seeing it almost seems like this was a bit prematurely committed? It seems like a lot of queries you could enter here are not really supported and might throw strange exceptions.\n\nMaybe it should live in contrib for now (with experimental warnings)? ",
            "author": "Michael Busch",
            "id": "comment-12733940"
        },
        {
            "date": "2009-07-22T01:42:36+0000",
            "content": "I originally thought it might live in contrib as well (see above), but I'm personally fine with it being in core.\n\nIt seems like a lot of queries you could enter here are not really supported and might throw strange exceptions.\n\nA lot of queries? I think Adriano is just having trouble with phrases inside phrases, which is unsupported. Other things that are not supported might throw exceptions too, but I think thats to be expected? I see what Adriano was talking about now - technically the first 2 quotes would match, and then the second two - I think Mark H was just demonstrating that you shouldn't try that query though - a user might think they are quoting smith, but for the example, it doesn't matter. I think he just trying to show that you shouldn't try and \"nest\" phrases - even though they wouldn't be interpreted that way anyway.\n\nIt only supports a limited subset of the Lucene query language - perhaps we could improve the exceptions being thrown, but the exceptions the queryparser throws often leave just as much to be desired. I don't think its experimental because of that.\n\nPersonally, I think the class does what it intends - allows a limited subset of the Lucene query language in phrases. Though of course it could be improved.\n\nI'll let Mark H respond though. I also don't mind seeing it moved to contrib, but I'm not sure anything glaring points to it being moved at the moment. It lives up to its limited contract I think. ",
            "author": "Mark Miller",
            "id": "comment-12733946"
        },
        {
            "date": "2009-07-22T02:37:01+0000",
            "content": "\nI see what Adriano was talking about now - technically the first 2 quotes would match, and then the second two - I think Mark H was just demonstrating that you shouldn't try that query though - a user might think they are quoting smith, but for the example, it doesn't matter. I think he just trying to show that you shouldn't try and \"nest\" phrases - even though they wouldn't be interpreted that way anyway.\n\nWell, if you guessed his intention correctly, the comment is misleading: \"phrases inside phrases is bad\". But lets wait for his response.\n\n\nOther things that are not supported might throw exceptions too\n\nI think a user would expect a ParseException. Probably, every query parser user catches ParserException and show a nice message to its final user. Now, if the query parser starts throwing random exception to say the syntax is invalid, every software that uses Lucene query parser is gonna start crashing. For me it's like if a compiler started throwing segmentation fault every time you forget a } in the code. ",
            "author": "Adriano Crestani",
            "id": "comment-12733956"
        },
        {
            "date": "2009-07-22T02:45:06+0000",
            "content": "\nI think a user would expect a ParseException. Probably, every query parser user catches ParserException and show a nice message to its final user. Now, if the query parser starts throwing random exception to say the syntax is invalid, every software that uses Lucene query parser is gonna start crashing. For me it's like if a compiler started throwing segmentation fault every time you forget a } in the code.\n\nThat's a fair point - addressable though - we can likely catch and rethrow in the worst case.\n\nI'll admit, the ... non exactness ... of this parser troubled me at first - one of the reasons I liked contrib as a landing spot early on. I took it for what it is in the end I suppose. I think the shortfalls brought up so far can be addressed to a large degree though. ",
            "author": "Mark Miller",
            "id": "comment-12733957"
        },
        {
            "date": "2009-07-22T02:50:22+0000",
            "content": "Well, if you guessed his intention correctly, the comment is misleading: \"phrases inside phrases is bad\". But lets wait for his response.\n\nI think thats a bit of judgement call. We know that the way the query is parsed, you cannot really ever do \"phrases inside phrases\". However, a user of this parser might think, that like the other syntax, perhaps you can use \"phrases inside phrases\" - and if you thought that, the example given is likely how you'd imagine it to work. The outside phrase, and then the inside phrase. I certainly agree some comments would clear it up, but I think its a useful example. ",
            "author": "Mark Miller",
            "id": "comment-12733958"
        },
        {
            "date": "2009-07-22T03:02:41+0000",
            "content": "\nI'll admit, the ... non exactness ... of this parser troubled me at first - one of the reasons I liked contrib as a landing spot early on. I took it for what it is in the end I suppose. I think the shortfalls brought up so far can be addressed to a large degree though.\n\nI think contrib would be a good place for now, until it gets more stable and better documented. ",
            "author": "Adriano Crestani",
            "id": "comment-12733961"
        },
        {
            "date": "2009-07-22T03:12:12+0000",
            "content": "I think contrib would be a good place for now, until it gets more stable and better documented.\n\nIf Mark H thinks it should be moved, I won't disagree. But I still don't see a convincing reason. It could use some more documentation, but so could quite a few other classes in core. Its something of a subjective call,  and  more importantly, it can be addressed now.\n\nI'm not yet convinced its unstable - the only major issue I see so far is the exception issue - but that wouldn't seem to prompt a move to contrib, but an update to address the concern. Moving to contrib is always an option, but I don't think its the default move based on whats been brought up. The standard move would be to address whatever issues are brought up ... so far I am just seeing the exception issue as a large one, and I think that is fairly easily addressable. ",
            "author": "Mark Miller",
            "id": "comment-12733966"
        },
        {
            "date": "2009-07-22T04:43:23+0000",
            "content": "\nIt only supports a limited subset of the Lucene query language - perhaps we could improve the exceptions being thrown, but the exceptions the queryparser throws often leave just as much to be desired. I don't think its experimental because of that.\n\nBecause it only supports a limited subset of the language, I feel like we could have taken a different approach here? Why not add the features that are supported and make sense to the main query parser? \n\nThe documentation does not tell me what is supported and what is not currently. And looking through the code some methods now throw RuntimeExceptions, because the overridden methods themselves don't throw anything. These things feel a bit unfinished. \n\nI'm not saying these issues are not fixable. But maybe we should rethink the design. My biggest concern is that this new parser doesn't seem to have a well-defined syntax. So since it doesn't check if a query is actually valid or not, it might be hard to maintain. E.g. if you add new language features to the main QP, it's currently not defined what will happen if you use them with this one.\n\nThat's why I'm proposing to move it to contrib and mark it as experimental. Then we have more time to decide if the approach of adding the new features to the main QP makes more sense.  ",
            "author": "Michael Busch",
            "id": "comment-12733982"
        },
        {
            "date": "2009-07-22T06:43:00+0000",
            "content": "I share same opinion as Michael,\nthe implementation has a lot of undefined/undocumented behaviors,\nsimple because it reuses the queryparser to parse the text inside a phrase. \nAll the lucene syntax needs to be accounted on this design, but it does not seem to be the case.\n\nProblems like Adriano described, phrase inside a phrase, position reporting for errors.\n\nI also have a lot of concerns about having the full lucene syntax inside phrases \nand trying to restrict this by throwing exceptions for particular cases does not seem the best design.\n\nHere is a example of with OR, AND, PARENTESIS with a proximity search\n\"(( jakarta OR green) AND (blue AND orange)  AND black~0.5) apache\"~10\n\nWhat should a user expect from this query, without looking at the code. I'm not sure.\nDoes it even make sense to support this complex syntax? In my opinion. no\n\nI think we should define what is the subset of the language we want to support inside the phrases with a well defined behavior.\nIf Mark describes all the syntax he wants to support inside phrases, I actually don't mind to implement a new parser.for this.\n\nMy view is, contrib is probably a better place to have this code, until we figure out a implementation that does not impose as many restrictions on changes to the original queryparser and describes a well defined syntax to be applied inside phrases.\n ",
            "author": "Luis Alves",
            "id": "comment-12734015"
        },
        {
            "date": "2009-07-22T14:53:43+0000",
            "content": "I added 2 testcases that return doc 3.\nThese queries do not make much sense,\nI added it just to prove the point that we need more information\ndescribing the use case for complex phrase qp.\nWe also should define a subset of the supported syntax we want to support inside phrases, \nwith well defined behaviors.\n\n\tcheckMatches(\"\\\"(goos~0.5 AND (mike OR smith) AND NOT ( percival AND john) ) vacation\\\"~3\",\"3\"); // proximity with fuzzy, OR, AND, NOT\n\tcheckMatches(\"\\\"(goos~0.5 AND (mike OR smith) AND ( percival AND john) ) vacation\\\"~3\",\"3\"); // proximity with fuzzy, OR, AND ",
            "author": "Luis Alves",
            "id": "comment-12734141"
        },
        {
            "date": "2009-07-22T15:16:30+0000",
            "content": "I'll try and catch up with some of the issues raised here:\n\nWhat do you mean on the last check by phrase inside phrase, I don't see any phrase inside a phrase\n\nCorrect, the \"inner phrase\" example was a term not a phrase. This is perhaps a better example:\n\n\t\tcheckBadQuery(\"\\\"jo* \\\"percival smith\\\" \\\"\"); //phrases inside phrases is bad\n\nI'm trying now to figure out what is supported \n\nThe Junit is currently the main form of documentation - unlike the XMLQueryParser (which has a DTD) there is no syntax to formally capture the logic. \nHere is a basic summary of the syntax supported and how it differs from normal non-phrase use of the same operators:\n\n\n\tWildcard/fuzzy/range clauses can be used to define a phrase element (as opposed to simply single terms)\n\tBrackets are used to group/define the acceptable variations for a given phrase element  e.g. \"(john OR jonathon) smith\"\n\t\"AND\" is irrelevant - there is effectively an implied \"AND_NEXT_TO\" binding all phrase elements\n\n\n\nTo move this forward I would suggest we consider following one of these options:\n\n1) Keep in core and improve error reporting and documentation\n2) Move into \"contrib\" as experimental \n3) Retain in core but simplify it to support only the simplest syntax (as in my Britney~ example)\n4) Re-engineer the QueryParser.jj to support a formally defined syntax for acceptable \"within phrase\" operators e.g. *, ~, ( ) \n\nI think 1) is achievable if we carefully define where the existing parser breaks (e.g. ANDs and nested brackets)\n2) is unnecessary if we can achieve 1).\n3) would be a shame if we lost useful features for some very convoluted edge cases\n4) is beyond my JavaCC skills.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n ",
            "author": "Mark Harwood",
            "id": "comment-12734148"
        },
        {
            "date": "2009-07-22T15:24:57+0000",
            "content": "My first thought is, if we can address some of the issues brought up, there is no reason to keep this out of core IMHO.\n\nMy second thought is, I have a feeling a lot of this concern stems from the fact that these guys (or one of them) has to duplicate this thing with the QueryParser code in contrib. That could be reason enough to move it to contrib. But it doesn't solve the issue longer term when the old QueryParser is removed. It would need to be replaced then, or dropped from contrib.\n\nWith the new info from Mark H, how hard would it be to create a new imp for the new parser that did a lot of this, in a more defined way? It seems you basically just want to be able to use multiterm queries and group/or things, right? We could even relax a little if we have to. This hasn't been released, so there is still a lot of wiggle room I think. But there does have to be a resolution with this and the new parser at some point either way. ",
            "author": "Mark Miller",
            "id": "comment-12734150"
        },
        {
            "date": "2009-07-22T18:37:38+0000",
            "content": "Hi Mark H.,\n\nThanks for the response, some comments inline:\n\n\nCorrect, the \"inner phrase\" example was a term not a phrase. This is perhaps a better example:\n\ncheckBadQuery(\"\\\"jo* \\\"percival smith\\\" \\\"\"); //phrases inside phrases is bad\n\nI think you did not get what I meant, even with your new example, there is no inner phrase, it is: a phrase <\"jo* \">, followed by a term <percival>, followed by another term <smith>, and an empty phrase <\" \">. So, with your change, the junit passes, but for the wrong reason. It gets an exception complaining about the empty phrase and not because there is an inner phrase (I still don't see how you can type an inner phrase with the current syntax). I think it's not a big deal, but I'm just trying to understand and raise a probable wrong test. I expect you understood what I mean, let me know if I did not make it clear.\n\n\nThe Junit is currently the main form of documentation\n\nBut not the ideal, because the source code (junit code) is not released in the binary release. So, the ideal place should be in the javadocs.\n\n\n\n\n\tWildcard/fuzzy/range clauses can be used to define a phrase element (as opposed to simply single terms)\n\tBrackets are used to group/define the acceptable variations for a given phrase element e.g. \"(john OR jonathon) smith\"\n\t\"AND\" is irrelevant - there is effectively an implied \"AND_NEXT_TO\" binding all phrase elements\n\n\n\n\nThanks, now it's clearer for me what is supported or not. I have some questions:\n\nI understand this AND_NEXT_TO implicit operator between the queries inside the phrase. However, what happens if the user do not type any explicit boolean operator between two terms inside parentheses: \"(query parser) lucene\". Is the operator between 'query' and 'parser' the implicit AND_NEXT_TO or the default boolean operator (usually OR)?\n\nWhat happens if I type \"(query AND parser) lucene\". In my point of view it is: \"(query AND parser) AND_NEXT_TO lucene\". Which means for me: find any document that contains the term 'query' and the term 'parser' in the position x, and the term 'lucene' in the position x+1. Is this the expected behaviour?\n\n\n1) Keep in core and improve error reporting and documentation\n2) Move into \"contrib\" as experimental\n3) Retain in core but simplify it to support only the simplest syntax (as in my Britney~ example)\n4) Re-engineer the QueryParser.jj to support a formally defined syntax for acceptable \"within phrase\" operators e.g. *, ~, ( )\n\n1 is good, but I would prefer 4 too. Documentation and throw the right exception are necessary. I just don't feel confortable on the complex phrase query parser relying on the main query parser syntax, any change on the main one could easialy brake the complex phrase QP. Anyway, 4 may be done in future \n\nMark M.:\n\n\nWith the new info from Mark H, how hard would it be to create a new imp for the new parser that did a lot of this, in a more defined way? It seems you basically just want to be able to use multiterm queries and group/or things, right? We could even relax a little if we have to. This hasn't been released, so there is still a lot of wiggle room I think. But there does have to be a resolution with this and the new parser at some point either way.\n\nYes, I am working on the new query parser code. I started recently to read and understand how the ComplexPhraseQP works, so I could reproduce the behaviour using the new QP framework. I first tried to look at this QP as a user and could not figure out what exactly I can or not do with it. I think now we are hitting a big problem, which is related to documentation. That is why I started raising these question, because others could also have the same issues in future.\n\nSo, yes, I can start coding some equivalent QP using the new QP framework, I'm just questioning and trying to understand everything before I start any coding. I don't wanna code anything that wil throw ConcurrentModificationExceptions, that's why I'm raising these issues now, before I start moving it to the new QP.\n\nBest Regards,\nAdriano Crestani Campos ",
            "author": "Adriano Crestani",
            "id": "comment-12734241"
        },
        {
            "date": "2009-07-22T20:24:38+0000",
            "content": "I think the best thing to do here is do exactly define what syntax is supposed to be supported (which Mark H. did in his latest comment), and then implement the new syntax with the new queryparser. It will enforce correct syntax and give meaningful exceptions if a query was entered that is not supported.\n\nI think we can still reuse big portions of Mark's patch: we should be able to write a new QueryBuilder that produces the new ComplexPhraseQuery.\n\nAdriano/Luis: how long would it take to implement? Can we contain it for 2.9?\n\nThis would mean that these new features would go into contrib in 2.9 as part of the new query parser framework, and then be moved to core in 3.0. Also from 3.0 these new features would then be part of Lucene's main query syntax. Would this makes sense? ",
            "author": "Michael Busch",
            "id": "comment-12734296"
        },
        {
            "date": "2009-07-22T20:26:25+0000",
            "content": "Reopening this issues; we haven't made a final decision on how we want to go forward yet, but in any case there's remaining work here. ",
            "author": "Michael Busch",
            "id": "comment-12734298"
        },
        {
            "date": "2009-07-22T20:27:46+0000",
            "content": "Hi Mark H\n\nI would like to propose 5,\n5) Re-engineer the QueryParser.jj to support a formally defined syntax for acceptable \"within phrase\" operators e.g. *, ~, ( ) \n    I propose doing this using using the new QP implementation. (I can write the new javacc QP for this)\n    (this implies that the code will be in contrib in 2.9 and be part of core on 3.0)\n\nI also want to propose to change the complexphrase to use single quotes,\nthis way we can have both implementation for phrases.\n\nHere is a summary:\n\n\tthe complexqueryparser would support all Lucene syntax even for phrases\n\tand we could add singlequoted text to identify complexphrases\n    1) Wildcard/fuzzy/range clauses can be used to define a phrase element (as opposed to simply single terms)\n    2) Brackets are used to group/define the acceptable variations for a given phrase element e.g. \"(john OR jonathon) smith\"\n    3) supported operators: OR, *, ~, ( ), ?\n    4) disallow fields, proximity, boosting and operators on single quoted phrases (I'm making an assumption here, Mark H please comment)\n    5) singlequotes need to be escaped, double quotes will be treated as regular punctuation characters inside single quoted strings\n\n\n\n\nMark H, can you please elaborate more on the these other operators \"+\" \"-\" \"^\" \"AND\" \"&&\" \"||\" \"NOT\" \"!\" \":\" \"[\" \"]\" \"\n{\" \"}\n\".\n\nExample:\nA query with single quoted (complexphrase) followed by a term and a normal phrase:\n\nquery: '(john OR jonathon) smith~0.3 order*' order:sell  \"stock market\"  \n ",
            "author": "Luis Alves",
            "id": "comment-12734300"
        },
        {
            "date": "2009-07-22T21:10:32+0000",
            "content": "Mark H - \n\nQuestion 1)\n\nI added a doc 5 and 6\nTestComplexPhraseQuery.java\n...\n  DocData docsContent[] = { new DocData(\"john smith\", \"1\"),\n      new DocData(\"johathon smith\", \"2\"),      \n      new DocData(\"john percival smith goes on  a b c vacation\", \"3\"),\n      new DocData(\"jackson waits tom\", \"4\"),\n      new DocData(\"johathon smith john\", \"5\"),\n      new DocData(\"johathon mary gomes smith\", \"6\"),\n      };\n...\n\n\n\nfor test \n    checkMatches(\"\\\"(jo* -john) smyth\\\"\", \"2\"); // boolean logic with\n\nwould document 5 be returned or just doc 2 should be returned,\nI'm assuming position is always important and doc 5 is supposed to be returned.\nIs this the correct behavior?\n\nQuestion 2)\nShould these 2 queries behave the same when we fix the problem\n    // checkMatches(\"\\\"john -percival\\\"\", \"1\"); // not logic doesn't work\n    // checkMatches(\"\\\"john (-percival)\\\"\", \"1\"); // not logic doesn't work\n\nQuestion 3)\nfor query:\ncheckMatches(\"\\\"jo*  smith\\\"~2\", \"1,2,3,5\"); // position logic works.\ndoc 6 is also returned, so this feature does not seem to be working.\n\nQuestion 4)\nThe usage of AND and AND_NEXT_TO is confusing to me\nthe query \ncheckMatches(\"\\\"(jo* AND mary)  smith\\\"\", \"1,2,5\"); // boolean logic with\n\nreturns 1,2,5 and not 6, but I was only expecting 6 to be returned,\nseems that like the AND is converted into a OR.\nWhat is the behavior you want to implement?\n\n ",
            "author": "Luis Alves",
            "id": "comment-12734323"
        },
        {
            "date": "2009-07-22T21:30:32+0000",
            "content": "Sorry for all the emails, \nI'm still new to JIRA and only now I realized that for every edit I do,a email is sent.\n\nBut now that I found the preview button, it won't happen again.  ",
            "author": "Luis Alves",
            "id": "comment-12734333"
        },
        {
            "date": "2009-07-22T21:32:21+0000",
            "content": "I think it's not a big deal, but I'm just trying to understand and raise a probable wrong test.\n\nGranted, the test fails for a reason other than the one for which I wanted it to fail. \nWe can probably strike the test and leave a note saying phrase-within-a-phrase just does not make sense and is not supported.\n\nIs the operator between 'query' and 'parser' the implicit AND_NEXT_TO or the default boolean operator (usually OR)?\n\nIn brackets it's an OR - the brackets are used to suggest that the current phrase element at position X is composed of some choices that are evaluated as a subclause in the same way that in normal query logic sub-clauses are defined in brackets e.g. +a +(b OR c). There seems to be a reasonable logic to this.\n\nIdeally the ComplexPhraseQueryParser should explicitly turn this setting on while evaluating the bracketed innards of phrases just in case the base class has AND as the default.\n\nMark H, can you please elaborate more on the these other operators \"+\" \"-\" \"^\" \"AND\" \"&&\" \"||\" \"NOT\" \"!\" \":\" \"[\" \"]\" \"{\" \"}\".\n\nOK I'll try and deal with them one by one but these are not necessarily definitive answers or guarantees of correctly implemented support\n\nOR,||,+, AND, && ..... ignored. The implicit operator is AND_NEXT_TO apart from in bracketed sections where all elements at this level are ORed\n^ .....boosts are carried through from TermQuerys to SpanTermQuerys\nNOT, ! ....Creates SpanNotQueries \n[]{} ....range queries are supported as are wildcards *, fuzzies  ~, ?\n\nquery: '(john OR jonathon) smith~0.3 order*' order:sell \"stock market\"\n\n\nI'll post the XML query syntax equivalent of what should be parsed here shortly (just seen your next comment come in) \n\n\n ",
            "author": "Mark Harwood",
            "id": "comment-12734337"
        },
        {
            "date": "2009-07-22T21:59:28+0000",
            "content": "for test checkMatches(\"\\\"(jo* -john) smyth\\\"\", \"2\"); \nwould document 5 be returned or just doc 2 should be returned,\n\nI presume you mean smith not smyth here otherwise nothing would match? If so, doc 5 should match and position is relevant (subject to slop factors).\n\n\nQuestion 2)\nShould these 2 queries behave the same when we fix the problem\n// checkMatches(\"\\\"john -percival\\\"\", \"1\"); // not logic doesn't work\n// checkMatches(\"\\\"john (-percival)\\\"\", \"1\"); // not logic doesn't work\n\nI suppose there's an open question as to if the second example is legal (the brackets are unnecessary)\n\n\n\n\nQuestion 3)\ncheckMatches(\"\\\"jo* smith\\\"~2\", \"1,2,3,5\"); // position logic works.\ndoc 6 is also returned, so this feature does not seem to be working.\n\nThat looks like a bug related to slop factor?\n\n\nQuestion 4)\nThe usage of AND and AND_NEXT_TO is confusing to me\nthe query \ncheckMatches(\"\\\"(jo* AND mary) smith\\\"\", \"1,2,5\"); // boolean logic with\nANDs are ignored and turned into ORs (see earlier comments) but maybe a query parse error should be thrown to emphasise this.\n\n\n ",
            "author": "Mark Harwood",
            "id": "comment-12734349"
        },
        {
            "date": "2009-07-22T22:14:20+0000",
            "content": "\nquery: '(john OR jonathon) smith~0.3 order*' order:sell \"stock market\"\nWould be parsed as follows (shown as equivalent XMLQueryParser syntax)\n\n \n<BooleanQuery>\n  <Clause occurs=\"should\">\n     <SpanNear >\t\t\n\t\t\t<SpanOr>\n\t\t\t\t<SpanOrTerms>john jonathon </SpanOrTerms>\n\t\t\t</SpanOr>\n\t\t\t<SpanOr>\n\t\t\t\t<SpanOrTerms> smith smyth</SpanOrTerms>\n\t\t\t</SpanOr>\n\t\t\t<SpanOr>\n\t\t\t\t<SpanOrTerms> order orders</SpanOrTerms>\n\t\t\t</SpanOr>\n   </SpanNear>\n </Clause>\n<Clause occurs=\"should\">\n     <TermQuery fieldName=\"order\" >sell</TermQuery>\t\t\n </Clause>\n<Clause occurs=\"should\">\n     <UserQuery>\"stock market\"</UserQuery >\t\t\n </Clause>\n</BooleanQuery> \n\n ",
            "author": "Mark Harwood",
            "id": "comment-12734355"
        },
        {
            "date": "2009-07-23T00:09:21+0000",
            "content": "\nI propose doing this using using the new QP implementation. (I can write the new javacc QP for this)\n(this implies that the code will be in contrib in 2.9 and be part of core on 3.0)\n\nThat would be good!\n\n\nGranted, the test fails for a reason other than the one for which I wanted it to fail.\nWe can probably strike the test and leave a note saying phrase-within-a-phrase just does not make sense and is not supported.\n\nCool, I agree to remove it. But I still don't see how an user can type a phrase inside a phrase with the current syntax definition, can you give me an example?\n\n\nIn brackets it's an OR - the brackets are used to suggest that the current phrase element at position X is composed of some choices that are evaluated as a subclause in the same way that in normal query logic sub-clauses are defined in brackets e.g. +a +(b OR c). There seems to be a reasonable logic to this.\n\nIdeally the ComplexPhraseQueryParser should explicitly turn this setting on while evaluating the bracketed innards of phrases just in case the base class has AND as the default.\n\nIf we use the implemented java cc code Luis suggested, we would have already a query parser that throws ParseExceptions whenever the user types an AND inside a phrase.\n\n\nOR,||,+, AND, && ..... ignored\n\nSo we should throw an excpetion if any of these is found inside a phrase. It could confuse the user if we just ignore it.\n\n\n    Question 2)\n    Should these 2 queries behave the same when we fix the problem\n    // checkMatches(\"\\\"john -percival\\\"\", \"1\"); // not logic doesn't work\n    // checkMatches(\"\\\"john (-percival)\\\"\", \"1\"); // not logic doesn't work\n\nI suppose there's an open question as to if the second example is legal (the brackets are unnecessary)\n\nYes, the second is unnecessary, but I don't think it's illegal. The user could type <(smith)> outside the phrase, it makes sense to support it inside also.\n\n\n    Question 3)\n    checkMatches(\"\\\"jo* smith\\\"~2\", \"1,2,3,5\"); // position logic works.\n    doc 6 is also returned, so this feature does not seem to be working.\n\nThat looks like a bug related to slop factor?\n\nI have not checked yet, but I think it's working fine. The slop means how many switches between the terms inside the phrase is allowed to match the query. It matches doc 6, because the term <smith> switches twice to the right and matched \"johathon mary gomes smith\". Twice = slop 2 \n\n\nANDs are ignored and turned into ORs (see earlier comments) but maybe a query parse error should be thrown to emphasise this.\n\nI think we could support AND also. I agree there are few cases where the user would use that. It would work as I explained before:\n\n\nWhat happens if I type \"(query AND parser) lucene\". In my point of view it is: \"(query AND parser) AND_NEXT_TO lucene\". Which means for me: find any document that contains the term 'query' and the term 'parser' in the position x, and the term 'lucene' in the position x+1. Is this the expected behaviour? ",
            "author": "Adriano Crestani",
            "id": "comment-12734398"
        },
        {
            "date": "2009-07-24T12:19:09+0000",
            "content": "Hi everyone,\n\nI am using your ComplexPhraseQueryParser. I integrated it into Solr. \nI am interested in it mainly because it supports OR operator and wildcards inside proximity search.\n\nSpecifically : \"(john johathon) smith\"~10   and   \"j* smith\"\nThey both work perfectly, thank you for your work.\n\nI downloaded source code of it from http://svn.apache.org/viewvc?view=rev&revision=791579\nAnd then edited the code a little bit since I am using lucene 2.4.1:\n\nI replaced those:\n1-) TermRangeQuery to RangeQuery.\n2-) getConstantScoreRewrite() to getUseOldRangeQuery();\n3-) setConstantScoreRewrite(false); to setUseOldRangeQuery(true);\n4-) On line 168 of ComplexPhraseQueryParser.java there are two semicolons ( ; ; )\n\nI am not sure what I did is the way to start using this query parser with latest versions of lucene/solr.\nIf it is not can you suggest me better ways or where to get/download latest source code of query parser.\n\nI am having problems with multi-field searches.\n\nQuery  \"(john johathon) smith\"~10 works on default field, e.g. text.\n\nBut when I want to run the same query on another field (other than default field)\ntitle:\"(john johathon) smith\"~10 \nit gives exception below:\nCannot have clause for field \"text\" nested in phrase for field \"title\"\n\nWhen I ran the query distibuting field name to all terms it works:\ntitle:\"(title:john title:johathon) title:smith\"~10\n\nIs there an easy way to set field of all terms (without specifying)?\n\nAnd about boosts of multi-field queries, is this query legal? (default operator = OR, default field = text)\n\ntitle:\"(title:john title:johathon) title:smith\"~10^1.5 OR \"(john johathon) smith\"~10^3.0\n\nShortly I want to use this queryparser to query on multi-fields with different boosts.\n\nI am not sure if I am allowed to ask such question in here, if not please accept my apologies.\n\nThank you for your consideration.\n\nAhmet Arslan ",
            "author": "Ahmet Arslan",
            "id": "comment-12735041"
        },
        {
            "date": "2009-07-24T13:57:09+0000",
            "content": "Fix for phrases using QueryParser's non-default field e.g. \n     author:\"j* smith\" ",
            "author": "Mark Harwood",
            "id": "comment-12735058"
        },
        {
            "date": "2009-07-29T21:30:45+0000",
            "content": "If we don't have a clear path for this very soon I think we should pull it from this release. ",
            "author": "Mark Miller",
            "id": "comment-12736851"
        },
        {
            "date": "2009-07-30T02:37:20+0000",
            "content": "My understanding is that with \"New flexible query parser\" (LUCENE-1567),\nthe old QueryParser classes will be deprecated in 2.9\nand removed in 3.0 (or moved to contrib in 3.0).\n\nThis change will also make ComplexPhraseQueryParser deprecated\nbecause it currently extends the old queryparser.\n\nComplexPhraseQueryParser was not part of any lucene release\nand was only checked in 2 months ago in trunk.\n\nFor the reasons above I think we should re-implement this functionality\nusing the new flexible query parser.\n\n3.0 and 2.9 releases will be very similar \nbut 3.0 will have all deprecated APIs removed (at least this is my understanding).\n\nIn my view the path should be:\n\n\tWait for LUCENE-1567 to be in trunk\n\tre-implement this feature using the \"New flexible query parser\"\n\tand probably do it using a super set of the current syntax with a new TextParser.\n\n\n\nI'm not sure if I'll have the time to implement a compatible implementation of\nComplexPhraseQueryParser before 2.9 release \n\nI'm currently working on 1567 to finalize the patch,\ncleaning up javadocs and some small clean up to the APIs.\n\nI'll try to work on ComplexPhraseQueryParser,\nonce lucene-1567 is in the trunk.\n\nSo in my view, ComplexPhraseQueryParser depends on 1567, \nand will require some extra work after 1567 is in the trunk.\n\nI think we have the following, options:\n\n\tWe could wait until 1567 is in trunk and wait for a compatible implementation of ComplexPhraseQueryParser using 1567,\n  before we release 2.9. (this would still remove the current ComplexPhraseQueryParser class, and provide this features with LuceneQueryParserHelper class, or with a new TextParser name complexphrase)\n\tWe can release 2.9 with only 1567, but that will require ComplexPhraseQueryParser to be removed from trunk or at least deprecated in 2.9, and in 3.X re-implement it using the \"New flexible query parser\" APIs\n\n\n\nI hope this helps \n ",
            "author": "Luis Alves",
            "id": "comment-12736965"
        },
        {
            "date": "2009-07-30T02:39:44+0000",
            "content": "Okay thanks. I think we should pull it for 2.9. ",
            "author": "Mark Miller",
            "id": "comment-12736966"
        },
        {
            "date": "2009-07-30T18:17:07+0000",
            "content": "Okay, so I guess the question is - who objects to pulling this from 2.9? I don't think we should release a class that extends a deprecated class and I don't think we want to hold up 2.9 waiting for an adequate non deprecated replacement. ",
            "author": "Mark Miller",
            "id": "comment-12737212"
        },
        {
            "date": "2009-07-30T20:41:50+0000",
            "content": "No objections to pulling from core given the impending deprecation of the QueryParser base class.\n\nI know of at least 2 folks using it so moving it to contrib would help provide somewhere to maintain fixes while we wait for the new QueryParser to incorporate the complex phrase features. ",
            "author": "Mark Harwood",
            "id": "comment-12737270"
        },
        {
            "date": "2009-07-30T21:47:24+0000",
            "content": "+1 for moving it to conrib. Then the users Mark H. mentioned can consume it from a contrib jar until these features are in the new QP. ",
            "author": "Michael Busch",
            "id": "comment-12737311"
        },
        {
            "date": "2009-07-30T21:53:06+0000",
            "content": "Alright, then - do you have time to handle that soon Mark H? If not I can probably make some time for it. ",
            "author": "Mark Miller",
            "id": "comment-12737314"
        },
        {
            "date": "2009-08-01T16:42:57+0000",
            "content": "patch that moves to contrib ",
            "author": "Mark Miller",
            "id": "comment-12737913"
        },
        {
            "date": "2009-08-05T23:33:22+0000",
            "content": "Reopening so we don't forget to do this one...\n\nCome 3.0, how will this work, even in contrib?  (Because the plan is to replace the old queryParser with the new one for 3.0). ",
            "author": "Michael McCandless",
            "id": "comment-12739824"
        },
        {
            "date": "2009-08-05T23:39:47+0000",
            "content": "The plan is to remove it and add a replacement built on the new QueryParser. The replacement may not be exactly the same, but it should be very similar.\n\nMy inclination was to leave it out of this release - its a single class and so easy to manage and plug it in separately if you want. I don't know that we should release a class that may or may not get a replacement (promises, promises  ) and extends a deprecated class. Contrib was once called sandbox though and consensus appeared to be to put it in contrib - so I went with that and added a warning that the class might change soon. ",
            "author": "Mark Miller",
            "id": "comment-12739826"
        },
        {
            "date": "2009-08-26T15:27:35+0000",
            "content": "I'm not sure why the ComplexPhraseQuery itself is buried in the Parser.  Can't the query stand on it's own?  Seems like it could be a useful class outside of the specific content of a QueryParser, no? ",
            "author": "Grant Ingersoll",
            "id": "comment-12747982"
        },
        {
            "date": "2009-08-26T17:42:01+0000",
            "content": "It does not stand on it's own as it is merely a temporary object used as a peculiarity in the way the parsing works. The SpanQuery family would be the legitimate standalone equivalents of this class.\n\nComplexPhraseQuery objects are constructed during the the first pass of parsing to capture everything between quotes as an opaque string.\nThe ComplexPhraseQueryParser then calls \"parsePhraseElements(...)\" on these objects to complete the process of parsing in a second pass where in this context any brackets etc take on a different meaning\nThere is no merit in making this externally visible.\n\n\n ",
            "author": "Mark Harwood",
            "id": "comment-12748046"
        },
        {
            "date": "2009-08-31T18:04:16+0000",
            "content": "We hope to implement this on LUCENE-1823, along with other features. ",
            "author": "Luis Alves",
            "id": "comment-12749557"
        },
        {
            "date": "2009-11-10T22:19:41+0000",
            "content": "Move to 3.1 as this is a new feature. ",
            "author": "Uwe Schindler",
            "id": "comment-12776113"
        },
        {
            "date": "2009-11-25T00:17:50+0000",
            "content": "Hi Mark,\n\nUp to now, I was consuming ComplexPhraseQueryParser.java by means of copy paste into my source code, so I didn't notice.\nToday I find out that ComplexPhraseQuery.java in Lucene 2.9.1 Misc has missed the non default field.patch.\nIt gives exception with author:\"fred* smith\" style queries.\nI am writing a solr plugin to contribute for this query parser and Solr 1.4.0 directly depends on lucene-misc-2.9.1.jar.\nShould I edit and include source code of  ComplexPhraseQueryParser.java in my patch to solve this problem?\nOr is there a more convenient way to do it?\n\nThank you for your consideration. ",
            "author": "Ahmet Arslan",
            "id": "comment-12782254"
        },
        {
            "date": "2009-11-25T17:31:35+0000",
            "content": "Ugh. There's probably two separate actions required here then:\n1) a bug needs raising on Lucene.\n2) guidance needed from the Solr team about preferred course of action ",
            "author": "Mark Harwood",
            "id": "comment-12782521"
        },
        {
            "date": "2009-12-07T19:12:57+0000",
            "content": "Could someone link the new Lucene bug mentioned above to this issue?  I couldn't find it. ",
            "author": "David Kaelbling",
            "id": "comment-12787053"
        },
        {
            "date": "2010-02-19T21:29:18+0000",
            "content": "Double Ugh. Applying the patch for the \"non-default field\" bug doesn't work any more because the latest ComplexPhraseQueryParser source sitting in contrib now has a different package to the QueryParser base class . This means that this subclass doesn't have the required write access to the package-protected \"field\" variable. This is needed to temporarily set the context of the parser when processing the inner contents of the phrase.\n\nFixing this would require changing the package name of ComplexPhraseQueryParser or changing the visibility of \"field\" in the QueryParser base class to \"protected\".\nAnyone have any strong feelings about which of these is the most acceptable? ",
            "author": "Mark Harwood",
            "id": "comment-12835961"
        },
        {
            "date": "2010-08-19T13:21:04+0000",
            "content": "Hi \n\nI'm about begin using the ComplexPhraseQueryParser with 3.0.2 as we need wildcard with phrases and proximity \n\nOur customers have a habit of including '-' in phrases which seem to trigger a bug :\n\nIf you add the following tests to the TestComplexPhraseQueryParser class:\n\n\t\tcheckMatches(\"\\\"joe john nosuchword\\\"\", \"\");  \n\t\tcheckMatches(\"\\\"joe-john-nosuchword\\\"\", \"\");  \n\t\tcheckMatches(\"\\\"john-nosuchword smith\\\"\", \"\");  \n\nAND add a rewrite() in checkMatches() just after parse :\n \t\t\tQuery q = qp.parse(qString);\n \t\t\tIndexReader reader = searcher.getIndexReader();  // need for rewrite\n  \t\t\tq = q.rewrite(reader); \n\n\nThe first two is OK, and is rewritten to:\n\nspanNear([name:joe, name:john, name:nosuchword], 0, true)\nname:\"joe john nosuchword\"\n\n\nThe third bomb out on \n\njava.lang.IllegalArgumentException: Unknown query type \"org.apache.lucene.search.PhraseQuery\" found in phrase query string \"john-nosuchword smith\"\n\tat org.apache.lucene.queryParser.ComplexPhraseQueryParser$ComplexPhraseQuery.rewrite(ComplexPhraseQueryParser.java:281)\n\tat org.apache.lucene.queryParser.TestComplexPhraseQuery.checkMatches(TestComplexPhraseQuery.java:120)\n.\n.\n.\n\n\nI made a fix that seem to fixit, but I feel on very shaky ground here.\nI've made so many debugging hack around that I can't make a propper patch, but I added this fix to ComplexPhraseQueryParser::rewrite()\njust before the place the exception is thrown:\n\n       } else {\n        \tif (qc instanceof TermQuery) \n{\n        \t\tTermQuery tq = (TermQuery) qc;\n        \t\tallSpanClauses[i] = new SpanTermQuery(tq.getTerm());\n\n// START  FIX \"A-B C\" phrases\n        \t}\n else if (qc instanceof PhraseQuery) {\n        \t\tPhraseQuery pq = (PhraseQuery) qc;\n        \t\tTerm[] subterms = pq.getTerms();\n\n        \t\tSpanQuery[] clauses = new SpanQuery[subterms.length];\n        \t\tfor (int j = 0; j < subterms.length; j++) \n{\n        \t\t\tclauses[j] = new SpanTermQuery(subterms[j]);\n        \t\t}\n        \t\tallSpanClauses[i] = new SpanNearQuery(clauses, 0, true);\n// END FIX\n        \t}\telse \n{\n\n        \t\tthrow new IllegalArgumentException(\"Unknown query type \\\"\"\n        \t\t\t\t+ qc.getClass().getName()\n        \t\t\t\t+ \"\\\" found in phrase query string \\\"\"\n        \t\t\t\t+ phrasedQueryStringContents + \"\\\"\");\n        \t}\n\n\n\n ",
            "author": "Terje Eggestad",
            "id": "comment-12900278"
        },
        {
            "date": "2012-02-04T01:39:25+0000",
            "content": "changing the visibility of \"field\" in the QueryParser base class to \"protected\".\n\nThis seems reasonable? ",
            "author": "Mark Miller",
            "id": "comment-13200258"
        },
        {
            "date": "2012-02-07T14:10:16+0000",
            "content": "Hi I'm working in this change to allow field queries. I noted that queries like:\nname:\"de*\" \nname:de* \nfail due to the exception thrown in the \"rewrite\" method: \n\n    public Query rewrite(IndexReader reader) throws IOException {\n      // ArrayList spanClauses = new ArrayList();\n      if (contents instanceof TermQuery) {\n        return contents;\n      }\n      \n      // Build a sequence of Span clauses arranged in a SpanNear - child\n      // clauses can be complex\n      // Booleans e.g. nots and ors etc\n      int numNegatives = 0;\n      if (!(contents instanceof BooleanQuery)) {\n        throw new IllegalArgumentException(\"Unknown query type \\\"\"\n            + contents.getClass().getName()\n            + \"\\\" found in phrase query string \\\"\" + phrasedQueryStringContents\n            + \"\\\"\");\n      }\n...\n\n\nBy changing it to something like:\n\nif (!(contents instanceof BooleanQuery)) {\n        return contents;\n}\n\n\nqueries like the one above work, together with all the other queries available in the unit test. Is there something I'm missing with the previous change? I know the ComplexPhraseQueryParser is not intended to be used for queries like the ones I'm proposing, but why does it needs to fail in those cases? ",
            "author": "Tom\u00e1s Fern\u00e1ndez L\u00f6bbe",
            "id": "comment-13202409"
        },
        {
            "date": "2012-02-07T16:49:45+0000",
            "content": "I attached a patch with the change of my previous comment plus the change that allows fielded queries. ",
            "author": "Tom\u00e1s Fern\u00e1ndez L\u00f6bbe",
            "id": "comment-13202523"
        },
        {
            "date": "2012-02-08T12:16:32+0000",
            "content": "Mark's and Tomas' non default field patches are combined. ",
            "author": "Ahmet Arslan",
            "id": "comment-13203507"
        },
        {
            "date": "2012-02-08T12:33:01+0000",
            "content": "Thanks for looking into this, Mark and Tomas. Do you think this issue is the right place to introduce boolean inOrder parameter? Currently always inOrder=true is passed to SpanNearQuery's ctor. ",
            "author": "Ahmet Arslan",
            "id": "comment-13203514"
        },
        {
            "date": "2012-02-08T15:01:42+0000",
            "content": "Ahmet, I created a Jira for the \"inOrder\" in the ComplexPhraseQueryParser. See LUCENE-3758. ",
            "author": "Tom\u00e1s Fern\u00e1ndez L\u00f6bbe",
            "id": "comment-13203652"
        },
        {
            "date": "2012-11-21T03:11:39+0000",
            "content": "The JIRA cleaning man is here.  I thought this was committed long ago, but I just noticed it's open and set for 4.1. Huh?\nLast activity on this pretty popular issue was from Mark Harwood back in 2008! ",
            "author": "Otis Gospodnetic",
            "id": "comment-13501679"
        },
        {
            "date": "2013-02-18T20:54:44+0000",
            "content": "Can someone give me a hand on this parser (despite the jira is so old)?\n\nWe need to have the NOT logic work properly in the boolean sense, that is the following should work correctly:\n\na AND NOT b\na AND NOT (b OR c)\na AND NOT ((b OR c) AND (d OR e))\n\nCan anybody guide me here? Is it at all possible to accomplish this with this original CPQP implementation? I would not be afraid of changing QueryParser.jj lexical specification, if the task requires it. ",
            "author": "Dmitry Kan",
            "id": "comment-13580828"
        },
        {
            "date": "2013-02-20T14:30:43+0000",
            "content": "OK, after some study, here is what we did:\n\nwe treat the AND clauses as spanNearQuery objects. So, the\n\na AND b\n\nbecomes %a b%slop, where %% operator is an unordered SpanNear query (change to QueryParser.jj was required for this).\n\nWhen there is a case of NOT clause with nested clauses:\n\nNOT( (a AND b) OR (c AND d) ) = NOT ( %a b%~slop OR %c d%~slop ) ,\n\nwe need to handle SpanNearQueries in the addComplexPhraseClause method. In order to handle this, we just added to the if statement:\n\n[code]\n    if (qc instanceof BooleanQuery) {\n[/code]\n\nthe following else if statement:\n\n[code]\nelse if (childQuery instanceof SpanNearQuery) {\n    ors.add((SpanQuery)childQuery);\n}\n[/code] ",
            "author": "Dmitry Kan",
            "id": "comment-13582207"
        },
        {
            "date": "2013-07-23T18:44:46+0000",
            "content": "Bulk move 4.4 issues to 4.5 and 5.0 ",
            "author": "Steve Rowe",
            "id": "comment-13717055"
        },
        {
            "date": "2014-02-17T09:03:57+0000",
            "content": "The patch posted by Ahmet Arslan on 8th Feb 2012 looks good to me. I have been using it in production for some time and did not find any issues.\n\nI will request a committer to kindly look into this and help get this included into Solr 4.7.  If any further work is required, then I will be happy to give it a shot. ",
            "author": "Nikhil Chhaochharia",
            "id": "comment-13903081"
        },
        {
            "date": "2014-02-17T13:22:16+0000",
            "content": "Any interest in LUCENE-5205? ",
            "author": "Tim Allison",
            "id": "comment-13903223"
        },
        {
            "date": "2014-02-17T13:50:18+0000",
            "content": "Hi Tim, of course. Do you think can we include TestComplexPhraseQuery.java in your work? To demonstrate it can replace ComplexPhraseQueryParser? ",
            "author": "Ahmet Arslan",
            "id": "comment-13903242"
        },
        {
            "date": "2014-02-17T20:23:42+0000",
            "content": "Happily.  Will add tomorrow and update patch.  Thank you! ",
            "author": "Tim Allison",
            "id": "comment-13903489"
        },
        {
            "date": "2014-02-18T18:50:06+0000",
            "content": "Attached update with tests from TestComplexPhraseQuery to LUCENE-5205. ",
            "author": "Tim Allison",
            "id": "comment-13904399"
        },
        {
            "date": "2014-02-19T08:53:43+0000",
            "content": "LUCENE-5205 is very interesting, thanks for pointing me to it. \n\nHowever, we should still try to get LUCENE-1486 closed - most of the work has already been done and it may be useful in certain cases where the full power of LUCENE-5205 is not required. ",
            "author": "Nikhil Chhaochharia",
            "id": "comment-13905074"
        },
        {
            "date": "2014-02-19T13:20:15+0000",
            "content": "Agreed. ComplexPhraseQueryParser has actually been fielded    ",
            "author": "Tim Allison",
            "id": "comment-13905403"
        },
        {
            "date": "2014-02-19T13:31:36+0000",
            "content": "I agree with Nikhil Chhaochharia, This fix is all about accidentally forgotten thing to an already committed code. Also I am not sure why this issue is reopened. Any feeling towards a separate issue would be a better fit for this? ",
            "author": "Ahmet Arslan",
            "id": "comment-13905417"
        },
        {
            "date": "2014-02-19T14:05:25+0000",
            "content": "+1 ",
            "author": "Tim Allison",
            "id": "comment-13905462"
        },
        {
            "date": "2014-03-03T08:59:37+0000",
            "content": "It looks like there is a problem with stopwords also - a query like \"A for B\" where 'for' is a stopword is parsed as \"A B\" and does not match documents containing \"A for B\". ",
            "author": "Nikhil Chhaochharia",
            "id": "comment-13917848"
        },
        {
            "date": "2014-03-16T14:01:28+0000",
            "content": "OK, this seems like it's completely obsolete, any objections to closing? Should we raise Nikhil Chhaochharia's comment in a new JIRA to test at least? ",
            "author": "Erick Erickson",
            "id": "comment-13937169"
        },
        {
            "date": "2014-03-16T16:41:15+0000",
            "content": "Should we raise Nikhil Chhaochharia's comment in a new JIRA to test at least?\nI created LUCENE-5530 for fielded query support.  ",
            "author": "Ahmet Arslan",
            "id": "comment-13937204"
        },
        {
            "date": "2014-03-16T16:49:47+0000",
            "content": "What about the stopwords bit? yet another JIRA?\n ",
            "author": "Erick Erickson",
            "id": "comment-13937207"
        },
        {
            "date": "2014-03-16T17:30:42+0000",
            "content": "What about the stopwords bit? yet another JIRA?\nThere is no patch/solution for that in ComplexPhraseQueryParser.  Tim says about the topic : \n\nThe root of this problem is that SpanNearQuery has no good way to handle stopwords in a way analagous to PhraseQuery.\n\nI suggested Nikhil Chhaochharia to use a modified StopwordFilter ( I sent the filter to him offlist) that does not remove but instead reduces given stop words to an impossible token. \n\"the\" => \"ImpossibleToken\"\n\"a\" => \"ImpossibleToken\"\n\"for\" => \"ImpossibleToken\"\n\nI think we don't need a jira for this functionality but we can document this as limitation and workaround for this. ",
            "author": "Ahmet Arslan",
            "id": "comment-13937228"
        },
        {
            "date": "2014-03-16T17:46:03+0000",
            "content": "One thing is , Tom\u00e1s Fern\u00e1ndez L\u00f6bbe has reported one problem in his comment . And he has provided a solution too. \nIts about \"fred*\" kind of queries. There is only one term inside quotes.   ",
            "author": "Ahmet Arslan",
            "id": "comment-13937235"
        },
        {
            "date": "2014-03-16T18:11:58+0000",
            "content": "One last thing that might come out of this jira is Terje Eggestad this comment and his fix. However I couldn't re-produce the problem he reported with new MockAnalyzer(random()); This problem could be analyzer specific. ",
            "author": "Ahmet Arslan",
            "id": "comment-13937245"
        },
        {
            "date": "2014-03-16T19:36:13+0000",
            "content": "The re-opens were from 2009. This stuff has been in Lucene for some time, and the comment \"Reopening so we don't forget to do this one\" makes me think this should have been closed a long time ago.\n\nNOTE: we're also doing more work with this in the 4.8 time frame, thus it's getting some attention now. ",
            "author": "Erick Erickson",
            "id": "comment-13937297"
        },
        {
            "date": "2014-03-17T17:37:25+0000",
            "content": "Thanks Erick Erickson for closing this beast  ",
            "author": "Ahmet Arslan",
            "id": "comment-13938086"
        },
        {
            "date": "2014-04-27T23:25:47+0000",
            "content": "Close issue after release of 4.8.0 ",
            "author": "Uwe Schindler",
            "id": "comment-13982575"
        }
    ]
}