{
    "id": "SOLR-5653",
    "title": "Create a RESTManager to provide REST API endpoints for reconfigurable plugins",
    "details": {
        "affect_versions": "None",
        "status": "Closed",
        "fix_versions": [
            "4.8",
            "6.0"
        ],
        "components": [],
        "type": "Sub-task",
        "priority": "Major",
        "labels": "",
        "resolution": "Fixed"
    },
    "description": "It should be possible to reconfigure Solr plugins' resources and init params without directly editing the serialized schema or solrconfig.xml (see Hoss's arguments about this in the context of the schema, which also apply to solrconfig.xml, in the description of SOLR-4658)\n\nThe RESTManager should allow plugins declared in either the schema or in solrconfig.xml to register one or more REST endpoints, one endpoint per reconfigurable resource, including init params.  To allow for multiple plugin instances, registering plugins will need to provide a handle of some form to distinguish the instances.\n\nThis RESTManager should also be able to create new instances of plugins that it has been configured to allow.  The RESTManager will need its own serialized configuration to remember these plugin declarations.\n\nExample endpoints:\n\n\n\tSynonymFilterFactory\n\t\n\t\tinit params: /solr/collection1/config/syns/myinstance/options\n\t\tsynonyms resource: /solr/collection1/config/syns/myinstance/synonyms-list\n\t\n\t\n\t\"/select\" request handler\n\t\n\t\tinit params: /solr/collection1/config/requestHandlers/select/options\n\t\n\t\n\n\n\nWe should aim for full CRUD over init params and structured resources.  The plugins will bear responsibility for handling resource modification requests, though we should provide utility methods to make this easy.\n\nHowever, since we won't be directly modifying the serialized schema and solrconfig.xml, anything configured in those two places can't be invalidated by configuration serialized elsewhere.  As a result, it won't be possible to remove plugins declared in the serialized schema or solrconfig.xml.  Similarly, any init params declared in either place won't be modifiable.  Instead, there should be some form of init param that declares that the plugin is reconfigurable, maybe using something like \"managed\" - note that request handlers already provide a \"handle\" - the request handler name - and so don't need that to be separately specified:\n\n\n<requestHandler name=\"/select\" class=\"solr.SearchHandler\">\n   <managed/>\n</requestHandler>\n\n\n\nand in the serialized schema - a handle needs to be specified here:\n\n\n<fieldType name=\"text_general\" class=\"solr.TextField\" positionIncrementGap=\"100\">\n...\n  <analyzer type=\"query\">\n    <tokenizer class=\"solr.StandardTokenizerFactory\"/>\n    <filter class=\"solr.SynonymFilterFactory\" managed=\"english-synonyms\"/>\n...\n\n\n\nAll of the above examples use the existing plugin factory class names, but we'll have to create new RESTManager-aware classes to handle registration with RESTManager.\n\nCore/collection reloading should not be performed automatically when a REST API call is made to one of these RESTManager-mediated REST endpoints, since for batched config modifications, that could take way too long.  But maybe reloading could be a query parameter to these REST API calls.",
    "attachments": {
        "SOLR-5653.patch": "https://issues.apache.org/jira/secure/attachment/12628125/SOLR-5653.patch"
    },
    "issue_links": {},
    "comments": [
        {
            "author": "Timothy Potter",
            "id": "comment-13897374",
            "date": "2014-02-11T00:55:25+0000",
            "content": "Here is the first attempt at a solution for the RestManager and implementations for managing stop words and synonyms via a REST API.\n\nA few things to notice about this implementation:\n\n1) The RestManager needs to be able to read/write data from/to ZooKeeper if in cloud mode or the local FS if in standalone mode. This is the purpose of the ManagedResourceStorage.StorageIO interface. The idea here is that the RestManager receives the StorageIO in its constructor from the SolrCore during initialization. Currently, this is done in the SolrCore object, which has to do an instanceof on the SolrResourceLoader to determine if it is ZK aware. This is a bit hacky but I didn't see a better way to determine if a core is running in ZK mode from within the SolrCore object. Currently, I provide 3 implementations of StorageIO: ZooKeeperStorageIO, FileStorageIO, and InMemoryStorageIO.\n\n2) A ManagedResource should be able to choose its own storage format, with the storageIO being determined by the container.\nThis gives the ManagedResource developer flexibility in how they store data without having to fuss with knowing how load/store bytes to ZK or local FS. Currently, the only provided storage format is JSON, see: ManagedResourceStorage.JsonStorage.\n\n3) I'm using a \"registry\" object that is available from the SolrResourceLoader to capture Solr components that declare themselves as being \"managed\". This is needed because parsing the solrconfig.xml may encounter managed components before it parses and initializes the RestManager. Basically, I wanted to separate the registration of managed components from the initialization of the RestManager and those components as I didn't want to force the position of the <restManager/> element in the solrconfig.xml to be before all other components.\n\n4) The design is based around the concept that there may be many different Solr components that share a single ManagedResource. For instance, there may be many ManagedStopFilterFactory instances declared in schema.xml that share a common set of managed English stop words. Thus, I'm using the \"observer\" pattern which allows Solr components to register as an observer of a shared ManagedResource. This way we don't end up with 10 different managers of the same stop word list.\n\n5) ManagedResourceObserver instances are notified once during core initialization (load or reload) when the managed data is available. This is their signal to internalize the managed data, such as the ManagedStopFilterFactory converting the managed set of terms into a CharArraySet used for creating StopFilters. This is a critical part of the design in that updates to the managed data are not applied until a core is reloaded. This is to avoid having analysis components with different views of managed data, i.e. we don't want some of the replicas for a shard to have a different set of stop words than the other shards.\n\n6) I've provided one concrete ManagedResource implementation for managing a word set, which is useful for stop words and protected words (KeywordMarkerFilter). This implementation shows how to handle initArgs and a managedList of words.\n\nKnown Issues:\n\na. The current RestManager attaches its registered endpoints using SolrRestApi, which is configured to process requests to /collection/schema. While this path works for stop words and synonyms, it doesn't work in the general case of any type of ManagedResource. We need to figure out a better path for which to configure the RestManager, but re-working that should be minor.\n\nb. I had to make a few things public in the BaseSchemaResource class and extended the RestManager.ManagedEndpoint class from it. We should refactor BaseSchemaResource into a BaseSolrResource as it has usefulness beyond schema related resources.\n\nc. Deletes - the ManagedResource framework supports deletes but I wasn't sure how to enable them in Restlet; again probably a minor issue in the restlet config / setup. "
        },
        {
            "author": "Mark Miller",
            "id": "comment-13897383",
            "date": "2014-02-11T00:59:36+0000",
            "content": "1. but I didn't see a better way to determine if a core is running in ZK mode from within the SolrCore object. \n\nYou can look at the descriptor for the core, get the corecontainer and call isZooKeeperAware. "
        },
        {
            "author": "Alan Woodward",
            "id": "comment-13897670",
            "date": "2014-02-11T09:30:24+0000",
            "content": "Or maybe add a getStorageIO() method to SolrResourceLoader itself?  We already abstract a lot of 'is this stuff in zk or on the file system' questions into here. "
        },
        {
            "author": "Timothy Potter",
            "id": "comment-13897896",
            "date": "2014-02-11T14:58:01+0000",
            "content": "Ummmm ... why didn't I think of that Alan! Thanks ... will do that instead. "
        },
        {
            "author": "Steve Rowe",
            "id": "comment-13902598",
            "date": "2014-02-16T00:49:57+0000",
            "content": "Hi Tim,\n\nI've looked over your code, and it looks very well thought out - nice!\n\nA few comments, in no particular order - I intentionally haven't looked at your synonyms/stopwords patches yet, so apologies in advance if that results in misunderstanding on my part:\n\n\n\tIn SolrDispatchFilter.doFilter(): The section starting if( path.startsWith(\"/rest\") ) appears to be a vestige?  It's not used anywhere.  (May be related to your known issue a) about RestManager endpoints?)\n\tThere's no way to create a new resource (i.e., one not mentioned in schema.xml/solrconfig.xml) - maybe that's what the above vestige was intended for?\n\tI don't see any REST API tests?\n\tI think we should limit the permissible top-level registerable paths, currently to /schema/ and /config/.  (This relates to your known issue a) about RestManager endpoints.)\n\tIn looking at the patch on SOLR-5641, which will need to be changed to use the RestManager solution developed here, I couldn't figure out a way to have a single Restlet Application subclass that covers more than one top-level path (/schema/ and /config/ in that issue). If you look at the patch on SOLR-5641, you'll see that it adds a new Restlet Application subclass.  My sense is that even if it might be possible to trick Restlet into doing this, it's an anti-pattern.  (This relates to your known issue b) about refactoring BaseSchemaResource.)\n\tIt's important that configuration in schema.xml/solrconfig.xml remains valid regardless of the operation of the RestManager interacting with managed resources; as written, it's possible to have initArgs in these files that are contradicted by initArgs stored in a manage resource.  This is bad.  I think we need to have an immutable initArgs concept, and it will either have to be per-arg, or we'll have to disallow mixing explicit initArgs with modifiable ones.\n\tAbout your known issue c): \"Deletes - the ManagedResource framework supports deletes but I wasn't sure how to enable them in Restlet\" - not sure about Restlet, but there are two Solr code locations I know of that need to be changed to enable new HTTP verbs (I ran into this when I added PUT support): SolrRequestParsers.parseParamsAndFillStreams() and SolrDispatchFilter.remoteQuery().\n\tIn ManagedWordSetResource, onManagedDataLoadedFromStorage() and updateInitArgs(), the String.toLowerCase() calls should be given a Locale argument (likely Locale.ROOT) to escape the wrath of forbidden-apis.  Running ant precommit at the top level will catch this kind of problem (and other things).\n\tYou didn't mention it here, but if we want to enable using PATCH REST calls via Restlet, we'll need to upgrade Restlet from the current v2.1.1 to at least v2.2M1 - note that v2.2RC1 was just released.  (See the issue adding PATCH support and the v2.2RC1 release announcement.)\n\tIn ManagedWordSetResource.updateInitArgs(), if ignoreCase is changed from true to false, the previous downcasing operation can't be undone.  Not sure the best way to handle this: maybe serialization should always capture the unprocessed original versions?\n\tManagedWordSetResource.doGet() ignores ignoreCase\n\tIn the current model, all managed resource GET calls will return dirty managed resource data, rather than live data.  I think it's important to make the dirty data accessible, but we should consider whether live data should be accessible in addition, maybe as a param to the GET call?\n\tIn your tests, you escape double-quotes in JSON strings, but there's a nice method in SolrTestCaseJ4 named json() that will accept single-quoted string values and auto-convert to double-quotes.  Makes the JSON much easier to look at without all the backslashes.\n\tManagedResource assumes JSON storage format, but the idea is to override methods to handle other formats, right?  I think there should be a complete example of doing that in a test.\n\tIt seems weird to me that PUT requests in your patch respond with the same information as GET would against the same resource.  Maybe just return a string indicating success?  (I might be off-base here, I haven't looked at many examples of this elsewhere.)\n\tThe patch ignores the (wt param) on GET methods - this should be fairly simple to fix, by storing data structures rather than JSON strings on the response; see e.g. CopyFieldCollectionResource.get().\n\tIn RestManager.doInit() on line 128, you have a TODO:\n\n\n\n\n// TODO: Feels like there should be a method in restlet to do this\nString rootPath = getRequest().getRootRef().toString();\nString resourceRef = getRequest().getResourceRef().toString();\nString resourceId = resourceRef.substring(rootPath.length());\nint qsAt = resourceId.indexOf(\"?\");\nif (qsAt != -1) resourceId = resourceId.substring(0,qsAt);\n\n\n\nRestlet's Reference class, an instance of which is returned by getRequest.getResourceRef(), has a method getRelativeRef() that can extract a URI reference relative to an absolute base reference, so you could do something like (untested):\n\n\nReference rootRef = getRequest().getRootRef();\nString resourceId = getRequest().getResourceRef().getRelativeRef(rootRef).getPath();\n\n "
        },
        {
            "author": "Timothy Potter",
            "id": "comment-13911210",
            "date": "2014-02-25T04:00:18+0000",
            "content": "Thanks for the thorough review Steve, very helpful! The updated patch cleans up a number of the issues you raised, specifically:\n\n1. In SolrDispatchFilter.doFilter(): The section starting if( path.startsWith(\"/rest\") ) appears to be a vestige?\nFixed (was vestige). Currently, the RestManager supports /schema and /config only.\n\n2. There's no way to create a new resource (i.e., one not mentioned in schema.xml/solrconfig.xml)\nThe RestManager's ManagedEndpoint class is now attached as the default resource class (no longer DefaultSchemaResource). If a request to create a new resource comes in, the PUT/POST request will be routed to the RestManager's RestManagerManagedResource, which knows how to create new managed resources and make them active in the server.\n\n3. I don't see any REST API tests?\nMost of the API testing is in the concrete endpoints (stop words / synonym) as most of what needs to be tested in the RestManager layer can be tested without making REST API calls. However, I've also added some additional REST API tests to TestRestManager.\n\n4. I think we should limit the permissible top-level registerable paths, currently to /schema/ and /config/. \nDone, but required the introduction of SolrConfigRestApi class and changes to Solr's web.xml. At this point, ManagedResource implementers have to choose which path makes the most sense for their resource, see ManagedStopFilterFactory as an example.\nWe may be able to get away with 1 class that extends Restlet's Application by implementing a custom Finder. However, I wanted to get something in place that solidifies the paths the API will support as soon as possible. If we determine a cleaner way to support /schema and /config, then we should be able to do that without breaking client code.\n\n5. In looking at the patch on SOLR-5641, which will need to be changed to use the RestManager solution developed here ... \nTBD - That's a large patch that will need more time to go over. There is some overlap in that this patch also includes a SolrConfigRestApi.\n\n6. It's important that configuration in schema.xml/solrconfig.xml remains valid regardless of the operation of the RestManager interacting with managed resources\nI've added a check for having additional args to the BaseManagedTokenFilterFactory however there's nothing in the RestManager framework that enforces this.\nThe main idea behind my implementation is that the \"managed\" attribute is the only one declared and then all initArgs are stored/managed in the managed data. That said, I could see the validity of supporting invariant initArgs so this might need some more work.\n\n7. About your known issue c): \"Deletes - the ManagedResource framework supports deletes but I wasn't sure how to enable them in Restlet\" - not sure about Restlet, but there are two Solr code locations I know of that need to be changed to enable new HTTP verbs (I ran into this when I added PUT support): SolrRequestParsers.parseParamsAndFillStreams() and SolrDispatchFilter.remoteQuery().\nThanks. Deletes are working now. However, a ManagedResource cannot be deleted if there are Solr components still using it.\n\n8. In ManagedWordSetResource, onManagedDataLoadedFromStorage() and updateInitArgs(), the String.toLowerCase() calls should be given a Locale argument (likely Locale.ROOT) to escape the wrath of forbidden-apis. Running ant precommit at the top level will catch this kind of problem (and other things).\nFixed.\n\n9. You didn't mention it here, but if we want to enable using PATCH REST calls via Restlet, we'll need to upgrade Restlet from the current v2.1.1 to at least v2.2M1 - note that v2.2RC1 was just released. (See the issue adding PATCH support and the v2.2RC1 release announcement.)\nWe should tackle upgrading Restlet in a different JIRA issue and then PATCH support can be added later if desired.\n\n10. In ManagedWordSetResource.updateInitArgs(), if ignoreCase is changed from true to false, the previous downcasing operation can't be undone. Not sure the best way to handle this: maybe serialization should always capture the unprocessed original versions?\nThis is a tough one. My thinking is that we shouldn't worry about this for now since it seems like more work / trouble supporting than it may be worth and seems like a client app issue vs. something that needs to be built-in to the RestManager framework. That said, I'm also open to hearing about cases where we should support this.\n\n11. ManagedWordSetResource.doGet() ignores ignoreCase\nFixed. Improved the unit tests to verify this as well.\n\n12. In the current model, all managed resource GET calls will return dirty managed resource data, rather than live data. I think it's important to make the dirty data accessible, but we should consider whether live data should be accessible in addition, maybe as a param to the GET call?\nThe use case I designed for was that updates would be applied using a core / collection reload very soon after submitting changes to the API. In other words, the time where live data and dirty data are different should very small and not all that important. Mainly, I don't want to start going down the path of implementing as version control system for what is supposed to be a simple API for changing config settings and then reloading the core to apply them. \n\n13. In your tests, you escape double-quotes in JSON strings, but there's a nice method in SolrTestCaseJ4 named json() that will accept single-quoted string values and auto-convert to double-quotes. Makes the JSON much easier to look at without all the backslashes.\nFixed. Thanks for tip, much nicer to look at indeed.\n\n14. ManagedResource assumes JSON storage format, but the idea is to override methods to handle other formats, right? I think there should be a complete example of doing that in a test.\nAdded. Please see - TestManagedResource#testCustomStorageFormat\n\n15. It seems weird to me that PUT requests in your patch respond with the same information as GET would against the same resource. Maybe just return a string indicating success? (I might be off-base here, I haven't looked at many examples of this elsewhere.)\nAgreed on the weird part and fixed. Now just returns 200 status code\n\n16. The patch ignores the (wt param) on GET methods - this should be fairly simple to fix, by storing data structures rather than JSON strings on the response; see e.g. CopyFieldCollectionResource.get().\nHmmm... Not sure what's up with this one as using wt=xml works for me without changes. To be sure, I added test to verify XML as well as JSON.\n\n17. In RestManager.doInit() on line 128, you have a TODO:\nGood catch ... Thanks! "
        },
        {
            "author": "Steve Rowe",
            "id": "comment-13911837",
            "date": "2014-02-25T18:22:46+0000",
            "content": "Hi Tim,\n\nI'll look at your new patch this afternoon, but first I'll comment on some of your responses to my review:\n\n\n4. I think we should limit the permissible top-level registerable paths, currently to /schema/ and /config/.\n\nDone, but required the introduction of SolrConfigRestApi class and changes to Solr's web.xml. At this point, ManagedResource implementers have to choose which path makes the most sense for their resource, see ManagedStopFilterFactory as an example.\n\nWe may be able to get away with 1 class that extends Restlet's Application by implementing a custom Finder. However, I wanted to get something in place that solidifies the paths the API will support as soon as possible. If we determine a cleaner way to support /schema and /config, then we should be able to do that without breaking client code.\n\nCool, sounds like a good plan - I didn't realize a custom Finder would address the multiple Applications issue - I'll have a look.\n\n\n6. It's important that configuration in schema.xml/solrconfig.xml remains valid regardless of the operation of the RestManager interacting with managed resources\n\nI've added a check for having additional args to the BaseManagedTokenFilterFactory however there's nothing in the RestManager framework that enforces this.\n\nThe main idea behind my implementation is that the \"managed\" attribute is the only one declared and then all initArgs are stored/managed in the managed data. That said, I could see the validity of supporting invariant initArgs so this might need some more work.\n\nMaybe it'll have to remain the case that each implementation ensures there are no non-\"managed\" attributes.  If nothing else, this choice (\"managed\" is the only supported attribute) should be doc'd (if not already), so that implementers know they need to perform this check.\n\n\n10. In ManagedWordSetResource.updateInitArgs(), if ignoreCase is changed from true to false, the previous downcasing operation can't be undone. Not sure the best way to handle this: maybe serialization should always capture the unprocessed original versions?\n\nThis is a tough one. My thinking is that we shouldn't worry about this for now since it seems like more work / trouble supporting than it may be worth and seems like a client app issue vs. something that needs to be built-in to the RestManager framework. That said, I'm also open to hearing about cases where we should support this.\n\nIf we don't support that use case, the request must fail.  This limitation should also be doc'd (if not already).\n\n\n12. In the current model, all managed resource GET calls will return dirty managed resource data, rather than live data. I think it's important to make the dirty data accessible, but we should consider whether live data should be accessible in addition, maybe as a param to the GET call?\n\nThe use case I designed for was that updates would be applied using a core / collection reload very soon after submitting changes to the API. In other words, the time where live data and dirty data are different should very small and not all that important. Mainly, I don't want to start going down the path of implementing as version control system for what is supposed to be a simple API for changing config settings and then reloading the core to apply them.\n\nFair enough.  This should be doc'd (if not already): this API may temporarily lie to you.\n\n\n16. The patch ignores the (wt param) on GET methods - this should be fairly simple to fix, by storing data structures rather than JSON strings on the response; see e.g. CopyFieldCollectionResource.get().\n\nHmmm... Not sure what's up with this one as using wt=xml works for me without changes. To be sure, I added test to verify XML as well as JSON.\n\nMy bad - this was based on code inspection.  I'll take another look. "
        },
        {
            "author": "Steve Rowe",
            "id": "comment-13915155",
            "date": "2014-02-27T22:53:30+0000",
            "content": "Tim, looks like ManagedWordSetResource.java is missing from your latest patch - it was in the previous one, though.\u0010 "
        },
        {
            "author": "Timothy Potter",
            "id": "comment-13915478",
            "date": "2014-02-28T05:36:43+0000",
            "content": "No major changes in this patch, but the previous one incorrectly pulled in some dependencies on the patches for SOLR-5654 and SOLR-5655. In addition, one of the TestRestManager tests had a subtle dependency on the patch for SOLR-5655. So this patch ensures it works w/o having to apply the patches for the other tickets. Btw ... I'm not going to bother posting more patches for the other tickets until this one gets resolved. "
        },
        {
            "author": "Alexandre Rafalovitch",
            "id": "comment-13925184",
            "date": "2014-03-09T11:29:36+0000",
            "content": "In terms of documenting the REST API, would something like Swagger be useful: https://helloreverb.com/developers/swagger ? "
        },
        {
            "author": "Steve Rowe",
            "id": "comment-13925822",
            "date": "2014-03-10T15:49:37+0000",
            "content": "Patch, building on Tim's patch. \n\n Left to do:\n\n\tinit args should be moved to NamedList (typed nested values) instead of the current String->String map, to support solrconfig.xml plugin init args\n\tjavadocs should be added where there are none\n\n\n\nThis patch has some minor cleanups, as well as the following changes:\n\n\n\tRenamed SolrRestApi -> SolrSchemaRestApi\n\tEnabled short-form \"solr.classname\" class lookup for o.a.s.rest.schema.analysis (e.g. \"solr.ManagedWordSetResource\")\n\tFinished the BaseSchemaResource -> BaseSolrResource renaming by executing svn mv [...]/BaseSchemaResource [...]/BaseSolrResource (to retain svn history) and making all classes extending BaseSchemaResource extend BaseSolrResource instead\n\tRemoved DefaultSchemaResource.java; unknown URI paths under /schema and /config are now handled by RestManager.ManagedEndpoint\n\tRestManager.Registry now protects against registration of resourceId-s that are already in use by the Schema REST API - protecting /config/managed and /schema/managed is now handled via this general mechanism\n\tTestRestManager:\n\t\n\t\tadded tests that already-spoken-for REST API endpoints can't be registered\n\t\tadded tests for switching ignoreCase of ManagedWordSetResource\n\t\tadded XML response format test\n\t\n\t\n\n\n\n\n\tManagedWordSetResource.updateInitArgs():\n\t\n\t\tcompare current/updated ignoreCase vals as booleans, instead of as string args\n\t\tthrow an exception if current ignoreCase = true and updated ignoreCase = false, since change this is not permitted\n\t\n\t\n\tIn RestManager.addManagedResource(), now assert'ing that the resourceId validation result from matches() is true, rather than throwing away the result; registry.registerManagedResource(), called earlier in addManagedResource(), already ensures that the regex matches against the resourceId.\n\n "
        },
        {
            "author": "Steve Rowe",
            "id": "comment-13930840",
            "date": "2014-03-11T19:46:28+0000",
            "content": "\nLeft to do:\n\n\tinit args should be moved to NamedList (typed nested values) instead of the current String->String map, to support solrconfig.xml plugin init args\n\n\n\nThis patch switches ManagedResource init arg handling to NamedList, and converts a couple of existing tests to illustrate use of typed nested args.\n\n\n\n\tjavadocs should be added where there are none\n\n\n\nWith the exception of the missing javadocs, I think this is ready to go.  I'll put up a final patch later today. "
        },
        {
            "author": "Timothy Potter",
            "id": "comment-13931113",
            "date": "2014-03-11T23:05:55+0000",
            "content": "Looking good Steve ...\n\nI like the conversion over to using NamedList<?> for managedInitArgs in general. However, I think we should serialize into a JSON Map when returning initArgs in the API. Apparently, a NamedList converts to JSON as a list and not a map, ie.\n\n\"wordSet\":{ \"initArgs\":[\"ignoreCase\",\"true\"], ...\n\nThis seems like an awkward format for exposing to client applications consuming the API. I think a map representation of initArgs seems better, i.e.\n\n\"wordSet\":{ \"initArgs\":\n{ \"ignoreCase\":true, ... }\n }\u200b\n\nTo address this, can you add the following method to ManagedResource:\n\n  /**\n\n\tConverts a NamedList<Object> into a sorted Map for returning as JSON.\n   */\n  protected Map<String,Object> convertNamedListToMap(NamedList<Object> args) {\n    Map<String,Object> argsMap = new TreeMap<String,Object>();\n    if (args != null && args.size() > 0) \nUnknown macro: {      Iterator<Map.Entry<String,Object>> argIter = args.iterator();      while (argIter.hasNext()) {\n        Map.Entry<String,Object> entry = argIter.next();\n        argsMap.put(entry.getKey(), entry.getValue());\n      }    } \n    return argsMap;\n  }\n\n\n\nAnd then change the buildMapToStore method to call it:\n\n    toStore.put(INIT_ARGS_JSON_FIELD, convertNamedListToMap(managedInitArgs));\n\nAlso, previously, the ManagedResource would return default values of the initArgs, but the conversion over to NamedList<?> has made that go away somehow. In other words, this test now fails when doing a GET against the initial state of the stop word resource because the default value for ignoreCase is not returned with the initial state of the resource anymore:\n\n    assertJQ(endpoint, \n             \"/wordSet/initArgs/ignoreCase==\\\"false\\\"\", <<< This now fails\n             \"/wordSet/managedList==[]\");\n\nI think the initial state of a resource should return the default values for initArgs if the default is not null so that this test case would pass.\n\nIf you can post an updated patch with these changes, I can finish the patches for SOLR-5655 and 5654.\n\nThanks. "
        },
        {
            "author": "Steve Rowe",
            "id": "comment-13931174",
            "date": "2014-03-11T23:51:54+0000",
            "content": "Patch attached with requested changes attached.\n\n\nI think we should serialize into a JSON Map when returning initArgs in the API\n[..]\nTo address this, can you add the following method to ManagedResource:\nprotected Map<String,Object> convertNamedListToMap(NamedList<Object> args)\n\nDone.  I changed to using an ordered map instead of a sorted map, though, to preserve intentional ordering (if any) from the NamedList.\n\n\n[...]\nI think the initial state of a resource should return the default values for initArgs if the default is not null\n\nAgreed, I've put this functionality back in ManagedWordSetResource and added a test to make sure the default ignoreCase gets serialized. "
        },
        {
            "author": "Steve Rowe",
            "id": "comment-13932368",
            "date": "2014-03-12T21:05:11+0000",
            "content": "Final patch.  The changes:\n\n\tAdded missing javadocs\n\tJava7: removed explicit types from generic ctor invocations -> diamond operator\n\tRe-implemented NamedList.removeBooleanArg() in terms of new method NamedList.getBooleanArg(), to allow other init args consumers to retrieve boolean args from NamedList-s without removing the arg.\n\n\n\nI think it's ready.  I'll commit to trunk shortly. "
        },
        {
            "author": "ASF subversion and git services",
            "id": "comment-13932451",
            "date": "2014-03-12T21:52:51+0000",
            "content": "Commit 1576939 from Steve Rowe in branch 'dev/trunk'\n[ https://svn.apache.org/r1576939 ]\n\nSOLR-5653: Create a RestManager to provide REST API endpoints for reconfigurable plugins "
        },
        {
            "author": "Steve Rowe",
            "id": "comment-13932460",
            "date": "2014-03-12T21:57:03+0000",
            "content": "Committed to trunk.\n\nI plan on waiting until SOLR-5654 and SOLR-5655 (the first concrete implementations of RestManager-enabled functionality) land on trunk, and letting them soak a bit, before backporting this to branch_4x. "
        },
        {
            "author": "ASF subversion and git services",
            "id": "comment-13932466",
            "date": "2014-03-12T21:59:25+0000",
            "content": "Commit 1576942 from Steve Rowe in branch 'dev/trunk'\n[ https://svn.apache.org/r1576942 ]\n\nSOLR-5653: Add CHANGES.txt entry "
        },
        {
            "author": "Steve Rowe",
            "id": "comment-13933817",
            "date": "2014-03-13T18:25:51+0000",
            "content": "In terms of documenting the REST API, would something like Swagger be useful: https://helloreverb.com/developers/swagger ?\n\nThanks Alexandre Rafalovitch, looks interesting.  Today somebody sent me a link to an interview with Reverb's CEO, where he talks about the evolution of Swagger among other things: <http://techcrunch.com/2014/03/12/founder-stories-when-it-comes-to-open-source-technologies-reverbs-tony-tam-has-a-word-for-it/> "
        },
        {
            "author": "Alexandre Rafalovitch",
            "id": "comment-13959902",
            "date": "2014-04-04T12:08:55+0000",
            "content": "Further on documentation. to be generically editable, does this require self-documenting plugins? This issue was discussed a little bit in SOLR-5287 (Jan's entry on 30 Sep 2013) with an example syntax.\n\nRight now, we seem to be relying a lot on magic keywords self-knowledge. But that seems to be more and more fragile as we are moving into UI-driven configuration. "
        },
        {
            "author": "ASF subversion and git services",
            "id": "comment-13960964",
            "date": "2014-04-05T04:32:35+0000",
            "content": "Commit 1584959 from sarowe@apache.org in branch 'dev/branches/branch_4x'\n[ https://svn.apache.org/r1584959 ]\n\nSOLR-5653: Create a RestManager to provide REST API endpoints for reconfigurable plugins (merged trunk r1576939 and r1576942) "
        },
        {
            "author": "Steve Rowe",
            "id": "comment-13961172",
            "date": "2014-04-05T17:25:02+0000",
            "content": "Committed to trunk and branch_4x.\n\nThanks Tim! "
        },
        {
            "author": "Uwe Schindler",
            "id": "comment-13982523",
            "date": "2014-04-27T23:25:36+0000",
            "content": "Close issue after release of 4.8.0 "
        }
    ]
}