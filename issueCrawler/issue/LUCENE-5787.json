{
    "id": "LUCENE-5787",
    "title": "LuceneTestCase static leak checker interferes with Groovy unit tests",
    "details": {
        "type": "Bug",
        "priority": "Major",
        "labels": "",
        "resolution": "Unresolved",
        "components": [],
        "affect_versions": "4.7,                                            4.8.1",
        "status": "Open",
        "fix_versions": []
    },
    "description": "LuceneTestCase's static memory leak checker can break Groovy subclasses. Specifically, Groovy classes have a synthetic static member variable of type org.codehaus.groovy.reflection.ClassInfo. If this variable grows too large then LTC will fail the test. Because the variable is added by the Groovy runtime instead of by the developer there is no way for the developer to clear the field themselves.\n\nAlso note that the static leak checker does not ignore memory held by soft or weak references. These should be ignored because the memory retained by such fields will be reclaimed instead of triggering OutOfMemoryErrors.\n\nNote that because LTC is a base class for Solr's testing support classes this also affects SolrTestCaseJ4 and AbstractSolrTestCase.",
    "attachments": {},
    "issue_links": {},
    "comments": [
        {
            "id": "comment-14041145",
            "author": "Uwe Schindler",
            "content": "This means you want to subclass LuceneTestCase with Groovy as basis for your own Solr/Lucene tests? ",
            "date": "2014-06-23T19:09:11+0000"
        },
        {
            "id": "comment-14041150",
            "author": "Dawid Weiss",
            "content": "We could exclude this particular reference by field class's name. As for weak/ soft refs \u2013 I agree, these should also be excluded from the count. What do you think, Uwe? ",
            "date": "2014-06-23T19:12:50+0000"
        },
        {
            "id": "comment-14041167",
            "author": "Uwe Schindler",
            "content": "I agree with all subclasses of Reference. The main usecase of WeakRefs is in static fields  - see for example the pointers to classes for static caches.\n\nThe particular reference to the groovy class could be added a String to the leak checker. On the other hand, if you subclass LTC for Groovy, you can add the annotation to prevent the leakchecker from running. This bug does not affect Lucene, it is a problem of 3rd party infrastructures using our test framework. So the big question: What does other scripting laguages do? Scala? JRuby? The list is endless. Maybe add an annotation like @SuppressLeakChecks([fieldname, fieldname, fieldname]). ",
            "date": "2014-06-23T19:25:43+0000"
        },
        {
            "id": "comment-14041202",
            "author": "Dawid Weiss",
            "content": "I think (didn't check) the leak checker is a test rule, so it cannot be easily replaced/ modified (you'd have to shadow the rule chain field and replace all the logic in there). Yet another JUnit dead-end corner case I guess. ",
            "date": "2014-06-23T19:52:47+0000"
        },
        {
            "id": "comment-14041224",
            "author": "John Gibson",
            "content": "\nThis means you want to subclass LuceneTestCase with Groovy as basis for your own Solr/Lucene tests?\nYes, exactly. Although in my case it was subclassing AbstractSolrTestCase (which is a descendent of LuceneTestCase).\n\n\nI think (didn't check) the leak checker is a test rule, so it cannot be easily replaced/ modified (you'd have to shadow the rule chain field and replace all the logic in there). Yet another JUnit dead-end corner case I guess.\nDawid, I believe that you're correct. When I first looked into this I couldn't figure out how to disable the check, so I ended up copying LTC into my project and whitelisting the necessary fields manually.\n\nThe most annoying part about this bug was that initially the test worked fine, then as I added more fields and code to the suite the ClassInfo reference passed the 10 MiB mark and suddenly it stopped working.\n\n\nThis bug does not affect Lucene, it is a problem of 3rd party infrastructures using our test framework. So the big question: What does other scripting laguages do? Scala? JRuby? The list is endless. Maybe add an annotation like \n\n@SuppressLeakChecks([fieldname, fieldname, fieldname])\n\n\nThis is an excellent observation that I hadn't thought of. An annotation may be the correct route. Another option would be to ignore all synthetic fields. (Note that I'm just assuming that Groovy's ClassInfo field is synthetic, given that it's generated by the groovy compiler/runtime.) ",
            "date": "2014-06-23T20:07:24+0000"
        },
        {
            "id": "comment-14041256",
            "author": "Dawid Weiss",
            "content": "Can you check if this is indeed the case (synthetic field), John? It makes sense to exclude these I think. ",
            "date": "2014-06-23T20:26:24+0000"
        },
        {
            "id": "comment-14041264",
            "author": "Dawid Weiss",
            "content": "I changed my mind; synthetic fields may be actually useful to capture (in case of some awkward compiler generated stuff we do want to include these, unless explicitly excluded).\n\nI think Uwe's idea is better \u2013 an annotation to exclude whatever needs to be excluded. I'd make it more flexible by specifying a list of filter classes (much like we do with leak thread exclusions); this allows people to write code to exclude whatever they need. ",
            "date": "2014-06-23T20:30:54+0000"
        },
        {
            "id": "comment-14041305",
            "author": "John Gibson",
            "content": "I just checked and Groovy's ClassInfo field is synthetic. However, I agree that Uwe's annotation idea is more flexible and will save you from the case where the compiler inexplicably generates gigantic static fields which later cause OOMs. ",
            "date": "2014-06-23T20:56:47+0000"
        },
        {
            "id": "comment-14041341",
            "author": "Uwe Schindler",
            "content": "I would allow to use the annotation, but fields explicitely marked as \"synthetic\" should always be excluded from the leak checker. Those fields/methods are defined to be any constructs introduced by the compiler that do not have a corresponding construct in the source code must be marked as synthetic, except for default constructors and the class initialization method (like Java 8 lambda methods and fields, access$-methods, the magic assertions enabled static final,...) ",
            "date": "2014-06-23T21:28:50+0000"
        },
        {
            "id": "comment-14041344",
            "author": "Uwe Schindler",
            "content": "here the compiler inexplicably generates gigantic static fields which later cause OOMs\n\nThe leak checker is meant for stuff in our tests that leak in static fields after test class has finished execution. Stuff the compiler adds is nt part of that. ",
            "date": "2014-06-23T21:30:30+0000"
        },
        {
            "id": "comment-14041726",
            "author": "Dawid Weiss",
            "content": "Synthetic fields are also used to pass final variables to the context of an anonymous inner class; not that I envision such constructs to be used as a test case from Java level, but if somebody wants to use a scripting language then who knows what gets passed (and how).\n\nI think we should keep it \u2013 if we hit something absurd we can always filter it away, but before we do who knows what's lurking out there. ",
            "date": "2014-06-24T05:46:06+0000"
        }
    ]
}