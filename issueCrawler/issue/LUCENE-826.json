{
    "id": "LUCENE-826",
    "title": "Language detector",
    "details": {
        "labels": "",
        "priority": "Major",
        "components": [],
        "type": "New Feature",
        "fix_versions": [],
        "affect_versions": "None",
        "resolution": "Won't Fix",
        "status": "Closed"
    },
    "description": "A formula 1A token/ngram-based language detector. Requires a paragraph of text to avoid false positive classifications. \n\nDepends on contrib/analyzers/ngrams for tokenization, Weka for classification (logistic support vector models) feature selection and normalization of token freuencies.  Optionally Wikipedia and NekoHTML for training data harvesting.\n\nInitialized like this:\n\n\n    LanguageRoot root = new LanguageRoot(new File(\"documentClassifier/language root\"));\n\n    root.addBranch(\"uralic\");\n    root.addBranch(\"fino-ugric\", \"uralic\");\n    root.addBranch(\"ugric\", \"uralic\");\n    root.addLanguage(\"fino-ugric\", \"fin\", \"finnish\", \"fi\", \"Suomi\");\n\n    root.addBranch(\"proto-indo european\");\n    root.addBranch(\"germanic\", \"proto-indo european\");\n    root.addBranch(\"northern germanic\", \"germanic\");\n    root.addLanguage(\"northern germanic\", \"dan\", \"danish\", \"da\", \"Danmark\");\n    root.addLanguage(\"northern germanic\", \"nor\", \"norwegian\", \"no\", \"Norge\");\n    root.addLanguage(\"northern germanic\", \"swe\", \"swedish\", \"sv\", \"Sverige\");\n\n    root.addBranch(\"west germanic\", \"germanic\");\n    root.addLanguage(\"west germanic\", \"eng\", \"english\", \"en\", \"UK\");\n\n    root.mkdirs();\n\n    LanguageClassifier classifier = new LanguageClassifier(root);\n    if (!new File(root.getDataPath(), \"trainingData.arff\").exists()) {\n      classifier.compileTrainingData(); // from wikipedia\n    }\n    classifier.buildClassifier();\n\n\n\n\nTraining set build from Wikipedia is the pages describing the home country of each registred language in the language to train. Above example pass this test:\n\n(testEquals is the same as assertEquals, just not required. Only one of them fail, see comment.)\n\n\n    assertEquals(\"swe\", classifier.classify(sweden_in_swedish).getISO());\n    testEquals(\"swe\", classifier.classify(norway_in_swedish).getISO());\n    testEquals(\"swe\", classifier.classify(denmark_in_swedish).getISO());\n    testEquals(\"swe\", classifier.classify(finland_in_swedish).getISO());\n    testEquals(\"swe\", classifier.classify(uk_in_swedish).getISO());\n\n    testEquals(\"nor\", classifier.classify(sweden_in_norwegian).getISO());\n    assertEquals(\"nor\", classifier.classify(norway_in_norwegian).getISO());\n    testEquals(\"nor\", classifier.classify(denmark_in_norwegian).getISO());\n    testEquals(\"nor\", classifier.classify(finland_in_norwegian).getISO());\n    testEquals(\"nor\", classifier.classify(uk_in_norwegian).getISO());\n\n    testEquals(\"fin\", classifier.classify(sweden_in_finnish).getISO());\n    testEquals(\"fin\", classifier.classify(norway_in_finnish).getISO());\n    testEquals(\"fin\", classifier.classify(denmark_in_finnish).getISO());\n    assertEquals(\"fin\", classifier.classify(finland_in_finnish).getISO());\n    testEquals(\"fin\", classifier.classify(uk_in_finnish).getISO());\n\n    testEquals(\"dan\", classifier.classify(sweden_in_danish).getISO());\n    // it is ok that this fails. dan and nor are very similar, and the document about norway in danish is very small.\n    testEquals(\"dan\", classifier.classify(norway_in_danish).getISO()); \n    assertEquals(\"dan\", classifier.classify(denmark_in_danish).getISO());\n    testEquals(\"dan\", classifier.classify(finland_in_danish).getISO());\n    testEquals(\"dan\", classifier.classify(uk_in_danish).getISO());\n\n    testEquals(\"eng\", classifier.classify(sweden_in_english).getISO());\n    testEquals(\"eng\", classifier.classify(norway_in_english).getISO());\n    testEquals(\"eng\", classifier.classify(denmark_in_english).getISO());\n    testEquals(\"eng\", classifier.classify(finland_in_english).getISO());\n    assertEquals(\"eng\", classifier.classify(uk_in_english).getISO());\n\n\n\nI don't know how well it works on lots of lanugages, but this fits my needs for now. I'll try do more work on considering the language trees when classifying.\n\nIt takes a bit of time and RAM to build the training data, so the patch contains a pre-compiled arff-file.",
    "attachments": {
        "ld.tar.gz": "https://issues.apache.org/jira/secure/attachment/12352807/ld.tar.gz"
    },
    "issue_links": {},
    "comments": [
        {
            "date": "2007-03-07T04:23:25+0000",
            "content": "tar-ball with code and a precompiled training data set that detects swedish, danish, norwegian, english and finnish. ",
            "author": "Karl Wettin",
            "id": "comment-12478680"
        },
        {
            "date": "2007-03-07T06:33:06+0000",
            "content": "Some performance in numbers: using only 160+ character long paragraphs as training data I get these results from a 10-fold cross validation:\n\n\nTime taken to build model: 2.12 seconds\n\n=== Stratified cross-validation ===\n=== Summary ===\n\nCorrectly Classified Instances        1199               98.6831 %\nIncorrectly Classified Instances        16                1.3169 %\nKappa statistic                          0.9814\nMean absolute error                      0.2408\nRoot mean squared error                  0.3173\nRelative absolute error                 84.8251 %\nRoot relative squared error             84.235  %\nTotal Number of Instances             1215     \n\n=== Detailed Accuracy By Class ===\n\nTP Rate   FP Rate   Precision   Recall  F-Measure   ROC Area  Class\n  1         0.009      0.989     1         0.995      0.995    eng\n  0.979     0.001      0.995     0.979     0.987      0.994    swe\n  0.973     0.003      0.984     0.973     0.979      0.996    nor\n  0.946     0.005      0.935     0.946     0.941      0.975    dan\n  0.989     0          1         0.989     0.995      0.997    fin\n\n=== Confusion Matrix ===\n\n   a   b   c   d   e   <-- classified as\n 562   0   0   0   0 |   a = eng\n   3 183   0   1   0 |   b = swe\n   1   0 183   4   0 |   c = nor\n   1   1   3  87   0 |   d = dan\n   1   0   0   1 184 |   e = fin ",
            "author": "Karl Wettin",
            "id": "comment-12478691"
        },
        {
            "date": "2007-03-07T06:53:22+0000",
            "content": "Foot note:\n\nThe diffrence between this and the Nutch gram-based language identifier is quite a bit. For a starter this calculate the vertices on full words, edge-grams and bi-grams where the two charaters are the same. The frequency is normalized against the text size. The same goes for analysis at classification time. The n most important (feature selection using ranked information gain)  tokens are selected for consideration by the classifier, currently 200 (out of 1000 per language) per registred language. So whis the default test (5 languages) there are 1000 tokens. It is really speedy on my dual core.  ",
            "author": "Karl Wettin",
            "id": "comment-12478694"
        },
        {
            "date": "2007-03-07T08:39:29+0000",
            "content": "Ahhh, I could not let be go without some more tests. Added a bunch of languages and it seems as it works quite splendid. Again, 10-cross fold validation output on 160+ characters long paragraphs:\n\nTime taken to build model: 45.51 seconds\n\n=== Stratified cross-validation ===\n=== Summary ===\n\nCorrectly Classified Instances        5566               98.8808 %\nIncorrectly Classified Instances        63                1.1192 %\nKappa statistic                          0.9874\nMean absolute error                      0.139 \nRoot mean squared error                  0.2555\nRelative absolute error                 93.6301 %\nRoot relative squared error             93.7791 %\nTotal Number of Instances             5629     \n\n=== Detailed Accuracy By Class ===\n\nTP Rate   FP Rate   Precision   Recall  F-Measure   ROC Area  Class\n  0.996     0.003      0.988     0.996     0.992      0.997    eng\n  0.988     0          0.998     0.988     0.993      0.995    swe\n  0.984     0.002      0.982     0.984     0.983      0.996    spa\n  0.988     0          0.995     0.988     0.992      0.997    fre\n  0.979     0.001      0.982     0.979     0.981      0.992    nld\n  0.97      0.002      0.97      0.97      0.97       0.993    nor\n  1         0          1         1         1          1        afr\n  0.914     0.001      0.946     0.914     0.93       0.992    dan\n  0.986     0.001      0.981     0.986     0.984      0.999    pot\n  0.998     0.001      0.993     0.998     0.995      0.999    fin\n  0.99      0.001      0.993     0.99      0.992      0.999    ita\n  0.998     0          0.998     0.998     0.998      0.999    ger\n\n=== Confusion Matrix ===\n\n    a    b    c    d    e    f    g    h    i    j    k    l   <-- classified as\n 1044    1    1    0    0    0    0    0    1    1    0    0 |    a = eng\n    2  425    0    0    2    0    0    0    0    0    1    0 |    b = swe\n    0    0  434    1    1    0    0    0    5    0    0    0 |    c = spa\n    2    0    0  418    0    0    0    0    0    1    0    2 |    d = fre\n    4    0    2    0  333    0    0    0    0    0    1    0 |    e = nld\n    1    0    0    0    0  322    0    7    1    0    1    0 |    f = nor\n    0    0    0    0    0    0  230    0    0    0    0    0 |    g = afr\n    1    0    0    0    2   10    0  139    0    0    0    0 |    h = dan\n    0    0    5    0    0    0    0    0  362    0    0    0 |    i = pot\n    0    0    0    0    0    0    0    1    0  440    0    0 |    j = fin\n    2    0    0    0    1    0    0    0    0    1  417    0 |    k = ita\n    1    0    0    1    0    0    0    0    0    0    0 1002 |    l = ger\n\n\n\n    root.addBranch(\"uralic\");\n    root.addBranch(\"uralic\", \"fino-ugric\");\n    root.addBranch(\"uralic\", \"ugric\");\n    //root.addLanguage(\"hungarian\", \"ugric\");\n    root.addLanguage(\"fino-ugric\", \"fin\", \"finnish\", \"fi\", \"Suomi\");\n    //root.addLanguage(\"sami\", \"fino-ugric\");\n    //root.addLanguage(\"estonian\", \"fino-ugric\");\n    //root.addLanguage(\"livonian\", \"fino-ugric\");\n\n    root.addBranch(\"proto-indo european\");\n\n    root.addBranch(\"proto-indo european\", \"italic\");\n    root.addBranch(\"italic\", \"latino-faliscan\");\n    root.addBranch(\"latino-faliscan\", \"latin\");\n    root.addLanguage(\"latin\", \"ita\", \"italian\", \"it\", \"Italia\");\n    root.addLanguage(\"latin\", \"fre\", \"french\", \"fr\", \"France\");\n    root.addLanguage(\"latin\", \"pot\", \"portugese\", \"pt\", \"Portugal\");\n    root.addLanguage(\"latin\", \"spa\", \"spanish\", \"es\", \"Espa%C3%B1a\");\n\n    root.addBranch(\"proto-indo european\", \"germanic\");\n    root.addBranch(\"germanic\", \"northern germanic\");\n    root.addLanguage(\"northern germanic\", \"dan\", \"danish\", \"da\", \"Danmark\");\n    root.addLanguage(\"northern germanic\", \"nor\", \"norwegian\", \"no\", \"Norge\");\n    root.addLanguage(\"northern germanic\", \"swe\", \"swedish\", \"sv\", \"Sverige\");\n\n    root.addBranch(\"germanic\", \"west germanic\");\n    root.addLanguage(\"west germanic\", \"eng\", \"english\", \"en\", \"UK\");\n    root.addLanguage(\"west germanic\", \"ger\", \"german\", \"de\", \"Deutschland\");\n\n    root.addBranch(\"west germanic\", \"middle dutch\");\n    root.addLanguage(\"middle dutch\", \"nld\", \"dutch\", \"nl\", \"Nederland\");\n    root.addLanguage(\"middle dutch\", \"afr\", \"afrikaans\", \"af\", \"Nederland\");\n ",
            "author": "Karl Wettin",
            "id": "comment-12478712"
        },
        {
            "date": "2007-03-08T06:33:20+0000",
            "content": "Added support for all modern large germanic, balto-slavic, latin and some other languages. I'll add the complete indo-iranian tree soon.\n\nThe test case will gather and classify random pages from wikipedia in the target language. Only on too small articles (again, I say that 160 charaters, one paragraph, is required) or them with very mixed language (article talking about something like a discography of a non native band) is there a false positive.\n\nDocuments with mixed languages could probably be handled at paragraph level, reporting back as the document is in language A, but contains paragraphs (quotes, et c) in language B and C.\n\nSupported languages(35):\n\nswedish\ndanish\nnorwegian\nislandic\nfaroese\n\ndutch\nafrikaans\nfrisian\n\nlow german\ngerman\n\nenglish\n\nlatvian\nlithuanian\n\nrussian\nukranian\nbelarussian\n\nczech\nslovak\npolish\n\nbosnian\ncroatian\nmacedonian\nbulgarian\nslovenian\nserbian\n\nitalian\nspanish\nfrench\nportugese\n\narmenian\n\ngreek\n\nhungarian\nfinnish\nestonian\n\nmodern persian (farsi)\n\nThere are some languages in the training set that due to low representation in Wikipedia also have problems with false positive classifications: \n\nFaroese with its 80 paragraphs (mean is 600) get some 60% false positives. \n\nMacedonian with its 150 paragraphs get 45% false positives, most often Serbian.\n\nCroatian is often confused with Bosnian.\n\nAlso, some of these southern slavic languages can use either cyrillic or latin alphabet, and this is something I should consider a bit. \n\nAll other languages are detected without any problems.\n\nOne simple way to get the false positives better here is to manually check the training data. There is some <!-- html comments --> here and there. Hopefully they are washed away with the feature selection.\n\nPreparing the training data (download data from Wikipedia, parse, tokenize) for all them languages takes just a few minutes on my dual core, but the token feature selection (selecting the 7000 most prominent tokens out of 65000, in 20000 paragraphs of text) takes 90 minutes and consumes something like 700MB heap. \n\nOnce the arff-file is create the classifier takes 10 minutes to compile (the support vectors) and once done it consumes not more than a fistful of MB. It could probably be serialized and dumped to disk for faster loading at startup time.\n\nThe time it takes to classify a document will of course depend on its size. Wikipedia articles average out on about 500ms.\n\nFor a really speedy classification of very large texts one could switch to REPtree instead of SVM. It does the job 95% as well (with a big enough text), but at 1% of the time or 2ms per classification. I still focus on 160 charaters long paragraphs though.\n\nNext step is optimizations. The current training data for the 35 languages is 25000 instances and 7000 attributes. That is an instane amount of data. Way too much.\n\nI think the CPU performance and RAM requirements can be optimized quite some by simply make the number of training instances (paragraphs) a bit more even. 500 per language. It is quite gaussian right now, and that is wrong. Also, by selecting 100*language attributes (tokens) for use in the SVM rathern than 200 as now does not do much to the classification quality, but would make the speed in creating training data and building the classifier to sqrt(what it is now).\n\nFor now I run on my 6 languages. It takes just a minute to download data from Wikipedia, tokenize and build the classifier. And classification time is about 100ms on average for a Wikipedia article.\n\n ",
            "author": "Karl Wettin",
            "id": "comment-12479239"
        },
        {
            "date": "2007-11-08T18:15:37+0000",
            "content": "Just out of curiosity which version of Weka are you using...\n\nI ask because in newer versions of weka...\n\nIn the LanguageClassifier.java source file we have the following problem...\n\nstringToWordVector.setDelimiters(\";\"); <-- setDelimiters method has disappeared\nstringToWordVector.setNormalizeDocLength(new SelectedTag(StringToWordVector.FILTER_NORMALIZE_ALL, StringToWordVector.TAGS_FILTER)); <-- this works\n\nand in older versions of weka...\n\nIn the LanguageClassifier.java source file we have the following problem...\n\nstringToWordVector.setDelimiters(\";\"); <-- this now works \nstringToWordVector.setNormalizeDocLength(new SelectedTag(StringToWordVector.FILTER_NORMALIZE_ALL, StringToWordVector.TAGS_FILTER)); <-- older versions of the API simply expect a boolean value rather than a SelectedTag object as a param)\n\nPlease advise \n\nCheers,\n\nPeter ",
            "author": "Peter Taylor",
            "id": "comment-12541094"
        },
        {
            "date": "2007-11-08T19:15:50+0000",
            "content": "Uh never mind  I have poked around and I am guessing you are using version 3.5.3 or thereabouts.\n ",
            "author": "Peter Taylor",
            "id": "comment-12541115"
        },
        {
            "date": "2007-11-09T01:54:32+0000",
            "content": "Peter Taylor - 08/Nov/07 10:15 AM\n> Just out of curiosity which version of Weka are you using...\n\nYou can also check out all Lucene-no-deps baysian LUCENE-1039, spell checker in the test case.\n\nI have 600 instances per class, and 25 classes. Get great results with ^3-4, 3- and 3-5$ ngrams of context sensitive 2-5 word sentances . Using a LUCENE-550 index is 4-5 times faster (100-300ms) than a RAMDirectory (500-1600) for classification. ",
            "author": "Karl Wettin",
            "id": "comment-12541202"
        },
        {
            "date": "2008-04-12T18:19:58+0000",
            "content": "too much dependencies and stuff. there will be something better in mahout in the future. ",
            "author": "Karl Wettin",
            "id": "comment-12588298"
        },
        {
            "date": "2010-01-24T19:35:22+0000",
            "content": "I think Nutch (and eventually Mahout) plan to use Tika for charset/mime-type/language detection going forward.\n\nI've filed an issue TIKA-369 about improving the current Tika code, which is a simplification of the Nutch code. While using this on lots of docs, there were performance issues. And for small chunks of text the quality isn't very good.\n\nIt would be interesting if Karl could comment on the approach Ted Dunning took (many years ago - 1994 ) versus what he did. ",
            "author": "Ken Krugler",
            "id": "comment-12804285"
        },
        {
            "date": "2010-01-26T13:34:20+0000",
            "content": "Hi Ken,\n\nit's hard for me to compare. I'll rant a bit about my experience from language detection though. \n\nI still haven't found a one strategy that works good on any text: a user query, a sentence, a paragraph or a complete document. 1-5 grams using SVM or NB works pretty good for them all but you really need to train it with the same sort of data you want to classify. Even when training with a mix of text lengths it tend to perform a lot worse than if you had one classifier for each data type. And you still probably want to twiddle with the classifier knobs to make it work great with the data you are classifying and training with.\n\nIn some cases I've used 1-10 grams and other times I've used 2-4 grams. Sometimes I've used SVM and other times I've used a simple desiction tree.\n\nTo sum it up, to achieve good quality I've always had to  build a classifier for that specific use case. Weka has a great test suite for figuring out what to use. Set it up, press play and return one week later to find out what to use. ",
            "author": "Karl Wettin",
            "id": "comment-12805027"
        },
        {
            "date": "2011-06-27T07:26:43+0000",
            "content": "Reviving this issue - would be interesting to arrive at a proposal whether this code could replace Tika's existing languageIdentifier. We still need to solve the case with small texts. I'm thinking of a hybrid solution where we fallback to a dictionary based detector for small texts, i.e. based on Ooo dictionaries. ",
            "author": "Jan H\u00f8ydahl",
            "id": "comment-13055374"
        }
    ]
}