{
    "id": "SOLR-11078",
    "title": "Solr query performance degradation since Solr 6.4.2",
    "details": {
        "labels": "",
        "priority": "Major",
        "components": [
            "search",
            "Server"
        ],
        "type": "Bug",
        "fix_versions": [],
        "affect_versions": "6.6,                                            7.1",
        "resolution": "Won't Fix",
        "status": "Resolved"
    },
    "description": "We are currently running 2 separate Solr servers - refer to screenshots:\n\n\tzasolrm02 is running on Solr 6.4.2\n\tzasolrm03 is running on Solr 6.6.0\n\n\n\nBoth servers have the same OS / JVM configuration and are using their own indexes. We round-robin load-balance through our Tomcats and notice that Since Solr 6.4.2 performance has dropped. We have two indices per server \"searchsuggestions\" and \"tradesearch\". There is a noticeable drop in performance since Solr 6.4.2.\n\nI am not sure if this is perhaps related to metric collation or other underlying changes. I am not sure if other high transaction users have noticed similar issues.\n\n\n1) zasolrm03 (6.6.0) is almost twice as slow on the tradesearch index:\n\n\n2) This is also visible in the searchsuggestion index:\n\n\n3) The Tradesearch index shows the biggest difference:",
    "attachments": {
        "solr-6-4-2-schema.xml": "https://issues.apache.org/jira/secure/attachment/12895351/solr-6-4-2-schema.xml",
        "jvm-stats.png": "https://issues.apache.org/jira/secure/attachment/12877242/jvm-stats.png",
        "solr-sample-warning-log.txt": "https://issues.apache.org/jira/secure/attachment/12877243/solr-sample-warning-log.txt",
        "solr-7-1-0-solrconfig.xml": "https://issues.apache.org/jira/secure/attachment/12895348/solr-7-1-0-solrconfig.xml",
        "screenshot-2.png": "https://issues.apache.org/jira/secure/attachment/12877241/screenshot-2.png",
        "solr-71-vs-64.png": "https://issues.apache.org/jira/secure/attachment/12895593/solr-71-vs-64.png",
        "screenshot-3.png": "https://issues.apache.org/jira/secure/attachment/12896346/screenshot-3.png",
        "image-2018-11-14-19-00-39-395.png": "https://issues.apache.org/jira/secure/attachment/12948186/image-2018-11-14-19-00-39-395.png",
        "solr-6-4-2-solrconfig.xml": "https://issues.apache.org/jira/secure/attachment/12895350/solr-6-4-2-solrconfig.xml",
        "screenshot-1.png": "https://issues.apache.org/jira/secure/attachment/12877240/screenshot-1.png",
        "compare-6.4.2-6.6.0.png": "https://issues.apache.org/jira/secure/attachment/12877239/compare-6.4.2-6.6.0.png",
        "solr-7-1-0-managed-schema": "https://issues.apache.org/jira/secure/attachment/12895349/solr-7-1-0-managed-schema",
        "schema.xml": "https://issues.apache.org/jira/secure/attachment/12877246/schema.xml",
        "core-admin-tradesearch.png": "https://issues.apache.org/jira/secure/attachment/12877244/core-admin-tradesearch.png",
        "solrconfig.xml": "https://issues.apache.org/jira/secure/attachment/12877245/solrconfig.xml",
        "solr.in.sh": "https://issues.apache.org/jira/secure/attachment/12895347/solr.in.sh",
        "image-2018-11-14-19-02-20-216.png": "https://issues.apache.org/jira/secure/attachment/12948187/image-2018-11-14-19-02-20-216.png"
    },
    "issue_links": {},
    "comments": [
        {
            "date": "2017-07-14T06:41:34+0000",
            "content": "Sample of warnings in log file ",
            "author": "bidorbuy",
            "id": "comment-16086934"
        },
        {
            "date": "2017-07-14T06:43:58+0000",
            "content": "Schema and solrconfig of 6.6.0 instance (is identical to our 6.4.2 instance with the difference of the luceneMatchVersion ",
            "author": "bidorbuy",
            "id": "comment-16086935"
        },
        {
            "date": "2017-11-02T05:52:53+0000",
            "content": "We have 3 identical production servers. Two are running Solr 6.4.2 where the schema is still using Trie* fields. The 3rd server where we have the performance degradation running any version of Solr since 6.4.2 has now been upgraded to Solr 7.1.0 where Trie*-fields have been changed to *Point-fields. Index has been rebuild and Solr performance is worse compared to Solr 6.4.2.\n\nAll servers are running:\n\n\t10 GB RAM, 4 CPUs\n\tCentOS 7.3.1611\n\tJava HotSpot(TM) 64-Bit Server VM (build 25.121-b13, mixed mode)\n\tSolr Heap -Xms/Xmx is set to 4GB. GC tuning as per attached solr.in.sh (the settings are the same between 6.4.2 and 7.1.0)\n\tTwo Solr indices: tradesearch (5.5m documents and 3,4GB size) and searchsuggestions (2.7m documents and 700MB size)\n\n\n\nSwitching Solr 7.1.0 into production load:\n\n\tLoad average (via top) shot to 19 and after a few minutes \"settled\" at 12 (on 6.4.2 it is about 2.2 - 4)\n\tAverage query time is about 230ms - this is 4 times slower compared to 6.4.2 (on 6.4.2 it is about 50ms)\n\tA specific query (we know it is generally slow) runs between 8-10 seconds (on 6.4.2 it would that about 1.3 seconds)\n\n\n\nI can switch 7.1.0 into parallel production tests to collate more data. Any help is appreciated. ",
            "author": "bidorbuy",
            "id": "comment-16235224"
        },
        {
            "date": "2017-11-02T05:53:38+0000",
            "content": "Config files attached to show 7.1.0 vs 6.4.2 configuration ",
            "author": "bidorbuy",
            "id": "comment-16235225"
        },
        {
            "date": "2017-11-02T08:09:24+0000",
            "content": "We have observed it too, and immediately went back to Trie* fields! The difference is huge, one of our collections dropped from many hundreds (~600 to 800) QPS to a mere handful.\n\n7.1.0 is fine, and faster than  6.x. Just don't use Point for the time being. ",
            "author": "Markus Jelsma",
            "id": "comment-16235350"
        },
        {
            "date": "2017-11-02T08:15:01+0000",
            "content": "Thank you Markus Jelsma. I am going to revert schemas back to Trie* fields, rebuild indexes and do another test. I am hoping to provide feedback in 24 hours. ",
            "author": "bidorbuy",
            "id": "comment-16235359"
        },
        {
            "date": "2017-11-02T14:30:03+0000",
            "content": "Are your queries searching for exact values, e.g. myNumericField:12345?  Points are designed for range queries, not tuned for single value lookup.  The Trie fields are efficient at single-value lookups because it has a full-precision encoded term for each input.   If you only search by exact value, then try using StrField (or if you must, Trie with precisionStep=0).  If you need both, then an optimally tuned system will include both StrField and Point.  What Solr lacks is typed numeric variants to StrField (which is a convenience; it's not going to stop you from meeting your requirements today).  The deprecated Trie fields played double duty as that, configurable with precisionStep for indexing for efficient ranges.  I suspect there's no such info/advise in the Solr ref guide but I didn't check.\n\nIn Solr's future, it'd be awesome if we could configure logical fields in the schema based on our requirements, and then internally it'd add the appropriate index/disk structures to support it.  Today, we are accustomed to mapping one logical input to potentially many Solr fields (using naming conventions, suffixes) for various use-cases (retrieval, keyword search, sorting, lookup, range-query, variations of keyword search (multi-lingual, or toggled options)). ",
            "author": "David Smiley",
            "id": "comment-16235815"
        },
        {
            "date": "2017-11-02T15:50:12+0000",
            "content": "Possibly dumb question:  Can a term be added to Point fields so they have the full capability that Trie has, or would doing that destroy the advantages that led Lucene to deprecate all other numeric types? ",
            "author": "Shawn Heisey",
            "id": "comment-16235991"
        },
        {
            "date": "2017-11-02T16:08:31+0000",
            "content": "David Smiley Any chance you could add that to the docs? I think that would close this JIRA, no? ",
            "author": "Erick Erickson",
            "id": "comment-16236026"
        },
        {
            "date": "2017-11-02T16:14:44+0000",
            "content": "Seems like deprecation of trie fields may have been premature and we should rethink when to deprecate / remove them given that people are (and will continue to) use them in the 7x line. ",
            "author": "Yonik Seeley",
            "id": "comment-16236036"
        },
        {
            "date": "2017-11-02T17:01:35+0000",
            "content": "Possibly dumb question: Can a term be added to Point fields so they have the full capability that Trie has\n\nNot a dumb question Shawn!  From what I can see in Lucene Field & DefaultIndexingChain classes, it appears it's okay to have a field that both has a terms index and a points index, just as it's okay for it to have other things (docValues, etc.).  So what we might want to do is index full-precision terms in Solr PointField base class so that it has both. Non-range queries would use the terms index. Certain faceting features, like facet.method=enum could then leverage the terms index as well.  I think this is a good idea!  Of course it should be toggle-able.  I'll file an issue if people like this idea.  I wonder how much total overhead there is in adding the terms index.\n\nDavid Smiley Any chance you could add that to the docs? I think that would close this JIRA, no?\n\nDocs: Ooookay.  Lets hear back from bidorbuy or Markus Jelsma on what their queries were like before closing the issue so that we can be sure we know what the cause is. ",
            "author": "David Smiley",
            "id": "comment-16236123"
        },
        {
            "date": "2017-11-02T17:16:21+0000",
            "content": "Hello David, \n\nThe particular index we reverted does range queries, facets, json-facets and value look-ups. Some indexes we haven't reverted use Point for boosting only. Another index we won't move to Point does facets. ",
            "author": "Markus Jelsma",
            "id": "comment-16236150"
        },
        {
            "date": "2017-11-02T17:47:03+0000",
            "content": "So what we might want to do is index full-precision terms in Solr PointField base class so that it has both.\n\nIf it doesn't destroy the advanatages, I like that idea.  That would also make point fields usable as uniqueKey, wouldn't it? ",
            "author": "Shawn Heisey",
            "id": "comment-16236242"
        },
        {
            "date": "2017-11-02T18:09:57+0000",
            "content": "Adding the full-precision terms to increase performance and capability is a good idea, but we do need to think about the situation where somebody has an existing index with a point field that is upgraded to a new release with this capability.  Anything reliant on the new data won't work correctly on that index.  I would hope for any related error messages to not be cryptic, so that it will be clear that they need to reindex. ",
            "author": "Shawn Heisey",
            "id": "comment-16236296"
        },
        {
            "date": "2017-11-02T18:10:40+0000",
            "content": "Adding points and terms to the same field would work, but also hurt indexing throughput and increase disk usage.\n\nMaybe we should update recommendations instead so that id fields would use StrField while true numbers would use point fields? ",
            "author": "Adrien Grand",
            "id": "comment-16236299"
        },
        {
            "date": "2017-11-02T23:12:11+0000",
            "content": ". Some indexes we haven't reverted use Point for boosting only.\n\nYou only need docValues for that (so index should probably be \"false\").   When index=true, point fields are added to a BKD index and trie fields add to a full-text index. ",
            "author": "Yonik Seeley",
            "id": "comment-16236792"
        },
        {
            "date": "2017-11-02T23:16:12+0000",
            "content": "Maybe we should update recommendations instead so that id fields would use StrField while true numbers would use point fields?\n\nThat would break a few things that expect numeric order (faceting tiebreaks, etc).  There's no reason not to just use the trie-field method of manipulating the value such that the lexical order is equal to the numeric order.  Range queries would then also still work and people could choose if the BKD overhead is worth it for better range query performance.  For some usecases with smaller numbers of unique numeric values, just using the postings will still be faster anyway.  ",
            "author": "Yonik Seeley",
            "id": "comment-16236794"
        },
        {
            "date": "2017-11-03T05:24:22+0000",
            "content": "Just some more feedback - we still need to run a few more tests to get an conclusive answer, but on the surface it does look that Point fields degrade performance over Trie fields with precision steps.\n\nOn Solr 6.4.2 we used \"primitive\" fieldTypes without precisionSteps and we also used fieldTypes with precisionSteps - i.e.\n\n<fieldType name=\"int\" class=\"solr.TrieIntField\" precisionStep=\"0\" omitNorms=\"true\" positionIncrementGap=\"0\"/>\n<fieldType name=\"tint\" class=\"solr.TrieIntField\" precisionStep=\"8\" omitNorms=\"true\" positionIncrementGap=\"0\"/>\n\n\n\nWe used precisionSteps=\"8\" in fields where we could have range queries and we used precisionSteps=\"0\" where fields contained an id or enum.\n\nWhen switching to Solr 7.1.0 we migrated those fieldTypes to *Point-definitions - i.e. instead of using \"int\" and \"tint\" we created just one definition using Point:\n\n<fieldType name=\"pint\" class=\"solr.IntPointField\" docValues=\"true\"/>\n\n\n\nLast night we reverted back to the 6.4.2 schema-definition using TrieIntFields with precisionSteps and initial tests looked better. We are now rebuilding the index one more time using Trie-fields with Precision-Step and will run the 7.1.0 Solr server in parallel to the current 6.4.2 in a loadbalanced fashion to get a proper comparison. In preliminary tests it does appear that 7.1.0 using Trie-fields and precision-steps is faster than 7.1.0 with Point-fields.\n\nWe will also revisit our current schema and the way we build queries/facets to perhaps see if we have other issues. ",
            "author": "bidorbuy",
            "id": "comment-16237115"
        },
        {
            "date": "2017-11-03T07:55:32+0000",
            "content": "Adrien Grand could you perhaps point me to Solr documentation where this is explained?\n\nMaybe we should update recommendations instead so that id fields would use StrField while true numbers would use point fields?\n\nI thought that in Java terms it would be more efficient to use solr.TrieIntField (primitive types) over Strings. ",
            "author": "bidorbuy",
            "id": "comment-16237239"
        },
        {
            "date": "2017-11-03T08:18:28+0000",
            "content": "Maybe we should update recommendations instead so that id fields would use StrField while true numbers would use point fields?\n\nbidorbuy I made that comment based on the assumption that there is no such recommendation today. \n\nI thought that in Java terms it would be more efficient to use solr.TrieIntField (primitive types) over Strings.\n\nIn that case the high-level types don't really matter. Both strings and numerics are handled as a byte[] internally for searching, and as a long internally for faceting (we use ordinals to identify strings). The thing here is that trie fields are based on terms, which precompute the result set for every unique term, which makes exact queries fast (my_numeric_field:42) but merging result sets of multiple values expensive (my_numeric_field:[100 TO 10000]) while points do not deduplicate data but organize it in a way that make ranges faster.\n\nThere's no reason not to just use the trie-field method of manipulating the value such that the lexical order is equal to the numeric order.\n\nHaving a StrField variant that would only accepts numbers, use an encoding that preserves order and use numeric doc values sounds good to me as well. We might want to forbid range queries entirely in that case though as they could be very slow.\n ",
            "author": "Adrien Grand",
            "id": "comment-16237257"
        },
        {
            "date": "2017-11-03T08:37:55+0000",
            "content": "Thank you Adrien Grand for the explanation. We have now been running Solr 7.1.0 and Solr 6.4.0 loadbalanced for about an hour of production load and I can confirm that response time on 7.1.0 using TrieFields (i.e. the same schema we use on Solr 6.4.0) is about 10-20% faster on Solr 7.1.0.\n\nAlso interesting to note is that on Solr 6.4.0 the load-average sites at 2.26 (4 cores) and Cpu is at 50-73%. On Solr 7.1.0 load-average is at 1.4 and CPU is around 20-30%.\n\nYou can see this in the graph below (zasolrm03 = Solr 7.1.0 / zasolrm02 = Solr 6.4.0) - weswitched zasolrm03/7.1.0 into the load-balancer at 09:44 - hence the initial warmup spike:\n\n ",
            "author": "bidorbuy",
            "id": "comment-16237277"
        },
        {
            "date": "2017-11-03T13:04:44+0000",
            "content": "@bidorbuy Thanks so much for sharing your real world results, and being willing to try some different configurations.\n\nI think it would be most helpful to us here if we could focus on the same Solr version (say 7.1) and only vary the schema use of field types.  Because of the many references to 6.4.2 in your past comments, I'm not 100% clear if you have found Points vs Trie (with precisionStep>0) shows Points to win on range queries.  Based on what I know, I expect Points to be faster at this task, while also using less memory and disk.  If you are finding to the contrary, perhaps some of your queries are actually doing lookups on these fields sometimes?  Or as Yonik pointed out, perhaps might have extremely low cardinality within the bounds of the range query sometimes (i.e. tight ranges matching few values)?\n\nFor now, I suggest using Trie with precisionStep=0 on fields you only use for lookups (no range queries).  Or use StrField if that suits you; it's almost the same. ",
            "author": "David Smiley",
            "id": "comment-16237574"
        },
        {
            "date": "2017-11-05T04:20:10+0000",
            "content": "Will will switch 7.1 into full production load tonight and monitor. From the stats over the last two days I can confidently say that 7.1 performs better using the same schema we used since 6.4.0. I think this is important, as I did not have the same level of performance on 6.4.2, 6.5.1 and 6.6.0.\n\nOur plan is to upgrade our cluster of servers from 6.4.0 to 7.1.0 using the same schema as we use in 6.4.0. Once we have done this, we will revisit the schema.\n\nMy takeway from your suggestions is that we should change Trie* fields to StrField where we only do lookups and change to *Point fields where we do range-queries.\n\nIs there more documentation available about *Point-types? I could only find Java docs and some info in the solr-user-group but I am unsure what it means from a performance perspective that Point-types do not support FieldCache and as such we need to use doc-values for faceting to be supported.\n\nWe certainly have range queries (as an example price-ranges, or numeric ranges for storage-sizes returned as facets) which would also require faceting.\n\nOne idea we had is to change all non-range fields to StrField (one by one) and measure performance impact and then start switching *Point-fields. I am not sure if there is a better/scientific way to go about this (analysing the query performance is difficult as queries are typically some text-search with filtering/faceting - so not many unique queries where it is easy to show some trends). ",
            "author": "bidorbuy",
            "id": "comment-16239384"
        },
        {
            "date": "2017-11-06T20:53:01+0000",
            "content": "Is there more documentation available about *Point-types?\n\nI'm not sure.  I'll update the ref guide after you take the changes for a whirl to confirm what I expect will happen.\n\nI am unsure what it means from a performance perspective that Point-types do not support FieldCache and as such we need to use doc-values for faceting to be supported.\n\nCurious; can you provide a reference to where you've read that about the FieldCache?  It's right but just wanted to see where that advise is; I didn't notice it in the ref guide.  Any way... I suspect you've already (in 6.x) been using docValues=true on appropriate fields since you didn't mention to the contrary.  So there's no change for you in this respect.  Basically, know that Solr needs fast access to values on a doc/field basis for certain non-search features.  Generally, the ideal way to make that available is to set docValues=true on the field.  Alternatively if you don't, and if the field type supports \"uninversion\" (Trie fields & StrField do, Point fields don't) then Solr will use it's so-called FieldCache which un-inverts the index=true data into memory.  Lets say you weren't using docValues at all and now you do.  The net perceived change is\n\n\tsmaller java heap requirements; this data is accessed off-heap in memory mapped IO instead.  So you still need same RAM roughly but Java GC can have an easier time.\n\tbetter realtime search.  The warmup queries (generally user-configured to run after commit in solrconfig) should be faster to complete if they use faceting, sorting etc. since they won't need to trigger the uninversion of index structures into memory.  If you don't have warmup, then the first user's search query to come along after a commit used to be hit with the uninversion penalty and now it won't (so faster queries at this 99 percentile).\n\tlarger disk requirements to hold the docValues data\n\n\n\nGeneral access performance isn't necessarily better though; in some cases it has been shown to be worse :-/\n\nOne idea we had is to change all non-range fields to StrField (one by one) and measure performance impact and then start switching *Point-fields. I am not sure if there is a better/scientific way to go about this (analysing the query performance is difficult as queries are typically some text-search with filtering/faceting - so not many unique queries where it is easy to show some trends).\n\nBenchmarking/analysis can be a real time sink; I suppose what you should do depends on what you hope to get out of it.  Assuming you hope to not use deprecated Trie fields... then yes moving away from them is one goal.  And getting equal or better performance is another goal.  I doubt you need to get any more precise than that unless you are digging deeper to discover why one of those goals isn't met (gets slower).  As you've indicated switching the \"non-range\" usages to StrField is one step.  My expectation of the result is that it'll be a non-event.  StrField loses the typed ergonomics of Trie but otherwise should be very similar for non-range use.  I wouldn't bother changing one field at a time and measuring in-between... that seems like a lot of time; although if you discover some unexpected bad results then you could do this to help deduce which field & query exhibits the problem.  RE the range fields, yep, them from TrieFields to PointFields (all at once) is the next step.  This one may be interesting; hopefully nothing gets worse.  If it's better than declare success and move on! ",
            "author": "David Smiley",
            "id": "comment-16240871"
        },
        {
            "date": "2017-11-07T04:28:51+0000",
            "content": "Minor correction: Some Point fields can be uninverted to the FieldCache when docValues isn't enabled and even then, not always.  Essentially single value ones can, multi-valued ones can't.  Oddly however, even then it may only work for sorting but not faceting; I'm not certain.  Any way, we recommend docValues=true for these features so it kinda doesn't matter too much when you can get away without it. ",
            "author": "David Smiley",
            "id": "comment-16241467"
        },
        {
            "date": "2017-11-07T06:14:18+0000",
            "content": "Thanks for the detailed responses David Smiley. We have switched 7.1.0 into production about 24 hours ago with full production load and although resource utilisation (compare zasolrm03=7.1.0 vs zasolrm02=6.4.0) is higher, response time on queries and QPS is generally faster/higher:\n\n\nThe above is based on using the 6.4.0 schema with Trie* fields on a 7.1.0 installation. The next step is to rebuild a server running 7.1.0, but then switching to StrFields and *Point-fields as mentioned. This will probably take at least a week before we have results, but I will feed back once I have them. ",
            "author": "bidorbuy",
            "id": "comment-16241563"
        },
        {
            "date": "2017-11-07T10:58:30+0000",
            "content": "To be clear, what is the official recommendation going to be?\n\nI have numbers and, intuitively, put them a type representing a number, not a string type. No new user will put numbers in strings. But new users using Point have a good change of a very bad performing search engine.\n\nAlso, if we put numbers in string (docValues=true), can we still use them a numbers in function queries? ",
            "author": "Markus Jelsma",
            "id": "comment-16241830"
        },
        {
            "date": "2017-11-07T14:12:51+0000",
            "content": "To be clear, what is the official recommendation going to be?\n\nI'm not going to sugar coat the fact that we have a shortcoming here.  Perhaps, for the moment, there really is no change in recommendation since many users for various reasons simply won't notice this deficiency with Point fields.  This  becomes more about a performance tip/warning.  It could go in the ref guide... and retroactively we could adjust the upgrade notes in CHANGES.txt for 7.0.  I propose this note in CHANGES.txt for 7.0:\n\n\"All Trie* numeric and date field types have been deprecated in favor of *Point field types.  Point field types are better at range queries (speed, memory, disk), however simple field:value queries underperform relative to Trie.  Either accept this, or continue to use Trie fields, or use StrField. This shortcoming may be addressed in a future release.\"\n\nSimilar language cold be added to the ref guide.  And it can be added to the next release announcement text so that people notice.  Does this sound good?  \"good\" not being you like this newfound revelation of course \n\nAlso, if we put numbers in string (docValues=true), can we still use them a numbers in function queries?\n\nNo. ",
            "author": "David Smiley",
            "id": "comment-16242068"
        },
        {
            "date": "2017-11-07T14:28:56+0000",
            "content": "My experience about the CHANGES.TXT (and I typically read them in detail and look at referenced JIRA tasks where I feel that a change could impact us) was that the Trie* change was very vaguely documented - i.e. for me I had:\n\nAll Trie* numeric and date field types have been deprecated in favor of *Point field types.\n\nI struggled finding any reference to what I need to do and what the possible consequences will be. I am not sure if other users would bother changing schemas or adjusting LUCENE_VERSION, but for me I could literally only throw Solr 7.1 against production to see what happens.\n\nSeeing that Solr 8.0 seems to get rid of Trie* fields, I do think it would be important for adopters / new users to fully understand the impact. Perhaps most users are not Java guys (the thought of changing a primitive integer to a StrField still somehow makes me feel a bit awkward). ",
            "author": "bidorbuy",
            "id": "comment-16242096"
        },
        {
            "date": "2017-11-07T14:42:59+0000",
            "content": "however simple field:value queries underperform relative to Trie\n\nThis also has implications for faceting and facet refinement (which look up a whole series of field:value)\nI wonder what the difference is for TermsQuery vs PointInSetQuery... that would be used in fq=field:(val1 val2 val3 val4 ...) type scenarios as well as graph/join queries. ",
            "author": "Yonik Seeley",
            "id": "comment-16242115"
        },
        {
            "date": "2017-12-05T22:32:58+0000",
            "content": "Adrien Grand as the RM for 7.2, do you think we could get in a note here to CHANGES.txt and/or the ref guide?  If not at the very least we cold add a notice/warning to the release notes.  I guess the ref-guide change isn't a blocker for the release artifacts since it's released separately?\n\nI suggest in CHANGES.txt I append further information to the first bullet to the \"Upgrading from Solr 6.x\" section under 7.0.  It's the same language I suggested a few comments ago but I'll repeat:\n\nAll Trie* numeric and date field types have been deprecated in favor of *Point field types. Point field types are better at range queries (speed, memory, disk), however simple field:value queries underperform relative to Trie. Either accept this, or continue to use Trie fields, or use StrField. This shortcoming may be addressed in a future release.\n\nI could repeat this in the ref guide, field-types-included-with-solr.adoc\n\nWhat do you think of the wording Yonik Seeley? ",
            "author": "David Smiley",
            "id": "comment-16279297"
        },
        {
            "date": "2017-12-05T22:46:25+0000",
            "content": "I would either leave out the \"or use StrField\", as it's not a substitute for a numeric field in any general sense. ",
            "author": "Yonik Seeley",
            "id": "comment-16279312"
        },
        {
            "date": "2017-12-06T16:23:55+0000",
            "content": "Commit d84c92ed113721247938bb88680e01c888b65a77 in lucene-solr's branch refs/heads/master from David Smiley\n[ https://git-wip-us.apache.org/repos/asf?p=lucene-solr.git;h=d84c92e ]\n\nSOLR-11078: Add note about the trade-off between Point and Trie fields. ",
            "author": "ASF subversion and git services",
            "id": "comment-16280414"
        },
        {
            "date": "2017-12-06T16:25:36+0000",
            "content": "Commit 292b30e697fedcc304981fe00be2537f071cb1e1 in lucene-solr's branch refs/heads/branch_7x from David Smiley\n[ https://git-wip-us.apache.org/repos/asf?p=lucene-solr.git;h=292b30e ]\n\nSOLR-11078: Add note about the trade-off between Point and Trie fields.\n\n(cherry picked from commit d84c92e) ",
            "author": "ASF subversion and git services",
            "id": "comment-16280417"
        },
        {
            "date": "2017-12-06T16:26:36+0000",
            "content": "Commit 12cd2a4352f4851abd88c7e1db7db5a0bd92aaa9 in lucene-solr's branch refs/heads/branch_7_2 from David Smiley\n[ https://git-wip-us.apache.org/repos/asf?p=lucene-solr.git;h=12cd2a4 ]\n\nSOLR-11078: Add note about the trade-off between Point and Trie fields.\n\n(cherry picked from commit 292b30e) ",
            "author": "ASF subversion and git services",
            "id": "comment-16280422"
        },
        {
            "date": "2017-12-06T16:40:21+0000",
            "content": "I would either leave out the \"or use StrField\", as it's not a substitute for a numeric field in any general sense.\n\nTo me this was the most important part of the note. When exact queries are performed on a numeric field, this is very often because this field is more of an identifier than a quantity. Users used a number probably because it was a number too in their MySQL database or in theirJava object, but they do not really care about the ordering and would be equally happy with a string. ",
            "author": "Adrien Grand",
            "id": "comment-16280457"
        },
        {
            "date": "2017-12-06T20:04:12+0000",
            "content": "I agree with Yonik, Strings are no substitute for numbers in some or many cases. We have numeric fields that we use for exact queries, ranges and in some cases arithmetic in boosts.\n\nIt would be bad if in the future, with Trie* definitively gone, we would have to index the same value as Point, and as String.\n\nWe know about this, novice users don't.  ",
            "author": "Markus Jelsma",
            "id": "comment-16280813"
        },
        {
            "date": "2018-02-20T06:56:56+0000",
            "content": "Do we know why the point fields are less performant when it comes to simple field:value queries?\u00a0Following this thread,\u00a0it seems that the point-fields are using some sort of KD-trees\u00a0and trie-fields use tries. So at a theoretical level, why are the point fields not performing in simple field:value queries, but doing great on the range side? (I did try to read some stuff on KD trees but could not gather much. Hence I am hoping to avoid reading more docs and code myself if someone more knowledgeable than me can share this part).\n\n\u00a0\n\nAlso, when trie-fields were first deprecated in favor of point-fields, what was the thought process at that time? I am just curious to know the initial chain of thought behind point-fields. So any Jira link etc would also be good to link with this issue. It would be good to\u00a0link\u00a0any performance tests done at that time and perhaps re-visit them? ",
            "author": "Sachin Goyal",
            "id": "comment-16369768"
        },
        {
            "date": "2018-02-20T07:50:28+0000",
            "content": "Also, when trie-fields were first deprecated in favor of point-fields, what was the thought process at that time?\n\nSolr has merely been reacting to realities forced on it by changes in Lucene.\n\nPoints were introduced to Lucene in the 6.x timeframe, I think it was relatively early.  Shortly afterwards, Lucene deprecated the legacy numeric code used by virtually every Lucene-based software in the world up through early 6.x, including Solr.  That legacy numeric code is completely gone from Lucene 7.0 and later.\n\nSolr was a little bit slow to add support for point field types.  It didn't happen until late in the 6.x series.\n\nIn 7.0, Solr incorporated the legacy numeric code from Lucene necessary for Trie fields to function, because without it, Solr 7.0 would not have been able to read most existing 6.x indexes.  This is a temporary band-aid, which is expected to be removed in 8.0.  I'm really hoping that we can restore the performance of numeric field searching in some way before 8.0 comes out.  I do not know if the issues with Points can be fixed without reducing the performance of the things Points are good at. ",
            "author": "Shawn Heisey",
            "id": "comment-16369787"
        },
        {
            "date": "2018-02-20T10:05:54+0000",
            "content": "Do we know why the point fields are less performant when it comes to simple field:value queries?\nYes. You are right that both the terms dictionary and the BKD tree have a tree-like structure. The important difference is that terms store postings lists on the leaves, while BKD trees store (blocks of) (docId, value) pairs. If you run a query on a single field, BKD trees need to sort the list of matching doc ids in order to return an iterator. If the query matches few documents, this doesn't matter, but if it matches many documents it does. Also postings include skip data, so if your query is intersected with another query, then Lucene will be able skip sections of the postings that don't matter. BKD trees don't have any way to make query execution more efficient with intersections, even though IndexOrDocValueQuery mitigates the issue.\n\nTo be clear, single-value queries are slower with BKD trees, but only if this query matches many documents. If it matches few documents, it's fast in both cases.\nPoints were introduced to Lucene in the 6.x timeframe, I think it was relatively early.\nPoints were introduced in Lucene 6.0, it was the main release highlight with the switch to BM25 by default. They made high-cardinality numeric fields much better: often 30% faster range queries, 70% faster indexing, 60% less disk usage and 80% less memory usage.\nSolr has merely been reacting to realities forced on it by changes in Lucene.\nSolr could have stayed on legacy numerics, this is something that can be supported on top of Lucene, it doesn't need to be in Lucene. But in this particular case, I do think that the right decision was made to deprecate trie fields and recommend users to switch to points instead. I hope that Solr will soon stop using other legacy Lucene APIs like SlowCompositeReaderWrapper. This might make faceting a bit slower in some cases, but this would also make Solr perform much better in the NRT case.\n\nIn my opinion we should just update documentation to say that id/enum fields that never need ranges should use StrField instead. I know it's not popular (see above comments) but in that case then let's just fill the gap with a new field, something like NumericIdField, that works exactly like StrField but uses an encoding that preserves the numeric order.\nI do not know if the issues with Points can be fixed without reducing the performance of the things Points are good at.\nOne easy way to do this would be to index both with points and terms. But in my opinion this would be wasteful, it's easier to make the decision when designing the schema of whether a field stores quantities/measures or ids/enums.\n\nAs a final note, some of these slow queries could be mitigated with IndexOrDocValueQuery, maybe we should add support for it in Solr's point fields? It allows to use doc values rather than points when the query on the BKD tree is not the one that would lead iteration. ",
            "author": "Adrien Grand",
            "id": "comment-16369875"
        },
        {
            "date": "2018-02-20T14:48:48+0000",
            "content": "Actually Tomas just let me know that Solr already uses IndexOrDocValuesQuery, so there is nothing more to do. ",
            "author": "Adrien Grand",
            "id": "comment-16370116"
        },
        {
            "date": "2018-02-20T16:33:29+0000",
            "content": "If there are things we can do in Solr to improve the situation, we should absolutely be doing them.  I personally do not know enough about Lucene code writing to do anything.  If I did know enough, I would be doing everything I could to improve it. ",
            "author": "Shawn Heisey",
            "id": "comment-16370239"
        },
        {
            "date": "2018-02-20T19:08:40+0000",
            "content": "Thanks Adrien Grand for a good detailed reply.\n\nSo it seems that point-fields are great for range-searches and few-document-matching single-field queries.\n\nWhat about faceting/pivoting and what about sorting? If there are some insights into their performance with point-fields, that would be great to know as well.\n\n\u00a0\n\nAlso, do we know Lucene's response for this performance hit? If Solr is just catching up to Lucene's deprecation/adoption of types, then I would imagine them\u00a0knowing this already and maybe having some fix or a recommendation?\n\n\u00a0 ",
            "author": "Sachin Goyal",
            "id": "comment-16370472"
        },
        {
            "date": "2018-02-20T20:18:38+0000",
            "content": "What about faceting/pivoting and what about sorting? If there are some insights into their performance with point-fields, that would be great to know as well.\n\nFor these operations, the field should have docValues defined for best performance.  This would be the case for any field type \u2013 string, Trie, Point, etc.  At the moment, it's not possible to enable docValues on a TextField type (the one used in Solr for tokenized terms).  But this is generally not a problem, as that type of field is normally not very useful for facets/groups/sorts.\n\nAlso, do we know Lucene's response for this performance hit?\n\nAdrien Grand probably qualifies as somebody who can comment here.  And I think what he wrote does serve as a response, but I would like more detail.  I'm not really familiar with how Solr actually leverages Lucene for its field types.  I have VERY little understanding of the Lucene API \u2013 have never actually written a program that uses Lucene.  I'm not opposed to learning, but every time I have started descending the rabbit hole, I have found myself getting lost and unable to figure out how it all fits together.\n\nsomething like NumericIdField, that works exactly like StrField but uses an encoding that preserves the numeric order.\n\nAdrien, I couldn't find any info on this. Can you point me at some relevant javadocs, or other documentation?  Hopefully it's not the old \"zero-padded string\" idea, which as far as I knew, wasn't used any more. ",
            "author": "Shawn Heisey",
            "id": "comment-16370568"
        },
        {
            "date": "2018-02-20T21:32:40+0000",
            "content": "I'd use the good old numericfield encoding. Or create a bytesref with the raw bytes of the long, just applying the usual bitmagic to make negatives sort correct. For floats do the other bitshifts from NunericUtils. There are methods for it. ",
            "author": "Uwe Schindler",
            "id": "comment-16370625"
        },
        {
            "date": "2018-03-08T05:05:12+0000",
            "content": "This degradation in query performance can be a big problem with Solr 7 adoption.\n\nEspecially the new-comers to Solr will not know about this and will straight away migrate to other search-engines.\n\n\tWould be it good to put back trie-fields in 7.3 release until issue with point-fields is fixed? Point-fields should not be made a default until they are atleast as performant as trie-fields?\n\tSecondly, we should link this ticket to the corresponding ticket in Lucene and create one in Lucene if there is none. Because AFAIK, there is nothing much that can be done from the Solr side to fix the point fields.\n\n\n\n\u00a0 ",
            "author": "Sachin Goyal",
            "id": "comment-16390763"
        },
        {
            "date": "2018-03-08T06:16:12+0000",
            "content": "Would be it good to put back trie-fields in 7.3 release until issue with point-fields is fixed? \n\nTrie fields are already slated to remain available for all 7.x versions.  You can still use them even now.  A deprecation warning is logged when they are used, but it is not an error.\n\nI'd use the good old numericfield encoding.\n\nUwe Schindler, I have no idea what's involved to do this.  Are there already fieldType classes in Solr that do this?  Or would some need to be created?  If it needs to be created, is there something available that shows how to code it, so we can create new types for Solr? ",
            "author": "Shawn Heisey",
            "id": "comment-16390798"
        },
        {
            "date": "2018-03-09T04:26:14+0000",
            "content": "I filed SOLR-12074 (linked to this one).  At this point I think we're waiting for someone to have the time/motivation to add numeric typed equivalents to StrField.  I signed up to mentor some junior developers (students?) for an event that occurs in about a month so perhaps this may happen then.  We'll see. ",
            "author": "David Smiley",
            "id": "comment-16392390"
        },
        {
            "date": "2018-08-08T20:24:57+0000",
            "content": "Closing as Won't Fix \u2013 that's the effective reality.  It can be re-opened if appropriate. ",
            "author": "David Smiley",
            "id": "comment-16573813"
        },
        {
            "date": "2018-11-14T16:50:08+0000",
            "content": "Adrien Grand or Michael McCandless are you aware of any Lucene benchmarking we have (or had done once and reported somewhere) on the performance difference for exact lookup queries on a Points field compared to the Trie fields? ",
            "author": "David Smiley",
            "id": "comment-16686856"
        },
        {
            "date": "2018-11-14T17:04:45+0000",
            "content": "I'm not aware of such benchmarks, but I've had a couple Elasticsearch users who reported slowdowns after we changed numeric fields to be backed by points rather than the inverted index. If your exact query doesn't match many documents, performance would be mostly the same, but otherwise the fact that points need to collect all doc IDs into an array and sort them when the inverted index has a ready-to-use DISI thanks to postings makes them slower. ",
            "author": "Adrien Grand",
            "id": "comment-16686873"
        },
        {
            "date": "2018-11-14T17:44:30+0000",
            "content": "Hi all,\n\nex CTO from bidorbuy here. I had planned to migrate to 7.5 before I am leaving the company end of November, but other priorities took over.\n\nCuriosity still got the better of me and over the last week I pulled up three 7.5. instances running on 8 cores, 10GB RAM (the Solr- and JVM tuning is unchanged from the 2017 configs I attached in the original post).\n\nI apologise for the lack of depth of the analysis - it is not how I typically work, but instead of not providing a follow-up I thought \"better little than nothing\". I am sure that my successor / team will follow up when they have an in-depth analysis by January 2019.\n\nThe test was done by\u00a0replaying Solr queries from an existing 7.4. Solr install across the 7.5 nodes\u00a0and replayed the same production-load on different schemas using the main-index which consists of 7,5m documents and a size of 4GB:\n\n\tGreen: Now deprecated Trie*-fields (this is what we currently running in production)\n\tOrange: Point*-fields\n\tBlue: StrField\n\n\n\nTrie*-fields (Green or bottom line) still produce overall lowest CPU and memory utilisation. Throughput:\u00a019,5m queries, 21ms avg query time, 7.3sec max query time\n\nPoint*-fields (Orange or middle line) consumed more resources.\u00a0Throughput:\u00a018,6m queries, 35ms avg query time, 10sec max query time\n\nStrField (Blue or top-line) was visibly using more resources. GC was also more frequent.\u00a0Throughput:\u00a017,6m queries, 42ms avg query time, 13sec max query time\n\nAdmittedly, I did not tune JVM (using G1) and I am sure that if I had the time I could have tuned resource utilisation better. I doubt that such tuning would have dramatically improved throughput or query time.\n\nPerhaps I misunderstood this, but I thought Point-field types would outperform Trie*fields in range queries. In my tests I did not notice a dramatic difference for range queries when using Point*fields. I did however notice that some simple field/value queries underperformed when using Point*-fields over Trie*fields.\n\nI know it was mentioned that if Point-fields are not performing we should use StrFields, and maybe I missed a fundamental configuration step, but StrField generally performed worse than Point or Trie fields.\n\nI wish I had more time to analyse queries in more detail and perhaps play with variations in the schema to possibly assist with an improvement in this. As you can see from our schema, it is pretty much \"vanilla\" and I am surprised that other users have not raised issues - in our business (ecommerce) a difference of 14ms in average queries (or a variance of a good 2.7 seconds in poor performing queries) has a dramatic result on performance. Perhaps in other use cases such small variances between field-types do not matter.\n\n\u00a0\n\n\n\nI am unfortunately not going to be able to contribute to this issue any more as I will not have access to the Solr environments.\n\nI would like to thank all Solr contributors for your outstanding work and deep level of knowledge and commitment as well as the helping hand you lend in assisting us with questions, issues and patches. I am grateful to have had the opportunity to use Solr when it started \"becoming mainstream\" as version 3.6 and thank you all for your contributions! All the best ~ Gerd Naschenweng. ",
            "author": "bidorbuy",
            "id": "comment-16686906"
        },
        {
            "date": "2018-11-14T19:01:10+0000",
            "content": "Thanks Gerd; you are welcome!  It's not every day that we get such nice analysis, so I'm appreciative of your efforts too.\n\nI suspect the slower performance on StrField might be because you are using it for all functions (range queries) in addition to lookups, whereas my recommendation is to use StrField only for lookups.  Also it doesn't help matters that the terms are longer (bigger) with a decimal encoding instead of 4-8 bytes that we'd get with SOLR-12074. ",
            "author": "David Smiley",
            "id": "comment-16686997"
        }
    ]
}