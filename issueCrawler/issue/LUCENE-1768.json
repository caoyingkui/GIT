{
    "id": "LUCENE-1768",
    "title": "NumericRange support for new query parser",
    "details": {
        "labels": "",
        "priority": "Major",
        "components": [
            "core/queryparser"
        ],
        "type": "New Feature",
        "fix_versions": [
            "3.4",
            "4.0-ALPHA"
        ],
        "affect_versions": "2.9",
        "resolution": "Fixed",
        "status": "Closed"
    },
    "description": "It would be good to specify some type of \"schema\" for the query parser in future, to automatically create NumericRangeQuery for different numeric types? It would then be possible to index a numeric value (double,float,long,int) using NumericField and then the query parser knows, which type of field this is and so it correctly creates a NumericRangeQuery for strings like \"[1.567..*]\" or \"(1.787..19.5]\".\n\nThere is currently no way to extract if a field is numeric from the index, so the user will have to configure the FieldConfig objects in the ConfigHandler. But if this is done, it will not be that difficult to implement the rest.\n\nThe only difference between the current handling of RangeQuery is then the instantiation of the correct Query type and conversion of the entered numeric values (simple Number.valueOf(...) cast of the user entered numbers). Evenerything else is identical, NumericRangeQuery also supports the MTQ rewrite modes (as it is a MTQ).\n\nAnother thing is a change in Date semantics. There are some strange flags in the current parser that tells it how to handle dates.",
    "attachments": {
        "week5-6.patch": "https://issues.apache.org/jira/secure/attachment/12485080/week5-6.patch",
        "week15_for_trunk.patch": "https://issues.apache.org/jira/secure/attachment/12493546/week15_for_trunk.patch",
        "TestNumericQueryParser-fix.patch": "https://issues.apache.org/jira/secure/attachment/12486391/TestNumericQueryParser-fix.patch",
        "week3.patch": "https://issues.apache.org/jira/secure/attachment/12482321/week3.patch",
        "week-7.patch": "https://issues.apache.org/jira/secure/attachment/12485963/week-7.patch",
        "week1.patch": "https://issues.apache.org/jira/secure/attachment/12480814/week1.patch",
        "week2.patch": "https://issues.apache.org/jira/secure/attachment/12481522/week2.patch",
        "week-14.patch": "https://issues.apache.org/jira/secure/attachment/12491078/week-14.patch",
        "week15_for_lucene_3x.patch": "https://issues.apache.org/jira/secure/attachment/12493547/week15_for_lucene_3x.patch",
        "week4.patch": "https://issues.apache.org/jira/secure/attachment/12483223/week4.patch",
        "week-8.patch": "https://issues.apache.org/jira/secure/attachment/12486797/week-8.patch",
        "week11-13_for_lucene_3x.patch": "https://issues.apache.org/jira/secure/attachment/12490364/week11-13_for_lucene_3x.patch"
    },
    "issue_links": {},
    "comments": [
        {
            "date": "2009-07-31T19:16:59+0000",
            "content": "Uwe, \n\nThanks for creating the jira issue.\n\nCan you add some simple query examples.\nWhat would be the lucene Query objects for those queries, if it was produce by a QP that supported that feature.\n\nAlso elaborate what is the current expect behavior for those queries.\n\nIf you can write a junit with one or 2 indexed docs, \nand a lucene Query that retrives just one of those docs and not the other\nwithout using the queryparser, that would be helpful. ",
            "author": "Luis Alves",
            "id": "comment-12737669"
        },
        {
            "date": "2009-08-02T12:09:10+0000",
            "content": "Luis,\nI will post an example of queries and the constructed Query objects when I am back from holidays (Thursday+). In principle the syntax would be the same like for normal range queries, only that the min/max arguments may be double, float, int, long or dates. You would create instances of NumericRangeQuery from it using one of the static factories for each data type (for dates a conversion to long using Date.getTime() would be done). The datatype must be somehow predefined for the field names using some type of schema (per field).. Open ends use \"*\" and the [], (), {} would define if incl. NumericRangeQuery is a subclass of MultiTermQuery so the rewrite method also applies to this query. For NRQ there is also a config parameter precisionStep which default value is 4, but should be also configureable per-field together with the data type.\n\nExample code for creating the NRQ are in the JavaDocs and there are 2 JUnits in trunk (TestNumericRangeQuery*) showing how it is used. Also the new LIA2 contains a chapter about it. ",
            "author": "Uwe Schindler",
            "id": "comment-12738052"
        },
        {
            "date": "2009-08-06T13:25:38+0000",
            "content": "I think, this should be in 2.9. Any Chance to do this. In my Opinion, it should be not so hard. I will prepare something tomorrow. ",
            "author": "Uwe Schindler",
            "id": "comment-12740051"
        },
        {
            "date": "2009-08-06T19:42:59+0000",
            "content": "I think, this should be in 2.9.\n\nThe standard way in the past was for the app to simply override getRangeQuery() to handle different fields differently.\nThis still seems the most flexible. ",
            "author": "Yonik Seeley",
            "id": "comment-12740222"
        },
        {
            "date": "2009-08-07T01:03:49+0000",
            "content": "You could still do something similar by simply override RangeQueryNodeBuilder.build(QueryNode queryNode), but this is not clean (it is kind of a hack).\n\nA clean implementation would allow the user to configure the field types (which the \"new flexible queryparser\" does).\nI'm new to NumericRange Queries and Rangequeries in general, but here is what I think it should look like.\n\nHere is a seudo java example:\n\n    final String defaultField = \"default\";\n    final String monthField = \"month\";\n    final String hourField = \"hour\";\n    final String distanceField = \"distance\";\n    final String moneyField = \"money\";\n\n    Map<CharSequence, RangeTools.Type> rangeTypes =  new HashMap<CharSequence, RangeTools.Type>();\n    \n    // set a field specific range type per field\n    rangeTypes.put(monthField, new RangeTools.Type(RangeUtils.DATE, DateTools.Resolution.MONTH) );\n    rangeTypes.put(hourField, new RangeUtils.Type(RangeUtils.DATE,  DateTools.Resolution.HOUR) );\n    rangeTypes.put(distanceField, RangeUtils.getType(RangeUtils.NUMERIC,  RangeUtils.NumericType.LONG, NumericUtils.PRECISION_STEP_DEFAULT) );\n    rangeTypes.put(moneyField, RangeUtils.getType(RangeUtils.NUMERIC,  RangeUtils.NumericType.Type.FLOAT, NumericUtils.PRECISION_STEP_DEFAULT) );\n\n    StandardQueryParser qp = new StandardQueryParser();\n\n    // set default range type to Int default precision\n    qp.setDefaultRangeType(RangeUtils.getType(RangeUtils.NUMERIC,  RangeUtils.NumericType.INT, NumericUtils.PRECISION_STEP_DEFAULT));\n\n    // set field range types\n    qp.setRangeTypes(rangeTypes);\n\n   Query q = qp.parser(\" month:[01/01/2004 TO 01/01/2005]  distance:[1000 to 2000] money: [23.50 to 50.99]\");\n\n\n ",
            "author": "Luis Alves",
            "id": "comment-12740340"
        },
        {
            "date": "2009-08-07T14:46:22+0000",
            "content": "It feels like going that route would add much code and complexity.\n\nIf the user already knows how to create a range query in code, it's much more straightforward to just do\n\n\nif (\"money\".equals(field)) return new NumericRangeQuery(field,...)\nelse return super.getRangeQuery(field,...)\n\n ",
            "author": "Yonik Seeley",
            "id": "comment-12740575"
        },
        {
            "date": "2009-08-07T16:08:29+0000",
            "content": "You could still do something similar by simply override RangeQueryNodeBuilder.build(QueryNode queryNode), but this is not clean (it is kind of a hack).\n\nWhat's the cleaner way to do this?  EG could I make my own ParametricRangeQueryNodeProcessor, subclassing the current one in the \"standard.processors\" package, that overrides postProcessNode to do its own conversion? ",
            "author": "Michael McCandless",
            "id": "comment-12740608"
        },
        {
            "date": "2009-08-07T17:34:47+0000",
            "content": "Hi Yonik,\n\nAs I said before you can do that in the RangeQueryNodeBuilder.build(QueryNode queryNode),\nbut it's ugly and this is not what we intended when using the \"new flexible query parser\".\n\nThe \"new flexible query parser\" does not follow the concept of method overwriting has the old one.\nSo solutions that worked in the old queryparser, like overwriting a method, have to be implemented\nusing a programmatic way.\n\nYour approach requires creating a new class, overwrite a method.\nyou still need to create a instance of your QueryParser and is not reusable.\n\nHere is a sample of what your approach is:\n\nClass YonikQueryParser extends QueryParser{\n\n  Query getRangeQuery(field,...) {\n    if (\"money\".equals(field)) return new NumericRangeQuery(field,...)\n    else return super.getRangeQuery(field,...)\n  }\n}\n\n...\n QueryParser yqp = new YonikQueryParser(...);\nyqp.parser(query);\n\n\n\n vs\n\nWhat I am proposing:\n\n\n    Map<CharSequence, RangeTools.Type> rangeTypes =  new HashMap<CharSequence, RangeTools.Type>();\n    \n    rangeTypes.put(\"money\", RangeUtils.getType(RangeUtils.NUMERIC,  RangeUtils.NumericType.Type.FLOAT, NumericUtils.PRECISION_STEP_DEFAULT) );\n\n    StandardQueryParser qp = new StandardQueryParser();\n    qp.setRangeTypes(rangeTypes);\n\n    qp.parser(query);\n\n\n\nThe second approach is programmatic does not require a new class, \nor the overwrite of a method and is reusable by other users, and it's\nbackward compatible, meaning we can integrate this on the current \n\"Flexible query parser\" and deliver this feature on 2.9 without affecting\nany current usecase.\n\nYour approach is not compatible, it does require new class, and is not programmatic,\nIt's not reusable by other users (we can't commit your code to lucene), \nsince fields are hard-coded.\n\nAlso the approach I proposing is very similar to setFieldsBoost setDateResolution,\nalready available on the old QP and the new flexible query parser.\n\nI also want to say, that extending the old QP vs extending the \"New flexible Query Parser\" approaches\nare never going to be similar, they completely different implementations.\n ",
            "author": "Luis Alves",
            "id": "comment-12740643"
        },
        {
            "date": "2009-08-07T18:04:13+0000",
            "content": "It's not reusable by other users (we can't commit your code to lucene)\n\nNeither is your version with rangeTypes.put(\"money\", RangeUtils.getType(RangeUtils.NUMERIC...\nThat's the application specific configuration code and doesn't need (or want) to be committed.\n\nDirectly instantiating the query you want is simple, ultimately configurable, and avoids adding a ton of unnecessary classes or methods that need to be kept in sync with everything that a user may want to do.\n\nIs there a simple way to provide a custom QueryBuilder for range queries (or any other query type?)  I'm sure there must be, but there are so many classes in the new QP,  I'm having a little difficulty finding my way around. ",
            "author": "Yonik Seeley",
            "id": "comment-12740659"
        },
        {
            "date": "2009-08-07T18:17:40+0000",
            "content": "\nWhat's the cleaner way to do this? EG could I make my own ParametricRangeQueryNodeProcessor, subclassing the current one in the \"standard.processors\" package, that overrides postProcessNode to do its own conversion?\n\nFor Yonik simple requirement, you could\n\nOption 1 (more flexible):\n\n\tmake your own ParametricRangeQueryNodeProcessor, subclassing the current, returning NumericQueryNodes where needed\n\tcreate a NumericQueryNode that extends RangeQueryNode (node extra code needed)\n\tcreate a NumericQueryNodeBuilder  that handles NumericQueryNodes, and set the map in  StandardQueryTreeBuilder, ex: setBuilder(NumericQueryNode.class, new NumericQueryNodeBuilder()),. RangeQueryNodes will still be normally handled by the RangeQueryNodeBuilder.\n\n\n\nOption 2, (less flexible):\n\n\tmake your own RangeQueryNodeBuilder subclassing the current(ex: NumericQueryNodeBuilder) , set the map in StandardQueryTreeBuilder, ex: setBuilder(RangeQueryNode.class, new NumericQueryNodeBuilder())\n\n\n\nOption 1, implements the correct usage of the APIs. It's more flexible and \"dirty work\" is done in the processors pipeline.\nOption 2, is not the correct use case for the APIs, requires less code and it will work, but the builder will be performing the tasks the Processor should be doing. ",
            "author": "Luis Alves",
            "id": "comment-12740662"
        },
        {
            "date": "2009-08-07T20:41:03+0000",
            "content": "\nNeither is your version with rangeTypes.put(\"money\", RangeUtils.getType(RangeUtils.NUMERIC...\nThat's the application specific configuration code and doesn't need (or want) to be committed.\nYou are correct, I was describing the use case from the user perspective. \nThat code was a example how to use the API's if we implement them in the future, those API's are not currently available.\n\n\nDirectly instantiating the query you want is simple, ultimately configurable, and avoids adding a ton of unnecessary classes or methods that need to be kept in sync with everything that a user may want to do.\n\nI'm not sure what to say here. So I'll point to the documentation that we currently have:\nYou can read https://issues.apache.org/jira/secure/attachment/12410046/QueryParser_restructure_meetup_june2009_v2.pdf\nand the java docs  for \npackage org.apache.lucene.queryParser.core \nclass org.apache.lucene.queryParser.standard.StandardQueryParser\n\nYou can also look at TestSpanQueryParserSimpleSample junit for another example how the API's can be used,\nin a completely different way.\n\nThe new QueryParser was designed to be extensible,\nallow the implementation of languages extensions or different languages,\nand have reusable components like the processors and builders\n\nWe use SyntaxParsers, Processors and Builders, all are replaceable components at runtime.\nAny user can build it's own pipeline and create new processors, builders, querynodes and integrate them\nwith the existing ones to create the features they require. \n\nSome of the features are:\n\n\tSyntax Tree optimization\n\tSyntax Tree expansion\n\tSyntax Tree validation and error reporting\n\tTokenization and normalization of the query\n\tMakes it easy to create extensions\n\tSupport for translation of error messages\n\tAllows users to plug and play processors and builders, without having to modify lucene code.\n\tAllow lucene users to implement features much faster\n\tAllow users to change default behavior in a easy way without having to modify lucene code.\n\n\n\n\nIs there a simple way to provide a custom QueryBuilder for range queries (or any other query type?) I'm sure there must be, but there are so many classes in the new QP, I'm having a little difficulty finding my way around.\n\nBelow is the java code for option 2. It's not the recomend way to use the new queryparser,\nbut is the shortest way to do what you want.\n\n\n  class NumericQueryNodeBuilder extends RangeQueryNodeBuilder {\n    public TermRangeQuery build(QueryNode queryNode) throws QueryNodeException {\n    RangeQueryNode rangeNode = (RangeQueryNode) queryNode;\n      \n    if (rangeNode.getField().toString().equals(\"money\")) {\n      // do whatever you need here with queryNode.\n      return new NumericRangeQuery(field,...)\n    }\n    else {\n        return super.build(queryNode);\n      }\n    }\n  }\n  \n  public void testNewRangeQueryBuilder() throws Exception {    \n    StandardQueryParser qp = new StandardQueryParser();\n    QueryTreeBuilder builder = (QueryTreeBuilder)qp.getQueryBuilder();\n    builder.setBuilder(RangeQueryNode.class, new NumericQueryNodeBuilder());\n    \n    String startDate = getLocalizedDate(2002, 1, 1, false);\n    String endDate = getLocalizedDate(2002, 1, 4, false);    \n    \n    StandardAnalyzer oneStopAnalyzer = new StandardAnalyzer();\n    qp.setAnalyzer(oneStopAnalyzer);\n    \n    Query a = qp.parse(\"date:[\" + startDate + \" TO \" + endDate + \"]\", null);\n    System.out.print(a);\n  }\n\n ",
            "author": "Luis Alves",
            "id": "comment-12740718"
        },
        {
            "date": "2009-08-07T20:56:51+0000",
            "content": "To go back to the idea why I opened the issue (and I think, this is also Mike's intention):\n\nFrom what you see on java-user, where users asking questions about how to use Lucene:\nMost users are not aware of the fact, that they can create Query classes themselves. Most examplecode on the list is just: \"I have such query string and I pass it to lucene and it does not work as exspected.\" It is hard to explain them, that they should simply not use a query parser for their queries and just instantiate the query classes directly. For such users it is even harder to customize this query parser.\n\nMy intention behind is: Make the RangeQueryNodeBuilder somehow configureable like Luis proposed, that you can set the type of a field (what we do not have in Lucene currently). If the type is undefined or explicite set to \"string/term\", create a TermRangeQuery. If it is set to any numeric type, create a NumericRangeQuery.newXxxRange(field,....).\n\nThe same can currently be done by the original Lucene query parser, but only for dates (and it is really a hack using this DateField class). I simply want to extend it that you can say: \"this field is of type 'int' and create automatically the correct range query for it.\" Because the old query parser is now \"deprecated\", I want to do it for the new one. This would also be an intention for new users to throw away the old parser and use the new one, because it can be configured easily to create numeric ranges in addition to term ranges. ",
            "author": "Uwe Schindler",
            "id": "comment-12740728"
        },
        {
            "date": "2009-08-08T09:44:31+0000",
            "content": "Given the complexity of customizing the new QueryParser, and given\nthat numeric fields will likely be commonly used, I think this is an\nimportant issue.  I think we should try to have the new QueryParser\ncleanly produce NumericRangeQuery, in 2.9.\n\nEG expecting a user to do \"option 1\" (the \"clean\", more flexible\noption) is a tall order.  Simple things should be simple...\n\nThe proposed RangeTools seems like a good approach, and I like how it\ncleanly absorbs the Date precisions that the old queryParser also\nsupports.\n\nBut we better get cracking here since 2.9 is real close....!\n\nHere's one side-question, about back compat promises for the new\nQueryParser: we are suggesting the users can start from all the\nbuilding blocks in StandardQueryParser, and override the processors,\ncreate new nodes, builders, etc. with their own.  But this is\npotentially dangerous, in that the next version of Lucene might change\nthings up such that your custom code doesn't work anymore?  It's alot\nlike a core class being subclassed externally, and then change to the\ncore class break those external subclasses.\n\nEG say we had not handled numerics for 2.9, and users go and do\n\"option 2\" (the quick & dirty, but simplest, way to get\nNumericRangeQueries out).  Then, say in 3.1 we implement the proposed\nfix here (\"option 1\").  Suddenly, we've altered what nodes come out of\nthe processor pipeline, because we've created a new NumericRangeQuery\nnode, and so the builders that users had added, for the RangeQuery\nnode, will no loner be invoked.  How are we going to handle\nback-compat here? ",
            "author": "Michael McCandless",
            "id": "comment-12740861"
        },
        {
            "date": "2009-08-10T17:27:33+0000",
            "content": "Personally, I don't think we should deprecate the standard QueryParser yet - and the new one should carry no back compat policy. It needs to be flushed out in a release before we tell users to move to it IMO. Not enough Committers have enough experience with it to promise back compat at this point I think. ",
            "author": "Mark Miller",
            "id": "comment-12741432"
        },
        {
            "date": "2009-08-12T05:19:33+0000",
            "content": "\nThe proposed RangeTools seems like a good approach, and I like how it\ncleanly absorbs the Date precisions that the old queryParser also\nsupports.\n\nYou meant DateTools, right?! I don't see so much difference to use this same approach over the \"option1\". You have a map based from field name to the DateTools.Resolution used for that field. Which is the same feature we want to implement on this JIRA, something you could configure how you are going to resolve the value defined on a range query based on the field name. The only difference is that we are expanding the options the user will have to resolve the values: RangeUtils.NUMERIC, RangeUtils.DATE, RangeUtils.FLOAT, etc...let me know if I missed or missunderstood something on this part.\n\n\nHere's one side-question, about back compat promises for the new\nQueryParser: we are suggesting the users can start from all the\nbuilding blocks in StandardQueryParser, and override the processors,\ncreate new nodes, builders, etc. with their own. But this is\npotentially dangerous, in that the next version of Lucene might change\nthings up such that your custom code doesn't work anymore? It's alot\nlike a core class being subclassed externally, and then change to the\ncore class break those external subclasses.\n\nEG say we had not handled numerics for 2.9, and users go and do\n\"option 2\" (the quick & dirty, but simplest, way to get\nNumericRangeQueries out). Then, say in 3.1 we implement the proposed\nfix here (\"option 1\"). Suddenly, we've altered what nodes come out of\nthe processor pipeline, because we've created a new NumericRangeQuery\nnode, and so the builders that users had added, for the RangeQuery\nnode, will no loner be invoked. How are we going to handle\nback-compat here?\n\nI think it's already happening with the \"old\" QP. It used to output RangeQuery objects and now it outputs TermRangeQuery objects. How is it going to be handled buy users expecting RangeQuery objects?\n\nThe \"new\" QP builder, delegates a query node based on its class to a builder, if there is no builder that knows how to build an object from that class it keeps looking up in the class hierarchy until it finds a builder that knows how to. Query nodes are supposed to be conceptual objects, they just represent some concept X, and ideally anything that fits in this concept should inherit from it, this way the user can create their own specific query nodes with no need to change how they are built (if there is no need for that). What I'm trying to say here is that if I create a node Y which extends X, I don't need to specify a new YBuilder for it, the XBuilder will be used. So, ideally, NumericRangeQueryNode should extends RangeQueryNode, the problem here is that we also need to specify a builder for the NumericRangeNode, and if the user sets a builder for RangeNode it will never be invoked for NumericRangeNode objects. Maybe it shouldn't at all, because if a new builder was specified for NumericRangeNode, it means a new kind of object should be built from it, something the user probably don't know yet, since it's a new kind of node, and his custom code needs to be updated anyway to support it.\n\nHowerver, there is a solution for this kind of back-compat problem (which I don't think it is). In a future release, if a new XRangeQueryNode is created, instead of set\n\n\n luceneBuilderMap.setBuilder(RangeQueryNode.class, new RangeQueryNodeBuilder());\nluceneBuilderMap.setBuilder(XRangeQueryNode.class, new XRangeQueryNodeBuilder());\n\n\n\nWe could do:\n\n\nrangeBuilderMap.setBuilder(RangeQueryNode.class, new RangeQueryNodeBuilder());\nrangeBuilderMap.setBuilder(XRangeQueryNode.class, new XRangeQueryNodeBuilder());\n\n// then\n\nluceneBuilderMap.setBuilder(RangeQueryNode.class, rangeBuilderMap);\n\n\n\nThis way, if the user reset the RangeQueryNode builder to its own builder, it will still be called for XRangeQueryNode and RangeQueryNode objects.\n\nLet me know if there is any question about what I just described.  ",
            "author": "Adriano Crestani",
            "id": "comment-12742223"
        },
        {
            "date": "2009-08-12T06:21:04+0000",
            "content": "I would propose to absorb the RangeTools/Utils and DateTools/Utils (ehat is the correct name???) in one configuration class (just a bigger enumeration with a good name, not Utils/.Tools. e.g. RangeQueryDataType). By that you can define simply the type of a range query: term, numeric-int, numeric-float, numeric-double, date-precision-xxx,... Based on this enumeration, the upper/lower terms are parsed differently and different query objects are created. We just need to list all possible combinations of data types, the user could create: We could make this class extensible, if it is a Lucene Parameter class also supporting the parsing and building: One could simply create a new constant for his specific range type and supply methods to parse and build the query in the constant's implementation (so each constant contains also code to parse/build). I am not sure how to do this with the new parser. I think of the same like the MTQRewriteMethod (final static singletons in MTQ that do the rewrite and can be passed as parameter).\n\nMaybe we can use this also to upgrade the old query parser if it gets not deprecated.\n\nI think it's already happening with the \"old\" QP. It used to output RangeQuery objects and now it outputs TermRangeQuery objects. How is it going to be handled buy users expecting RangeQuery objects?\n\nI was thinking about that, too. But here the API clearly defines, that getRangeQuery() returns a Query object without further specification. So the change was correct from the API/BW side. The change that another object is returned is documented in CHANGES.txt (as far as I know). We have here the same problem: You change the inner class implementations, but the abstract QueryParser's API is stable. The general contract when doing such things is, that you use instanceof checks before you try to cast some abstract return type to something specific, not documented.\n\nYou have the same in various factories also in the very bw-oriented JDK: XML factories create things like SAXParser and so on. If you cast the returned objects to some special implementation class, its your problem, because you remove the abstraction and work with implementations. This happened e.g. from the change between Java 1.4 to 1.5, when the internal SAX parsers were exchanged and their class names changed. A lot of programs broke by that, because the developers casted the objects returned from factories without instanceof checks. ",
            "author": "Uwe Schindler",
            "id": "comment-12742232"
        },
        {
            "date": "2009-08-12T12:08:10+0000",
            "content": "I would propose to absorb the RangeTools/Utils and DateTools/Utils (ehat is the correct name???) in one configuration class \n\n+1\n\nHowerver, there is a solution for this kind of back-compat problem (which I don't think it is).\n\nActually, on reading your explanation I agree it's not really a back compat break, since the user's custom builder for RangeQueryNode would still be invoked, and the core's builder for NumericRangeQuery would handle the newly added numeric range support.  I think this is reasonable. ",
            "author": "Michael McCandless",
            "id": "comment-12742308"
        },
        {
            "date": "2009-08-12T17:15:37+0000",
            "content": "\nI would propose to absorb the RangeTools/Utils and DateTools/Utils (ehat is the correct name???) in one configuration class \n\n+1 this way is easier for the user to config \n\n\nI was thinking about that, too. But here the API clearly defines, that getRangeQuery() returns a Query object without further specification. So the change was correct from the API/BW side. The change that another object is returned is documented in CHANGES.txt (as far as I know). We have here the same problem: You change the inner class implementations, but the abstract QueryParser's API is stable. The general contract when doing such things is, that you use instanceof checks before you try to cast some abstract return type to something specific, not documented.\n\nAgreed, I also think it's fine as long as it's documented ",
            "author": "Adriano Crestani",
            "id": "comment-12742458"
        },
        {
            "date": "2009-08-14T18:14:39+0000",
            "content": "\nI would propose to absorb the RangeTools/Utils and DateTools/Utils (ehat is the correct name???) in one configuration class \n+1 \n\n\nI am not sure how to do this with the new parser. I think of the same like the MTQRewriteMethod (final static singletons in MTQ that do the rewrite and can be passed as parameter). \n\nI think we probably should have TermRangeQueryNode a NumericRangeQueryNode and 2 builders classes that match that, change ParametricRangeQueryNodeProcessor to do the dirty work and create the new TermRangeQueryNode and NumericRangeQueryNode in the correct places, based on the a map with [field name,RangeTools.TYPE] or something similar.\nThe builders should simple and just convert each type to the correct Lucene Object.\n\n\n\twe should rename RangeQueryNode to TermRangeQueryNode (to match lucene name)\n\tcreate the new NumericRangeQueryNode that extends from TermRangeQueryNode\n\tchange the ParametricRangeQueryNodeProcessor to read the configuration passed by the user and create the correct QueryNode objects.\n\tcreate a new NumericRangeQueryNodeBuilder add it to the StandardQueryTreeBuilder mapping.\n\n\n\nI hope this helps ",
            "author": "Luis Alves",
            "id": "comment-12743334"
        },
        {
            "date": "2009-08-14T18:33:18+0000",
            "content": "If the existing query parser is not being deprecated, should this issue be pushed out to 3.0 or 3.1 to give it more time?  In the meantime, people can use the existing override getRangeQuery() method.  2.9 is looking really close. ",
            "author": "Yonik Seeley",
            "id": "comment-12743349"
        },
        {
            "date": "2009-08-18T03:33:03+0000",
            "content": "Finally read through this whole issue.\n\nIf the existing query parser is not being deprecated, should this issue be pushed out to 3.0 or 3.1 to give it more time? In the meantime, people can use the existing override getRangeQuery() method. 2.9 is looking really close.\n\n+1 on pushing this. getRangeQuery() will still be first class.\n\nIt does seem like we should at least do this though:\n\nwe should rename RangeQueryNode to TermRangeQueryNode (to match lucene name) ",
            "author": "Mark Miller",
            "id": "comment-12744347"
        },
        {
            "date": "2009-08-18T05:41:27+0000",
            "content": "\nIf the existing query parser is not being deprecated, should this issue be pushed out to 3.0 or 3.1 to give it more time? In the meantime, people can use the existing override getRangeQuery() method. 2.9 is looking really close.\n+1  ",
            "author": "Luis Alves",
            "id": "comment-12744374"
        },
        {
            "date": "2009-08-18T06:14:15+0000",
            "content": "we should rename RangeQueryNode to TermRangeQueryNode (to match lucene name)\n\nI would not do this. RangeQueryNode is in the syntax tree and the syntax of numeric and term ranges is equal, so the query parser cannot know what type of query it is. When this issue is fixed 3.1, this node will use the configuration of data types for  field names (date, numeric, term) to create the correct range query.\n\n+1 on pushing this. getRangeQuery() will still be first class.\n\nAs noted in my comment on java-dev: We should add a comment in Javadocs, that the old (and also new) query parser do not work automatically with NumericRangeQuery, and that you should override getRangeQuery() and do a case-switch on the field name. I will do this later this day. ",
            "author": "Uwe Schindler",
            "id": "comment-12744383"
        },
        {
            "date": "2009-08-19T23:03:33+0000",
            "content": "\n    we should rename RangeQueryNode to TermRangeQueryNode (to match lucene name)\n\nI would not do this. RangeQueryNode is in the syntax tree and the syntax of numeric and term ranges is equal, so the query parser cannot know what type of query it is. When this issue is fixed 3.1, this node will use the configuration of data types for field names (date, numeric, term) to create the correct range query.\n\nI think it's ok to rename, as far as I know, the standard.parser.SyntaxParser generates ParametricRangeQueryNode from a range query, which has 2 ParametricQueryNode as child. So, the range processor, will need to convert the 2 ParametricQueryNode to the respective type, based on the user config: TermRangeQueryNode (renamed from RangeQueryNode) or NumericRangeQueryNode. ",
            "author": "Adriano Crestani",
            "id": "comment-12745236"
        },
        {
            "date": "2011-03-22T02:38:19+0000",
            "content": "I think this is also a good candidate for GSoC 2011. I will add the labels to it.\n\nAny comments? ",
            "author": "Adriano Crestani",
            "id": "comment-13009522"
        },
        {
            "date": "2011-03-24T23:32:24+0000",
            "content": "Hi Uwe,\n\nAre you willing to mentor this project on GSoC? If you are, I will keep it assigned to you, otherwise let me know so I assign it to me  ",
            "author": "Adriano Crestani",
            "id": "comment-13011007"
        },
        {
            "date": "2011-03-24T23:35:51+0000",
            "content": "I can help! ",
            "author": "Uwe Schindler",
            "id": "comment-13011011"
        },
        {
            "date": "2011-03-28T05:06:51+0000",
            "content": "Hi Uwe and Adriano, \n\nI read the description, javadocs about the numeric support and the new query parser and all the comments here. Let me try to summarize what needs to be done here:\n\nfigure out a way to configure in query parser which fields are numeric, and for each of these fields, the numeric type must also be defined...from the comments, it seems the best way to do this is using a map field>NumericType\n\n-create a NumericQueryNodeProcessor that converts ParametricRangeQueryNode to NumericRangeQueryNode, when its field is a numeric field. This processor should also convert the range string values to numeric values based on the NumericType\n\n-create a NumericRangeQueryNodeBuilder, which will build which will build NumericRangeQuery objects from NumericRangeQueryNode objects\n\n-rename RangeQueryNode to TermRangeQueryNode as it will only be used for string\n\n-create a NumericRangeQueryNode which will be used for any non-string range query\n\n-merge DateTools with a new NumericTools class. Does that make sense? I am not sure if I got everything correctly here.\n\nSome questions below:\n\n\nLuis:\ncreate the new NumericRangeQueryNode that extends from TermRangeQueryNode\n\n-should NumericRangeQueryNode extends TermRangeQueryNode? I don't see any reason for that, since one will hold Number values and the other String values\n\n-I remember the old date query, using strings, used to not only allow range queries, but also term queries (date:2010/10/10), is that correct? Does numeric fields also support this kind of query? I could only fine NumericRangeQuery, but no NumericQuery. If the user enters (age:19) in the query, and \"age\" is a numeric field, should the query parser throw an error saying it's not suppported?\n\nI am planning to create a GSOC proposal for this project, it looks interesting, very cool this new support to numeric in Lucene, I missed that first time I used Lucene, maybe because I was used to regular databases. Also, the query parser uses some design patterns I have been reading about lately, as builders and processors.  ",
            "author": "Vinicius Barros",
            "id": "comment-13011914"
        },
        {
            "date": "2011-03-29T01:50:18+0000",
            "content": "Hi Vinicius,\n\nNice summary! There is a formatting problem, but I think people can understand it.\n\nI had to re-read all the comments, it took sometime, it seems you got all the main points in the summary.\n\n\n-should NumericRangeQueryNode extends TermRangeQueryNode? I don't see any reason for that, since one will hold Number values and the other String values\n\nYou are right, it does not make sense to one extend the other. However, I think they should have a common parent (e.g. <interface> RangeQueryNode), that will have common methods like QueryNode getLowRange().\n\nI will let Uwe answer the other questions, I am curious to know the answers too \n\nThe student proposal period has started, so go ahead and start drafting it  ",
            "author": "Adriano Crestani",
            "id": "comment-13012314"
        },
        {
            "date": "2011-03-29T06:41:16+0000",
            "content": "\n\n\tI remember the old date query, using strings, used to not only allow range queries, but also term queries (date:2010/10/10), is that correct? Does numeric fields also support this kind of query? I could only fine NumericRangeQuery, but no NumericQuery. If the user enters (age:19) in the query, and \"age\" is a numeric field, should the query parser throw an error saying it's not suppported?\n\n\n\nTo create something like a NumericQuery (age:19), the correct and most performant way is to use a NumericRangeQuery with (includeLower==includeUpper)==true and (lower==upper)==value. This query is since Lucene 2.9 always rewritten in the most optimal way (internally it uses a ConstantScore TermQuery using the prefix encoded term. This should also be noted in JavaDocs?\n\nThis is also how Solr's QP works. ",
            "author": "Uwe Schindler",
            "id": "comment-13012352"
        },
        {
            "date": "2011-03-29T06:44:28+0000",
            "content": "\n-merge DateTools with a new NumericTools class. Does that make sense? I am not sure if I got everything correctly here.\n\nDo you mean Lucene'Core's org.apache.lucene.document.DateTools? Because this class is somehow deprecated (not officially) but all those tool classes should not be used together with NRQ. Or does the new QP has its own tools classes? ",
            "author": "Uwe Schindler",
            "id": "comment-13012353"
        },
        {
            "date": "2011-04-03T13:29:47+0000",
            "content": "Hi folks, \n\nI'm PhD student from Croatia willing to participate in GSoC this year. I work in Croatian firm called Superius Ltd on software modelling based on graph database (Neo4J to be concrete). This issue here sounds like a nice addition to Lucene that would help us also make queries that are needed over our business data contained in graph (indexed by Lucene). I was wondering whether is this project still open for GSoC or already assigned to someone?\n\nThank you! ",
            "author": "Nikola Tankovic",
            "id": "comment-13015147"
        },
        {
            "date": "2011-04-04T02:54:29+0000",
            "content": "Hi,\n\nThanks Uwe and Adriano,\n\nI finally finished and submitted my proposal to this project, please, take a look and tell me if I need to change something. My linkid is viniciusbarros\n\nSorry for taking so long to submit it, but just got a free time this weekend, college stuffs are keeping me busy.\n\nUwe: I added to my proposal the idea of enabling the user to enter a query that searches for a single numeric value, example, age:19.\n\nAbout DateTools, I think this can be decided later, in the end it's just a class with some format options the user may choose. Anyway, the numeric already have a pre-defined form to format number in strings before indexing right?! Take a look to what I have defined in my proposal, where I allow the user to specify a Format object, which is used by the query parser to parse the string value entered by the user to Number. Please, let me know if I am not getting something here. ",
            "author": "Vinicius Barros",
            "id": "comment-13015260"
        },
        {
            "date": "2011-04-05T01:45:12+0000",
            "content": "Hi Nikola,\n\nThat's great you are interested in submit a proposal for gsoc this year. Proposal submissions are still open until next 8th (check GSOC timeline at the website). It means you can submit a proposal to any project or even suggest your own project (in this case the community will need to accept it as a gsoc project).\n\nThere is already a proposal for this project, but feel free to submit another one. To raise your chances of getting into gsoc this year, I would suggest you to apply to a project with no candidates yet, check the Lucene projects here: https://issues.apache.org/jira/secure/IssueNavigator.jspa?reset=true&jqlQuery=labels+%3D+lucene-gsoc-11\n\nGood luck!  ",
            "author": "Adriano Crestani",
            "id": "comment-13015712"
        },
        {
            "date": "2011-04-05T01:51:28+0000",
            "content": "Hi Vinicius,\n\nYour proposal looks good, details everything you intend to do and the proposed solutions looks good to me, include what the community has previously discussed.\n\n+1 for adding support for simple numeric queries as age:19 \n\nOne thing I would suggest you to change is to make it clearer the query parser you are intending to change is the contrib query parser, to be more specific the standard implementation. You just mention it only once in the entire proposal! ",
            "author": "Adriano Crestani",
            "id": "comment-13015714"
        },
        {
            "date": "2011-04-07T02:05:27+0000",
            "content": "Thanks for reviewing it Adriano. I updated the proposal to clarify it's the contrib query parser. ",
            "author": "Vinicius Barros",
            "id": "comment-13016653"
        },
        {
            "date": "2011-05-30T02:58:16+0000",
            "content": "This patch includes the work I did this first week. I started with one of the project's objective: restructure RangeQueryNode and its related classes to support number and text range queries.\n\nI created some querynode interfaces, such as ValueQueryNode that abstract the value a leaf node may hold, since now, leaf nodes do not only hold text anymore, but also number values.\n\nLet me know if you have any questions or any suggestions about the code.\n\nI expect I created the patch correctly, as it's the first time I play with subversion ",
            "author": "Vinicius Barros",
            "id": "comment-13040979"
        },
        {
            "date": "2011-05-31T20:51:14+0000",
            "content": "Hi Vinicius,\n\nthanks for your update! The patch looks correct, I assume it's for Lucene trunk? You should  produce them against the top-level directory (below trunk/), not the lucene sub-directory (since Lucene was merged with Solr last year).\n\nI have not closely looked at the code (came back from California recently), but your refactoring as a first step looks fine. I would only suggest to never depend on the default locale (Robert Muir will tell you the same thing), so it should respect the local given to query parser.\n\nI will report back, when I had time to look into it, but it looks really fine - also from the Generics Policeman Point of View g ",
            "author": "Uwe Schindler",
            "id": "comment-13041823"
        },
        {
            "date": "2011-06-01T03:27:21+0000",
            "content": "Hi Uwe,\n\nThanks for quickly reviewing the patch. Yes, I am using trunk's code. I will do the changes you suggested and include in the next patch. ",
            "author": "Vinicius Barros",
            "id": "comment-13041961"
        },
        {
            "date": "2011-06-05T21:39:56+0000",
            "content": "This is the patch for my second week of work. ",
            "author": "Vinicius Barros",
            "id": "comment-13044622"
        },
        {
            "date": "2011-06-05T21:46:45+0000",
            "content": "The second patch includes the week1 changes plus: implemented classes to support numeric configuration in query parser\n\nI was not sure what to do about the locale. The locale is required by EscapeQuerySyntax.escape, which seems to escape characters so they don't mix with query parser's operators. The code I used locale I copied from FieldQueryNode, which uses the escaper and passes the default locale, however, other nodes as RegexpQueryNode ignore the escaper and just return the plain text. I was not sure what to do, then I am forcing the locale to ENGLISH now.\n\nI also took a long time to figure out how to implement the numeric configuration, it seemed to me the best approach was to copy the way FieldBoostAttribute is configured. It's complex, but it's the only way I found without doing any ugly workaround.\n\nPlease, take a look at the code and give me some suggestions in case you thing I need to change something.\n\nPS: the patch is now created from the trunk folder, as Uwe suggested\n\nThanks! ",
            "author": "Vinicius Barros",
            "id": "comment-13044624"
        },
        {
            "date": "2011-06-05T21:47:14+0000",
            "content": "ah, one more thing. Uwe, what is \"Generics Policeman Point of View\"? ",
            "author": "Vinicius Barros",
            "id": "comment-13044625"
        },
        {
            "date": "2011-06-05T21:52:38+0000",
            "content": "ah, one more thing. Uwe, what is \"Generics Policeman Point of View\"?\n\nThat's just my nickname, because I always watch correct usage of Java 5 Generics  I just wanted to confirm, that your generification of some classes looked fine.\n\nI will revisit your patch tomorrow together with others here at BerlinBuzzword (a conference about Lucene and other NoSQL related stuff).\n\nUwe ",
            "author": "Uwe Schindler",
            "id": "comment-13044627"
        },
        {
            "date": "2011-06-05T22:44:58+0000",
            "content": "Vinicius: you are right, contrib QP configuration is very complicated, that's why Phillip is working on another GSOC project to make it simpler. So don't worry much about the best way to use the config API, since it will change, just make it work for now using the old API . You have a good point when you mentioned the escaper problem with Locale. I should think more about it...\n\nUwe: Are you intending to commit the patch only at the end of gsoc? Just wondering, since Vinicius is not selecting the ASF checkbox when submitting the patch, which means the current patches will not be able to be committed. ",
            "author": "Adriano Crestani",
            "id": "comment-13044642"
        },
        {
            "date": "2011-06-10T17:02:39+0000",
            "content": "Hi Vinicius,\n\nif you want the code be committed later, you should check the license box (\"Grant license to ASF for inclusion in ASF works (as per the Apache License \u00a75)\"), else we will be not able to submit it to the main repository.\n\nIf you want us to commit the patch only at the end of GSOC, it's enough to check this box in your final submission, but it should be noted, that we may submit minor parts of the work even before (once you are at a state where it is 'useable' and passes existing tests). A second commit could e.g. adding sophisticated tests, and so on. ",
            "author": "Uwe Schindler",
            "id": "comment-13047291"
        },
        {
            "date": "2011-06-10T17:41:30+0000",
            "content": "One small thing I have seen after applying your patch:\nThe code guidelines of Lucene require no TABS but two whitespace to indent. We have a code style available for Eclipse and IDEA in the dev-tools folder (below trunk). You only have to install it.\n\nAlso you are using Java 6 interface overrides, so the code does not compile with Java 5 (unfortunately this is a bug in Java 6's javac, as it does not complain when in \"-source 1.5\" mode). In Java 5 compatible code it is not allowed to add @Override to methods implemented for interfaces:\n\n\ncommon.compile-core:\n    [mkdir] Created dir: C:\\Users\\Uwe Schindler\\Projects\\lucene\\trunk-lusolr2\\lucene\\build\\contrib\\queryparser\\classes\\java\n    [javac] Compiling 175 source files to C:\\Users\\Uwe Schindler\\Projects\\lucene\\trunk-lusolr2\\lucene\\build\\contrib\\queryparser\\classes\\java\n    [javac] C:\\Users\\Uwe Schindler\\Projects\\lucene\\trunk-lusolr2\\lucene\\contrib\\queryparser\\src\\java\\org\\apache\\lucene\\queryParser\\core\\nodes\\FieldQueryNode.java:182: method does not override a method from its superclass\n    [javac]     @Override\n    [javac]          ^\n    [javac] C:\\Users\\Uwe Schindler\\Projects\\lucene\\trunk-lusolr2\\lucene\\contrib\\queryparser\\src\\java\\org\\apache\\lucene\\queryParser\\core\\nodes\\FieldQueryNode.java:187: method does not override a method from its superclass\n    [javac]     @Override\n    [javac]          ^\n    [javac] C:\\Users\\Uwe Schindler\\Projects\\lucene\\trunk-lusolr2\\lucene\\contrib\\queryparser\\src\\java\\org\\apache\\lucene\\queryParser\\standard\\config\\NumericFieldConfigListener.java:21: method does not override a method from its superclass\n    [javac]     @Override\n    [javac]          ^\n    [javac] C:\\Users\\Uwe Schindler\\Projects\\lucene\\trunk-lusolr2\\lucene\\contrib\\queryparser\\src\\java\\org\\apache\\lucene\\queryParser\\standard\\nodes\\AbstractRangeQueryNode.java:17: method does not override a method from its superclass\n    [javac]     @Override\n    [javac]          ^\n    [javac] C:\\Users\\Uwe Schindler\\Projects\\lucene\\trunk-lusolr2\\lucene\\contrib\\queryparser\\src\\java\\org\\apache\\lucene\\queryParser\\standard\\nodes\\AbstractRangeQueryNode.java:32: method does not override a method from its superclass\n    [javac]     @Override\n    [javac]          ^\n    [javac] C:\\Users\\Uwe Schindler\\Projects\\lucene\\trunk-lusolr2\\lucene\\contrib\\queryparser\\src\\java\\org\\apache\\lucene\\queryParser\\standard\\nodes\\AbstractRangeQueryNode.java:79: method does not override a method from its superclass\n    [javac]     @Override\n    [javac]          ^\n    [javac] C:\\Users\\Uwe Schindler\\Projects\\lucene\\trunk-lusolr2\\lucene\\contrib\\queryparser\\src\\java\\org\\apache\\lucene\\queryParser\\standard\\nodes\\NumericQueryNode.java:20: method does not override a method from its superclass\n    [javac]     @Override\n    [javac]          ^\n    [javac] C:\\Users\\Uwe Schindler\\Projects\\lucene\\trunk-lusolr2\\lucene\\contrib\\queryparser\\src\\java\\org\\apache\\lucene\\queryParser\\standard\\nodes\\NumericQueryNode.java:25: method does not override a method from its superclass\n    [javac]     @Override\n    [javac]          ^\n    [javac] C:\\Users\\Uwe Schindler\\Projects\\lucene\\trunk-lusolr2\\lucene\\contrib\\queryparser\\src\\java\\org\\apache\\lucene\\queryParser\\standard\\nodes\\NumericQueryNode.java:35: method does not override a method from its superclass\n    [javac]     @Override\n    [javac]          ^\n    [javac] C:\\Users\\Uwe Schindler\\Projects\\lucene\\trunk-lusolr2\\lucene\\contrib\\queryparser\\src\\java\\org\\apache\\lucene\\queryParser\\standard\\nodes\\NumericQueryNode.java:52: method does not override a method from its superclass\n    [javac]     @Override\n    [javac]          ^\n    [javac] C:\\Users\\Uwe Schindler\\Projects\\lucene\\trunk-lusolr2\\lucene\\contrib\\queryparser\\src\\java\\org\\apache\\lucene\\queryParser\\standard\\nodes\\NumericQueryNode.java:57: method does not override a method from its superclass\n    [javac]     @Override\n    [javac]          ^\n    [javac] C:\\Users\\Uwe Schindler\\Projects\\lucene\\trunk-lusolr2\\lucene\\contrib\\queryparser\\src\\java\\org\\apache\\lucene\\queryParser\\standard\\parser\\JavaCharStream.java:367: warning: [dep-ann] deprecated name isnt annotated with @Deprecated\n    [javac]   public int getEndColumn() {\n    [javac]              ^\n    [javac] C:\\Users\\Uwe Schindler\\Projects\\lucene\\trunk-lusolr2\\lucene\\contrib\\queryparser\\src\\java\\org\\apache\\lucene\\queryParser\\surround\\parser\\CharStream.java:34: warning: [dep-ann] deprecated name isnt annotated with @Deprecated\n    [javac]   int getColumn();\n    [javac]       ^\n    [javac] C:\\Users\\Uwe Schindler\\Projects\\lucene\\trunk-lusolr2\\lucene\\contrib\\queryparser\\src\\java\\org\\apache\\lucene\\queryParser\\surround\\parser\\CharStream.java:41: warning: [dep-ann] deprecated name isnt annotated with @Deprecated\n    [javac]   int getLine();\n    [javac]       ^\n    [javac] Note: Some input files use or override a deprecated API.\n    [javac] Note: Recompile with -Xlint:deprecation for details.\n    [javac] 11 errors\n    [javac] 3 warnings\n\n\n\nWith Java 6 the code compiles, but some tests fail to work. I assume its simply because of the work-in-progress, ",
            "author": "Uwe Schindler",
            "id": "comment-13047315"
        },
        {
            "date": "2011-06-10T23:55:11+0000",
            "content": "Hi Uwe,\n\nThanks for reviewing the patch again. I will fix the problems you mentioned.\n\nI do not think the code is ready to be committed, I am just sending the patches so you can keep track of my progress. I hope to have something useable soon, then you can commit, probably before the end of gsoc. ",
            "author": "Vinicius Barros",
            "id": "comment-13047788"
        },
        {
            "date": "2011-06-12T05:54:48+0000",
            "content": "Hi Vinicius,\n\nAssuming you are using eclipse, you can find the codestyle used to create lucene code at the bottom of this page: http://wiki.apache.org/lucene-java/HowToContribute, it will fix the identation problem Uwe mentioned.\n\nAfter reviewing the code, I want to remember you that all files must have the ASF header. Take a look at the other Java classes in Lucene repository so you can have an example.\n\nThe way you are organizing the code looks good to me, just make sure whenever you add a new class to contrib query parser, place it under the right package. \"core\", if the class is generic and might be used by other queryparser implemenations; \"standard\", if the class is specific to lucene standard query parser implementation. ",
            "author": "Adriano Crestani",
            "id": "comment-13048249"
        },
        {
            "date": "2011-06-12T06:27:25+0000",
            "content": "One more thing I forgot to mention, when creating new QueryNodes, try to enforce the user when using the constructor to pass the required arguments. For example: NumericQueryNode does not have any constructor, I would suggest you to change it to NumericQueryNode(CharSequence field, Number number, NumberFormat format).\n\n ",
            "author": "Adriano Crestani",
            "id": "comment-13048253"
        },
        {
            "date": "2011-06-13T04:05:09+0000",
            "content": "This patch includes:\n\n-changes suggested by Adriano and Uwe:\n  -remvoed @Override\n  -applied Lucene codestyle\n  -created constructor to NumericQueryNode\n  -added ASF header to new classes\n  -Implemented new NumericQueryNodeProcessor and NumericRangeQueryNodeProcessor ",
            "author": "Vinicius Barros",
            "id": "comment-13048463"
        },
        {
            "date": "2011-06-21T00:22:53+0000",
            "content": "This patch includes the builder for numeric range queries. This week I intend to start writing junits. ",
            "author": "Vinicius Barros",
            "id": "comment-13052288"
        },
        {
            "date": "2011-07-03T05:54:16+0000",
            "content": "This patch includes code from week 5 and 6. Sorry for taking so long to submit a new patch, but I was hitting many problems when I finally started run the junits.\n\nI updated my workspace and got the new changes which use NumericField to add numeric fields to Documents. So I adapted my junits to that and also refactored some code to use NumericField.DataType in NumericConfig, instead of using Class<? extends Number> when specifying the NumericConfig type.\n\nI added a junit class (TestNumericQueryParser). I reused some LuceneTestCase methods, mainly the ones that generate random things. I took sometime to get where I wanted, I was hitting many problems when using dates in range. In the end, I liked the way the junit is running, inputs are very random, mainly the date formats, using randomly different format styles and locale. I ran the junit in a loop 1000 times and I got no error, so I think it's pretty stable now. Uwe, please, take a look and let me know what you think about it.\n\ntestInclusiveLowerRangeQuery and testInclusiveUpperRangeQuery are commented since I found that StandardQueryParser is not supporting mixed include syntaxes, such as {1 TO 2]. Shouldn't it be supported? I don't see why not.\n\nAlso, the query parser is not supporting open ended range queries, such as [... to 3].\n\nI am checking \"Grant license to ASF for inclusion in ASF works (as per the Apache License \u00a75)\" now, because I think the patch is finally ready to be checked in. I ran Lucene top level ant and it finished successfully.\n\nI will work on creating javadocs now. ",
            "author": "Vinicius Barros",
            "id": "comment-13059163"
        },
        {
            "date": "2011-07-03T20:28:49+0000",
            "content": "testInclusiveLowerRangeQuery and testInclusiveUpperRangeQuery are commented since I found that StandardQueryParser is not supporting mixed include syntaxes, such as {1 TO 2]. Shouldn't it be supported? I don't see why not.\n\nI will take a look into it, thanks for reporting it, this might really be a bug  ",
            "author": "Adriano Crestani",
            "id": "comment-13059275"
        },
        {
            "date": "2011-07-05T01:06:08+0000",
            "content": "Hi,\n\nI committed the first patch from LUCENE-2979 and it changed completely the queryparser config API. \n\nIt seems Vinicius is ahead of schedule with this project, is that corret?! Is there anything else to do after documentation? If not, I would ask whether it's possible for you to change the way you use config API for numeric. I think it will not require a lot of change, the api is much simpler now. I can ask Phillipe to help you and explain how the new api works  Otherwise, Uwe will not be able to commit your patch, since there will be many classes missing now.\n\nWhat do you think Uwe? ",
            "author": "Adriano Crestani",
            "id": "comment-13059653"
        },
        {
            "date": "2011-07-05T07:54:01+0000",
            "content": "Hi Adriano,\n\nI will also review the patch today (using older trunk rev) and then respond.\n\nI think, Vinicius should help with updating the code to the latest config API version which was committed. This is where \"community\" in this project gets involved. Maybe the other GSoC student and Vinicius should work together to get this solved.\n\nNext week the mid-term evaluations will come, so we should have something to work on this issue except documentation for the second half. ",
            "author": "Uwe Schindler",
            "id": "comment-13059707"
        },
        {
            "date": "2011-07-05T22:21:23+0000",
            "content": "I downgraded my trunk checkout to rev. 1142861 and applied the patch. All tests pass, so nice work until now. The problem is that I am no longer able to commit the patch, as rev. 1142862 was committed before, changing the QP config API, so how to proceed?\n\nVinicius, how do you want to proceed, are you planning to rewrite the stuff related to LUCENE-2979? ",
            "author": "Uwe Schindler",
            "id": "comment-13060168"
        },
        {
            "date": "2011-07-05T22:41:24+0000",
            "content": "Hi Uwe,\n\nI talked to Phillipe about the new API, it does not look complicated. I will try to do the change and submit a new patch by the end of this week, then we can finally have something checked in \\o/\n\nNext things do to then:\n-fix config\n-write javadocs\n-write wiki/tutorial explaining how to use query parser with numeric fields\n\nSomething else you have in mind Uwe that we can add to the above list? Maybe fix the range query in contrib queryparser which I mentioned in my past comments above. (Have you verified the bug Adriano?) ",
            "author": "Vinicius Barros",
            "id": "comment-13060176"
        },
        {
            "date": "2011-07-05T22:48:55+0000",
            "content": "I think the \"bug\" in Contrib QP is there because it's also a bug in Lucene's Core QP (the default impl just emulates core's QP). But in my opinion, it should have separate include/exclude for both limits, so a query like {1 TO 2] should behave as expected.\n\nThe QP should in my opinion also support open-ended ranges. The syntax by NumericRangeQuery's toString() is by using stars (this is also what Solr's QP does). For numeric fields, half open ranges are important, as it supports queries like \"price < 2.00 Dollar\". Wasn't there not also an issue open to support other syntax for numerics like > and < operators? ",
            "author": "Uwe Schindler",
            "id": "comment-13060180"
        },
        {
            "date": "2011-07-05T23:08:06+0000",
            "content": "I have some small things (maybe I will extend this comment when i review more of the code):\n\n\n\tin NumericRangeQueryNodeBuilder, i would use switch statement on the NumericField.DataType and throw a UnsupportedEx if an unknown type is hit. I want to do this, because there is already an issue open to extend NumericField and NumericRangeQuery by BYTE and SHORT. If we add those types, the code gets unpredictable. With a switch statement and a exception in the defalt clause, it fails predicatable. You should also add similar \"default\" statement throwing exceptions in all switch statements on this enum type (in general it is good code style to do this).\n\tThe current code always handles Date as Long (like Solr does). I am not sure, if this would always be the best idea (see e.g. Lucene In Action book). Maybe we should add a possibility to override the conversion Date <-> Number at a central place to customize? One of the reasons to not support direkt DateRangeQueries was to make the representation of Dates as Numbers open to the user.\n\tMethod \"NumericField.DataType getNumericDataType(Number number)\": I would use instanceOf checks (as all Number subclasses are final, this is fine and correct). They should be faster than this reflection code.\n\n\n\nThis is all for now, more may be added tomorrow. ",
            "author": "Uwe Schindler",
            "id": "comment-13060186"
        },
        {
            "date": "2011-07-05T23:23:33+0000",
            "content": "Hi Uwe,\n\n>>>I think the \"bug\" in Contrib QP is there because it's also a bug in Lucene's Core QP (the default impl just emulates core's QP). But in my opinion, it should have separate include/exclude for both limits, so a query like {1 TO 2] should behave as expected.\n\nI think the same way, no idea why it's not supporting {1 TO 2]. I can try to fix it, but not sure how long it will take, haven't looked at the code yet. Anyway, it shouldn't be that hard, since core QueryParser is already working the way we expect, we need somehow to copy the same behavour to contrib queryparser.\n\n>>>in NumericRangeQueryNodeBuilder, i would use switch statement on the NumericField.DataType and throw a UnsupportedEx if an unknown type is hit. I want to do this, because there is already an issue open to extend NumericField and NumericRangeQuery by BYTE and SHORT. If we add those types, the code gets unpredictable. With a switch statement and a exception in the defalt clause, it fails predicatable. You should also add similar \"default\" statement throwing exceptions in all switch statements on this enum type (in general it is good code style to do this).\n\nAgreed! I will do the change.\n\n>>>The current code always handles Date as Long (like Solr does). I am not sure, if this would always be the best idea (see e.g. Lucene In Action book). Maybe we should add a possibility to override the conversion Date <-> Number at a central place to customize? One of the reasons to not support direkt DateRangeQueries was to make the representation of Dates as Numbers open to the user.\n\nDo you mean that Date could return some other type other than LONG? Like INT?! I could add a new parameter to NumberDateFormat that will receive NumeridField.DataType, this way the code could parse the date to the expected number type.\n\n\n>>> Method \"NumericField.DataType getNumericDataType(Number number)\": I would use instanceOf checks (as all Number subclasses are final, this is fine and correct). They should be faster than this reflection code.\n\nI will change that as well. ",
            "author": "Vinicius Barros",
            "id": "comment-13060192"
        },
        {
            "date": "2011-07-05T23:40:37+0000",
            "content": "\n>>>The current code always handles Date as Long (like Solr does). I am not sure, if this would always be the best idea (see e.g. Lucene In Action book). Maybe we should add a possibility to override the conversion Date <-> Number at a central place to customize? One of the reasons to not support direkt DateRangeQueries was to make the representation of Dates as Numbers open to the user.\n\nDo you mean that Date could return some other type other than LONG? Like INT?! I could add a new parameter to NumberDateFormat that will receive NumeridField.DataType, this way the code could parse the date to the expected number type.\n\nIn general, the formatting of a Date to a Number should be possible to customize (e.g. if you only want to format the Date without the time and your index supports only Int dates, like number of days).\n\nI talked to Phillipe about the new API, it does not look complicated. I will try to do the change and submit a new patch by the end of this week, then we can finally have something checked in \\o/\n\nThat communication should be done in public... ",
            "author": "Uwe Schindler",
            "id": "comment-13060195"
        },
        {
            "date": "2011-07-05T23:50:31+0000",
            "content": ">>> In general, the formatting of a Date to a Number should be possible to customize (e.g. if you only want to format the Date without the time and your index supports only Int dates, like number of days).\n\nThat's possible, the user just need to provide a NumberFormat that will convert String to whatever Number object the user wants. ",
            "author": "Vinicius Barros",
            "id": "comment-13060196"
        },
        {
            "date": "2011-07-06T02:50:53+0000",
            "content": "Hey,\n\nIn the next week or so I'm going to want to move this QueryParser, along with the contents of contrib/queryparser, to the new consolidated queryparser module.  Is this going to get in the way of the work here? ",
            "author": "Chris Male",
            "id": "comment-13060244"
        },
        {
            "date": "2011-07-06T05:20:45+0000",
            "content": "Hi Chris,\n\nIf you are just moving code, I think it's fine, at max we will need to rename the paths in the patch to match the new file structure. ",
            "author": "Adriano Crestani",
            "id": "comment-13060295"
        },
        {
            "date": "2011-07-06T17:30:16+0000",
            "content": "\nFor numeric fields, half open ranges are important, as it supports queries like \"price < 2.00 Dollar\". Wasn't there not also an issue open to support other syntax for numerics like > and < operators?\n\nYes, there is, just do not recall the JIRA number now. Maybe Vinicius could try to implement it as well to fill out his task list in case he finishes his tasks before schedule, since it is also related to numeric queries. I am just not sure how much complex the task would be, I know the big change for this is in the syntax parser, which will require to know how to change javacc files. ",
            "author": "Adriano Crestani",
            "id": "comment-13060707"
        },
        {
            "date": "2011-07-09T18:04:28+0000",
            "content": "This patch includes the fix for the new config api and all changes suggested by Uwe.\n\nUwe, you should be able to commit it now, I checked out the trunk and applied the patch myself and everything is working fine. ",
            "author": "Vinicius Barros",
            "id": "comment-13062596"
        },
        {
            "date": "2011-07-09T18:58:24+0000",
            "content": "Hi Vinicius,\ncool thanks! Patched, works - nothing to complain about.\n\nI think I will commit this soon, so your partner from LUCENE-2979 can also coordinate with you (which was also committed). ",
            "author": "Uwe Schindler",
            "id": "comment-13062602"
        },
        {
            "date": "2011-07-09T21:07:32+0000",
            "content": "Committed to Lucene trunk revision: 1144744\nYou can now start and improve the documentation, tests,... Please use current trunk as basis.\n\nOne note: I have still seen some switch statements without a default while reviewing.\n\nWe should also decide together with LUCENE-2979 if we should backport this stuff to 3.x (once finished). Adriano? ",
            "author": "Uwe Schindler",
            "id": "comment-13062625"
        },
        {
            "date": "2011-07-09T21:52:58+0000",
            "content": "I had to fix a javadoc warning, breaking the Jenkins Builds: rev 1144755 ",
            "author": "Uwe Schindler",
            "id": "comment-13062643"
        },
        {
            "date": "2011-07-10T23:02:02+0000",
            "content": "Hi Uwe,\n\nThere are plans to backport LUCENE-2979 to 3.x, Phillipe is already working on it, still evaluating if it will be possible.\n\nI am not sure about numeric support, Vinicius changed TermRangeQueryNode inheritance, which breaks the backwards compatibility. I am not saying the change is bad, I agree with the new structure, however Vinicius will need to find another solution before backporting it to 3.x. ",
            "author": "Adriano Crestani",
            "id": "comment-13062820"
        },
        {
            "date": "2011-07-11T21:26:00+0000",
            "content": "Vinicius, do you have any plans about backporting the stuff to Lucene 3.x - it should not be that hard \n\nI am not sure about numeric support, Vinicius changed TermRangeQueryNode inheritance, which breaks the backwards compatibility. I am not saying the change is bad, I agree with the new structure, however Vinicius will need to find another solution before backporting it to 3.x.\n\nI am not sure if this is really a break when you change inheritance. If code still compiles, its no break, if classes were renamed its more serious. I am not sure, if implementation classes (and -names) should be covered by the backwards compatibility. In my opinion, mainly the configuration and interfaces of the QP must be covered by backwards policy.\n\nAs we are now at mid-time, it would be a good idea, to maybe add some extra syntax support for numerics, like \"<\" and \">\"? We should also add tests/support for half-open ranges, so syntax like \"[* TO 1.0]\" should also be supported (I am not sure, if TermRangeQueryNode supports this, but numerics should do this in all cases) - the above syntax is also printed out on NumericRangeQuery.toString(), if one of the bounds is null. The latter could be easily implemented by checking for \"*\" as input to the range bounds and map those special \"values\" to NULL. Adding support for \"<\" and \">\" (also \"<=\", \">=\") needs knowledge of JavaCC parser language. Vinicius, have you ever worked with JavaCC, so do you think you will be able to extend the syntax? ",
            "author": "Uwe Schindler",
            "id": "comment-13063555"
        },
        {
            "date": "2011-07-11T21:59:01+0000",
            "content": "\nI am not sure if this is really a break when you change inheritance. If code still compiles, its no break, if classes were renamed its more serious. I am not sure, if implementation classes (and -names) should be covered by the backwards compatibility. In my opinion, mainly the configuration and interfaces of the QP must be covered by backwards policy.\n\nI didn't see any class renaming, I need to double check Vinicius's patches. But he did change the query node inheritance, which may affect how processors and builder (specially QueryNodeTreeBuilder) work. I am not saying it is not possible to implement his approach on 3.x, but he will need to deal differently with query nodes classes he created. As I said before, what he did is good and clean, I like the way it is, but it will break someone's code if pushed to 3.x. So if you ask me whether to push it to 3.x, I say YES, just make sure to not break the query node structure that people may be relying on.\n\n\nAs we are now at mid-time, it would be a good idea, to maybe add some extra syntax support for numerics, like \"<\" and \">\"? We should also add tests/support for half-open ranges, so syntax like \"[* TO 1.0]\" should also be supported (I am not sure, if TermRangeQueryNode supports this, but numerics should do this in all cases) - the above syntax is also printed out on NumericRangeQuery.toString(), if one of the bounds is null. The latter could be easily implemented by checking for \"*\" as input to the range bounds and map those special \"values\" to NULL. Adding support for \"<\" and \">\" (also \"<=\", \">=\") needs knowledge of JavaCC parser language. Vinicius, have you ever worked with JavaCC, so do you think you will be able to extend the syntax?\n\nI still need to investigate the bugs Vinicius reported (should have been created a JIRA for that already), I never really tried open ranges in contrib QP. And if Vinicius thinks he will have time and skills to do the JAVACC change to support those new operators, go for it! And remember Vinicius, you don't need to do everything during gsoc, you are always welcome to contribute code whenever you want  ",
            "author": "Adriano Crestani",
            "id": "comment-13063570"
        },
        {
            "date": "2011-07-11T23:29:00+0000",
            "content": "Thanks for committing the patch Uwe!\n\nI will review the code again looking for switch without default case and fix it.\n\nI never did anything with javacc, I just quickly looked at the code, does not seem complicated, however, I have no idea how complex is to run javacc and regenerate the java files. Does lucene ant script do that automaticaly?\n\nI can try to fix open range queries on contrib query parser, add \"<=\"-like operators or backport numeric support to 3.x. Just let me know the priorities and I will work on it. My suggestion is that the bug on open range queries is the most critical now, so I could start working on that. Your call Uwe. ",
            "author": "Vinicius Barros",
            "id": "comment-13063607"
        },
        {
            "date": "2011-07-12T17:55:45+0000",
            "content": "Hey guys, we had some hudson problems I wonder if you could look at:\n\nThe first thing, the randomization of this test was not working correctly, because it used 'random' from static initializers. \nIn LuceneTestCase, the random is first initialized in @beforeClass, so its not really usable before then.\n\nI committed this to fix the randomization: http://svn.apache.org/viewvc/lucene/dev/trunk/lucene/contrib/queryparser/src/test/org/apache/lucene/queryParser/standard/TestNumericQueryParser.java?r1=1145452&r2=1145451&pathrev=1145452\n\nOnce I did this, then the test is working correctly (reproducible etc) but it would fail and sometimes hang.\n\nI took care of the hang, the reason was if the test got minIntegerDigits < 4, it would loop forever looking for a number >= 1000.\nYou can see the fix here: http://svn.apache.org/viewvc/lucene/dev/trunk/lucene/contrib/queryparser/src/test/org/apache/lucene/queryParser/standard/TestNumericQueryParser.java?view=diff&r1=1145456&r2=1145457&pathrev=1145457\n\nBut one problem still remains, for some situations (e.g. certain numbers and locales) the test is failing. ",
            "author": "Robert Muir",
            "id": "comment-13064040"
        },
        {
            "date": "2011-07-12T20:03:55+0000",
            "content": "Hi Robert,\n\nThanks for fixing the problems.\n\nAbout the tests failing, do you know how I can reproduce it? When I was testing, whenever I hit a failure, ant would give me some seed values so I could set in the properties when re-running the tests. Do you have the same values? ",
            "author": "Vinicius Barros",
            "id": "comment-13064100"
        },
        {
            "date": "2011-07-12T20:10:00+0000",
            "content": "Here are some, from hudson: \nhttps://builds.apache.org/job/Lucene-Solr-tests-only-trunk/9527/testReport/junit/org.apache.lucene.queryParser.standard/TestNumericQueryParser/testSimpleNumericQuery/\n\n\nant test -Dtestcase=TestNumericQueryParser -Dtestmethod=testSimpleNumericQuery -Dtests.seed=941414100019268099:-3819525649270784880 -Dtests.multiplier=3\n\n\n\nThere is no guarantee this will work though, because when randomizing locales, the number available can vary from JRE to JRE, even changing in minor versions. ",
            "author": "Robert Muir",
            "id": "comment-13064107"
        },
        {
            "date": "2011-07-12T20:13:08+0000",
            "content": "I assume the problem lies in Thai locale - as always  ",
            "author": "Uwe Schindler",
            "id": "comment-13064111"
        },
        {
            "date": "2011-07-12T23:00:55+0000",
            "content": "Hi Robert,\n\nI updated my code to latest revision and I don't get any junit failure, I ran \n\nant test -Dtestcase=TestNumericQueryParser -Dtestmethod=testSimpleNumericQuery -Dtests.seed=941414100019268099:-3819525649270784880 -Dtests.multiplier=3\n\nin contrib/queryparser and junit on eclipse with\n\n-Dtestcase=TestNumericQueryParser -Dtestmethod=testSimpleNumericQuery -Dtests.seed=941414100019268099:-3819525649270784880 -Dtests.multiplier=3\n\nNone of them failed. ",
            "author": "Vinicius Barros",
            "id": "comment-13064222"
        },
        {
            "date": "2011-07-12T23:07:47+0000",
            "content": "yeah the seed will unfortunately rely upon how many locales you have on your JRE\n\nSo to get some seeds that work on your machine, can you try this script?\n\n#!/bin/bash\nx=0\nwhile [ $x -lt 50 ]\ndo\n  echo \"test iteration number $x\"\n  (cd lucene/contrib/queryparser && ant test -Dtestcase=TestNumericQueryParser) >> /home/rmuir/log.txt 2>&1\n  x=$(( $x + 1 ))\ndone\n\n ",
            "author": "Robert Muir",
            "id": "comment-13064223"
        },
        {
            "date": "2011-07-13T00:01:30+0000",
            "content": "Hi Robert,\n\nThanks for the script, it helped me to find a case where it fails.\n\nOn my JRE, the code below fails:\n\n\n  SimpleDateFormat df = (SimpleDateFormat) DateFormat.getDateTimeInstance(\n      DateFormat.FULL, DateFormat.LONG, new Locale(\"de_CH\"));\n  // most of date pattern do not include era, so we add it here. Also,\n  // sometimes second is not available, we make sure it's present too\n  df.applyPattern(df.toPattern() + \" G s Z yyyy\");\n  df.setTimeZone(TimeZone.getTimeZone(\"America/Grand_Turk\"));\n  long l1 = -1881411016000l;\n  long l2 = -1881411028000l;\n  String d1 = df.format(new Date(l1));\n  String d2 = df.format(new Date(l2));\n  long newL1 = df.parse(d1).getTime();\n  long newL2 = df.parse(d2).getTime();\n  \n  System.out.println(l1 + \" => \" + d1 + \" => \" + newL1);\n  System.out.println(l2 + \" => \" + d2 + \" => \" + newL2);\n  assertEquals(l1, newL1);\n  assertEquals(l2, newL2);\n\n\n\nand it outputs: \n\n-1881411016000 => Friday, May 20, 1910 4:42:32 AM EST => -1881411448000\n-1881411028000 => Friday, May 20, 1910 4:42:20 AM EST => -1881411460000\n\n\n\nAs you can see, it seems DateFormat is not very reliable and do not convert back and forth from date(long) to string format and vice-versa.\n\nI am planning to add a sanity check when creating randomly the date format, the check will check whether the date can be converted to/from long from/to string without data loss.\n\nWhat do you think? ",
            "author": "Vinicius Barros",
            "id": "comment-13064245"
        },
        {
            "date": "2011-07-13T02:38:27+0000",
            "content": "Another trunk failure:  https://builds.apache.org/job/Lucene-Solr-tests-only-trunk/9532/ ",
            "author": "Chris Male",
            "id": "comment-13064304"
        },
        {
            "date": "2011-07-13T03:36:47+0000",
            "content": "Also, note in LUCENE-3285 I'm about to move the flexible QP over to the new queryparser module and remove the contrib. ",
            "author": "Chris Male",
            "id": "comment-13064328"
        },
        {
            "date": "2011-07-13T06:53:42+0000",
            "content": "As you can see, it seems DateFormat is not very reliable and do not convert back and forth from date(long) to string format and vice-versa.\n\nI would write the test a little bit different: Use a random number as basis for the date, then convert to string and back. Throw away the orginal random number and use the \"normalized\" number and their string representation only?\n\nThis should work better, as I assume SimpleDateFormat always produces same results for same numbers? But you can still add the sanity check and throw away random numbers that don't meet the requirement.\n\nAdditionally, the millisecond part should always be 000, as you dont use miliseconds? ",
            "author": "Uwe Schindler",
            "id": "comment-13064389"
        },
        {
            "date": "2011-07-13T07:01:13+0000",
            "content": "I disabled the test case for now: Trunk revision: 1145885\n\nI would write the test a little bit different: Use a random number as basis for the date, then convert to string and back. Throw away the orginal random number and use the \"normalized\" number and their string representation only?\n\nAh, you already did that, so the DateFormats are not really reliabe, you are right! ",
            "author": "Uwe Schindler",
            "id": "comment-13064392"
        },
        {
            "date": "2011-07-14T00:28:36+0000",
            "content": "This is the fix for the junit failure. I used the Robert's script and the test has not failed anymore. ",
            "author": "Vinicius Barros",
            "id": "comment-13064980"
        },
        {
            "date": "2011-07-14T02:58:50+0000",
            "content": "Note, I've just moved this contrib to the queryparser module and nuked the contrib.  Sorry Vinicius :/ ",
            "author": "Chris Male",
            "id": "comment-13065021"
        },
        {
            "date": "2011-07-14T03:40:10+0000",
            "content": "Hey Chris,you just moved the files right?! Vinicus patch only includes a single file (the failing junit), all Uwe need to do is to apply the patch to the moved file, is that correct?! ",
            "author": "Adriano Crestani",
            "id": "comment-13065032"
        },
        {
            "date": "2011-07-14T03:44:22+0000",
            "content": "Correct.\n\nThe Flexible QueryParser can now be found at org.apache.lucene.queryparser.flexible.* ",
            "author": "Chris Male",
            "id": "comment-13065033"
        },
        {
            "date": "2011-07-14T06:59:21+0000",
            "content": "This is the fix for the junit failure. I used the Robert's script and the test has not failed anymore.\n\nThanks Vinicius,\nI will check the patch and apply it to the new location of the query parser. You don't need to do anything!\n\nIf you have other changes or fixes in your checkout, I would recommend to create a patch first (below the queryparser folder) and then update svn and reapply the patch at the new location. ",
            "author": "Uwe Schindler",
            "id": "comment-13065087"
        },
        {
            "date": "2011-07-14T18:09:02+0000",
            "content": "Hi Vinicius,\n\nI tested your patch (after converting it to new trunk directory/package layout (thanks Chris Male \n\nIt still fails quite often for some locales (at least in Java 6). The problem is that some locales produce date formats that are not immune to case changes. As QueryParser seems to lowercase the range bounds, some dates cannot be parsed.\n\nThis throwed with your patch a NPE, because you implemented NumberDateFormat wrong: public Number parse(String source, ParsePosition parsePosition) is allowed to return null (it must if a parse error occurs). The same applies to date formats, but if you call getTime() on a null Date it throws NPE. So the attached patch also fixes the NumberDateFormat to handle null correctly.\n\nI also changed the test initialization a bit to produce sane dates from the beginning.\n\nI then added a toLowerCase(LOCALE) to the sanity checker\n\nNow the static initializer fails for:\n\nant test -Dtestcase=TestNumericQueryParser -Dtestmethod=testInclusiveNumericRange -Dtests.seed=5825000776503943381:-1057095952794658416\n\n\n\nAs a lowercased date cannot be parsed, this fails with ParseException. The locale is \"es\", so the spanisch translation of \"GMT\" is case sensitive:\n\nThis parses:\n\ndomingo 19 de agosto de 1973 11H31' GAMT AD 34 -0900 1973\n\n\n\nThis not:\n\ndomingo 19 de agosto de 1973 11h31' gamt ad 34 -0900 1973\n\n ",
            "author": "Uwe Schindler",
            "id": "comment-13065430"
        },
        {
            "date": "2011-07-14T18:10:38+0000",
            "content": "I would suggest to not lowercase range bounds for numbers/dates in the QueryParser. This makes only sense for terms, but numbers should not change case. I think we can remove the toLowerCase() in the query builder. ",
            "author": "Uwe Schindler",
            "id": "comment-13065431"
        },
        {
            "date": "2011-07-14T20:33:06+0000",
            "content": "I agree with Uwe. I think the format passed to NumericConfig should decide if it supports or not case. ",
            "author": "Adriano Crestani",
            "id": "comment-13065517"
        },
        {
            "date": "2011-07-14T21:15:34+0000",
            "content": "Attached you find the same patch, but with the numeric nodes not lowercased. The fix was easy: As the NumericQueryNodeProcessor transforms all text nodes to numeric nodes, we can simply move the LowerCaseExpandedTerms processor after those transformations, so the nodes are no longer touched.\n\nThe attached patch simply moves the LowercaseExpandedTermsQueryNodeProcessorfilter after the NumericRangeQueryNodeProcessor.\n\nTests now pass, Vinicius & Adriano, what do you think? ",
            "author": "Uwe Schindler",
            "id": "comment-13065539"
        },
        {
            "date": "2011-07-15T00:50:28+0000",
            "content": "Hi Uwe,\n\nThanks for fixing the junit, I think changing the order of those processors is OK, mainly if Numeric processors do no require lowercasing. ",
            "author": "Vinicius Barros",
            "id": "comment-13065640"
        },
        {
            "date": "2011-07-15T06:43:29+0000",
            "content": "I will commit those fixes ASAP to get it again into the nightly test runs (where this test is currently disabled). I never trust the complexity of all Locales, maybe there are more glitches which can only be found with random testing. ",
            "author": "Uwe Schindler",
            "id": "comment-13065741"
        },
        {
            "date": "2011-07-15T06:49:21+0000",
            "content": "It sounds ok for me to change when LowercaseExpandedTermsQueryNodeProcessor gets executed. ",
            "author": "Adriano Crestani",
            "id": "comment-13065742"
        },
        {
            "date": "2011-07-15T07:07:34+0000",
            "content": "Here the patch I'll commit now. I changed the initialization order of beforeClass() a little bit to make it easier to undertstand. The NumberFormat is no longer initialized inside the Date loop, as its not used there.\n\nI'll commit now. ",
            "author": "Uwe Schindler",
            "id": "comment-13065745"
        },
        {
            "date": "2011-07-18T06:53:30+0000",
            "content": "This patch includes javadocs for the changes I did so far.\n\nI am working right now on fixing open range bug on flexible standard query parser. ",
            "author": "Vinicius Barros",
            "id": "comment-13066813"
        },
        {
            "date": "2011-07-25T01:02:53+0000",
            "content": "Fixed open range and mixed include and exclude bugs on LUCENE-3338 ",
            "author": "Vinicius Barros",
            "id": "comment-13070287"
        },
        {
            "date": "2011-07-25T13:07:02+0000",
            "content": "Committed the javadocs changes in rev 1150671. ",
            "author": "Uwe Schindler",
            "id": "comment-13070483"
        },
        {
            "date": "2011-08-06T05:26:23+0000",
            "content": "Sorry, I have been in silence for so long time, trying to get some results, but many doubts showed up, I need to guidance here.\n\nFirst, I started working on implementing >=, <=, <, > and = operator for standard query parser. Then I later realized someone had submitted a patch for that already and I stopped working on it.\n\nThen I decided to implement support for date resolutions for numeric queries in query parser. I started by changing NumberDateFormat to receive a resolution parameter (DAY, SECONDS, MINUTES, etc) and this new parameter is taken into account when doing the date conversion. For that, I added a new method to do the date rounding that takes TimeZone into account, since the current round methods in DateTools do not support timezone. I was able to make it work up to this part.\n\nAfter that, I started to work on date compression, as you suggested before Uwe. For example, if the user wants a DAY resolution, NumberDateFormat should only return the number of days for the given date since 1970, not the miliseconds. For SECOND resolution, it's easy, just divide the miliseconds by 1000. For minutes the same, divide the miliseconds by 1000 * 60 and so on. However, when I got to month, I have no easy way to compress the miliseconds, I mean, no easy way to truncate the days and only get the month count since 1970. The only good solution I found was to get the number of years since 1970 and multiply by 12 plus the current month number.\n\nI am still wondering if we can always assume that dividing the miliseconds by 1000 (sec), 60 (minute), 60 (hour) and 24 (day) will actually be precise. What about the leap second? Not sure if the miliseconds -> (defined_resolution) and (defined_resolution) -> miliseconds will always be correct. Maybe I am missing something or overcomplicating. ",
            "author": "Vinicius Barros",
            "id": "comment-13080357"
        },
        {
            "date": "2011-08-06T05:32:31+0000",
            "content": "I also started working on applying the numeric support to 3x. However I am not sure about backwards compatibility there.\n\nThe problem is that in trunk I had renamed RangeQueryNode to TermRangeQueryNode. Also, TermRangeQueryNode no longer extends ParametricRangeQueryNode, it now extends AbstractRangeQueryNode. Because of that, ParametricRangeQueryNodeProcessor returns a TermRangeQueryNode instead of RangeQueryNode. As you can see, many things the user might expect to still work the same is working completely different. I see some classes in Lucene use Version, but I don't know exactly how that works and why standard query parser do not use it. Should it?\n\nNot sure how I should proceed now. Should I ignore the backward compatibility and go ahead and change how everything behaves or try to make everything backward compatible (not sure how I could do that without the use of Version).\n\nDo you have any comments on that Uwe? ",
            "author": "Vinicius Barros",
            "id": "comment-13080359"
        },
        {
            "date": "2011-08-06T05:56:56+0000",
            "content": "I see some classes in Lucene use Version, but I don't know exactly how that works and why standard query parser do not use it. Should it?\n\nVersion is inteneded to be used for behavioural changes to keep index compatibility, so people can use new Lucene versions without reindexing. It does not help for API changes (it could sometimes, but only for those cases where the API changes are something like: If versionA call method a else method b, if method a or b trigger different APIs).\n\nTypical examples for Version are changes in tokenization (so most analyzers use it): When a bugfix in the analyzer produces different tokens than before the version flag is used to be able to enable the \"buggy\" behaviour, so querying your index with the \"wrong\" tokens still works. The core queryparser also uses it to change the behaviour of creating phrase queries (the flexible query parser is, as far as I know, still missing this).\n\nI am away this weekend, I will come back to you on Monday for the other questions. ",
            "author": "Uwe Schindler",
            "id": "comment-13080360"
        },
        {
            "date": "2011-08-09T03:36:20+0000",
            "content": "Good point, should flexible query parser be using version? The changes below might break users' code.\n\n\n\tprocessor pipeline configuration changes: any change on the configuration may affect the query node tree result. If the user has created it's own query builder (or somehow extended/modified the current builder), changes to what the processor pipeline outputs might break user's code.\n\n\n\n\n\tsyntax parser changes: if the syntax parser starts outputting a different query node tree it may break any user processor or builder\n\n\n\n\n\twhenever a builder is expecting XQueryNode and then in a later version is expects YQueryNode as input\n\n\n\nThe question is: should we support versioning for the above changes or should we only document the changes and let the user be aware of such change?\n\nI think we should be very careful and only use Version when it's really required (like things that imply in index changes). So I vote for only documenting the change and also try to avoid changes that will change the code behavior.\n\nI see the classic QP only uses version to change the default value for certain instance attributes between 2.9/3.0 and 3.x versions. I think it's only there because 2.9 and 3.0 were required to be the same, except removed deprecations. I don't think 4.0 will have the same requirement, will it? ",
            "author": "Adriano Crestani",
            "id": "comment-13081404"
        },
        {
            "date": "2011-08-09T03:55:22+0000",
            "content": "I took a look at the code and I have some suggestions to avoid doing to many changes:\n\n\n\tfor 3x, do not rename RangeQueryNode to TermRangeQueryNode, just deprecate it and document it saying it will change name in future (Uwe, can you confirm this is the right procedure for class renaming?!).\n\n\n\n\n\tParametricRangeQueryNode and AbstractRangeQueryNode have exactly the same methods, why can't they share the a new common interface? I think this will enable you to keep the same inheritance structure for RangeQueryNode, is that correct?! I would name this new interface RangeQueryNode, if there was no such class already. So I will let you pick any name for it \n\n\n\nI think it's a start, I haven't tried the changes, so I will let you(Vinicius) play with it. Let us know if it helped or if you hit any new problems  ",
            "author": "Adriano Crestani",
            "id": "comment-13081412"
        },
        {
            "date": "2011-08-09T17:24:50+0000",
            "content": "for 3x, do not rename RangeQueryNode to TermRangeQueryNode, just deprecate it and document it saying it will change name in future (Uwe, can you confirm this is the right procedure for class renaming?!).\n\nI can confirm this, we do it generally a little bit different, there are two possibilities (depending on if the user will create instances of this class and pass it to the API or if the API returns the instance):\n\n\tFor the first case, you would leave the name as in trunk, but simply create an empty subclass with the old 3.x name (only copy the ctors) and deprecate this subclass.\n\tFor the second case, create the deprecated class as superclass of the new one (and deprecate it), copying all code to this deprecated class. The problem here is that deprecation inherits... To fix, you have to declare all methods and let them call super without deprecation.\n\n\n\nI agree with the rest of Adriano's comments.\n\nIn general this is a contrib module and contrib modules don't have the strict backwards requirements like core classes. Because of this I would only provide minimal backwards layers (no sophisticated ones) and document all changes. Backwards compatibility sometimes get a pain, so we even document and break backwards in core (sometimes). We list all those breaks in the backwards section. Backwards breaks that can be fixed by recompilation are very minor and should only be documented (as drop-in-JAR replacements no longer work), so they are no issue at all.\n\nI see the classic QP only uses version to change the default value for certain instance attributes between 2.9/3.0 and 3.x versions. I think it's only there because 2.9 and 3.0 were required to be the same, except removed deprecations. I don't think 4.0 will have the same requirement, will it?\n\n4.0 breaks backwards completely with no deprecation layers. The core API of Lucene changed hard (new enum types, new structures, totally new API, change from char[] to byte[],... the list is very long). We have a MIGRATION.txt that explains all changes.\n\nWe only add deprecation layers in 3.x core for cases where very high-level user classes are affected (e.g. IndexSearcher.search() methods, so transition is easy). All other places in Lucene that are more expert will change as described before. ",
            "author": "Uwe Schindler",
            "id": "comment-13081776"
        },
        {
            "date": "2011-08-10T04:15:10+0000",
            "content": "Hi Uwe and Adriano,\n\nThanks for the comments.\n\nI have been trying to follow Adriano's instructions to avoid major changes to API and behavior. However, ParametricRangeQueryNode and AbstractRangeQueryNode do not share the same methods (as Adriano said above). ParametricRangeQueryNode has lower and upper bound, which are ParametricQueryNodes, and these last ones hold the inclusive/exclusive information (they use CompareOperator for that). AbtractRangeQueryNode have lower and upper bounds (these ones defined by the template, so it could be a ParametricQueryNode, which is compatible with ParametricRangeQueryNode), however it holds the inclusive/exclusive information differently, through isLowerInclusive and isUpperInclusive methods.\n\nI just don't understand why ParametricQueryNode hold this CompareOperator value, I think this should be part of the ParametricRangeQueryNode and ParametricQueryNode should only be a simple value (FieldQueryNode). Any suggestions here? ",
            "author": "Vinicius Barros",
            "id": "comment-13082128"
        },
        {
            "date": "2011-08-10T23:00:33+0000",
            "content": "\nI just don't understand why ParametricQueryNode hold this CompareOperator value, I think this should be part of the ParametricRangeQueryNode and ParametricQueryNode should only be a simple value (FieldQueryNode). Any suggestions here?\n\nThat's a looong story. And you are right, they are not compatible (my fault) and CompareOperator does not make much sense. Today, if you want, you can set a ParametricRangeQueryNode with CompareOperator.LE set in the two bounds :S. Lets take the opportunity and try to redesign it.\n\nI also agree that ParametricRangeQueryNode could only have FieldQueryNode as its bounds, so I think we can get rid of ParametricQueryNode (for 4.0). For now, I will suggest the following change:\n\n\n\tkeep using ParametricQueryNode in ParametricRangeQueryNode\n\n\n\n\n\tdeprecate ParametricQueryNode\n\n\n\n\n\tmake ParametricRangeQueryNode implement that RangeQueryNode interface I mentioned on my last comment. This interface will have isLowerInclusive, isUpperInclusive, setUpperInclusive and setLowerInclusive. For the template parameter, ParametricRangeQueryNode should use FieldQueryNode.\n\n\n\n\n\tMake sure whenever the user sets lowerInclusive and upperInclusive we replicate that to the ParametricQueryNode (upper and lower bounds) setting the equivalent CompareOperator.\n\n\n\nI think this way we can get rid of ParametricQueryNode in future. I don't know the implications of these changes, since I haven't tried it. So let me know if you find any new conflict. ",
            "author": "Adriano Crestani",
            "id": "comment-13082741"
        },
        {
            "date": "2011-08-14T00:32:18+0000",
            "content": "This patches backports the numeric support to 3x.\n\nUwe and Adriano, please, review it and let me know if the backports looks OK.\n\nThanks! ",
            "author": "Vinicius Barros",
            "id": "comment-13084751"
        },
        {
            "date": "2011-08-17T04:38:24+0000",
            "content": "Hi Vinicius,\n\nGood work, the patch looks good. I saw you named the new interface RangeQueryNode as well. I don't see any problem, since they are in different packages. ",
            "author": "Adriano Crestani",
            "id": "comment-13086132"
        },
        {
            "date": "2011-08-17T07:37:02+0000",
            "content": "I have no problems with the patch, too. We have unfortunately no real backwards tests for contribs, but I see no major problems.\n\nI will commit this soon and record merges from trunk, so the commits are related by mergeprops. What changes are still missing from trunk that will never be backported?\n\nAdriano: Can you summarize all your changes in both issues into a changes.txt entry for both branches? ",
            "author": "Uwe Schindler",
            "id": "comment-13086181"
        },
        {
            "date": "2011-08-17T12:59:12+0000",
            "content": "In 3.x we depend on Java 5, I found two interface @Override in your patch, that are not detected by Java6's javac (it's a bug there). ",
            "author": "Uwe Schindler",
            "id": "comment-13086283"
        },
        {
            "date": "2011-08-17T13:00:35+0000",
            "content": "Attached a patch that fixes the interface @Override, including all merge-props needed. ",
            "author": "Uwe Schindler",
            "id": "comment-13086286"
        },
        {
            "date": "2011-08-17T22:12:09+0000",
            "content": "\nAdriano: Can you summarize all your changes in both issues into a changes.txt entry for both branches?\n\nHi Uwe, yes, I can do it, I will need to review the entire code again (3x and trunk). I plan to do this during the weekend. But if you want, commit Vinicius's code and I commit the changes to changes.txt later  ",
            "author": "Adriano Crestani",
            "id": "comment-13086636"
        },
        {
            "date": "2011-08-17T22:13:37+0000",
            "content": "OK. Of course, also Vinicius can help  ",
            "author": "Uwe Schindler",
            "id": "comment-13086637"
        },
        {
            "date": "2011-08-18T20:45:36+0000",
            "content": "Committed 3.x revision: 1159411\n\nI keep this issue open until CHANGES.txt for trunk and 3.x is finished (including upgrade guidelines for backwards breaks). ",
            "author": "Uwe Schindler",
            "id": "comment-13087274"
        },
        {
            "date": "2011-08-18T20:59:53+0000",
            "content": "Adriano: Can you take this issue, because I will fly to California on Sunday and have no time next week? Of course, I will fill out the GSoC evaluation form once it is available online. ",
            "author": "Uwe Schindler",
            "id": "comment-13087283"
        },
        {
            "date": "2011-08-18T21:25:44+0000",
            "content": "I had to fix Javadoc warnings in 3.x revision: 1159420 ",
            "author": "Uwe Schindler",
            "id": "comment-13087303"
        },
        {
            "date": "2011-08-19T04:16:48+0000",
            "content": "Thanks for committing the patch Uwe.\n\nI tried to summarize everything I have changed so far for this JIRA. I hope this helps:\n\n\n\tnew query node interfaces: FieldValuePairQueryNode, ValueQueryNode\n\tFieldQueryNode now implements FieldValuePairQueryNode\n\ttwo new public methods added to StandardQueryParser: setNumericConfigMap and getNumericConfigMap\n\tnew query builders: DummyQueryNodeBuilder, NumericRangeQueryNodeBuilder, TermRangeQueryNodeBuilder\n\tremoved builders (trunk only): RangeQueryNodeBuilder\n\tchanges to StandardQueryTreeBuilder configuration: it now uses DummyQueryNodeBuilder for NumericQueryNodes and uses NumericRangeQueryNodeBuilder for NumericRangeQueryNodes\n\tchanges to StandardQueryTreeBuilder configuration (trunk only): removed builder for RangeQueryNodes, as this class was removed in trunk\n\tadded NumberDateFormat, that helps to parse/format dates into number and index it as numeric\n\tadded NumericConfig, used to set the numeric configuration of a certain field in the query parser. It contains information about its numeric type, how to parse/format from/to string and its precision step.\n\tadded NumericFieldConfigListener that sets the corresponding NumericConfig object to the FieldConfig object\n\tadded NUMERIC_CONFIG and NUMERIC_CONFIG_MAP constants to StandardQueryConfigHandler, used to set numeric configuration to StandardQueryConfigHandler\n\tadded AbstractRangeQueryNode that is the common parent of all currently available RangeQueryNodes\n\tadded RangeQueryNode interface, that should be implemented by all range query nodes, such as NumericRangeQueryNode and TermRangeQueryNode\n\tadded NumericQueryNode, which is equivalent to FieldQueryNode, but holds a Number instead of String\n\tadded NumericRangeQueryNode, which is equivalent to TermRangeQueryNode, but holds NumericQueryNodes instead of ParametricQueryNodes (3x)/FieldQueryNodes(trunk)\n\tadded NumericRangeQueryNodeProcessor, that processes RangeQueryNodes and convert them to NumericRangeQueryNodes when its field is configured as numeric\n\tadded NumericQueryNodeProcessor, which converts FieldQueryNodes into NumericRangeQueryNodes (lower bound == upper bound) when the field is configured as numeric\n\t(trunk only) ParametricRangeQueryNodeProcessor now creates TermRangeQueryNode instead of RangeQueryNode from ParametricRangeQueryNode\n\tchanged StandardQueryNodeProcessorPipeline configuration: NumericQueryNodeProcessor followed by NumericRangeQueryNodeProcessor are executed right after LowercaseExpandedTermsQueryNodeProcessor\n\t(3x only) deprecated RangeQueryNode, TermRangeQueryNode should be used instead\n\t(3x only) deprecated ParametricQueryNode, FieldQueryNode should be used instead and the compare operators should be set using RangeQueryNode.setLowerBoundInclusive and RangeQueryNode.setUpperBoundInclusive methods\n\n ",
            "author": "Vinicius Barros",
            "id": "comment-13087515"
        },
        {
            "date": "2011-08-19T04:18:11+0000",
            "content": "Right now I am reviewing the API changes I did in 3x and trying to replicate it back to trunk (removing deprecated classes, etc). I should have a new patch soon. ",
            "author": "Vinicius Barros",
            "id": "comment-13087516"
        },
        {
            "date": "2011-08-20T02:23:51+0000",
            "content": "Hi Vinicius,\n\nThanks for the info, but maybe it is too much details for the changes.txt. Let me try to simplify it.\n\n(3.x)\n\nNew features:\nLUCENE-1768: added support for numeric ranges in contrib query parser; added support for simple numeric queries, such as <age:4>, in contrib query parser (Vinicius Barros via Uwe Schindler)\n\nChanges in runtime behavior:\nLUCENE-1768: StandardQueryConfigHandler now uses NumericFieldConfigListener to set a NumericConfig to its corresponding FieldConfig; StandardQueryTreeBuilder now uses DummyQueryNodeBuilder for NumericQueryNodes and uses NumericRangeQueryNodeBuilder for NumericRangeQueryNodes; StandardQueryNodeProcessorPipeline now executes NumericQueryNodeProcessor followed by NumericRangeQueryNodeProcessor right after LowercaseExpandedTermsQueryNodeProcessor; (Vinicius Barros via Uwe Schindler)\n\nAPI changes: \nLUCENE-1768: setNumericConfigMap and getNumericConfigMap were added to StandardQueryParser; ParametricRangeQueryNode and oal.queryParser.standard.nodes.RangeQueryNode now implement oal.queryParser.core.nodes.RangeQueryNode; oal.queryParser.core.nodes.RangeQueryNode was deprecated and now extends TermRangeQueryNode, which extends AbstractRangeQueryNode; ParametricQueryNode was deprecated; FieldQueryNode now implements the new FieldValueQueryNode<CharSequence>, which this last one implements FieldableQueryNode and thew new ValueQueryNode; (Vinicius Barros via Uwe Schindler)\n\n\n(trunk)\n\nChanges in runtime behavior:\nLUCENE-1768: StandardQueryTreeBuilder uses RangeQueryNodeBuilder for RangeQueryNodes, since theses two classes were removed; ParametricRangeQueryNodeProcessor now creates TermRangeQueryNode, instead of RangeQueryNode, from ParametricRangeQueryNode (Vinicius Barros via Uwe Schindler)\n\nAPI Changes:\nLUCENE-1768: ParametricRangeQueryNode now implements RangeQueryNode<FieldQueryNode> instead of RangeQueryNode<ParametricQueryNode> (Vinicius Barros via Uwe Schindler)\n\nVinicius, please, review the summary I wrote above, I hope I could simplify correctly what you summarized. The API Changes for trunk I am assuming you are going to remove ParametricQueryNode(deprecated) and replace by FieldQueryNode in that statement.\n\nUwe, I hope this helps  ",
            "author": "Adriano Crestani",
            "id": "comment-13088110"
        },
        {
            "date": "2011-08-21T04:18:32+0000",
            "content": "I have changed again trunk to reflect the latest changes on 3x.\n\nI also realized that ParametricRangeQueryNode and TermRangeQueryNode are basically the same, so I decided to removed ParametricRangeQueryNode and only use TermRangeQueryNode. Everything seems to be working fine. Let me know if I should not have done that for any reason.\n\nI have some few changes on 3x to submit yet, but I was wondering: is it necessary to deprecate a class in 3x if it's ONLY going to be removed in 4.0? Not sure if I understand how these things work yet. ",
            "author": "Vinicius Barros",
            "id": "comment-13088311"
        },
        {
            "date": "2011-08-21T04:20:02+0000",
            "content": "Thanks Adriano, your summary looks better!\n\nTo trunk behavior changes, I would add that \"StandardSyntaxParser\" no longer outputs ParametricRangeQueryNodes for range queries, instead, it outputs TermRangeQueryNodes. ",
            "author": "Vinicius Barros",
            "id": "comment-13088312"
        },
        {
            "date": "2011-09-07T22:43:11+0000",
            "content": "Hi Vinicius, any news for trunk? We want to release Lucene 3.4.0, just to confirm: Are we finished with the 3.x branch? I will just quickly add the changes entry as suggested by Adriano. ",
            "author": "Uwe Schindler",
            "id": "comment-13099626"
        },
        {
            "date": "2011-09-08T05:04:15+0000",
            "content": "Sorry Uwe, college is taking my time again.\n\nHere are the latest changes, for trunk and 3x.\n\nTests are passing for both. ",
            "author": "Vinicius Barros",
            "id": "comment-13099944"
        },
        {
            "date": "2011-09-08T06:23:58+0000",
            "content": "Hi Adriano,\n\nthanks. For applying the patch you have to first do a svn rename:\nmodules/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/processors/ParametricRangeQueryNodeProcessor.java -> modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/processors/TermRangeQueryNodeProcessor.java\n\nAfter doing this, the patch applies. I will verify the changes and respond back later.\nI will apply the 3.x javadoc/code changes to the 3.x and 3.4 branches. ",
            "author": "Uwe Schindler",
            "id": "comment-13100102"
        },
        {
            "date": "2011-09-08T10:56:35+0000",
            "content": "The cleanups in trunk look fine, I think we can commit them. The tests did not change so I am confident that they break nothing.\n\nI think we can resolve this issue after those. Nice work! ",
            "author": "Uwe Schindler",
            "id": "comment-13100217"
        },
        {
            "date": "2011-09-08T16:50:32+0000",
            "content": "Committed final changes to trunk revision: 1166789\nCommitted Javadocs/deprecation changes + changes.txt to 3.x branch revision: 1166536; 3.4 release branch revision: 1166538 ",
            "author": "Uwe Schindler",
            "id": "comment-13100441"
        },
        {
            "date": "2011-09-08T16:51:22+0000",
            "content": "If you have any more comments, please reopen, I think this is resolved now.\n\nThanks Vinicius, good work! ",
            "author": "Uwe Schindler",
            "id": "comment-13100443"
        },
        {
            "date": "2011-09-08T23:37:11+0000",
            "content": "Hi Uwe,\n\nThat's it. No, I don't have any other changes in my workspace.\n\nIt was nice working with you, thanks! ",
            "author": "Vinicius Barros",
            "id": "comment-13100792"
        },
        {
            "date": "2015-02-13T21:11:59+0000",
            "content": "Though this is old and Lucene 3.x is not supported anymore, We have found a bug in our old indexing service cause by the RangeQueryNode. It has been incorrectly implemented back in 3.4. The logic is reversed compared to the fix in 4.0 thus making it unusable.\n\nThat is the logic in 3.x:\n\nsuper(lower, upper, lower.getOperator() == CompareOperator.LE, upper\n        .getOperator() == CompareOperator.GE);\n\n\n\nand the logic in 4.x:\n\nreturn new TermRangeQueryNode(lower, upper,\n          lower.getOperator() == CompareOperator.GE,\n          upper.getOperator() == CompareOperator.LE);\n\n ",
            "author": "Michael Osipov",
            "id": "comment-14320767"
        }
    ]
}