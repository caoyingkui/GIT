{
    "id": "LUCENE-5014",
    "title": "ANTLR Lucene query parser",
    "details": {
        "components": [
            "core/queryparser",
            "modules/queryparser"
        ],
        "fix_versions": [],
        "affect_versions": "4.3",
        "priority": "Major",
        "labels": "",
        "type": "Improvement",
        "resolution": "Unresolved",
        "status": "Open"
    },
    "description": "I would like to propose a new way of building query parsers for Lucene.  Currently, most Lucene parsers are hard to extend because they are either written in Java (ie. the SOLR query parser, or edismax) or the parsing logic is 'married' with the query building logic (i.e. the standard lucene parser, generated by JavaCC) - which makes any extension really hard.\n\n\nFew years back, Lucene got the contrib/modern query parser (later renamed to 'flexible'), yet that parser didn't become a star (it must be very confusing for many users). However, that parsing framework is very powerful! And it is a real pity that there aren't more parsers already using it - because it allows us to add/extend/change almost any aspect of the query parsing. \n\nSo, if we combine ANTLR + queryparser.flexible, we can get very powerful framework for building almost any query language one can think of. And I hope this extension can become useful.\n\nThe details:\n\n\n\tevery new query syntax is written in EBNF, it lives in separate files (and can be tested/developed independently - using 'gunit')\n\tANTLR parser generates parsing code (and it can generate parsers in several languages, the main target is Java, but it can also do Python - which may be interesting for pylucene)\n\tthe parser generates AST (abstract syntax tree) which is consumed by a  'pipeline' of processors, users can easily modify this pipeline to add a desired functionality\n\tthe new parser contains a few (very important) debugging functions; it can print results of every stage of the build, generate AST's as graphical charts; ant targets help to build/test/debug grammars\n\tI've tried to reuse the existing queryparser.flexible components as much as possible, only adding new processors when necessary\n\n\n\nAssumptions about the grammar:\n\n\tevery grammar must have one top parse rule called 'mainQ'\n\tparsers must generate AST (Abstract Syntax Tree)\n\n\n\nThe structure of the AST is left open, there are components which make assumptions about the shape of the AST (ie. that MODIFIER is parent of a a FIELD) however users are free to choose/write different processors with different assumptions about the AST shape.\n\n\n\nMore documentation on how to use the parser can be seen here:\n\nhttp://29min.wordpress.com/category/antlrqueryparser/\n\n\nThe parser has been created more than one year back and is used in production (http://labs.adsabs.harvard.edu/adsabs/). A different dialects of query languages (with proximity operatos, functions, special logic etc) - can be seen here: \n\nhttps://github.com/romanchyla/montysolr/tree/master/contrib/adsabs\nhttps://github.com/romanchyla/montysolr/tree/master/contrib/invenio",
    "attachments": {
        "LUCENE-5014.txt": "https://issues.apache.org/jira/secure/attachment/12584412/LUCENE-5014.txt"
    },
    "issue_links": {},
    "comments": [
        {
            "date": "2013-05-23T00:27:13+0000",
            "content": "Patch without binary files (if possible, use the other patch) ",
            "author": "Roman Chyla",
            "id": "comment-13664733"
        },
        {
            "date": "2013-05-23T00:28:15+0000",
            "content": "Includes binary files (ie. one jar and xls)\n\nsvn diff --force --diff-cmd /usr/bin/diff -x -au > LUCENE-5014.txt ",
            "author": "Roman Chyla",
            "id": "comment-13664735"
        },
        {
            "date": "2013-05-27T04:19:55+0000",
            "content": "Interesting.  Just read your description but didn't look at the 2.5MB patch file \n\nAt Lucene Revolution I saw a cool presentation by John Berryman that showed off using Parboiled, which uses a new innovative approach to making a parser.  I was quite impressed by how easy to use it was vs the classic incumbents (specifically ANTLR).  I am curious what you think, in relation to your aims in this patch. ",
            "author": "David Smiley",
            "id": "comment-13667456"
        },
        {
            "date": "2013-05-27T19:01:06+0000",
            "content": "Hi David,\nIn practical terms ANTLR can do exactly the same thing as PEG (ie lookahead, backtracking,memoization) - see this http://stackoverflow.com/questions/8816759/ll-versus-peg-parsers-what-is-the-difference\n\nBut it is also capable of doing more things than PEG (ie. better error recovery - PEG parser needs to parse the whole tree before it discovers an error; then the error recovery is not the same thing)\n\nPEG's can be easier especially because of the first-choice operator; in fact at times I wished that ANTLR just chose the first available option (well, it does, but it reports and error and I didn't want to have grammar with errors). So, in CFG&ANTLR world, ambiguity is solved using syntactic predicates (lookahead) \u2013 so far, this has been a theoretical, here are few more points:\n\nGrammar vs code\n===============\n\nI looked at the presentation and the parser contains the operator precedence, however there it is spread across several screens of java code, i find the following much more readable\n\n\nmainQ : \n  clauseOr+ EOF\n  ;\n  \nclauseOr\n  : clauseAnd (or clauseAnd )*\n  ;\n\nclauseAnd\n  : clauseNot  (and clauseNot)*\n  ; ....\n\n\n\nIt is essentially the same thing, but it is independent of the Java and I can see it on few lines - and extend it adding few more lines. The patch I wrote makes the handling of separate grammar and generated code seamless. So the 2/3 advantages of PEG over ANTLR disappear.\n\n\nSyntax vs semantics (business logic)\n====================================\n\nThe example from the presentation needs to be much more involved if it is to be used in the real life. Consider this query:\n\n\ndog NEAR cat\n\n\n\nThis is going to work only in the simplest case, where each term is a single TermQuery. Yet if there was a synonym expansion (where would it go inside the PEG parser, is one question) - the parser needs to rewrite the query \n\nsomething like:\n\n\n(dog|canin) NEAR cat --> (dog NEAR cat) OR (canin NEAR cat)\n\n\n\nSo, there you get the 'spaghetti problem' - in the example presented, the logic that rewrites the query must reside in the same place as the query parsing. That is not an improvement IMO, it is the same thing as the old Lucene parsers written in JavaCC which are very difficult to extend or debug\n\nI think I'll add a new grammar with the proximity operators so that you can see how easy it is to solve the same situation with ANTLR (but you will need to read the patch this time ) btw. the patch is big because i included the html with SVG charts of the generated parse trees and one Excel file (that one helps in writing unittest for the grammar)\n\n\nDeveloper vs user experience\n============================\n\nI think PEG definitely looks simpler to developers (in the presented example) and its main advantage is the first-choice operator. But since ANTLR can do the same and it has programming language independent grammar, it can do the same job. The difference may be in maturity of the project, tools available (ie debuggers) - and of course implementation (see the link above for details)\n\nI can imagine that for PEG you can use your IDE of choice, while with ANTLR there is this 'pesky' level of abstraction - but there are tools that make life bearable, such as ANTLRWorks or Eclipse ANTLR debugger (though I have not liked that one); grammar unittest and I added ways to debug/view the grammar. If you apply the patch, you can try:\n\n\nant -f aqp-build.xml gunit\n# edit StandardLuceneGrammar and save as 'mytestgrammar'\nant -f aqp-build.xml try-view -Dquery=\"foo NEAR bar\" -Dgrammar=mytestgrammar\n\n\n\n\nThere may be of course more things to consider, but I believe the 3 issues above present some interesting vantage points. ",
            "author": "Roman Chyla",
            "id": "comment-13667908"
        },
        {
            "date": "2013-06-27T23:10:15+0000",
            "content": "Adding an example, standard lucene grammar extended with NEAR operators (as discussed above)\n\nThis should illustrate how easy it is to extend/modify/add a new query dialect. Handling of NEAR operators is not at all trivial, so I hope you will have some fun realizing it can be done in two lines \n\n\n\nsetGrammarName(\"ExtendedLuceneGrammar\");\n((AqpQueryTreeBuilder) qp.getQueryBuilder()).setBuilder(AqpNearQueryNode.class,\tnew AqpNearQueryNodeBuilder());\n\n\n\nHave a look at TestAqpExtendedLGSimple ",
            "author": "Roman Chyla",
            "id": "comment-13695149"
        },
        {
            "date": "2013-06-27T23:11:21+0000",
            "content": "The same patch + lucene grammar extended with NEARx operator ",
            "author": "Roman Chyla",
            "id": "comment-13695150"
        },
        {
            "date": "2013-06-28T16:17:20+0000",
            "content": "The patch that actually contains the extended parser with NEAR operator support ",
            "author": "Roman Chyla",
            "id": "comment-13695542"
        },
        {
            "date": "2013-07-03T13:51:47+0000",
            "content": "Roman - I see \"SOLR\" mentions in the patch, but this is purely at the lucene module level in this patch, right?  At least the mentions should be removed, but anything else needs adjusting?   Is there Solr QParserPlugin stuff you're contributing as well? ",
            "author": "Erik Hatcher",
            "id": "comment-13698970"
        },
        {
            "date": "2013-07-03T14:01:09+0000",
            "content": "HiErik, i'll add a solr qparser plugin too. thanks for reminding me.  ",
            "author": "Roman Chyla",
            "id": "comment-13698981"
        },
        {
            "date": "2013-07-03T14:04:50+0000",
            "content": "will it be OK to include the solr parts in this ticket? besides the jira name, that seems s aa best option to me. ",
            "author": "Roman Chyla",
            "id": "comment-13698985"
        },
        {
            "date": "2013-07-03T14:15:08+0000",
            "content": "will it be OK to include the solr parts in this ticket?\n\nSeems the best way to do it to me as well.  It's probably not more than a few lines of code as a thin shim factory. ",
            "author": "Erik Hatcher",
            "id": "comment-13699005"
        },
        {
            "date": "2013-07-03T20:49:41+0000",
            "content": "New addition: solr qparser plugin. \n\nIt is unfortunately not as easy as one may think, because of various defaults - e.g. user may want to specify different defaultField, whether wildcards are allowed at the beginning, what is the maximum range for proximity values... some of which should be only in solrconfig.xml, and some also in query params. \n\nSo here is a stab at it, it works, but may require more config options - there is also a new unittest. Only that Ivy mirrors decided to not work now (ughhh) so I could not test solr unittests - ihope it works. Lucene's 'ant test' went fine. \n\nIf sb wants to try in solr, please make sure you have antlr-runtime.jar in your solr libs and this should go inside solrconfig.xml\n\n\n<queryParser name=\"lucene2\" class=\"AqpLuceneQParserPlugin\">\n    <lst name=\"defaults\">\n       <str name=\"defaultField\">text</str>\n    </lst>\n  </queryParser>\n\n ",
            "author": "Roman Chyla",
            "id": "comment-13699417"
        },
        {
            "date": "2013-07-03T20:50:31+0000",
            "content": "Added solr qparserplugin ",
            "author": "Roman Chyla",
            "id": "comment-13699418"
        }
    ]
}