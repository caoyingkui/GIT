{
    "id": "LUCENE-2308",
    "title": "Separately specify a field's type",
    "details": {
        "labels": "",
        "priority": "Major",
        "components": [
            "core/index"
        ],
        "type": "Improvement",
        "fix_versions": [
            "4.0"
        ],
        "affect_versions": "None",
        "resolution": "Fixed",
        "status": "Closed"
    },
    "description": "This came up from dicussions on IRC.  I'm summarizing here...\n\nToday when you make a Field to add to a document you can set things\nindex or not, stored or not, analyzed or not, details like omitTfAP,\nomitNorms, index term vectors (separately controlling\noffsets/positions), etc.\n\nI think we should factor these out into a new class (FieldType?).\nThen you could re-use this FieldType instance across multiple fields.\n\nThe Field instance would still hold the actual value.\n\nWe could then do per-field analyzers by adding a setAnalyzer on the\nFieldType, instead of the separate PerFieldAnalzyerWrapper (likewise\nfor per-field codecs (with flex), where we now have\nPerFieldCodecWrapper).\n\nThis would NOT be a schema!  It's just refactoring what we already\nspecify today.  EG it's not serialized into the index.\n\nThis has been discussed before, and I know Michael Busch opened a more\nambitious (I think?) issue.  I think this is a good first baby step.  We could\nconsider a hierarchy of FIeldType (NumericFieldType, etc.) but maybe hold\noff on that for starters...",
    "attachments": {
        "LUCENE-2308-merge-1.patch": "https://issues.apache.org/jira/secure/attachment/12490573/LUCENE-2308-merge-1.patch",
        "LUCENE-2308-merge-3.patch": "https://issues.apache.org/jira/secure/attachment/12491059/LUCENE-2308-merge-3.patch",
        "LUCENE-2308.branchdiffs.moved": "https://issues.apache.org/jira/secure/attachment/12490473/LUCENE-2308.branchdiffs.moved",
        "LUCENE-2308-12.patch": "https://issues.apache.org/jira/secure/attachment/12486337/LUCENE-2308-12.patch",
        "LUCENE-2308-7.patch": "https://issues.apache.org/jira/secure/attachment/12485814/LUCENE-2308-7.patch",
        "LUCENE-2308.patch": "https://issues.apache.org/jira/secure/attachment/12474583/LUCENE-2308.patch",
        "LUCENE-2308-6.patch": "https://issues.apache.org/jira/secure/attachment/12485484/LUCENE-2308-6.patch",
        "LUCENE-2308-branch.patch": "https://issues.apache.org/jira/secure/attachment/12491283/LUCENE-2308-branch.patch",
        "LUCENE-2308-merge-2.patch": "https://issues.apache.org/jira/secure/attachment/12490685/LUCENE-2308-merge-2.patch",
        "LUCENE-2308-17.patch": "https://issues.apache.org/jira/secure/attachment/12487743/LUCENE-2308-17.patch",
        "LUCENE-2308-14.patch": "https://issues.apache.org/jira/secure/attachment/12486465/LUCENE-2308-14.patch",
        "LUCENE-2308-13.patch": "https://issues.apache.org/jira/secure/attachment/12486350/LUCENE-2308-13.patch",
        "LUCENE-2308-final.patch": "https://issues.apache.org/jira/secure/attachment/12491648/LUCENE-2308-final.patch",
        "LUCENE-2308-4.patch": "https://issues.apache.org/jira/secure/attachment/12483723/LUCENE-2308-4.patch",
        "LUCENE-2308-3.patch": "https://issues.apache.org/jira/secure/attachment/12483699/LUCENE-2308-3.patch",
        "LUCENE-2308-19.patch": "https://issues.apache.org/jira/secure/attachment/12488432/LUCENE-2308-19.patch",
        "LUCENE-2308-5.patch": "https://issues.apache.org/jira/secure/attachment/12485180/LUCENE-2308-5.patch",
        "LUCENE-2308-8.patch": "https://issues.apache.org/jira/secure/attachment/12485968/LUCENE-2308-8.patch",
        "LUCENE-2308-ltc.patch": "https://issues.apache.org/jira/secure/attachment/12486105/LUCENE-2308-ltc.patch",
        "LUCENE-2308-10.patch": "https://issues.apache.org/jira/secure/attachment/12486119/LUCENE-2308-10.patch",
        "LUCENE-2308-2.patch": "https://issues.apache.org/jira/secure/attachment/12483035/LUCENE-2308-2.patch",
        "LUCENE-2308-15.patch": "https://issues.apache.org/jira/secure/attachment/12486929/LUCENE-2308-15.patch",
        "LUCENE-2308-21.patch": "https://issues.apache.org/jira/secure/attachment/12489571/LUCENE-2308-21.patch",
        "LUCENE-2308-16.patch": "https://issues.apache.org/jira/secure/attachment/12487593/LUCENE-2308-16.patch",
        "LUCENE-2308-20.patch": "https://issues.apache.org/jira/secure/attachment/12489245/LUCENE-2308-20.patch",
        "LUCENE-2308-11.patch": "https://issues.apache.org/jira/secure/attachment/12486333/LUCENE-2308-11.patch",
        "LUCENE-2308.branchdiffs": "https://issues.apache.org/jira/secure/attachment/12490455/LUCENE-2308.branchdiffs",
        "LUCENE-2308-9.patch": "https://issues.apache.org/jira/secure/attachment/12486088/LUCENE-2308-9.patch",
        "LUCENE-2308-18.patch": "https://issues.apache.org/jira/secure/attachment/12488232/LUCENE-2308-18.patch",
        "LUCENE-2308-FT-interface.patch": "https://issues.apache.org/jira/secure/attachment/12492580/LUCENE-2308-FT-interface.patch"
    },
    "issue_links": {},
    "comments": [
        {
            "date": "2010-03-11T17:46:22+0000",
            "content": "Hi Mike,\n\n+1 to this idea.\n\nDo you envisage FieldType instances being immutable or would you be able to change the Analyzer on a FieldType?  If they are mutable, would you see FieldType instances being shared across multiple Fields? Or would each Field have its own FieldType instance? ",
            "author": "Chris Male",
            "id": "comment-12844150"
        },
        {
            "date": "2010-03-11T17:58:06+0000",
            "content": "I think immutable & shareable across Field instances for sure and presumably also across different fields?\n\nAnd maybe we should have some hierarchy, eg analyzed or not.\n\nI think it's important that we contain this to the baby steps (eg not ambitiously make a huge type hierarchy) \u2013 it really is just pulling out the \"type-like\" configuration from Field, leaving just the actual value of the field on Field. ",
            "author": "Michael McCandless",
            "id": "comment-12844153"
        },
        {
            "date": "2010-03-11T18:02:47+0000",
            "content": "Yeah I agree with the immutability and shareability.\n\nI'll give this a shot, with taking the babiest of baby steps. ",
            "author": "Chris Male",
            "id": "comment-12844154"
        },
        {
            "date": "2010-03-12T17:32:37+0000",
            "content": "\ndetails like omitTfAP, omitNorms\n\npersonal pet peeve, i wonder if we could consider improving on 'omit' here,\nI think things like omit(false), disable(false) are a little awkward. ",
            "author": "Robert Muir",
            "id": "comment-12844578"
        },
        {
            "date": "2010-03-12T17:40:25+0000",
            "content": "So you are thinking more along the lines indexNorms(true|false)? ",
            "author": "Chris Male",
            "id": "comment-12844579"
        },
        {
            "date": "2010-03-12T17:51:01+0000",
            "content": "So you are thinking more along the lines indexNorms(true|false)? \n\nor whatever you come up with, that doesn't create double-negatives!\nbut yeah, i think something like that is a little easier... no big deal \njust figured I would bring it up if this stuff was getting refactored anyway ",
            "author": "Robert Muir",
            "id": "comment-12844585"
        },
        {
            "date": "2010-03-12T17:54:46+0000",
            "content": "I agree entirely.  This is definitely the moment to remove any ambiguity or confusion in this API.  I'll make sure to incorporate this idea. ",
            "author": "Chris Male",
            "id": "comment-12844587"
        },
        {
            "date": "2010-03-12T19:17:25+0000",
            "content": "I think we might consider matchOnly() instead of omitNorms().  If a field is\n\"match only\", we don't need boost bytes a.k.a. \"norms\" because they are only\nused as a scoring multiplier.\n\nHaven't got a good synonym for \"omitTFAP\", but I'd sure like one. ",
            "author": "Marvin Humphrey",
            "id": "comment-12844626"
        },
        {
            "date": "2010-03-12T19:22:02+0000",
            "content": "How about enable(TYPE/FEATURE) and corresponding disable? So Type/Feature will have NORMS, TF, POSITIONS and calls would look like:\nf.enable(Type.NORMS), f.disable(Type.TF)? ",
            "author": "Shai Erera",
            "id": "comment-12844629"
        },
        {
            "date": "2010-03-12T19:26:35+0000",
            "content": "Just also to mention (probably too much for this one issue)!\n\nI think it would be nice of OmitTF was separately selectable \nfrom OmitPositions, as Shai implied. We would have to\nactually implement this though I think! ",
            "author": "Robert Muir",
            "id": "comment-12844630"
        },
        {
            "date": "2010-03-12T19:41:44+0000",
            "content": "If you disable term freq, you also have to disable positions.  The \"freq\" \ntells you how many positions there are.\n\nI think it's asking an awful lot of our users to require that they understand\nall the implications of posting format modifications when committers \nhave difficulty mastering all the subtleties. ",
            "author": "Marvin Humphrey",
            "id": "comment-12844637"
        },
        {
            "date": "2010-03-12T20:05:18+0000",
            "content": "\nIf you disable term freq, you also have to disable positions. The \"freq\"\ntells you how many positions there are. \n\nMarvin: as stated, we would have to actually implement this.\nThere's an issue open for it too: LUCENE-2048.\nI was just discussing this with someone the other day.\n\n\nI think it's asking an awful lot of our users to require that they understand\nall the implications of posting format modifications when committers\nhave difficulty mastering all the subtleties.\n\nI don't know what I did to piss you off, but I just thought it would be nice\nfor completeness, to mention that this feature is still open and its\nsomething we should think about. ",
            "author": "Robert Muir",
            "id": "comment-12844653"
        },
        {
            "date": "2010-03-12T20:20:26+0000",
            "content": "I'm simply suggesting that the proposed API is too hard to understand.  \n\nMost users know whether their fields can be \"match-only\" but have no idea what\nTFAP is.  And even advanced users will have difficulty understanding all the\nimplications for matching and scoring when they selectively disable portions\nof the posting format.\n\nI'm not a fan of omitTFAP, omitTF, omitNorms, omitPositions, or omit(flags).\nSomething that ordinary users can grok would be used more often and more\neffectively. ",
            "author": "Marvin Humphrey",
            "id": "comment-12844659"
        },
        {
            "date": "2010-03-12T20:25:34+0000",
            "content": "What I covered with Mike earlier was whether FieldType methods would be immutable or not.  \n\nIf they are, which seems a good idea, then everything will be enabled/disabled in the construction of the FieldType so we would only need to support property getter methods. ",
            "author": "Chris Male",
            "id": "comment-12844661"
        },
        {
            "date": "2010-03-12T21:10:46+0000",
            "content": "Hmm one challenge with making FieldType immutable is.... we don't want\na zillion ctors over time.  Also creating a FieldType with args like\nnew FieldType(true, false, false) isn't really readable.\n\nIt would be nice if we could do something similar to IndexWriterConfig\n(LUCENE-2294), where you use incremental ctor/setters to set up the\nconfiguration but then once it's used (\"bound\" to a Field), it's\nimmutable.\n\nI'm torn on naming: yes, search-oriented names like \"matchOnly\" is\ntempting, but then we really should tease apart termFreq and positions\n(they are stuck together now with omitTFAP).  And the two are not\nfully independent as Marvin noted \u2013 so maybe we use a cryptic enum\n(DOCS, DOCS_TERM_FREQ, DOCS_TERM_FREQ_POSITIONS)?  If we can only find\nbetter names...\n\nI'm not sure we can/should find better index-time names.  What is\nstored in the index is relatively independent from how/whether\nsearches make use of it.  EG if you store termFreq (but not positions)\nyou can still do match only searching, or, you can do full scoring of\nthe query.  You can't use positional queries. ",
            "author": "Michael McCandless",
            "id": "comment-12844684"
        },
        {
            "date": "2010-03-12T21:21:20+0000",
            "content": "> Also creating a FieldType with args like\n> new FieldType(true, false, false) isn't really readable. \n\nAgreed Another option would be a \"flags\" integer and bitwise constants:\n\n\nFieldType type = new FieldType(analyzer, FieldType.INDEXED | FieldType.STORED);\n\n\n\n> It would be nice if we could do something similar to IndexWriterConfig\n> (LUCENE-2294), where you use incremental ctor/setters to set up the\n> configuration but then once it's used (\"bound\" to a Field), it's\n> immutable.\n\nI bet that'll be more popular than flags, but I thought it was worth\nbringing it up anyway.  ",
            "author": "Marvin Humphrey",
            "id": "comment-12844688"
        },
        {
            "date": "2010-03-12T21:28:56+0000",
            "content": "I'm strongly against names like 'matchOnly'. They are perfectly fine in some 'schema' layer over Lucene, but here, in lowlevel guts, I'd prefer names that clearly state what the hell do they do, without forcing me to consult javadocs/code. ",
            "author": "Earwin Burrfoot",
            "id": "comment-12844690"
        },
        {
            "date": "2010-03-12T21:41:05+0000",
            "content": "For the non-expert user, it's just a label and won't have much meaning regardless of what it's called, and they will need to consult the docs.  Of course, if one starts to dig deeper, \"norms\" actually does have a physical meaning in the index, so preferring a label with \"norms\" in it seems completely reasonable.\n\nThere's also history to consider - when you change the name of something, you cut the link to the past in search engines, and in the memories of many developers.\n\nAs it relates to Solr - I don't care so much since it makes sense for the Solr schema to isolate these changes and stick with \"omitNorms\" regardless. ",
            "author": "Yonik Seeley",
            "id": "comment-12844700"
        },
        {
            "date": "2010-03-12T21:42:05+0000",
            "content": "\nIt would be nice if we could do something similar to IndexWriterConfig\n(LUCENE-2294), where you use incremental ctor/setters to set up the\nconfiguration but then once it's used (\"bound\" to a Field), it's\nimmutable.\n\nYeah we could use something like a FieldTypeBuilder which could provide a fluid interface for specifying each property, which then get built into an immutable FieldType at the end. ",
            "author": "Chris Male",
            "id": "comment-12844702"
        },
        {
            "date": "2010-03-12T21:51:36+0000",
            "content": "I'm not sure if strict immutability is necessary - there's everything in between too.\nOne can simply say that all changes should be made before first use, and after that point it's undefined.\n\nUnrelated question: I assume that this would retain the same flexibility as we have today... the ability to change FieldType for field \"foo\" from one document to the next? ",
            "author": "Yonik Seeley",
            "id": "comment-12844707"
        },
        {
            "date": "2010-03-12T22:00:51+0000",
            "content": "\nI'm not sure if strict immutability is necessary - there's everything in between too.\nOne can simply say that all changes should be made before first use, and after that point it's undefined.\n\nI'm really unsure about this if people are going to be using a FieldType instance with multiple Fields.  Perhaps this really is just an edge case though.\n\n\nUnrelated question: I assume that this would retain the same flexibility as we have today... the ability to change FieldType for field \"foo\" from one document to the next?\n\nAre you wanting to be able to reuse the same Field instance in both documents while defining separate FieldTypes? Or is creating new Field instances okay? ",
            "author": "Chris Male",
            "id": "comment-12844710"
        },
        {
            "date": "2010-03-12T22:13:45+0000",
            "content": "I'm really unsure about this if people are going to be using a FieldType instance with multiple Fields.\n\nI will, if I can (provided the FieldType does not contain the field name).  That shouldn't have anything to do with immutability though.\n\nAre you wanting to be able to reuse the same Field instance in both documents while defining separate FieldTypes? Or is creating new Field instances okay?\n\nnew Field instances should be fine - it's not really my use case anyway.  But we're designing for the 1000's of use cases that are out there and we should be careful about adding new constraints. ",
            "author": "Yonik Seeley",
            "id": "comment-12844716"
        },
        {
            "date": "2010-03-12T22:23:38+0000",
            "content": "\nI will, if I can (provided the FieldType does not contain the field name). That shouldn't have anything to do with immutability though.\n\nYeah the field name will stay inside the Field.  To me the reuse issue relates immutability in that a change to a property in one FieldType after construction means the change effects all the Fields that use that type.  \n\nBut as you say, if we document that its best to set everything at instantiation and that whatever happens after that is undefined, then I imagine it'll be fine.\n\n\nnew Field instances should be fine - it's not really my use case anyway. But we're designing for the 1000's of use cases that are out there and we should be careful about adding new constraints.\n\nYeah I appreciate that this API will be used in lots of different ways.  Baby steps as Mike said   But to answer your question, yes the flexibility will remain. ",
            "author": "Chris Male",
            "id": "comment-12844720"
        },
        {
            "date": "2010-03-12T22:30:24+0000",
            "content": "Of course... given that Fieldable is an interface, one could create an implementation that just delegated all the calls like omitNorms to a shared instance, except for the value part.  Add a getAnalyzer() method to Fieldable, and it's the same thing in the end? ",
            "author": "Yonik Seeley",
            "id": "comment-12844722"
        },
        {
            "date": "2011-03-11T14:59:21+0000",
            "content": "I'm surprised to barely even see a mention to Solr here which already, of course obviously, already has a FieldType.  Might it be ported? ",
            "author": "David Smiley",
            "id": "comment-13005668"
        },
        {
            "date": "2011-03-13T12:07:56+0000",
            "content": "Brief Summary for GSoC Students:\n\nFieldType aims on the one hand to separate field properties from the\nactual value and on the other make Field's extensibility easier. Both\nseem equally important while far from easy to achieve. Fieldable and\nField are a core API and changes to it need to well thought. Further\nthis issue can easily cause drastic performance degradation if not\ndone right. Consider this as a massive change since fields are used\nalmost all over lucene and solr. ",
            "author": "Simon Willnauer",
            "id": "comment-13006182"
        },
        {
            "date": "2011-03-13T12:10:28+0000",
            "content": "I'm surprised to barely even see a mention to Solr here which already, of course obviously, already has a FieldType. Might it be ported?\n\nMoving stuff from Solr to Lucene involves lots of politics. It is way easier to let Solr adopt eventually than fight your way through the politics (this is my opinion though.)  ",
            "author": "Simon Willnauer",
            "id": "comment-13006184"
        },
        {
            "date": "2011-03-13T12:17:24+0000",
            "content": "\nMoving stuff from Solr to Lucene involves lots of politics. It is way easier to let Solr adopt eventually than fight your way through the politics (this is my opinion though.)\n\nThen why do we still have merged codebases?\nIf this is the way things are, then we should un-merge the two projects. \n\nbecause as a lucene developer, i spend a lot of time trying to do my part to fix various things in Solr... if its a one-way-street then we need to un-merge. ",
            "author": "Robert Muir",
            "id": "comment-13006185"
        },
        {
            "date": "2011-03-13T12:40:26+0000",
            "content": "I'm surprised to barely even see a mention to Solr here which already, of course obviously, already has a FieldType. Might it be ported?\n\nI think there is a lot of overlap but Solr's FieldTypes also integrate with its schema through SchemaField so maybe its an option to port the overlap and then let Solr extend whatever is created, to provide its schema integration/Solr specific functions? ",
            "author": "Chris Male",
            "id": "comment-13006187"
        },
        {
            "date": "2011-03-13T15:55:53+0000",
            "content": "I think there is a lot of overlap but Solr's FieldTypes also integrate with its schema through SchemaField so maybe its an option to port the overlap and then let Solr extend whatever is created, to provide its schema integration/Solr specific functions?\n\nYeah, that seems reasonable. ",
            "author": "Yonik Seeley",
            "id": "comment-13006213"
        },
        {
            "date": "2011-03-13T16:08:35+0000",
            "content": "\nI think there is a lot of overlap but Solr's FieldTypes also integrate with its schema through SchemaField so maybe its an option to port the overlap and then let Solr extend whatever is created, to provide its schema integration/Solr specific functions?\n\n+1 ",
            "author": "Simon Willnauer",
            "id": "comment-13006215"
        },
        {
            "date": "2011-03-25T01:17:24+0000",
            "content": "Throwing my ideas into the ring.  Currently just the implementation of FieldType (I'm waiting on LUCENE-2310 before attacking Field).  I've tried to incorporate all the various ideas suggested here.\n\n\n\tFieldType has two constructors, modeled along the same lines as what Marvin suggested.\n\n\n\n\n\tIntroduces a simplified Attribute concept (FieldTypeAttribute) that allows context specific extensions to FieldType to be added.  An example of this would be a SpatialAttribute that provides more information about the spatial information stored in a certain field.  AttributeSource and Attribute were not used since they really seem designed around the AttributeFactory idea, which seems unnecessary here, and that the content of Attributes could change often, rather than being readonly as I would prefer them here.\n\n\n\n\n\tFieldTypeBuilder provides a fluid interface for creating FieldTypes, much like IndexWriterConfig.\n\n\n\n\n\tFieldType is readonly.\n\n ",
            "author": "Chris Male",
            "id": "comment-13011061"
        },
        {
            "date": "2011-04-06T20:06:26+0000",
            "content": "Hi folks, \n\nI wrote an GSoC proposal for this issue, but I am missing a mentor for this issue. Any volonters?  ",
            "author": "Nikola Tankovic",
            "id": "comment-13016504"
        },
        {
            "date": "2011-04-06T20:45:55+0000",
            "content": "I submitted first draft of my proposal (LUCENE-2308 Separately specify a field's type), hope you can see it and give me some further pointers if needed. \nThank you! ",
            "author": "Nikola Tankovic",
            "id": "comment-13016522"
        },
        {
            "date": "2011-04-06T22:00:43+0000",
            "content": "I wrote an GSoC proposal for this issue, but I am missing a mentor for this issue. Any volonters? \ndon't worry we will find somebody to mentor! \n\nI submitted first draft of my proposal (LUCENE-2308 Separately specify a field's type), hope you can see it and give me some further pointers if needed. \n\nyep I can see it - looks good so far. ",
            "author": "Simon Willnauer",
            "id": "comment-13016571"
        },
        {
            "date": "2011-04-06T22:22:26+0000",
            "content": "Hi Nikola, I'd be happy to mentor for this issue!  Your proposal looks great. ",
            "author": "Michael McCandless",
            "id": "comment-13016582"
        },
        {
            "date": "2011-04-07T16:02:35+0000",
            "content": "Thank you Michael! I'll make some further small adjustments and add you as my mentor  ",
            "author": "Nikola Tankovic",
            "id": "comment-13017015"
        },
        {
            "date": "2011-06-02T15:37:41+0000",
            "content": "Hey Nikola,\n\nany progress on this issue already? I'd love to see some patches even a starter would be great.\n\nsimon ",
            "author": "Simon Willnauer",
            "id": "comment-13042831"
        },
        {
            "date": "2011-06-04T08:08:07+0000",
            "content": "Yes, I'm continuing along the path Chris started with his first patch, mine is coming soon.\n\nNikola ",
            "author": "Nikola Tankovic",
            "id": "comment-13044226"
        },
        {
            "date": "2011-06-04T15:37:42+0000",
            "content": "Sorry guys to keep you waiting, I had some slight problems and tight schedule. I will now continue with regular patching.\n\nProposed in patch:\n\n\tRemove from Fieldable everything that has to do with FieldType\n\tIntroduce CoreField (could be just Field) instead of AbstractField with included field type\n\n\n\nI will continue with extending CoreField with StandardField (which is now Field) and NumericField (refactored) if this proves to be OK. ",
            "author": "Nikola Tankovic",
            "id": "comment-13044312"
        },
        {
            "date": "2011-06-07T10:20:51+0000",
            "content": "I've opened LUCENE-3177 (and linked to this issue), to strongly\ndecouple what indexer needs when indexing documents/fields from what\nwe do in this issue.  Ie, LUCENE-3177 gives us more freedom here, I\nthink, to create specific concrete FieldType hierarhy for creating\ndocuments. ",
            "author": "Michael McCandless",
            "id": "comment-13045350"
        },
        {
            "date": "2011-06-07T10:21:33+0000",
            "content": "Thanks for the patch Nikola!\n\nNote: when you submit patches that you intend to donate to Apache, you\nshould remember to check the box that says \"Grant license to ASF...\",\nas long as you are the sole creator of that patch (and thus have the\nright to grant this patch the ASF).  Patches that incorporate someone\nelses source code are more interesting because we have to ensure the\nlicense is compatible with Apache's, update our LICENSE/NOTICE, etc.\n\nStepping back here... I think we should think a bit about the target\nend goal here and then work out the baby steps to get there?\n\nI think ideally once we are done here, it should be incredibly simple\nto create a document, something like this:\n\n\nDocument d = new Document();\nd.add(new TextField(title));\nd.add(new StringField(id));\nd.add(new BinaryField(bytes));\nd.add(new NumericField(price));\n\n\n\nThese classes each use a default FieldType under the hood:\n\n\n\tTextField indexes, tokenizes, with norms and TFAP\n\n\n\n\n\tStringField indexes untokenized and no norms, no TFAP (maybe)\n\n\n\n\n\tBinaryField only stores the byte[]\n\n\n\n\n\tNumericField does what it does today\n\n\n\nIf an app wants to tweak the type, it can do so, something like this:\n\n\nFieldType titleFieldType = new FieldType(Textfield.DEFAULT_TYPE);\ntitleFieldType.setOmitNorms(true);\ntitleFieldType.setOmitTFAP(true);\nd.add(new Field(titleFieldType, title));\n\n\n\nIe, the default *Field classes are sugar for binding to the common\ndefault type, but you can easily go and customize the type if you want\nto.\n\nDoes that sound \"roughly\" like the goal here....? ",
            "author": "Michael McCandless",
            "id": "comment-13045351"
        },
        {
            "date": "2011-06-07T11:30:50+0000",
            "content": "Mike, that's exactly what I needed, quick API goal summary. This looks very clean and nice to me. Next patch will continue in that direction.\n\nBasically, like I said, we should remove AbstractField and keep only Field (with Fieldable interface). Then extend Field with Text,String,Binary and Numeric. ",
            "author": "Nikola Tankovic",
            "id": "comment-13045374"
        },
        {
            "date": "2011-06-07T13:51:36+0000",
            "content": "I think we can create only Field?  Ie, no Fieldable interface nor AbstractField?\n\nI think IndexableField (LUCENE-3177) is the only interface we need? ",
            "author": "Michael McCandless",
            "id": "comment-13045428"
        },
        {
            "date": "2011-06-07T14:49:55+0000",
            "content": "Yes, IndexableField looks sufficient. ",
            "author": "Nikola Tankovic",
            "id": "comment-13045460"
        },
        {
            "date": "2011-06-09T18:02:25+0000",
            "content": "I created a new branch, where we can iterate on these interlinked issues:\n\n\n  https://svn.apache.org/repos/asf/lucene/dev/branches/fieldtype\n\n\n\nAnd I committed the initial patch from LUCENE-3177, decoupling indexer from the doc/field impl. ",
            "author": "Michael McCandless",
            "id": "comment-13046715"
        },
        {
            "date": "2011-06-18T09:57:58+0000",
            "content": "New patch: a baby step towards dividing AbstractField and Field towards Field, TextField, StringField, NumericField and BinaryField with default FieldType's. ",
            "author": "Nikola Tankovic",
            "id": "comment-13051492"
        },
        {
            "date": "2011-06-18T13:28:34+0000",
            "content": "Patch looks good, thanks Nikola!\n\nWhen you make the patch, can you run \"svn diff\" from the top-level\ndir?  Ie, so that file paths look\nlucene/src/java/org/apache/lucene/document/Field.java\n\nA couple minor code-formatting things:\n\n\n\tPlease add { } around one-line ifs, eg in FieldType.toString\n\n\n\n\n\timport lines go after the copyright (FieldType.java)\n\n\n\n\n\tIf possible please try to avoid adding \"noise\" to the patch, for\n    example re-formatting javadocs (eg NumericField.java).  It's fine\n    to clean things up (add missing {}'s to existing code) as you go,\n    but if it's simply a reformat that just adds noise which makes it\n    harder to see real changes.\n\n\n\nOther stuff:\n\n\n\tThe DEFAULT_TYPE for each field can be final right?\n\n\n\n\n\tFor FieldType, can we use direct members of the class, instead of\n    the EnumSet?  (Ie, boolean indexed, boolean stored, etc.).\n\n\n\nThe patch causes compilation errors when I run \"ant compile-core\", but\nthat's expected right?\n\nI think our immediate goal here should be to get a compilable patch\nwith tests passing, ie the \"dirt path\".  Then we can go back and\niterate.\n\nBut, because so many tests rely on the current Document/Field API... I\nthink in order to stage this we should make a totally new package,\ncall it document2 for now, and create all these new classes inside\nthere.  Then, one by one we can cutover tests to use document2/*,\nstarting with TestDemo.  Eventually, once everything is cutover, we\ncan remove document and rename document2 to document. ",
            "author": "Michael McCandless",
            "id": "comment-13051512"
        },
        {
            "date": "2011-06-18T16:52:08+0000",
            "content": "Thanks Mike,\n\neverything sound good, I'll correct suggested things, then start with document2 package!  ",
            "author": "Nikola Tankovic",
            "id": "comment-13051553"
        },
        {
            "date": "2011-06-24T12:51:00+0000",
            "content": "Patch: copied oal.doc to oal.doc2 with new FieldType changes, modified TestDocument Unit Test, but have some failures. I think it's because reference to oal.doc should change to oal.doc2 but I don't know exactly where so I need some help. I changed imports at IndexSearcher and IndexReader only. ",
            "author": "Nikola Tankovic",
            "id": "comment-13054419"
        },
        {
            "date": "2011-06-24T15:37:48+0000",
            "content": "Patch No.4: Passing TestDemo Unit test ",
            "author": "Nikola Tankovic",
            "id": "comment-13054505"
        },
        {
            "date": "2011-06-26T14:38:53+0000",
            "content": "Great \u2013 everything compiles and all core tests pass (\"ant test-core\")\nwith this patch, including TestDemo, which is the only test cutover so\nfar to the new Field/Document API!\n\nFeedback:\n\n\n\tFor the new Document (oal.document2.Document), I think we should\n    remove setBoost and require instead that apps should do this\n    multiplication themselves into the field's boost.\n\n\n\n\n\tCan you remove all methods from the new Document class, and add\n    back only what we need for the tests, as we cutover?  (Ie, vs\n    copying everything from Document).  We'll need to later iterate on\n    this API, to fix problems w/ existing Document class.  EG I don't\n    like that lookup-by-name is secretly O(N) cost, that multi-valued\n    fields are \"awkward\", and I'm not sure we should have \"sugar\"\n    methods like String getField(String name)).\n\n\n\n\n\tThe TestDemo cutover already exposes a danger w/ the new API: it's\n    modifying TextField.DEFAULT_TYPE.  I think somehow we need to make\n    these default types read-only?  EG maybe each has a \"frozen\" bit,\n    and we through IllegalStateExc if you try to change anything once\n    it's frozen?\n\n\n\nI think the next step is to cutover more and more tests... ",
            "author": "Michael McCandless",
            "id": "comment-13055092"
        },
        {
            "date": "2011-07-04T20:34:48+0000",
            "content": "Some test are cutover, more to come...\nThis fifth patch is to monitor progress, and see if something is wrong, or could be better.\n\nCutover InstantiatedDocument along the way also ",
            "author": "Nikola Tankovic",
            "id": "comment-13059603"
        },
        {
            "date": "2011-07-04T22:25:41+0000",
            "content": "Patch looks good Nikola \u2013 I'll commit it to the branch!\n\nI removed the 2 nocommits from oal.document2.Document \u2013 I think they were leftover from copying from Document. ",
            "author": "Michael McCandless",
            "id": "comment-13059628"
        },
        {
            "date": "2011-07-06T20:53:13+0000",
            "content": "Minor fixes and more tests cutover. ",
            "author": "Nikola Tankovic",
            "id": "comment-13060831"
        },
        {
            "date": "2011-07-07T17:31:25+0000",
            "content": "I'm seeing compilation errors with the last patch, eg:\n\n    [javac] /lucene/fieldtype/lucene/src/test/org/apache/lucene/index/TestSegmentMerger.java:53: setupDoc(org.apache.lucene.document2.Document) in org.apache.lucene.index.DocHelper cannot be applied to (org.apache.lucene.document.Document)\n    [javac]     DocHelper.setupDoc(doc1);\n    [javac]              ^\n\n\n\nOtherwise patch looks good! ",
            "author": "Michael McCandless",
            "id": "comment-13061451"
        },
        {
            "date": "2011-07-09T11:45:06+0000",
            "content": "Most of tests are now cutover, except those that require refactoring of IndexReader and Solr. ",
            "author": "Nikola Tankovic",
            "id": "comment-13062364"
        },
        {
            "date": "2011-07-09T19:45:21+0000",
            "content": "Some mistakes corrected in patch 8, so hopefully it is ready for commit. ",
            "author": "Nikola Tankovic",
            "id": "comment-13062606"
        },
        {
            "date": "2011-07-10T21:01:52+0000",
            "content": "Hmm I'm still hitting compilation errors here, eg:\n\n    [javac] /lucene/fieldtype/modules/analysis/common/src/test/org/apache/lucene/analysis/shingle/ShingleFilterTest.java:59: cannot find symbol\n    [javac] symbol  : variable TYPE_UNSTORED\n    [javac] location: class org.apache.lucene.analysis.tokenattributes.TypeAttributeImpl\n    [javac]         typeAtt.setType(TypeAttributeImpl.TYPE_UNSTORED);\n\n\n\nI think this is just another accidental replace of DEFAULT_TYPE... can you run a top-level \"ant test\" to make sure the patch compiles and passes tests?  Also, the javadoc changes to Token.java should be reverted too. ",
            "author": "Michael McCandless",
            "id": "comment-13062807"
        },
        {
            "date": "2011-07-11T19:02:59+0000",
            "content": "Patch 9: few more compilation errors fixed. ",
            "author": "Nikola Tankovic",
            "id": "comment-13063472"
        },
        {
            "date": "2011-07-11T19:11:33+0000",
            "content": "Great!  Tests pass and it looks like the accidental changes are gone.  I'll commit to the branch... ",
            "author": "Michael McCandless",
            "id": "comment-13063473"
        },
        {
            "date": "2011-07-11T21:24:30+0000",
            "content": "Small patch to fix LTC.newField to again randomly add in term vectors when they are disabled. ",
            "author": "Michael McCandless",
            "id": "comment-13063553"
        },
        {
            "date": "2011-07-11T23:27:37+0000",
            "content": "Solr cutover to FieldType. Having repeated similar errors in tests. Trying to debug. Help is appriciated  ",
            "author": "Nikola Tankovic",
            "id": "comment-13063606"
        },
        {
            "date": "2011-07-12T00:15:18+0000",
            "content": "Nikola tracked this down \u2013 it's because we're not reading numeric field back properly from stored fields. ",
            "author": "Michael McCandless",
            "id": "comment-13063618"
        },
        {
            "date": "2011-07-13T17:31:00+0000",
            "content": "Solr cutover, tests ok! ",
            "author": "Nikola Tankovic",
            "id": "comment-13064716"
        },
        {
            "date": "2011-07-13T17:42:06+0000",
            "content": "Patch looks good and tests pass!\n\nWhat remains to be cutover (index time)?\n\nI'll commit this patch to the branch... ",
            "author": "Michael McCandless",
            "id": "comment-13064721"
        },
        {
            "date": "2011-07-13T18:01:00+0000",
            "content": "Patch 12: Small cutover that's left ",
            "author": "Nikola Tankovic",
            "id": "comment-13064734"
        },
        {
            "date": "2011-07-13T19:10:59+0000",
            "content": "Patch 13: FieldsReader cutover /w tests ",
            "author": "Nikola Tankovic",
            "id": "comment-13064779"
        },
        {
            "date": "2011-07-14T16:20:32+0000",
            "content": "14th patch fixes lucene javadoc errors. ",
            "author": "Nikola Tankovic",
            "id": "comment-13065364"
        },
        {
            "date": "2011-07-18T17:12:46+0000",
            "content": "javadocs patch looks good \u2013 all the Lucene warnings are fixed.  I'll commit to the branch. ",
            "author": "Michael McCandless",
            "id": "comment-13067149"
        },
        {
            "date": "2011-07-18T21:38:32+0000",
            "content": "Patch 15 (untested): IR.document2 implemantation with Document2StoredFieldVisitor. More test cutover. ",
            "author": "Nikola Tankovic",
            "id": "comment-13067322"
        },
        {
            "date": "2011-07-18T22:58:06+0000",
            "content": "This seems to fail w/ the patch: ant test -Dtestcase=BasicFunctionalityTest -Dtestmethod=testLazyField -Dtests.seed=-6444563330259805074:273924987296571588 but so far other failures! ",
            "author": "Michael McCandless",
            "id": "comment-13067371"
        },
        {
            "date": "2011-07-19T10:54:35+0000",
            "content": "Patch looks good, except, you should not have to add {{IR.document2(int\ndocID, StoredFieldVisitor visitor)}}, right?  Ie, doesn't the existing\ndocument(int, StoredFieldVisitor) suffice?  The StoredFieldVisitor is\ncompletely agnostic as to whether you're creating a new vs old\nDocument. ",
            "author": "Michael McCandless",
            "id": "comment-13067615"
        },
        {
            "date": "2011-07-19T10:58:35+0000",
            "content": "Hmmm, I think I added it only 'cause of precaution, I think it is not needed. ",
            "author": "Nikola Tankovic",
            "id": "comment-13067616"
        },
        {
            "date": "2011-07-23T16:02:56+0000",
            "content": "Patch 16: Solr new StoredFieldVisitor cutover + more tests. Please validate patch, as I have some strange errors in Solr. Ty! ",
            "author": "Nikola Tankovic",
            "id": "comment-13069990"
        },
        {
            "date": "2011-07-25T17:39:53+0000",
            "content": "Patch looks good \u2013 nice you just had to add IR.document2 and not touch the subclasses (since you're just using a different visitor).\n\nBut, I see this failure: ant test -Dtestcase=HighlighterTest -Dtestmethod=testAlternateSummary -Dtests.seed=3152255204045715539:5957936590584148410 ",
            "author": "Michael McCandless",
            "id": "comment-13070628"
        },
        {
            "date": "2011-07-25T18:45:00+0000",
            "content": "P.17 (non-tested): fixed suggested issues ",
            "author": "Nikola Tankovic",
            "id": "comment-13070673"
        },
        {
            "date": "2011-07-25T19:12:40+0000",
            "content": "Looks great Nikola!  All tests pass.  I'll commit this to the branch... ",
            "author": "Michael McCandless",
            "id": "comment-13070687"
        },
        {
            "date": "2011-07-29T17:28:54+0000",
            "content": "Getting some errors, maybe someone can help or check. ",
            "author": "Nikola Tankovic",
            "id": "comment-13072933"
        },
        {
            "date": "2011-08-01T18:52:36+0000",
            "content": "Removed old oal.Document, except in documentation. Tests pass! ",
            "author": "Nikola Tankovic",
            "id": "comment-13073659"
        },
        {
            "date": "2011-08-02T00:34:49+0000",
            "content": "Patch looks good Nikola; I'll commit to the branch!\n\nI think the next step is to remove the oal.document package and any related classes (eg, DocumentStoredFieldVisitor), and then do a massive rename of doc/document2 back to doc/document? ",
            "author": "Michael McCandless",
            "id": "comment-13075978"
        },
        {
            "date": "2011-08-02T05:00:19+0000",
            "content": "Yes, exactly! That is my next step, shouldn't take long. ",
            "author": "Nikola Tankovic",
            "id": "comment-13076033"
        },
        {
            "date": "2011-08-03T20:29:02+0000",
            "content": "Removed old oal.document and replaced with new one completely. Now I need to fix javadoc errors. ",
            "author": "Nikola Tankovic",
            "id": "comment-13078992"
        },
        {
            "date": "2011-08-04T16:51:15+0000",
            "content": "Patch looks great... such a big milestone, to finally cutover entirely to the new API: awesome!  I'll commit shortly to the branch... ",
            "author": "Michael McCandless",
            "id": "comment-13079461"
        },
        {
            "date": "2011-08-05T06:21:03+0000",
            "content": "YES! Indeed a big milestone, finally  So now merging back? ",
            "author": "Nikola Tankovic",
            "id": "comment-13079798"
        },
        {
            "date": "2011-08-06T14:52:57+0000",
            "content": "21th patch  Fixed Javadocs errors. ",
            "author": "Nikola Tankovic",
            "id": "comment-13080413"
        },
        {
            "date": "2011-08-10T14:28:28+0000",
            "content": "Thanks Nikola.\n\nI'll have a look at this patch once I'm back online (on vacation this week).\n\nAfter that I'll work on merging this back to trunk!  If anyone wants to review the new FieldType API before we merge back, now is a good time... ",
            "author": "Michael McCandless",
            "id": "comment-13082366"
        },
        {
            "date": "2011-08-15T17:10:45+0000",
            "content": "Patch looks good \u2013 I'll commit to the branch, and then work [slowly] towards making a committable (to trunk) final patch! ",
            "author": "Michael McCandless",
            "id": "comment-13085177"
        },
        {
            "date": "2011-08-15T18:44:22+0000",
            "content": "This merge is going to be \"challenging\" so I'm going to attach several patches as I iterate towards making a real patch against current trunk.\n\nThis first patch is the diff vs the trunk as of when I cut the branch (rev 1134018), ie it contains all changes committed to the branch.  I generated this w/ dev-tools/scripts/diffSources.py, ie it should be applyable if you checkout that base rev.\n\nNext up I'll tweak the patch to account for moved files since we branched. ",
            "author": "Michael McCandless",
            "id": "comment-13085253"
        },
        {
            "date": "2011-08-15T21:32:59+0000",
            "content": "Next patch file, this time with the filenames in the patch moved to match svn moves that happened in trunk after the branch was cut. ",
            "author": "Michael McCandless",
            "id": "comment-13085347"
        },
        {
            "date": "2011-08-15T22:09:48+0000",
            "content": "I committed mike's patch as https://svn.apache.org/repos/asf/lucene/dev/branches/fieldtype_conflicted\n\nConflicts remain: you can see them with:\n\nfind . | xargs grep -l \"<<<<<<<\" | grep -v tmp\n\n\n\nAdditionally there is a lot of new code since the branch was created (e.g. faceting module) that likely needs fixing too. ",
            "author": "Robert Muir",
            "id": "comment-13085374"
        },
        {
            "date": "2011-08-15T22:12:50+0000",
            "content": "Awesome, thanks Robert!\n\nNikola, can you switch to the fieldtype_conflicted branch and resolve the conflicts / fix the newly added code?  If we do this quickly then hopefully trunk won't change much in the meantime  ",
            "author": "Michael McCandless",
            "id": "comment-13085377"
        },
        {
            "date": "2011-08-16T05:02:51+0000",
            "content": "Nice, \n\nI'll do my best to be as quick as I can, but probably we'll need one more quick iteration  ",
            "author": "Nikola Tankovic",
            "id": "comment-13085531"
        },
        {
            "date": "2011-08-16T20:42:20+0000",
            "content": "First merge patch, fixes almost every lucene/src/test. Mike can you merge stuff regarding FieldVisitor? And implement visit method in new IndexReader extended classes? ",
            "author": "Nikola Tankovic",
            "id": "comment-13085963"
        },
        {
            "date": "2011-08-16T23:20:44+0000",
            "content": "Patch looks good \u2013 I'll commit, and I'll work on the FieldVisitor conflicts! ",
            "author": "Michael McCandless",
            "id": "comment-13086034"
        },
        {
            "date": "2011-08-16T23:40:28+0000",
            "content": "OK I resolved the cases of FieldSelector/Visitor that I could find \u2013 Nikola were there other cases I should look at?  (I was confused by \"And implement visit method in new IndexReader extended classes?\"). ",
            "author": "Michael McCandless",
            "id": "comment-13086042"
        },
        {
            "date": "2011-08-17T05:21:50+0000",
            "content": "Great Mike, you did it all! ",
            "author": "Nikola Tankovic",
            "id": "comment-13086144"
        },
        {
            "date": "2011-08-17T19:09:48+0000",
            "content": "Further merging. Test pass, except for few wierd fails in Solr, please check.\n\nNext stop: fixing docs. ",
            "author": "Nikola Tankovic",
            "id": "comment-13086523"
        },
        {
            "date": "2011-08-17T22:43:40+0000",
            "content": "Great progress!  I'll commit shortly!\n\nBut, strangely, I see TestStressNRT failing: spooky! ",
            "author": "Michael McCandless",
            "id": "comment-13086656"
        },
        {
            "date": "2011-08-20T16:38:10+0000",
            "content": "Javadocs fixed. ",
            "author": "Nikola Tankovic",
            "id": "comment-13088218"
        },
        {
            "date": "2011-08-21T10:22:47+0000",
            "content": "Looks good Nikola \u2013 I'll commit to the branch.  I'll also svn rm AbstractField.java. ",
            "author": "Michael McCandless",
            "id": "comment-13088336"
        },
        {
            "date": "2011-08-21T10:57:15+0000",
            "content": "Patch, fixing all nocommits, adding direct test case for IndexableField, and removing dead code / making some names consistent.\n\nI still see failures in TestStressNRT, but besides that I think we are close to landing!! ",
            "author": "Michael McCandless",
            "id": "comment-13088347"
        },
        {
            "date": "2011-08-21T11:17:27+0000",
            "content": "That's strange 'cause on my machine all tests pass, or maybe this test\nskipped for some reason?\n\nNikola\n\n ",
            "author": "Nikola Tankovic",
            "id": "comment-13088349"
        },
        {
            "date": "2011-08-21T12:58:02+0000",
            "content": "Well, the test is heavily threaded so it could be it only fails if you have enough cores?\n\nThe failure is also intermittent, though often I see it fail after just one iteration... ",
            "author": "Michael McCandless",
            "id": "comment-13088357"
        },
        {
            "date": "2011-08-22T18:06:13+0000",
            "content": "Another merge patch \u2013 fixed a few more conflicts, some places where we lost the doc-level boost, simplified the Field/Document API some more, added some missing @Overrides, etc. ",
            "author": "Michael McCandless",
            "id": "comment-13088866"
        },
        {
            "date": "2011-08-22T22:56:54+0000",
            "content": "This is the svn diff vs the base of when we cut this branch, ie, has all changes in the branch, for reviewing.\n\nI think it's close to committable now! ",
            "author": "Michael McCandless",
            "id": "comment-13089115"
        },
        {
            "date": "2011-08-25T15:55:53+0000",
            "content": "Final [applyable] patch!  I think it's ready to commit and I hope\ntrunk doesn't up and change too much  I plan to commit in a day or\nso... ",
            "author": "Michael McCandless",
            "id": "comment-13091085"
        },
        {
            "date": "2011-08-25T16:03:29+0000",
            "content": "Congratulations, I think we did it \n\nNikola\n\n ",
            "author": "Nikola Tankovic",
            "id": "comment-13091090"
        },
        {
            "date": "2011-08-25T16:05:12+0000",
            "content": "Thank you for all this hard work Nikola! ",
            "author": "Michael McCandless",
            "id": "comment-13091093"
        },
        {
            "date": "2011-08-25T16:09:29+0000",
            "content": "Well this GSOC was definitively a pleasure for me  thank you all,\nbut especially you Mike for your epic 24/7 support!\n\nNikola\n\n ",
            "author": "Nikola Tankovic",
            "id": "comment-13091095"
        },
        {
            "date": "2011-08-27T13:27:20+0000",
            "content": "OK I committed the final patch!  I'll leave this open for a while in case we have small things to fix... ",
            "author": "Michael McCandless",
            "id": "comment-13092291"
        },
        {
            "date": "2011-08-27T13:47:12+0000",
            "content": "Yay! Great work Nikola, Mike. ",
            "author": "Chris Male",
            "id": "comment-13092297"
        },
        {
            "date": "2011-08-29T17:55:02+0000",
            "content": "Can we add some stuff to MIGRATE.txt for this issue? ",
            "author": "Robert Muir",
            "id": "comment-13093018"
        },
        {
            "date": "2011-08-29T18:45:15+0000",
            "content": "Can we add some stuff to MIGRATE.txt for this issue?\n\nWoops, yes, I will! ",
            "author": "Michael McCandless",
            "id": "comment-13093075"
        },
        {
            "date": "2011-08-29T19:49:46+0000",
            "content": "Patch, fixing a few small things: added missing ft.freeze() calls; added MIGRATE.txt entry; added jdocs for the XXXField classes; removing *Lazy from FieldType. ",
            "author": "Michael McCandless",
            "id": "comment-13093143"
        },
        {
            "date": "2011-08-30T15:26:51+0000",
            "content": "Thanks Mike! This is really helpful!\n\nWhile reviewing this/merging the flexscoring branch, I had a few ideas of improvements:\n\n\tI think FT should be immutable? Personally, I don't think we should enforce \"patterns\" like Freezable or Builder at this low-level, instead I think FieldType should be a simple immutable class with a single ctor that takes the minimal stuff that we (core lucene) need. It can still be concrete, but then you have to specify everything. Then, things like TextField/StringField are sugar APIs for common configurations. I don't like the idea of mutable FieldTypes that are reused across different fields because I am concerned that somehow the 'wrong configuration' will be applied accidentally.\n\tAlong these lines, we can then remove the \"copy constructor\", which also seems unnatural to java users, since FieldType would then be immutable there is no reason to ever copy it.\n\tI think BinaryField should be able to index as binary? This is a new feature in Lucene 4 but its unfortunately really hard to do: there are a few approaches, but they are all difficult: custom tokenstream/AttributeImpls/AttributeFactory etc.\n\tIn the future, a BinaryField like this could be a base impl for CollationField: due to historical reasons we expose this capability as an Analyzer but I think this isn't great: its really an implementation detail. For example in Solr, its a real FieldType that uses an analyzer behind the scenes. So in this sense I think its more consistent with NumericField.\n\n ",
            "author": "Robert Muir",
            "id": "comment-13093816"
        },
        {
            "date": "2011-08-30T16:11:28+0000",
            "content": "\nI think FT should be immutable?\nI don't like the idea of mutable FieldTypes that are reused across different fields because I am concerned that somehow the 'wrong configuration' will be applied accidentally.\n\nThis is why we have FT.freeze, and why an FT is frozen as soon as it's\nused in a Field.  But I agree it'd be even better if we had true\nimmutability (all fields in FT are final).\n\nI think FieldType should be a simple immutable class with a single ctor that takes the minimal stuff that we (core lucene) need.\nIt can still be concrete, but then you have to specify everything. Then, things like TextField/StringField are sugar APIs for common configurations.\n\nThis is a neat idea!\n\nAnother plus is this is a single place where we can check consistency\nof the settings (eg you cannot enable term vectors if indexed is\nfalse).\n\nSo this would mean we'd have alternate ctors to the sugar classes for\nthe common cases, like maybe:\n\n   new StringField(name, value)\n   new StoredStringField(name, value)\n\n\n\nStringField would always omitNorms, not tokenize, index DOCS_ONLY.\n\nFor TextField maybe:\n\n   new TextField(name, value)\n   new TextField(name, value, omitNorms)\n   new TextField(name, value, omitNorms, indexTVPos, indexTVOffsets)\n   new StoredTextField(name, value)\n   new StoredTextField(name, value, omitNorms)\n   new StoredTextField(name, value, omitNorms, indexTVPos, indexTVOffsets)\n\n\n\nExpert usage would always have the out of invoking FT directly with\nall options.  Even more expert usage can bypass the \"userspace\"\nFieldType/Field/Document entirely and code directly to IndexableField\ninstead.\n\nI think BinaryField should be able to index as binary?\n\nI agree!  Not sure on the details of how we'd do that though... Today\nthis field is only stored byte[]. ",
            "author": "Michael McCandless",
            "id": "comment-13093856"
        },
        {
            "date": "2011-08-30T16:44:16+0000",
            "content": "Much of what has been suggested here I'm looking at incorporating in LUCENE-3312 but perhaps its best to do it in small steps. \n\nWhat I want to do is as follows:\n\n\n\tChange FieldType to an interface inside index.* and use it for the source of properties about an IndexableField.  It will be simple and immutable and won't enforce any creation techniques.\n\tAdd a builder for FieldType to document.* which will create FieldType instances.\n\tAdd the syntactic sugar ctors suggested above which would use the builder to instantiate the FieldTypes they need.\n\n ",
            "author": "Chris Male",
            "id": "comment-13093880"
        },
        {
            "date": "2011-08-30T17:02:00+0000",
            "content": "\nAdd a builder for FieldType to document.* which will create FieldType instances.\n\nCan we avoid the builder API? I think we shouldnt invite accidental creation of lots of FieldType instances during indexing... why not just a single ctor in fieldtype that takes all the parameters the base class cares about? then it serves double-duty as the 'expert' fieldtype anyway, subclasses like TextField are just the sugar.\n\nIf someone wants to implement their subclass with a builder, they could still do this, but I don't think we should force the builder API on people with such a user-facing API: I think we should just keep it a very simple immutable class with one ctor.\n\nGiven the choice between builder and freezable though, I'll take freezable any day... but as I said before I think we should keep this even simpler. ",
            "author": "Robert Muir",
            "id": "comment-13093895"
        },
        {
            "date": "2011-08-31T02:16:39+0000",
            "content": "I'm definitely -1 for a constructor for all the properties.  We may only have a few properties today but it's not going to stay that way.  One of the benefits I see of FieldType is that we can extend it to have a greater range of properties that allow more customized handling of fields.  If we put everything into a constructor then it'll grow out of control, prevent us from adding more properties and we'll end up having another project just to break it up more.\n\nWith an interface, we're not forcing anything on anyone.  Users can create FieldTypes however they like. ",
            "author": "Chris Male",
            "id": "comment-13094256"
        },
        {
            "date": "2011-08-31T02:20:33+0000",
            "content": "I'm definitely -1 for a constructor for all the properties. We may only have a few properties today but it's not going to stay that way\n\nWhat is the problem? I am talking about the core \"FieldType\" that is the main stuff we need: e.g. indexed/stored/etc\n\nSubclasses can do whatever they want (builders/freezable/i dont care), but we should make a simple extendable immutable core class for the limited\nset of properties that really need to be in the fieldtype subclass. ",
            "author": "Robert Muir",
            "id": "comment-13094258"
        },
        {
            "date": "2011-08-31T02:24:38+0000",
            "content": "The problem is that it locks us in to this limited set of 'core' properties.  They will grow, I can assure you. ",
            "author": "Chris Male",
            "id": "comment-13094260"
        },
        {
            "date": "2011-08-31T02:36:47+0000",
            "content": "it doesn't lock us into anything. we deprecate the old ctor and make a new one with the correct default.\n\nThis is easy!\n\nBesides, you arent assuring me? what new things really need to be added that apply to all field types across the board?! ",
            "author": "Robert Muir",
            "id": "comment-13094263"
        },
        {
            "date": "2011-08-31T02:39:59+0000",
            "content": "Alright, I'll wait to see your patch using the ctor approach. ",
            "author": "Chris Male",
            "id": "comment-13094265"
        },
        {
            "date": "2011-08-31T02:44:22+0000",
            "content": "I'm not really motivated to work on a patch with a solution you already said you are -1 on?\n\nAgain, I'm totally against any builder here, I'm ok with freezable that we have now, but i think a plain immutable java object would be a lot simpler and clear... at the end of the day I'm ok with compromising with what we have already, I just brought this immutability idea up as a suggestion. ",
            "author": "Robert Muir",
            "id": "comment-13094266"
        },
        {
            "date": "2011-08-31T03:01:10+0000",
            "content": "Then we're at a bit of an impasse because you're totally against what I suggested as well.  I'm suggesting you cut a patch and we can go over it, I might see how it can be simpler and clearer. ",
            "author": "Chris Male",
            "id": "comment-13094272"
        },
        {
            "date": "2011-08-31T03:59:54+0000",
            "content": "What about a compromise and have both the plain Java object and a builder? That way if someone wants the simple clear way you describe, they have the ctor they can go to.  If they want what I feel would be more readable code, they can use the builder. ",
            "author": "Chris Male",
            "id": "comment-13094293"
        },
        {
            "date": "2011-08-31T07:43:21+0000",
            "content": "Hey guys, why don't we put plain old immutable java objects with a single ctor into core and add a builder API into modules / sandbox? This keeps things simple in core and if users want to use it they can grab it out of a module? \n\nCan we avoid the builder API? I think we shouldnt invite accidental creation of lots of FieldType instances during indexing... why not just a single ctor in fieldtype that takes all the parameters the base class cares about? then it serves double-duty as the 'expert' fieldtype anyway, subclasses like TextField are just the sugar.\n\nso I haven't seen a single technical argument against a builder here. I personally think that a builder has many advantages:\n\n\n\tsimple to add new fields, doesn't need deprecation if you add another field to a type\n\tsimple to use since lots of people are use to chaining\n\tprovides immutability by design\n\trepresents a small but clear DSL to build a field type. you could do things like providing setters for TV only if you chain it with a call to indexed() like: \n\n builder.indexed().storeTV(); \n\n which would not be visible otherwise.\n\ta ctor call will require many parameters that you don't want to set, but you're forced to pass a value for them anyway\n\tsince most of the parameters are booleans long sequences of identically typed parameters can cause subtle bugs. If the user accidentally reverses two such parameters, the compiler won't complain, but the program will misbehave at runtime. That sucks! especially if you spend hours of indexing and realize that your TV has not been stored because you missed to set indexed = true\n\tbuilder code is easy to write and, more importantly, to read.\n\ta builder simulates named optional parameters like in python and other languages which java is lacking.\n\n\n\nI think the Builder pattern is a good choice when designing classes whose constructors would have more than a handful of parameters, especially if most of those parameters are optional. Client code is much easier to read and write with builders than with the traditional telescoping constructor pattern.\n ",
            "author": "Simon Willnauer",
            "id": "comment-13094364"
        },
        {
            "date": "2011-08-31T08:11:06+0000",
            "content": "+1\n\nI couldn't have put it better myself. ",
            "author": "Chris Male",
            "id": "comment-13094371"
        },
        {
            "date": "2011-08-31T08:16:33+0000",
            "content": "+1\n\nI agree, too! I am personally in favour of builder patterns when parameters get beyond 3 or 4, especially if they are simply booleans. ",
            "author": "Uwe Schindler",
            "id": "comment-13094378"
        },
        {
            "date": "2011-08-31T08:17:38+0000",
            "content": "Somehow related, but for the same reasons (too many booleans in ctor), WordDelimiterFilter would also be a candidate for a WordDelimiterFilterBuilder. ",
            "author": "Uwe Schindler",
            "id": "comment-13094379"
        },
        {
            "date": "2011-08-31T12:12:59+0000",
            "content": "\nso I haven't seen a single technical argument against a builder here. I personally think that a builder has many advantages:\n\nI gave one already, it creates too many objects. It also adds complexity to the API.\n\nJust because a constructor has a couple parameters does NOT mean a builder fits. In situations like this one, its a bad choice. ",
            "author": "Robert Muir",
            "id": "comment-13094462"
        },
        {
            "date": "2011-08-31T12:19:55+0000",
            "content": "How does it create too many objects? ",
            "author": "Chris Male",
            "id": "comment-13094466"
        },
        {
            "date": "2011-08-31T12:28:42+0000",
            "content": "How does it create too many objects?\n\nThats implementation internal. If you want final unmodifiable objects, every builder call will produce a new one in its return parameter (see ScorerContext).\n\nIn general the builder pattern can also change existing objects, like StringBuilder does. ",
            "author": "Uwe Schindler",
            "id": "comment-13094476"
        },
        {
            "date": "2011-08-31T12:29:40+0000",
            "content": "we have to realize, most people indexing with lucene do it like this:\n\n\nwhile(...) {\n  Document doc = new Document(...);\n  Field field1 = new Field(...);\n  Field field2 = new Field(...);\n}\n\n\n\nSo for MOST people FT is increasing the number of objects being created per-document (most people will create a new one for every field). I think we should keep that at a minimum.\n\nAdding a builder on top, will at minimum require an additional object for the builder itself AND:\n\n\tcreation of a new intermediate throw-away FieldType with each .set() OR\n\tcreation of an additional mutable object used internally by the builder which will require keeping in sync with the immutable form.\n\n ",
            "author": "Robert Muir",
            "id": "comment-13094477"
        },
        {
            "date": "2011-08-31T12:31:05+0000",
            "content": "\nIn general the builder pattern can also change existing objects, like StringBuilder does\n\nAnd thats another bug in the builder anti-pattern, if you want to have a resulting immutable form, thats going to require either an object-creation orgy or a massive code duplication so that it can store an internal mutable form.\n\nEdit: got my antipatterns confused: visitor -> builder ",
            "author": "Robert Muir",
            "id": "comment-13094478"
        },
        {
            "date": "2011-08-31T12:40:04+0000",
            "content": "just to get this straight, FT is created only once and then shared this is its point. So the builder would be used only to set stuff up. Even if you create this each time all the object created are super short living plus modern VM allocate this on the stack I doubt that this is an issue anywhere. \n\nAnd thats another bug in the builder anti-pattern, if you want to have a resulting immutable form, thats going to require either an object-creation orgy or a massive code duplication so that it can store an internal mutable form.\n\nthat is simply not true, the builder doesn't create the actual FT until you call BUilder.build() until there you are mutable which is the point of the builder. So where are those objects are created again? ",
            "author": "Simon Willnauer",
            "id": "comment-13094482"
        },
        {
            "date": "2011-08-31T12:42:34+0000",
            "content": "\njust to get this straight, FT is created only once and then shared this is its point. \n\nSecond time this morning you didn't even read what I said.\n\nscroll up, as i said before most people indexing with lucene don't reuse document/field objects. ",
            "author": "Robert Muir",
            "id": "comment-13094485"
        },
        {
            "date": "2011-08-31T12:43:49+0000",
            "content": "Thats not a bug if you implement it correctly, in general a Builder/Factory combination is the solution. The Builder itsself is mutable. The last call on the builder is something like .createField() that no longer returns a Builder instance, but instead the immutable field. Thats all. All calls before use the same builder instance and always returning itsself. See e.g. Google Collections, they have their builders implemented exactly that way.\n\n\nField field1 = new FieldBuilder(name).setFoo().setBar().createField(value);\n\n\n\nAnd for indexing you can even reuse the builder to produce many identical fields:\n\n\nFieldBuilder builder = new FieldBuilder(name).setFoo().setBar();\nfor (documents) {\n  Field field1 = builder.createField(value);\n}\n\n ",
            "author": "Uwe Schindler",
            "id": "comment-13094486"
        },
        {
            "date": "2011-08-31T12:49:44+0000",
            "content": "\nThe Builder itsself is mutable.\n\nWhich, as i said before, is a massive code duplication/hassle for maintenance because then when want to add an additional property to fieldtype, we have to add it to the builder, too.\n\nAgain, look at the loop i posted above, which is the most common indexing loop. I just dont think we should introduce any more objects!\n\nIF we want to enforce that you must reuse field objects (and have a completely different solution for multivalued fields), then I might drop my complaints about builder, because then in that case it would avoid the pitfalls. ",
            "author": "Robert Muir",
            "id": "comment-13094489"
        },
        {
            "date": "2011-08-31T12:53:07+0000",
            "content": "Second time this morning you didn't even read what I said.\nI did but apparently we talk about different things? the entire purpose of FT is that you don't have to create it multiple times so folks can create Field each time but they should reuse FT, no? I personally talk about createing FT using a builder but what uwe says is we can also do that for field though. \n\nAgain how do you create way more object when you use a builder than when you use the ctor? ",
            "author": "Simon Willnauer",
            "id": "comment-13094491"
        },
        {
            "date": "2011-08-31T12:54:05+0000",
            "content": "I'm confused about what the reuse of Field objects has to do with this? That seems a corollary issue.  Aren't we talking about reducing the cost of creating FieldType instances? Which as Simon said, are then shared. ",
            "author": "Chris Male",
            "id": "comment-13094492"
        },
        {
            "date": "2011-08-31T12:57:03+0000",
            "content": "Its shared only if the person reuses them explicitly, but if they arent reusing fields (like most people don't do), then they arent likely to reuse fieldtypes either.\n\nIn general, I think we shouldnt create so many objects or add so much complexity to the indexing loop. \n\nPersonally I just dont think in practice people are going to set things up so that they actually reuse fieldtype. ",
            "author": "Robert Muir",
            "id": "comment-13094496"
        },
        {
            "date": "2011-08-31T12:59:09+0000",
            "content": "Change FieldType to an interface inside index.* and use it for the source of properties about an IndexableField. \n\n+1, I think we should have an oal.index.FieldType interface, that\nexposes (get-only) methods.  Ie, we'd just move the getters out of\nIndexableField into this new FT interface (likewise for\nStorableField).\n\nThis interface should be marked as experimental, ie, we are free to\nchange it.\n\nAdd a builder for FieldType to document.* which will create FieldType instances.\n\nI don't think we should use a builder API here; I think either\nbig-ctor-takes-all-settings and so all fields are final, or what we\nhave today (.freeze()) is better.\n\nThere are two things I don't like about the builder pattern: setter\nchaining and the object overhead of hard immutability.\n\nOn setter chaining:\n\n\n\tIt's two ways to do the same thing (chaining or not); generally an\n    API (and a PL) should offer one (obvious) way to do things.\n    Suddenly we'll see tutorials and articles etc. online, some with\n    chaining, some without, and some mixed.\n\n\n\n\n\tCode is less readable w/ chaining: it makes it easy to sneak in\n    multiple statements per line, embed them into other statements,\n    etc., vs unchained where you always have one statement per line\n\n\n\n\n\tI don't like .indexed() as a name; I prefer .setIndexed() so it's\n    clear you setting something about the object.\n\n\n\n\n\tIn encourages inefficient code, because it's easy to inline new\n    X().this().that() when in fact the app really should create &\n    reuse FieldType up front.  This is trappy \u2013 the app doesn't\n    realize they're creating N+1 objects.\n\n\n\nI also don't like the hard immutability (every field is final so every\nsetter returns a new object) since this will mean the typical use is\ncreating tons of objects per field per doc.  Yes we can have a mutable\nbuilder with a .build() in the end but that's making the API even more\ncumbersome.\n\nIn contrast, the \"soft\" immutability we have now (freeze) is very\neffective, and creates no additional objects: it will prevent you from\naltering a FT instance once any Field uses it.  Really the\nimmutability is a minor detail of the implementation here; we only\nneed it to prevent this trap.\n\nGenerally we should try to keep Lucene's core APIs as\nplain/simple/straightforward as possible.  Someone can always later\nlayer on a builder API on top of the simpler setter+freeze or\nall-properties-to-ctor API, but, not vice/versa (efficiently anyway). ",
            "author": "Michael McCandless",
            "id": "comment-13094499"
        },
        {
            "date": "2011-08-31T13:02:32+0000",
            "content": "Didn't Simon suggest we add the big-ctor version to core?\n\n\nwhy don't we put plain old immutable java objects with a single ctor into core and add a builder API into modules / sandbox? \n\nSo yes, Lucene's core can stay lean and mean, but we can have the builder in userland / module / sandbox ",
            "author": "Chris Male",
            "id": "comment-13094502"
        },
        {
            "date": "2011-08-31T13:22:55+0000",
            "content": "I am on opposite side:\n\nIn general the constructor of the immutable class is hidden (package-private or private depending on class hierarchy). So nobody can use it. The only API the user sees is the builder pattern. By that we only have one API and one usage type.\n\nBuilder patterns can be formatted very nice and it does not matter if people do:\n\n\nField.Builder b = new Field.Builder();\nb.setFoo();\nb.setBar();\nField f = b.build();\n\n\n\nversus\n\n\nField f = new Field.Builder()\n .setFoo()\n .setBar()\n .build();\n\n\n\nThe last chaining one is even more readable, and that is why I prefer builders. A so called \"telescoping constructor\" is the antipattern because its completely unreadable, as Java lacks of named parameters [the best example is WordDelimiterFilter, that one is horrible - a typical candidate for WordDelimiterFilter.Builder subclass). The chaining code is for stack based machines like the JVM and the x86 processors also more natural than the first one. The return value of the previous call resides already on the stack after the method returns, but instead of popping it and pushing again, it can stay there and you simply add the parameters of the next method call. This leads to also very elegant bytecode, for which hotspot has optimizations \n\nAbout code duplication: You can in the hidden ctor of the immutable class make a clone of the builder and keep it somewhere private final inside the instance. This one then holds the unmodifiable instance state.\n\nAbout number of objects (yes, we have the builder object and possibly a clone to it as suggested before and finally the immutable object): The number of objects is really nonsense here as all of those will be created in the Eden space and disappear as soon as the loop/method exits. You can try autoboxing with a recent JavaVM - you would in most cases see no slowdown caused by autoboxing. These are problems from pre-2000 when we had Java 1.1.\n\nUwe ",
            "author": "Uwe Schindler",
            "id": "comment-13094514"
        },
        {
            "date": "2011-08-31T13:28:12+0000",
            "content": "awesome writeup uwe! thank you! ",
            "author": "Simon Willnauer",
            "id": "comment-13094517"
        },
        {
            "date": "2011-08-31T13:34:06+0000",
            "content": "\nIn general the constructor of the immutable class is hidden (package-private or private depending on class hierarchy). So nobody can use it. The only API the user sees is the builder pattern.\n\nI am strongly against this: there is no reason to do this. We should instead expose the constructor of the immutable class so that people who want builders can use them, but i don't want builders, i shouldnt have to. there is no reason for this. ",
            "author": "Robert Muir",
            "id": "comment-13094522"
        },
        {
            "date": "2011-08-31T13:37:32+0000",
            "content": "If we release the code with the builder pattern then there is only one possibility and one example code in the class description. If somebody does not like the builder pattern, who cares? If there is nothing else, you have to use it. PERIOD.\n\nAbout code duplication: You can in the hidden ctor of the immutable class make a clone of the builder and keep it somewhere private final inside the instance. This one then holds the unmodifiable instance state.\n\nI already explained: The code duplication comes from the two ways to do it.\n\nOf course for lovers of telescopic unreadbale methods we can still add some conventional factory methods, taking tons of parameters, but internally use the builder. The user would not see the builder. ",
            "author": "Uwe Schindler",
            "id": "comment-13094526"
        },
        {
            "date": "2011-08-31T13:40:25+0000",
            "content": "I care, thats why i am -1 to the builder pattern. The pro-builders on this issue just silently argue that my concerns don't matter.\n\nMike gave his opinion on it too.\n\nStating that our concerns are meaningless is not the way to create consensus towards a good solution here. ",
            "author": "Robert Muir",
            "id": "comment-13094527"
        },
        {
            "date": "2011-08-31T13:43:48+0000",
            "content": "\nThe pro-builders on this issue just silently argue that my concerns don't matter.\n\nI resent that.  I've actively tried to understand your concerns and reach a compromise and consensus. ",
            "author": "Chris Male",
            "id": "comment-13094529"
        },
        {
            "date": "2011-08-31T13:45:03+0000",
            "content": "\nSo yes, Lucene's core can stay lean and mean, but we can have the builder in userland / module / sandbox\n\nChris, personally I think this is a reasonable solution, but my arguments are instead against the other ridiculous statements on the issue implying that my concerns do not matter.\n\nThe original idea for using a simple java object was just this, so that people can do whatever they want (builders, whatever). But there is no reason to enforce any specific anti-pattern here, when we can just leave that to the application. ",
            "author": "Robert Muir",
            "id": "comment-13094531"
        },
        {
            "date": "2011-08-31T13:45:47+0000",
            "content": "I think we should have an oal.index.FieldType interface, that exposes (get-only) methods.\n\n+1\n\nI also don't see a lot of value in jumping through too many hoops trying to enforce immutability (vs just making it easy for people to avoid common mistakes). ",
            "author": "Yonik Seeley",
            "id": "comment-13094532"
        },
        {
            "date": "2011-08-31T13:52:30+0000",
            "content": "Alright, so can we move towards a consensus on a solution?\n\nSo far I see people are okay with:\n\n\n\tMoving FieldType over to an interface which exposes get only methods\n\tCreating the core implementation which uses a ctor with final fields\n\tBuilder API can be created and placed in a yet to be determined place.\n\n\n\nSweet? ",
            "author": "Chris Male",
            "id": "comment-13094539"
        },
        {
            "date": "2011-08-31T13:57:53+0000",
            "content": "Err Yonik pointed out that we still have the option of continuing to use the freezable 'soft' immutability.  I didn't mean to ignore it. ",
            "author": "Chris Male",
            "id": "comment-13094541"
        },
        {
            "date": "2011-08-31T13:59:55+0000",
            "content": "I disagree, because that would again create different usage patterns and more questions on the user.\n\nIf we only have one way to do it (I favour the builder pattern) with a code example (like NumericRangeQuery does in its javadocs) this is all obvious to users.\n\nI think telescopic ctors/methods are an antipattern because of readability and I think also Robert will agree with me that e.g. WordDelimiterFilter is unuseable. ",
            "author": "Uwe Schindler",
            "id": "comment-13094543"
        },
        {
            "date": "2011-08-31T14:03:29+0000",
            "content": "But if fieldtype is an interface with get-only methods, then someone could make a Freezable implementation right?\nMaybe the interface is good, because I dislike 'forcing' freezable too, just not as much as a dislike builder. \n\nso, i think the interface sounds good, and would still personally prefer if our 'default' core implementation did not use freezable, and used the simpler ctor instead.\n\nalso I think we should be gearing the API so that most people can use the simpler fieldtypes (StringField/TextField etc) for 90% of lucene uses instead: I think we want using FieldType directly to be more expert usage (e.g. i should be able to do a typical body+title+metadata fields with these StringField/TextField etc and never deal with this stuff). ",
            "author": "Robert Muir",
            "id": "comment-13094547"
        },
        {
            "date": "2011-08-31T14:03:43+0000",
            "content": "I don't see anything wrong with providing options. ",
            "author": "Chris Male",
            "id": "comment-13094548"
        },
        {
            "date": "2011-08-31T14:06:29+0000",
            "content": "Okay so we seem to have consensus on moving to a get-only interface.\n\nThe question just remains how to implement the 'default' core implementation. ",
            "author": "Chris Male",
            "id": "comment-13094551"
        },
        {
            "date": "2011-08-31T14:13:16+0000",
            "content": "Freezeable is an antipattern and produces messy code on the implementation side, just because someone still stays in the 1990s when Java was not able to handle lots of small short-living objects. That's since almost the beginning of this century no issue anymore. ",
            "author": "Uwe Schindler",
            "id": "comment-13094557"
        },
        {
            "date": "2011-08-31T14:21:04+0000",
            "content": "In my opinion, we should vote for the following solutions:\n\n[1] Old-style telescopic ctors on a immutable FieldType\n[2] FieldType.Builder pattern with hidden FieldType Ctor and optionally static FieldType factory methods that produce commonly used types/maybe even telescopic (thise factories use builder internally / have a set of preconfigured builders available). The private ctor tkaes the Builder instance and clones it to keep state final (like IndexWriter)\n[3] Modifiable FieldType with a freeze() method and iffecient code because of stupid checks on every method - this is somehow a builder, the difference is only that the builder and final instance are same class.\n[4] Readonly interface with all three implementations\n\nHere my +1 for a easy to use Builder-only [2] implementation and nothing else. This has no additional object creation except the builder and an internal clone, but those are shortliving. ",
            "author": "Uwe Schindler",
            "id": "comment-13094564"
        },
        {
            "date": "2011-08-31T14:25:52+0000",
            "content": "\nOkay so we seem to have consensus on moving to a get-only interface.\n\nI'm not sure: we should see what Uwe thinks. It seems he might be against the idea that there are multiple ways to do this (I think its a valid concern, i just disagree with him though). I think the ideal situation is where StringField/TextField cover the majority of use cases and doing anything with FT is expert, e.g. intended for apps like Solr to implement the interface and probably not even use our 'default' FieldType implementation. I think the default impl is just for someone that wants something thats not out-of-box, e.g. tokenized TextField that omits TF. ",
            "author": "Robert Muir",
            "id": "comment-13094567"
        },
        {
            "date": "2011-08-31T14:30:25+0000",
            "content": "\nI think the ideal situation is where StringField/TextField cover the majority of use cases and doing anything with FT is expert, e.g. intended for apps like Solr to implement the interface and probably not even use our 'default' FieldType implementation.\n\nSeparate to the implementation issue, I don't think I've fully grasped what you want StringField/TextField to be? Do you seem them as having pre-defined FieldType setups? ",
            "author": "Chris Male",
            "id": "comment-13094570"
        },
        {
            "date": "2011-08-31T14:31:18+0000",
            "content": "well, looking at them, thats what they are now already? or am i totally confused? ",
            "author": "Robert Muir",
            "id": "comment-13094572"
        },
        {
            "date": "2011-08-31T14:34:57+0000",
            "content": "Ah sorry, when I last looked at them some had constructors which accepted FieldTypes.  Now those have been removed so yes, thats what they are now. ",
            "author": "Chris Male",
            "id": "comment-13094575"
        },
        {
            "date": "2011-08-31T15:08:28+0000",
            "content": "Builder patterns can be formatted very nice:\n\n\nField f = new Field.Builder()\n .setFoo()\n .setBar()\n .build();\n\n\n\nThis is nice in theory but in practice I often see massive compound\nhard-to-read lines like this:\n\n\n  IndexWriter writer = new IndexWriter(dir, newIndexWriterConfig( TEST_VERSION_CURRENT, new MockAnalyzer(random)).setMaxBufferedDocs(2).setMergePolicy(newLogMergePolicy()));\n\n\n\nI don't like that the chained setters make such code possible: it's\nunreadable. ",
            "author": "Michael McCandless",
            "id": "comment-13094606"
        },
        {
            "date": "2011-08-31T15:20:01+0000",
            "content": "This is still more readable than \n\n\nnew IndexWriter(dir, TEST_VERSION_CURRENT, new MockAnalyzer(random), 2, newLogMergePolicy());\n\n\n\nWhat does 2 mean? Yes its more verbose, but withy any recent UI, the syntax highlighting makes even a one-line chain easy readable.\n\nHere some quotes from Jushua Bloch (who is also the founder of Java Collections framework) about \"his\" pattern: http://www.goodreads.com/author/quotes/60805.Joshua_Bloch ",
            "author": "Uwe Schindler",
            "id": "comment-13094615"
        },
        {
            "date": "2011-08-31T15:26:40+0000",
            "content": "I don't like that the chained setters make such code possible: it's unreadable.\n\nEven as one-line its much better readable than anything else. Did you try to create a WordDelimiterFilter using it 15 argument ctor? Two minutes later you dont know anymore whet the 3rd boolean is about.\n\nThe chained calls can be read left to right and you can do that very fast. The syntax shown above is just extra sugar, but the one line variant is perfectly readable. OK, not for people still using two whitespaces after the end-of-sentence-period (http://en.wikipedia.org/wiki/Sentence_spacing)  ",
            "author": "Uwe Schindler",
            "id": "comment-13094618"
        },
        {
            "date": "2011-08-31T15:35:28+0000",
            "content": "So I want to get some actions out of this:\n\nUwe, lets open an issue to look at improving WordDelimiterFilter, yeah? I've seen that floating around in tests: new WordDelimiter(1, 1, 0, 1, 1, 0, 0..), yeah its tough to read.  \n\nHowever whether or not people agree with you on Builders and chain calls, at this stage there just isn't the support to make Builders mandatory.  Yes we should create one and I'll look to you for help on that.  But as a first step forward lets move FieldType over to being a get-only interface.  That will leave the freezable API in there and we can then consider the next step forward.  But again, I don't really see consensus on the Builder-only approach.  Rather I see a lot of support for having a single ctor implementation and a builder using that.\n\nWhere necessary I think we should strive to document anything around object creation that might catch someone whose blindingly migrating, off guard.\n\nI'm going to move forward with creating a patch for this first step tomorrow. ",
            "author": "Chris Male",
            "id": "comment-13094619"
        },
        {
            "date": "2011-08-31T15:50:19+0000",
            "content": "\nUwe, lets open an issue to look at improving WordDelimiterFilter, yeah? I've seen that floating around in tests: new WordDelimiter(1, 1, 0, 1, 1, 0, 0..), yeah its tough to read. \n\nI agree we should open an issue to improve WDF, these int parameters are actually all boolean flags and we could just pass 'int flags' instead.\n\nthis way you could do new WordDelimiterFilter(GENERATE_WORD_PARTS | CATENATE_ALL | SPLIT_ON_CASE_CHANGE), much more readable. ",
            "author": "Robert Muir",
            "id": "comment-13094629"
        },
        {
            "date": "2011-08-31T15:53:58+0000",
            "content": "Even as one-line its much better readable than anything else. Did you try to create a WordDelimiterFilter using it 15 argument ctor? Two minutes later you dont know anymore whet the 3rd boolean is about.\n\nIn fact this is what I like about .freeze(): you invoke simple\nsetters, one per line (usually), one object.\n\nThe only reason we want immutability here is to prevent the trap of\nchanging the FT after binding it to a Field.  And freeze accomplishes\nthis well.\n\nI agree massive single ctor isn't great; but maybe w/ EnumSet or int\nflags for the boolean properties it's OK.  Or maybe we go back to\nField.Index.X, Field.Store.Y, etc.  Or stick with .freeze.\n\nBuilder API can still be built out (eg in contrib or modules or google\ncode or somewhere) on top; I just don't think it should be in Lucene's core.\nIn general Lucene's core should keep things as straightforward as\npossible. ",
            "author": "Michael McCandless",
            "id": "comment-13094632"
        },
        {
            "date": "2011-08-31T16:01:29+0000",
            "content": "LUCENE-3410 for WDF improvements. ",
            "author": "Chris Male",
            "id": "comment-13094638"
        },
        {
            "date": "2011-08-31T16:21:10+0000",
            "content": "The only reason we want immutability here is to prevent the trap of changing the FT after binding it to a Field. And freeze accomplishes this well.\n\nWhere is the difference to builder?\n\nYou can also call builders one per line if you like it. I like builders especially for their readability: You can read the line and break it at any place just like a sentence. This is why the method names should look like sentence components and not setXXX() like (ideally).\n\nFreeze is an antipattern as you use one object for changing and then for freezing, leading to if-checks everywhere. If you make return freeze() an new immutable object, it is builder. Just without the possibility to chain.\n\nI dislike freeze, but if you want to do this, please add chaining, it costs you nothing as implementor. ",
            "author": "Uwe Schindler",
            "id": "comment-13094656"
        },
        {
            "date": "2011-08-31T16:27:02+0000",
            "content": "Since it seems like there is no agreement on enforcing immutability, perhaps we shouldn't.\nWe don't do it in a lot of other places, for example all of our query classes (and I don't think we should start).\n\nRethinking the \"interface\" a bit... even that seems like a little overkill (and perhaps just a by-product of no one agreeing on the concrete implementation?)  After all, if this is to just be a holder for parameters (like indexed, stored, etc) then allowing one to subclass doesn't add any power or even make much sense (they aren't going to change the \"behavior\" of anything, right?)  The other normal use cases for interfaces wouldn't seem to apply to this situation either. ",
            "author": "Yonik Seeley",
            "id": "comment-13094662"
        },
        {
            "date": "2011-08-31T16:32:25+0000",
            "content": "\nI agree massive single ctor isn't great; but maybe w/ EnumSet or int\nflags for the boolean properties it's OK. \n\nMaybe FieldType should really just be an 'int' (e.g. we dont have a class or anything) ? ",
            "author": "Robert Muir",
            "id": "comment-13094664"
        },
        {
            "date": "2011-08-31T16:32:27+0000",
            "content": "However whether or not people agree with you on Builders and chain calls, at this stage there just isn't the support to make Builders mandatory. Yes we should create one and I'll look to you for help on that. But as a first step forward lets move FieldType over to being a get-only interface. That will leave the freezable API in there and we can then consider the next step forward. But again, I don't really see consensus on the Builder-only approach. Rather I see a lot of support for having a single ctor implementation and a builder using that.\n\nI would like to have an on-list vote, please. Thanks. ",
            "author": "Uwe Schindler",
            "id": "comment-13094665"
        },
        {
            "date": "2011-09-01T00:11:38+0000",
            "content": "Just when I thought we had some consensus...\n\n\nAfter all, if this is to just be a holder for parameters (like indexed, stored, etc) then allowing one to subclass doesn't add any power or even make much sense (they aren't going to change the \"behavior\" of anything, right?) The other normal use cases for interfaces wouldn't seem to apply to this situation either.\n\nI don't see the interface just holding a series of boolean properties.  I've long favored moving Analyzer there (lets not fight that fight here) and information about numeric datatypes and docvalues types probably belong there too.  I've also explored using Attributes to provide context specific extensions (more datatypes ideas, uniqueness, spatial info) that allow customized indexing of Fields.  \n\nEqually, we have moved towards liberating the core indexer code from implementations of these concepts, starting with IndexableField and moving onto StorableField (if I ever get there).  I don't see it as overkill for the indexer to rely on the interface for FieldType too. ",
            "author": "Chris Male",
            "id": "comment-13095016"
        },
        {
            "date": "2011-09-01T00:13:17+0000",
            "content": "\nI would like to have an on-list vote, please. Thanks.\n\nCan you / someone else call one? I'm exhausted by the idea of summarizing this discussion. ",
            "author": "Chris Male",
            "id": "comment-13095017"
        },
        {
            "date": "2011-09-01T01:52:27+0000",
            "content": "We should probably really let the dust settle after such a large, rapid discussion before falling to any official vote - I think that should be a last resort, and not something that we quickly drop to. To me, calling a vote means we have failed completely at building a consensus and we need to solve this the worst way possible - with one side winning and another losing. Sure, that might end up being where things go on some issues, but lets not get there within hours of a large hash out... ",
            "author": "Mark Miller",
            "id": "comment-13095074"
        },
        {
            "date": "2011-09-01T05:55:09+0000",
            "content": "Patch which ports FieldType over to being an interface in index.* and changes document.FieldType to being document.CoreFieldType.\n\nCommand:\n\n\nsvn copy lucene/src/java/org/apache/lucene/document/FieldType.java lucene/src/java/org/apache/lucene/index/FieldType.java\nsvn mv lucene/src/java/org/apache/lucene/document/FieldType.java lucene/src/java/org/apache/lucene/document/CoreFieldType.java\n\n\n\nThis is just for consideration and I'm not sidestepping anyones opinions or concerns.  I just want to have a concrete first step which people can discuss rather than abstract ideas. ",
            "author": "Chris Male",
            "id": "comment-13095137"
        },
        {
            "date": "2011-09-02T17:58:24+0000",
            "content": "Regarding the latest patch:\n\n\n-  public Field(String name, FieldType type) {\n+  public Field(String name, CoreFieldType type) {\n\n\n\nSeems like the FieldType interface should be used for parameters and return types? ",
            "author": "Yonik Seeley",
            "id": "comment-13096167"
        },
        {
            "date": "2011-09-03T01:04:08+0000",
            "content": "I would like it to be but Field ensures any FieldType passed in is frozen by calling freeze() which is a CoreFieldType notion.  This is sort of messy and is a concern I have with the freezable state idea.  If we removed this and let Field assume state was immutable/frozen/whatever then we could use the interface yes.\n\n ",
            "author": "Chris Male",
            "id": "comment-13096539"
        },
        {
            "date": "2011-09-06T14:29:51+0000",
            "content": "Anyone else have any thoughts? Any objections to committing this patch as a first step? ",
            "author": "Chris Male",
            "id": "comment-13098032"
        },
        {
            "date": "2011-09-06T14:49:19+0000",
            "content": "Instead of introducing a dependency on CoreFieldType in many places (only to have to change it back later when some sort of consensus is finally reached), it would seem much cleaner to either\n\n\tremove freeze() until we decide on the right approach\n\tmove freeze() to the FieldType interface temporarily (and remove it later if the approach changes)\n\n\n\nThe other changes in the patch look fine. ",
            "author": "Yonik Seeley",
            "id": "comment-13098051"
        },
        {
            "date": "2011-09-07T04:19:20+0000",
            "content": "Patch updated following Yonik's advice.  I'd removed the freeze() calls from Field so that it can now accept a FieldType instance.  If freezing is important, its up to the created of the CoreFieldType. ",
            "author": "Chris Male",
            "id": "comment-13098584"
        },
        {
            "date": "2011-09-07T12:45:40+0000",
            "content": "I guess it's OK to remove the auto-freeze from Field... it's sort of sneaky to do that.\n\nBut, this means we've opened up the trap (where users change a FT after using it on a field, thinking/assuming somehow that the Field took a copy).  Chris can you fix the jdocs on Field ctors to make it clear that the Field instances holds a ref to the provided FT and so any changes later made to that FT will affect the Field instance? ",
            "author": "Michael McCandless",
            "id": "comment-13098899"
        },
        {
            "date": "2011-09-07T12:56:45+0000",
            "content": "Should we also move numeric(), numericDataType() and maybe\ndocValuesType() into oal.index.FieldType?  (We can do this as a\nspeparate issue though).\n\nI also like Marvin's/Robert's suggestion of using int flags for all\nthese booleans (also a separate issue!).\n\nWe lost the jdocs on each of the boolean methods (indexed(), stored(),\netc.).\n\nMaybe name oal.index's FT to IndexableFieldType?  And then drop Core from\noal.document's?  Ie, oal.document.FieldType and\noal.index.IndexableFieldType?  (Aren't we going to shortly need\noal.index.StorableFieldType?).\n\nAlso fix the jdocs for CoreFT.freeze \u2013 it still claims Field will\nauto-freeze. ",
            "author": "Michael McCandless",
            "id": "comment-13098904"
        },
        {
            "date": "2011-09-07T13:50:53+0000",
            "content": "I will make the appropriate javadoc changes right now.\n\n\nShould we also move numeric(), numericDataType() and maybe\ndocValuesType() into oal.index.FieldType? (We can do this as a\nspeparate issue though).\n\nYup.\n\n\nI also like Marvin's/Robert's suggestion of using int flags for all\nthese booleans (also a separate issue!).\n\nI like them too.  Lets do that.\n\n\nMaybe name oal.index's FT to IndexableFieldType? And then drop Core from\noal.document's? Ie, oal.document.FieldType and\noal.index.IndexableFieldType? (Aren't we going to shortly need\noal.index.StorableFieldType?).\n\nGood idea.  Its going to reduce this patch size considerably. ",
            "author": "Chris Male",
            "id": "comment-13098957"
        },
        {
            "date": "2011-09-07T14:04:42+0000",
            "content": "New patch based on the feedback from Mike.\n\n\n\tField now includes a class level jdoc saying its recommended no changes are made to FieldTypes after a Field is created.\n\tFieldType is now IndexableFieldType and CoreFieldType has gone back to FieldType.\n\tFieldType.freeze() no longer mentions auto-freezing, however it does recommend freeze() is called once properties have been set.\n\n\n\nWe're all green so I'm looking to commit this shortly and spin off the remaining changes. ",
            "author": "Chris Male",
            "id": "comment-13098966"
        },
        {
            "date": "2011-09-08T11:00:40+0000",
            "content": "I am not green but gave up due to vacation. I am still against freeze, but my complaints are ignored. ",
            "author": "Uwe Schindler",
            "id": "comment-13100222"
        },
        {
            "date": "2011-09-08T11:07:02+0000",
            "content": "Far from it Uwe, your complaints are being actively taken into consideration and we have every intention to open a new issue to move away from freeze (see Mike's comments).  I'm just wanting to take one step at a time. ",
            "author": "Chris Male",
            "id": "comment-13100226"
        },
        {
            "date": "2011-09-08T11:17:07+0000",
            "content": "I am not green but gave up due to vacation. I am still against freeze, but my complaints are ignored.\n\nThis sentence is too funny  I don't agree and I am not happy with the whole stuff. As Simon seems to be silent, so there is nothing I can do anymore with my limited time. I still favour the builder approach, and this API looks like the old one coming back... ",
            "author": "Uwe Schindler",
            "id": "comment-13100227"
        },
        {
            "date": "2011-09-10T06:19:25+0000",
            "content": "Final patch before committing.  This includes a change to MIGRATE.txt.\n\nI notice we don't have a CHANGES.txt entry anywhere, so I'll add that upon committing ",
            "author": "Chris Male",
            "id": "comment-13101993"
        },
        {
            "date": "2011-09-11T04:08:50+0000",
            "content": "Committed revision 1167668. ",
            "author": "Chris Male",
            "id": "comment-13102210"
        },
        {
            "date": "2012-01-12T17:42:17+0000",
            "content": "We're coming up on 4.0, and it doesn't seem like there ever was a consensus here wrt immutability.\nI'm also still in favor of removing freeze. ",
            "author": "Yonik Seeley",
            "id": "comment-13185094"
        },
        {
            "date": "2012-05-23T20:42:14+0000",
            "content": "can we close this issue? seems like except of yoniks last comment everything else has been resolved? ",
            "author": "Simon Willnauer",
            "id": "comment-13281892"
        },
        {
            "date": "2012-07-11T23:03:43+0000",
            "content": "bulk cleanup of 4.0-ALPHA / 4.0 Jira versioning. all bulk edited issues have hoss20120711-bulk-40-change in a comment ",
            "author": "Hoss Man",
            "id": "comment-13412287"
        },
        {
            "date": "2012-08-07T03:41:26+0000",
            "content": "rmuir20120906-bulk-40-change ",
            "author": "Robert Muir",
            "id": "comment-13429707"
        },
        {
            "date": "2013-03-22T16:34:05+0000",
            "content": "[branch_4x commit] Michael McCandless\nhttp://svn.apache.org/viewvc?view=revision&revision=1389535\n\nLUCENE-2308: add MIGRATE.txt entry about Document.setBoost ",
            "author": "Commit Tag Bot",
            "id": "comment-13610771"
        },
        {
            "date": "2013-05-10T10:33:08+0000",
            "content": "Closed after release. ",
            "author": "Uwe Schindler",
            "id": "comment-13653838"
        }
    ]
}