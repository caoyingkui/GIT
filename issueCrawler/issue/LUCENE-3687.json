{
    "id": "LUCENE-3687",
    "title": "Allow similarity to encode norms other than a single byte",
    "details": {
        "labels": "",
        "priority": "Major",
        "components": [
            "core/index",
            "core/search"
        ],
        "type": "New Feature",
        "fix_versions": [
            "4.0-ALPHA"
        ],
        "affect_versions": "4.0-ALPHA",
        "resolution": "Fixed",
        "status": "Closed"
    },
    "description": "LUCENE-3628 cut over norms to docvalues. This removes the long standing limitation that norms are a single byte. Yet, we still need to expose this functionality to Similarity to write / encode norms in a different format.",
    "attachments": {
        "LUCENE-3687.patch": "https://issues.apache.org/jira/secure/attachment/12510176/LUCENE-3687.patch"
    },
    "issue_links": {},
    "comments": [
        {
            "date": "2012-01-11T11:37:06+0000",
            "content": "here is a first patch allowing similarity be more flexible when encoding norms. This patch  allows similarity to write all numeric values plus fixed bytes. I tried to keep the actual DocValues type out of similarity to reduce complexity. From my perspective this is a fair game here not exposing the entire power of DocValues to similarity to reduce complexity in the API. \n\nI cleaned up the Lucene4FieldInfoFormat and added a preflex and 3x version. The 3x version is read-only and only deals with what was supported in 3x. 4x FieldInfo format has no backwards logic in there anymore too. \n\nThe preflex version is slightly different. Even that this is a 3x mock codec for RW support I need to write fieldnumbers since the actual FI ord might be different from the field number assigned by the trunk IW. so I have a special format for this.\n\nthere is certainly room for improvement but its a start. comments are welcome ",
            "author": "Simon Willnauer",
            "id": "comment-13184003"
        },
        {
            "date": "2012-01-11T19:22:11+0000",
            "content": "what a typo... s/omit/emit in the patch! anyway I think we should name the methos setXXX instead. ",
            "author": "Simon Willnauer",
            "id": "comment-13184300"
        },
        {
            "date": "2012-01-11T20:17:12+0000",
            "content": "I havent done a full review but with the typo fix I am very happy with the sim api. \n\nI also understand the preflex problem and I totally agree with the solution here. ",
            "author": "Robert Muir",
            "id": "comment-13184346"
        },
        {
            "date": "2012-01-12T11:26:51+0000",
            "content": "new patch with setXXX methods on Norm class. I also fixed some JavaDoc issues since computeNorm signature has changed. All tests pass but still need to add JavaDoc to the norms class. \n\npatch created with svn diff --show-copies-as-adds for readability. ",
            "author": "Simon Willnauer",
            "id": "comment-13184877"
        },
        {
            "date": "2012-01-13T09:11:49+0000",
            "content": "new patch. added some cleanups + javadoc.\nI now throw a hard IArgExc if sim emits different types for the same field and added tests to check if that is happening.\n\nI also remove setByte in favor of setInt(byte) \n\nI think its ready! ",
            "author": "Simon Willnauer",
            "id": "comment-13185510"
        },
        {
            "date": "2012-01-13T09:36:01+0000",
            "content": "\nI also remove setByte in favor of setInt(byte)\n{quote]\n\nWhy? this is really confusing! I think setByte should take byte, setInt int, setLong, long etc.\n ",
            "author": "Robert Muir",
            "id": "comment-13185520"
        },
        {
            "date": "2012-01-13T09:47:07+0000",
            "content": "I just saw DocValuesField has this same problem. Ill open a separate issue for that.\n\nBut this is a real serious trap. Overloading setint as setInt(short) setInt(int) setInt(byte) setInt(long),\nbesides being confusing (and I see no advantage to doing this), has the nice property\nof easily quadrupling peoples norms with no type safety unless they are like, peeking at \ntheir generated bytecode to verify java didn't promote them up to setInt(int)\n\nby making it setByte(byte) instead, if they don't pass an actual byte they will get\na compile error. ",
            "author": "Robert Muir",
            "id": "comment-13185524"
        },
        {
            "date": "2012-01-13T10:12:53+0000",
            "content": "Why? this is really confusing! I think setByte should take byte, setInt int, setLong, long etc.\n\nI agree. That's also a problem in other DocValues use cases like sorting. The SortField name uses INT but sorts by long and so on. There is already an issue open: LUCENE-3192 ",
            "author": "Uwe Schindler",
            "id": "comment-13185533"
        },
        {
            "date": "2012-01-13T11:01:53+0000",
            "content": "I agree, I will change this accordingly for all methods in Norm. Any other comments? ",
            "author": "Simon Willnauer",
            "id": "comment-13185544"
        },
        {
            "date": "2012-01-14T19:43:00+0000",
            "content": "I think otherwise the patch is great.\n\nwe really needed to split out fieldinfos implementations for 3.x and 4.x, for example\nthis will be useful to support offsets in the postings lists for lucene4xcodec (LUCENE-3684)\n\na few minor/trivial comments:\n\nin PreFlexRW and SimpleText's impl:\nthrow new IllegalArgumentException(\"Codec only supports single byte norm values. Type give: \" + type);\nI think this should be UOE?\n\nshouldn't we combine Norm and DocValueNorm into one final class (Norm) and pull it out of Sim?\nI don't think it needs to be inside Sim anymore, as I don't see any usefulness to making your own\nsubclass (how will this affect scoring versus just using the DocValueNorm impl)\n\nIs there any other use case to Norm being abstract? iff there is, shouldnt normsconsumer[perfield] pull the impl from the codec? ",
            "author": "Robert Muir",
            "id": "comment-13186315"
        },
        {
            "date": "2012-01-14T19:56:38+0000",
            "content": "Two more questions:\n\nIn the patch omitNorms is still a separate boolean from normValueType == null.\nIf this is the case, aren't we now able to represent (in 4.x codec) that norms are not omitted for the field,\nthey just don't exist at all (e.g. all documents without norms are deleted).\nCouldn't we take advantage of this to provide a true fix for LUCENE-3678, removing the bogus fileExists() stuff in NormsFormat's files()?\n\nWhat happens if a sim doesnt ever set anything in computeNorm at all for a field? \nPreviously this was 'required' because the method required that you return a byte.\nI think, if we do the above and are able to separately represent 'doesnt hvae any norms for this segment' \nfrom 'omitNorms for this field always', that we would just have normValueType as null, and it would all just work? ",
            "author": "Robert Muir",
            "id": "comment-13186320"
        },
        {
            "date": "2012-01-14T20:21:12+0000",
            "content": "in PreFlexRW and SimpleText's impl:\nI agree this should be UOE\n\nshouldn't we combine Norm and DocValueNorm into one final class (Norm) and pull it out of Sim?\nI kind of like the separation here. DocValues is really the Codec side of things and it would be nice if we would not mix that stuff in the similarity API.\n\nIf this is the case, aren't we now able to represent (in 4.x codec) that norms are not omitted for the field, they just don't exist at all (e.g. all documents without norms are deleted).\n\nyeah we can do that I will look into it but I am not sure if we should rather let that patch bake in for a bit and then do that change in a second issue. Would make debugging simpler if we run into problems.\n\nfrom 'omitNorms for this field always', that we would just have normValueType as null, and it would all just work?\n\nI agree, maybe its better to get this right in this patch already I can still move the stupid file checks removed in a second issue. But I should really handle null types ie. Sims that don't set a value, currently I have tons of asserts that enforce a value. ",
            "author": "Simon Willnauer",
            "id": "comment-13186328"
        },
        {
            "date": "2012-01-14T20:44:11+0000",
            "content": "\nI kind of like the separation here. DocValues is really the Codec side of things and it would be nice if we would not mix that stuff in the similarity API.\n\nBut what is the use case of having a separate Abstract class (Norm) from an implementation class (DocValueNorm) that the codec doesn't even provide (its instantiated as DocValues by normsconsumer[perfield] directly.\n\nIf we are going to have separate classes, then norm should be abstract and the codec should provide the implementation. But we need a real use case as to why a codec would need to customize the implementation of Norm to justify this. ",
            "author": "Robert Muir",
            "id": "comment-13186335"
        },
        {
            "date": "2012-01-14T20:51:58+0000",
            "content": "If we are going to have separate classes, then norm should be abstract and the codec should provide the implementation. But we need a real use case as to why a codec would need to customize the implementation of Norm to justify this.\n\nmaybe we should. if a user wants to do crazy stuff with norms ie. use packed ints for norms or var length bytes they should be able the do this ie return a different type then we do right now? ",
            "author": "Simon Willnauer",
            "id": "comment-13186338"
        },
        {
            "date": "2012-01-14T21:01:01+0000",
            "content": "\nmaybe we should. if a user wants to do crazy stuff with norms ie. use packed ints for norms or var length bytes they should be able the do this ie return a different type then we do right now?\n\nWhat crazy stuff would they be doing? Keep in mind that the only thing you can put in a norm is stuff from FieldInvertState. ",
            "author": "Robert Muir",
            "id": "comment-13186340"
        },
        {
            "date": "2012-01-14T21:09:26+0000",
            "content": "\nyeah we can do that I will look into it but I am not sure if we should rather let that patch bake in for a bit and then do that change in a second issue. Would make debugging simpler if we run into problems.\n\nI agree, that case is crazy today and it shouldn't block nor confuse the issue. I just wanted us to have a plan for the file format. Otherwise there is no point in writing OMIT_NORMS bit in the fieldinfoswriter because it could be represented by normValueType of 0.\n\n\nI agree, maybe its better to get this right in this patch already I can still move the stupid file checks removed in a second issue. But I should really handle null types ie. Sims that don't set a value, currently I have tons of asserts that enforce a value.\n\nThis isn't a huge deal though, its mostly just curiousity. Previously you always had to return something, we didnt even have the option for a sim (like basic tf * idf) to not encode any length normalization information. The way you had to do that before was to return a bogus byte in computeNorm and ensure you always did omitNorms for the field.\n\nIf its tricky or messy, in my opinion we could even just add an assertion for now and document \"you must set something\" in Similarity, because its a lower level API than it was in previous release (most people would generally extend higher level stuff like BM25Similarity, TFIDFSimilarity,  or even DefaultSimilarity that do not expose this stuff). ",
            "author": "Robert Muir",
            "id": "comment-13186342"
        },
        {
            "date": "2012-01-15T11:42:25+0000",
            "content": "new patch \n\n\n\trenamed setXXX to setDouble, setFloat etc.\n\tmoved Norm our of similarity and merged it with DocValueNorm\n\tuse UOE in simpletext and 3x norms\n\tutilize normValueType to actually not write norms if only bogus norms would be written. Lucene4 can now check if norms are present without looking at the directory.\n\n\n\nthis patch actually doesn't even write norms if not absolutely needed. Do we have any requirement that this needs to happen even if there is not a single doc with norms in that field? I removed all the crazy 0 value writing in NormsConsumer and still all tests pass. If there is a case where these bogus norms are required we need to have a test for it. ",
            "author": "Simon Willnauer",
            "id": "comment-13186484"
        },
        {
            "date": "2012-01-16T01:03:09+0000",
            "content": "This looks great!  I love how you pass Norm to the sim and it sets\nwhat it wants...\n\nHmm... Norm impls DocValue which I just removed... maybe we should add\nit back?\n\nVery nice to have a private 3x FieldInfos reader/writer!\n\nWhat happens if an app (incorrectly) tries to change up the normType\nsuddenly...?  If you change in the middle of an IW session... it's\nquietly ignored and you get 0/empty bytes indexed instead?\n(FieldInfo.setNormValueType silently does nothing if it's already\nset).  Can we throw an exception if it's already set to a conflicting\nvalue?\n\nIf you change on a new IW session... they will be merged according to\nthe normal type promotion rules of doc values right?\n\nMaybe instead of set and reset methods on FieldInfo just have a single\nset method with force boolean?\n\nThis fails for me:\n\n\n    [junit] Testsuite: org.apache.solr.search.function.TestFunctionQuery\n    [junit] Tests run: 1, Failures: 0, Errors: 1, Time elapsed: 0.939 sec\n    [junit] \n    [junit] ------------- Standard Error -----------------\n    [junit] NOTE: reproduce with: ant test -Dtestcase=TestFunctionQuery -Dtestmethod=testGeneral -Dtests.seed=-406004cdb5fb0321:-4f9a2e7a9fa49aa4:7de466246285c0e9 -Dargs=\"-Dfile.encoding=UTF-8\"\n    [junit] NOTE: test params are: codec=Lucene40: {}, sim=RandomSimilarityProvider(queryNorm=true,coord=true): {}, locale=ro, timezone=Europe/Malta\n    [junit] NOTE: all tests run in this JVM:\n    [junit] [TestFunctionQuery]\n    [junit] NOTE: Linux 2.6.33.6-147.fc13.x86_64 amd64/Sun Microsystems Inc. 1.6.0_21 (64-bit)/cpus=24,threads=1,free=171062240,total=239534080\n    [junit] ------------- ---------------- ---------------\n    [junit] Testcase: testGeneral(org.apache.solr.search.function.TestFunctionQuery):\tCaused an ERROR\n    [junit] null\n    [junit] java.lang.NullPointerException\n    [junit] \tat org.apache.solr.search.function.TestFunctionQuery.testGeneral(TestFunctionQuery.java:352)\n    [junit] \tat org.apache.lucene.util.LuceneTestCase$3$1.evaluate(LuceneTestCase.java:528)\n    [junit] \tat org.apache.lucene.util.LuceneTestCaseRunner.runChild(LuceneTestCaseRunner.java:165)\n    [junit] \tat org.apache.lucene.util.LuceneTestCaseRunner.runChild(LuceneTestCaseRunner.java:57)\n\n\n ",
            "author": "Michael McCandless",
            "id": "comment-13186638"
        },
        {
            "date": "2012-01-16T11:04:17+0000",
            "content": "here is a new patch with changes.txt and more tests for cases where norms are not written but also not omitted.\n\nall tests pass, I think this is ready though!\n\nHmm... Norm impls DocValue which I just removed... maybe we should add it back?\nI used DocValuesField as a delegate in this patch. I don't think we need this interface at this point.\n\n \nWhat happens if an app (incorrectly) tries to change up the normType suddenly...? If you change in the middle of an IW session... it's quietly ignored and you get 0/empty bytes indexed instead? \nthere is a test for this in TestCustomNorms (testExceptionOnRandomType) it throws a IAE in NormsConsumerPerField.\n\n(FieldInfo.setNormValueType silently does nothing if it's already\nset). Can we throw an exception if it's already set to a conflicting\nvalue? \n\nI added some logic in there to throw an exc if it is not forced and the value != null.\n\n If you change on a new IW session... they will be merged according to\nthe normal type promotion rules of doc values right? \n\nright!\n\nMaybe instead of set and reset methods on FieldInfo just have a single\nset method with force boolean?\n\ndone! I also added some sugar to FieldInfo to check if the norms are present.\n\nThis fails for me:\nfixed my fault ",
            "author": "Simon Willnauer",
            "id": "comment-13186865"
        },
        {
            "date": "2012-01-16T13:51:42+0000",
            "content": "I plan to commit this soon if nobody objects. ",
            "author": "Simon Willnauer",
            "id": "comment-13186923"
        },
        {
            "date": "2012-01-16T14:25:40+0000",
            "content": "Patch looks good!  Small typo in FieldInfo.setNormValueType \"Norn type...\" --> \"Norm type...\".\n\nI don't like the inconsistency of Field.setValue(T value) but Norm.setT(T value)... we should somehow reconcile how we name the native type setters on these \"value holder\" classes... but we can sort this later.\n\nYou can remove the unused BytesRef spare in NormsConsumerPerField... ",
            "author": "Michael McCandless",
            "id": "comment-13186937"
        },
        {
            "date": "2012-01-16T14:57:03+0000",
            "content": "Patch looks good! Small typo in FieldInfo.setNormValueType \"Norn type...\" --> \"Norm type...\".\nI will fix that.\n\nI don't like the inconsistency of Field.setValue(T value) but Norm.setT(T value)... we should somehow reconcile how we name the native type setters on these \"value holder\" classes... but we can sort this later.\n\nI will open a followup issue\n\nYou can remove the unused BytesRef spare in NormsConsumerPerField...\ndone! ",
            "author": "Simon Willnauer",
            "id": "comment-13186953"
        }
    ]
}