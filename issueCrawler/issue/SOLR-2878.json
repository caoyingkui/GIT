{
    "id": "SOLR-2878",
    "title": "Regression in SolrDispatchFilter.java concerning the getOutputStream vs getWriter",
    "details": {
        "affect_versions": "3.4",
        "status": "Resolved",
        "fix_versions": [],
        "components": [
            "Build",
            "Response Writers"
        ],
        "type": "Bug",
        "priority": "Major",
        "labels": "",
        "resolution": "Not A Problem"
    },
    "description": "In solr 1.4 we used getWriter in the writeResponse for solrDispatchFilter::doFilter which invoked writeResponse.\nThis code looked in summary like this :\n\nsolrDispatchFilter.java\nprivate void writeResponse(SolrQueryResponse solrRsp, ServletResponse response, \n   QueryResponseWriter responseWriter, SolrQueryRequest solrReq, Method reqMethod) \n   throws IOException {\n...\n PrintWriter out = response.getWriter();\n responseWriter.write(out, solrReq, solrRsp);\n...\n\n\n\nIn solr 3.x this has changed to something like this \nsolrDispatchFilter.java\nprivate void writeResponse(SolrQueryResponse solrRsp, ServletResponse response,\n  QueryResponseWriter responseWriter, SolrQueryRequest solrReq, Method reqMethod) \n  throws IOException {\n...\nString charset = ContentStreamBase.getCharsetFromContentType(ct);\nWriter out = (charset == null || charset.equalsIgnoreCase(\"UTF-8\"))\n  ? new OutputStreamWriter(response.getOutputStream(), UTF8)\n  : new OutputStreamWriter(response.getOutputStream(), charset);\nout = new FastWriter(out);\nresponseWriter.write(out, solrReq, solrRsp);\nout.flush();\n...\n\n\n\nNow, when we add another filter that tries to modify the output it is being blocked by the out.flush(). \nflush() is telling our outputstream that it can write directly to the destination (similar to the out.close()), since this normally happens automatically there shouldn't be a need to execute this flush.\nIn our case this secondary filter is trying to add headers to the response object. When we were using getwriter() it was not closing the writer so we could still modify this output. Since the flush happens now we are no longer able to modify the headers accordingly. \nIt would be an easy fix if the flush could be commented out and everything would work but that is not the case. The headers are working when this happens but there is no more output.\nWhen I modify both classes to use getWriter() everything is working as expected.\n\nThis is a severe regression for our use of solr.\n\nOur code that is used in the filter\nsolrCustomFilter.java\npublic void doFilter(ServletRequest req, ServletResponse res,FilterChain chain) \n  throws IOException, ServletException {\n...\nWriter out = new OutputStreamWriter(response.getOutputStream(), \"UTF8\"); //auto flush\nout = new FastWriter(out);\n// convert to a chartext\nCharResponseWrapper wrapper = new CharResponseWrapper((HttpServletResponse) response);\nchain.doFilter(request, wrapper);\nString responseBody = wrapper.toString();\n//write the outgoing header. Only succeeds when flush of solrDispatchFilter is commented out\nresponse.addHeader(\"pragma\", \"somevalue;\");\nout.write(responseBody);\n...\n\n\n\nSources :\n\nSRV.5.5 Closure of Response Object\nWhen a response is closed, the container must immediately flush all remaining content in the response buffer to the client. The following events indicate that the servlet has satisfied the request and that the response object is to be closed:\n\u2022 The termination of the service method of the servlet. \n\u2022 The amount of content specified in the setContentLength method of the response has been written to the response. \n\u2022 The sendError method is called. \n\u2022 The sendRedirect method is called.\n\nSolr 1.4 https://svn.apache.org/repos/asf/lucene/solr/branches/branch-1.4/src/webapp/src/org/apache/solr/servlet/SolrDispatchFilter.java\nSolr 3.4 https://svn.apache.org/repos/asf/lucene/dev/branches/lucene_solr_3_4/solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter.java",
    "attachments": {},
    "issue_links": {},
    "comments": [
        {
            "author": "Hoss Man",
            "id": "comment-13144494",
            "date": "2011-11-05T00:51:24+0000",
            "content": "I think you are missunderstanding the problem \u2013 i don't think it has anything to do with the \"flush\" call.\n\nin Solr 1.4, response.getWriter() was used by the SolrDispatchFilter for any character based responses \u2013 but in Solr 3.4, because of the issues related to SOLR-2381, SolrDispatchFilter was modified to use response.getOutputStream() for both binary and character based streams.\n\nIf you have your own Filter that wraps the HttpServletResponse in something named \"CharResponseWrapper\" (which i assume by the name is similar to this example that poped up when i searched for it)  then you are probably not ever wrapping/buffering the OutputStream \u2013 you are just wrapping a Writer that is never used \u2013 so the Output written to by the SOlrDispatchFilter is going straight back to the client.\n\nFWIW: if you just want to add some headers to the response, and those headers don't depend on the output of the SolrDispatchFilter, you should be able to set them on the response prior to calling chain.doFilter, and then you don't have to worry about wrapping the response at all. "
        },
        {
            "author": "Nick Veenhof",
            "id": "comment-13144622",
            "date": "2011-11-05T07:30:02+0000",
            "content": "I'm trying to understand the conceptual change between getWriter and getOutputStream but so far I am not convinced that the problem lies with CharResponseWrapper. \n\n1) When I change the getOutputStream to getWriter in SolrDispatchFilter and in my code, everything is working\n2) When removing that flush, my headers are added.\n\nThe header added relies on the response that came back from the other filters so I need to add the header after the chain.doFilter. I did not give you a correct sample in the first post.\n\n\npublic void doFilter(ServletRequest req, ServletResponse res,FilterChain chain) \n  throws IOException, ServletException {\n...\nWriter out = new OutputStreamWriter(response.getOutputStream(), \"UTF8\"); //auto flush\nout = new FastWriter(out);\n// convert to a chartext\nCharResponseWrapper wrapper = new CharResponseWrapper((HttpServletResponse) response);\nchain.doFilter(request, wrapper);\nString responseBody = wrapper.toString();\n//write the outgoing header. Only succeeds when flush of solrDispatchFilter is commented out\nresponse.addHeader(\"pragma\", \"somevalue\" + responseBody + \";\");\nout.write(responseBody);\n...\n\n\n\nAlso, the class that you found for CharResponseWrapper is the one we use. There is however another example that can be found here (but it is not solving the problem)\nhttp://www.java2s.com/Tutorial/Java/0400__Servlet/Filterthatusesaresponsewrappertoconvertalloutputtouppercase.htm\nThey are using getWriter() "
        },
        {
            "author": "Nick Veenhof",
            "id": "comment-13144627",
            "date": "2011-11-05T08:27:35+0000",
            "content": "After loads of research and figuring out why it happened I found a CharResponseWrapper that worked for getOutputStream also.\nFor archiving purposes I'd like to put the full class here :\n\nWith this class it all seems to work as it did before. Thanks for the pointer on the CharResponseWrapper, I was not deep enough in the java servlets world to understand that this CharResponseWrapper could have such an impact on the response.\n\n\n/**\n * \n */\npackage clime.messadmin.filter;\n\nimport java.io.CharArrayWriter;\nimport java.io.IOException;\nimport java.io.PrintWriter;\n\nimport javax.servlet.ServletOutputStream;\nimport javax.servlet.http.HttpServletResponse;\nimport javax.servlet.http.HttpServletResponseWrapper;\n\n/**\n * @author C&eacute;drik LIME\n */\nclass CharResponseWrapper extends HttpServletResponseWrapper {\n\tprotected CharArrayWriter output;\n\tprotected ServletOutputStream stream = null;\n\tprotected PrintWriter writer = null;\n\n\tstatic class CharOutputStream extends ServletOutputStream {\n\t\tCharArrayWriter outstream;\n\n\t\tpublic CharOutputStream(CharArrayWriter out) {\n\t\t\toutstream = out;\n\t\t}\n\n\t\t/** {@inheritDoc} */\n//\t  @Override\n\t\tpublic void write(int b) {\n\t\t\toutstream.write(b);\n\t\t}\n\t\tpublic void write(String str) throws IOException {\n\t\t\toutstream.write(str);\n\t\t}\n\t}\n\n\t/** {@inheritDoc} */\n//  @Override\n\tpublic String toString() {\n\t\treturn output.toString();\n\t}\n\n\tpublic char[] toCharArray() {\n\t\treturn (output.toCharArray());\n\t}\n\n\tpublic CharResponseWrapper(HttpServletResponse response) {\n\t\tsuper(response);\n\t\toutput = new CharArrayWriter();\n\t}\n\n\t/** {@inheritDoc} */\n//  @Override\n\tpublic synchronized PrintWriter getWriter() {\n\t\tif (stream != null) {\n\t\t\tthrow new IllegalStateException(\"getOutputStream() has already been called for this response\");\n\t\t}\n\t\tif (writer == null) {\n\t\t\twriter = new PrintWriter(output);\n\t\t}\n\t\treturn writer;\n\t}\n\n\t/** {@inheritDoc} */\n//  @Override\n\tpublic synchronized ServletOutputStream getOutputStream() {\n\t\tif (writer != null) {\n\t\t\tthrow new IllegalStateException(\"getWriter() has already been called for this response\");\n\t\t}\n\t\tif (stream == null) {\n\t\t\tstream = new CharOutputStream(output);\n\t\t}\n\t\treturn stream;\n\t}\n\n}\n\n "
        },
        {
            "author": "Nick Veenhof",
            "id": "comment-13144629",
            "date": "2011-11-05T08:28:25+0000",
            "content": "Solr is working as expected but the extensibility is hard to figure out "
        },
        {
            "author": "Uwe Schindler",
            "id": "comment-13144648",
            "date": "2011-11-05T10:40:09+0000",
            "content": "Just to add another note:\nThe API of ServletResponse supplying getWriter() APIs is a mis-conception in relation to the HTTP protocol. The HTTP protocol is defined to transfer binary output. The use of a char stream as Java supplies by getWriter() is only for convenience, but a filter should never rely on the fact that a Servlet uses a Writer. Unfortunately Sun never changed this for backwards compatibility reasons, but the correct API design of the Servlet API would be to make the getWriter() method final in the ServletResponse.\n\nAbout your last example code that works around your issue: The code of your filter is simply wrong - it assumes that all chars are represented by exactly one byte with the same binary code-point in the output, which is only true for US-ASCII. It completely ignores the charset. Solr by default always uses UTF-8 so you would make the output unreadable once a code poiunt > 127 would appear in the output. To correctly buffer your output use a ByteArrayOutputStream. To check the contents of the buffered code as a string, you have to use: new String(ByteArrayOutputStream.getBytes(), ServletResponse.getCharacterEncoding()); "
        },
        {
            "author": "Nick Veenhof",
            "id": "comment-13144656",
            "date": "2011-11-05T11:22:49+0000",
            "content": "Changed my wrapper to something like this to support the ByteArrayOutputStream. This looks more correct to you? I am not using the ServletResponse.getCharacterEncoding() because I am not 100% sure where to use it.\n\n\nclass CharResponseWrapper extends HttpServletResponseWrapper {\n\tprotected ByteArrayOutputStream output;\n\tprotected ServletOutputStream stream = null;\n\tprotected PrintWriter writer = null;\n\n  /** {@inheritDoc} */\n  //  @Override\n  public String toString() {\n    return new String(getBytes());\n  }\n\n  public byte[] getBytes(){\n    return output.toByteArray();\n  }\n\n  public CharResponseWrapper(HttpServletResponse response){\n    super(response);\n    output = new ByteArrayOutputStream();\n  }\n\n  /** {@inheritDoc} */\n  // @Override\n  public PrintWriter getWriter() {\n    if (stream != null) {\n      throw new IllegalStateException(\"getOutputStream() has already been called for this response\");\n    }\n    if (writer == null) {\n      writer = new PrintWriter(output);\n    }\n    return writer;\n  }\n\n  /** {@inheritDoc} */\n  //  @Override\n\tpublic ServletOutputStream getOutputStream() {\n    return new ServletOutputStream() {\n        @Override\n        public void write(int b) throws IOException {\n           output.write(b);\n        }\n    };\n  }\n}\n\n\n\nWhen used with :\n\n\n      response.setCharacterEncoding(\"UTF-8\");\n      Writer out = new OutputStreamWriter(response.getOutputStream(), \"UTF-8\"); //auto flush\n      CharResponseWrapper wrapper = new CharResponseWrapper((HttpServletResponse) response);\n      // CharResponseWrapper is responsable for the getWriter and\n      // getOutputStream support.\n      chain.doFilter(request, wrapper);\n      String responseBody = wrapper.toString();\n      response.addHeader(\"pragma\", \"hash of responsebody\");\n      out.write(responseBody);\n      out.flush();\n\n "
        },
        {
            "author": "Uwe Schindler",
            "id": "comment-13144687",
            "date": "2011-11-05T13:38:42+0000",
            "content": "Your class still ignores the charset, you simply have to pass it everywhere (when creating writers, when creating strings,...). Also you are also mixing bytes with characters at lots of places in an inconsequent way (out.write should take the bytes, not the string).\n\nIf you are simply calculating a hash of the response, why not remove the string handling at all? Hashing is always done on bytes not characters so all transformations between strings and bytes are useless and slowdowns everything (+ it introduces bugs). A filter that simply hashes the output is constructed like that: it buffers the response bytes (using ByteArrayOutputStream), then calculates the hash using MessageDigest (it can also do this during writing), writes the hash as header, and finally copies the buffered bytes to the output stream. Why transform from/to strings everywhere?\n\nThis code is so chaotic and violates character encodings at lots of places, so I refuse to correct it. Ask somebody who understands your use-case. Sorry  "
        },
        {
            "author": "Nick Veenhof",
            "id": "comment-13146354",
            "date": "2011-11-08T15:25:47+0000",
            "content": "New try!\n\nAlmost the same CharResponseWrapper is used except that I've thrown away the getString method.\nI took your comments into account and no strings are used anymore. Could you verify if this is what you were pointing at?\n\n\nCharResponseWrapper newResponse = new CharResponseWrapper(\n    (HttpServletResponse) response);\n\n// CharResponseWrapper is responsable for the getWriter and\n// getOutputStream support.\nchain.doFilter(request, newResponse);\n\n// The response works with byteArrays so we do to\nbyte[] responseBody = newResponse.getBytes();\n\n// Write the outgoing header with the ByteArray (Performance)\nresponse.addHeader(\"pragma\", \"auth=\" +\n    buildAuthentication(responseBody) + \";\");\n// Force the encoding to UTF-8 since we know Drupal works with UTF-8\nresponse.setCharacterEncoding(\"UTF-8\");\nresponse.getOutputStream().write(responseBody);\nresponse.getOutputStream().flush();\n\n "
        }
    ]
}