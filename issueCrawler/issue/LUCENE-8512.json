{
    "id": "LUCENE-8512",
    "title": "GeoPolygon test failure",
    "details": {
        "components": [
            "modules/spatial3d"
        ],
        "status": "Resolved",
        "resolution": "Fixed",
        "fix_versions": [
            "6.7",
            "7.6",
            "master (8.0)"
        ],
        "affect_versions": "None",
        "labels": "",
        "priority": "Major",
        "type": "Bug"
    },
    "description": "[junit4] \u00a0 2> NOTE: reproduce with: ant test\u00a0 -Dtestcase=RandomGeoPolygonTest -Dtests.method=testCompareSmallPolygons -Dtests.seed=7BA5F34669E15F97 -Dtests.slow=true -Dtests.badapples=true -Dtests.locale=es-CU -Dtests.timezone=America/La_Paz -Dtests.asserts=true -Dtests.file.encoding=UTF8\n\u00a0\u00a0 [junit4] FAILURE 0.01s | RandomGeoPolygonTest.testCompareSmallPolygons {seed=[7BA5F34669E15F97:F73170EC892310D]} <<<\n\u00a0\u00a0 [junit4]\u00a0 \u00a0 > Throwable #1: java.lang.AssertionError: Test point1 not correctly in/out of set according to test point2\n\u00a0\u00a0 [junit4]\u00a0 \u00a0 > at __randomizedtesting.SeedInfo.seed([7BA5F34669E15F97:F73170EC892310D]:0)\n\u00a0\u00a0 [junit4]\u00a0 \u00a0 > at org.apache.lucene.spatial3d.geom.GeoComplexPolygon.<init>(GeoComplexPolygon.java:239)\n\u00a0\u00a0 [junit4]\u00a0 \u00a0 > at org.apache.lucene.spatial3d.geom.GeoPolygonFactory$BestShape.createGeoComplexPolygon(GeoPolygonFactory.java:465)\n\u00a0\u00a0 [junit4]\u00a0 \u00a0 > at org.apache.lucene.spatial3d.geom.GeoPolygonFactory.makeLargeGeoPolygon(GeoPolygonFactory.java:389)\n\u00a0\u00a0 [junit4]\u00a0 \u00a0 > at org.apache.lucene.spatial3d.geom.GeoPolygonFactory.makeGeoPolygon(GeoPolygonFactory.java:226)\n\u00a0\u00a0 [junit4]\u00a0 \u00a0 > at org.apache.lucene.spatial3d.geom.GeoPolygonFactory.makeGeoPolygon(GeoPolygonFactory.java:142)\n\u00a0\u00a0 [junit4]\u00a0 \u00a0 > at org.apache.lucene.spatial3d.geom.RandomGeoPolygonTest.testComparePolygons(RandomGeoPolygonTest.java:157)\n\u00a0\u00a0 [junit4]\u00a0 \u00a0 > at org.apache.lucene.spatial3d.geom.RandomGeoPolygonTest.testCompareSmallPolygons(RandomGeoPolygonTest.java:109)\n\u00a0\u00a0 [junit4]\u00a0 \u00a0 > at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\u00a0\u00a0 [junit4]\u00a0 \u00a0 > at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n\u00a0\u00a0 [junit4]\u00a0 \u00a0 > at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\u00a0\u00a0 [junit4]\u00a0 \u00a0 > at java.base/java.lang.reflect.Method.invoke(Method.java:564)\n\u00a0\u00a0 [junit4]\u00a0 \u00a0 > at java.base/java.lang.Thread.run(Thread.java:844)\n\u00a0\u00a0 [junit4] OK\u00a0 \u00a0 \u00a0 0.34s | RandomGeoPolygonTest.testCompareSmallPolygons {seed=[7BA5F34669E15F97:3DDFF260BF592657]}\n\u00a0\u00a0 [junit4] OK\u00a0 \u00a0 \u00a0 0.35s | RandomGeoPolygonTest.testCompareSmallPolygons {seed=[7BA5F34669E15F97:EA54A4DADB0E1105]}\n\u00a0\u00a0 [junit4] \u00a0 2> NOTE: test params are: codec=HighCompressionCompressingStoredFields(storedFieldsFormat=CompressingStoredFieldsFormat(compressionMode=HIGH_COMPRESSION, chunkSize=1818, maxDocsPerChunk=791, blockSize=936), termVectorsFormat=CompressingTermVectorsFormat(compressionMode=HIGH_COMPRESSION, chunkSize=1818, blockSize=936)), sim=RandomSimilarity(queryNorm=false): {}, locale=es-CU, timezone=America/La_Paz",
    "attachments": {
        "LUCENE-8512.patch": "https://issues.apache.org/jira/secure/attachment/12940736/LUCENE-8512.patch"
    },
    "issue_links": {},
    "comments": [
        {
            "id": "comment-16623154",
            "author": "Ignacio Vera",
            "content": "Attached is a test reproducing the issue. It seems the test is building a quite degenerated polygon. ",
            "date": "2018-09-21T06:44:55+0000"
        },
        {
            "id": "comment-16623208",
            "author": "ASF subversion and git services",
            "content": "Commit af2de93451bbf0cfffb00dc785feef1a94633644 in lucene-solr's branch refs/heads/master from Karl Wright\n[ https://git-wip-us.apache.org/repos/asf?p=lucene-solr.git;h=af2de93 ]\n\nLUCENE-8512: Add disabled test for failure. ",
            "date": "2018-09-21T07:46:55+0000"
        },
        {
            "id": "comment-16623210",
            "author": "ASF subversion and git services",
            "content": "Commit bf0f10d831a10db1607ef18cc9d85c75fc9122ad in lucene-solr's branch refs/heads/branch_7x from Karl Wright\n[ https://git-wip-us.apache.org/repos/asf?p=lucene-solr.git;h=bf0f10d ]\n\nLUCENE-8512: Add disabled test for failure. ",
            "date": "2018-09-21T07:47:56+0000"
        },
        {
            "id": "comment-16623211",
            "author": "ASF subversion and git services",
            "content": "Commit 4460196af6d13baf325db434084b1243abda0d3e in lucene-solr's branch refs/heads/branch_6x from Karl Wright\n[ https://git-wip-us.apache.org/repos/asf?p=lucene-solr.git;h=4460196 ]\n\nLUCENE-8512: Add disabled test for failure. ",
            "date": "2018-09-21T07:49:22+0000"
        },
        {
            "id": "comment-16624860",
            "author": "Karl Wright",
            "content": "I started looking at this.\nBasically, the problem is that during construction of the GeoComplexPolygon we come up with two points from which to compute crossings: the test point, and the antipodes of the test point.  We then compute whether the antipodes of the test point is in set, and as a confirmation, we compute whether the original point is in set if you start at the test point.  It's that check that fails.\n\nIn this case, logging additions show that the two traversals take different paths.  One path is apparently yielding the right answer, but the other is not:\n\n\n   [junit4]   1> traveling from point1 to point2...\n   [junit4]   1>\n   [junit4]   1> IsInSet called for [0.30714981250962886,0.2184407265252787,-0.9262519320737786], testPoint=[X=-0.30714981250962886, Y=-0.2184407265252787, Z=0.9262519320737786]; is in set? true\n   [junit4]   1>  Using two planes\n   [junit4]   1> Trying traversal strategy {firstLegValue=-0.2184407265252787; secondLegValue=0.30714981250962886; firstLegPlane=[A=0.0, B=1.0; C=0.0; D=0.2184407265252787]; secondLegPlane=[A=1.0, B=0.0; C=0.0; D=-0.30714981250962886]; intersectionPoint=[X=0.30714981250962886, Y=-0.2184407265252787, Z=0.9262519320737789]}\n   [junit4]   1> Applying traversal strategy...\n   [junit4]   1> traveling from poin2 to point1...\n   [junit4]   1>\n   [junit4]   1> IsInSet called for [-0.30714981250962886,-0.2184407265252787,0.9262519320737786], testPoint=[X=0.30714981250962886, Y=0.2184407265252787, Z=-0.9262519320737786]; is in set? true\n   [junit4]   1>  Using two planes\n   [junit4]   1> Trying traversal strategy {firstLegValue=0.2184407265252787; secondLegValue=-0.30714981250962886; firstLegPlane=[A=0.0, B=1.0; C=0.0; D=-0.2184407265252787]; secondLegPlane=[A=1.0, B=0.0; C=0.0; D=0.30714981250962886]; intersectionPoint=[X=-0.30714981250962886, Y=0.2184407265252787, Z=0.9262519320737789]}\n   [junit4]   1> Applying traversal strategy...\n\n\n\nIgnacio Vera, what I need to know is which traversal (p1->p2 or p2->p1) is yielding the incorrect result.  Some visualization would help a lot I think. ",
            "date": "2018-09-22T23:26:30+0000"
        },
        {
            "id": "comment-16624978",
            "author": "Karl Wright",
            "content": "More debug output:\n\n\n   [junit4] Suite: org.apache.lucene.spatial3d.geom.GeoPolygonTest\n   [junit4]   1> traveling from point1 to point2...\n   [junit4]   1> \n   [junit4]   1> IsInSet called for [0.30714981250962886,0.2184407265252787,-0.9262519320737786], testPoint=[X=-0.30714981250962886, Y=-0.2184407265252787, Z=0.9262519320737786]; is in set? true\n   [junit4]   1>  Using two planes\n   [junit4]   1> Trying traversal strategy {firstLegValue=-0.2184407265252787; secondLegValue=0.30714981250962886; firstLegPlane=[A=0.0, B=1.0; C=0.0; D=0.2184407265252787]; secondLegPlane=[A=1.0, B=0.0; C=0.0; D=-0.30714981250962886]; intersectionPoint=[X=0.30714981250962886, Y=-0.2184407265252787, Z=0.9262519320737789]}\n   [junit4]   1> Applying traversal strategy...\n   [junit4]   1>  Finding whether [X=0.30714981250962886, Y=-0.2184407265252787, Z=0.9262519320737789] is in-set, based on travel from [X=-0.30714981250962886, Y=-0.2184407265252787, Z=0.9262519320737786] along [A=0.0, B=1.0; C=0.0; D=0.2184407265252787] (value=-0.2184407265252787)\n   [junit4]   1>  creating sector linear crossing edge iterator\n   [junit4]   1>  Finding whether [0.30714981250962886,0.2184407265252787,-0.9262519320737786] is in-set, based on travel from [X=0.30714981250962886, Y=-0.2184407265252787, Z=0.9262519320737789] along [A=1.0, B=0.0; C=0.0; D=-0.30714981250962886] (value=0.30714981250962886)\n   [junit4]   1>  creating sector linear crossing edge iterator\n   [junit4]   1>  failed; create full linear crossing edge iterator\n   [junit4]   1>  Constructing full linear crossing edge iterator\n   [junit4]   1> \n   [junit4]   1>  The following edges intersect the travel plane within the given bounds:\n   [junit4]   1>   Edge [lat=-1.18434322804154, lon=0.618199439360918([X=0.3071490586684479, Y=0.2184426438256418, Z=-0.9262517298864009])] --> [lat=-1.1843453737470075, lon=0.6181782206159809([X=0.30715207402261285, Y=0.21843497462105488, Z=-0.9262525386123953])]:\n   [junit4]   1>    ... intersects!!\n   [junit4]   1>   Edge [lat=-1.1843453737470075, lon=0.6181782206159809([X=0.30715207402261285, Y=0.21843497462105488, Z=-0.9262525386123953])] --> [lat=-1.1843432280405986, lon=0.6181994393547311([X=0.30714905867051, Y=0.21844264382424686, Z=-0.9262517298860461])]:\n   [junit4]   1>    ... intersection [X=0.30714981250962886, Y=-0.9497725277626164, Z=0.05992610601991444] excluded by edge start plane (-0.9856796711858306)\n   [junit4]   1>    ... intersection [X=0.30714981250962886, Y=-0.9497725277626164, Z=0.05992610601991444] excluded by edge backing plane (-0.1686326247309164)\n   [junit4]   1>    ... intersection [X=0.30714981250962886, Y=0.21844072652709384, Z=-0.9262519320733508] excluded by iterator bound (-1.8648971256141067E-12)\n   [junit4]   1>   Edge [lat=-1.1843432280405986, lon=0.6181994393547311([X=0.30714905867051, Y=0.21844264382424686, Z=-0.9262517298860461])] --> [lat=-1.1843432280416921, lon=0.618199439357646([X=0.30714905866904785, Y=0.21844264382455517, Z=-0.9262517298864584])]:\n   [junit4]   1>    ... intersection [X=0.30714981250962886, Y=-0.29365668638619585, Z=0.9052208256640913] excluded by edge start plane (-0.5888137834947567)\n   [junit4]   1>    ... intersection [X=0.30714981250962886, Y=-0.29365668638619585, Z=0.9052208256640913] excluded by edge backing plane (-0.8082687228684081)\n   [junit4]   1>    ... intersection [X=0.30714981250962886, Y=0.21844248489294116, Z=-0.9262515173909822] excluded by iterator bound (-1.806604178589133E-6)\n   [junit4]   1>    ... intersection [X=0.30714981250962886, Y=0.21844248489294116, Z=-0.9262515173909822] excluded by edge start plane (-7.991787842054343E-7)\n   [junit4]   1>   Edge [lat=-1.1843432280416921, lon=0.618199439357646([X=0.30714905866904785, Y=0.21844264382455517, Z=-0.9262517298864584])] --> [lat=-1.18434322804154, lon=0.618199439360918([X=0.3071490586684479, Y=0.2184426438256418, Z=-0.9262517298864009])]:\n   [junit4]   1>    ... intersection [X=0.3071498125096288, Y=-0.8847045499103079, Z=0.35065203841315323] excluded by edge start plane (-0.9057986100955359)\n   [junit4]   1>    ... intersection [X=0.3071498125096288, Y=-0.8847045499103079, Z=0.35065203841315323] excluded by edge backing plane (-0.4237084822722725)\n   [junit4]   1>    ... intersection [X=0.3071498125096288, Y=0.21844127824994175, Z=-0.9262518019587498] excluded by iterator bound (-5.668597927166452E-7)\n   [junit4]   1>    ... intersection [X=0.3071498125096288, Y=0.21844127824994175, Z=-0.9262518019587498] excluded by edge start plane (-1.5614941759473089E-6)\n   [junit4]   1>  ...done\n   [junit4]   1> \n   [junit4]   1>  Edge [[lat=-1.18434322804154, lon=0.618199439360918([X=0.3071490586684479, Y=0.2184426438256418, Z=-0.9262517298864009])] --> [lat=-1.1843453737470075, lon=0.6181782206159809([X=0.30715207402261285, Y=0.21843497462105488, Z=-0.9262525386123953])]] potentially crosses travel plane [A=1.0, B=0.0; C=0.0; D=-0.30714981250962886]\n   [junit4]   1>   Point is on the edge; in-set\n   [junit4]   1>  Check point in set? true\n   [junit4]   1> traveling from poin2 to point1...\n   [junit4]   1> \n   [junit4]   1> IsInSet called for [-0.30714981250962886,-0.2184407265252787,0.9262519320737786], testPoint=[X=0.30714981250962886, Y=0.2184407265252787, Z=-0.9262519320737786]; is in set? true\n   [junit4]   1>  Using two planes\n   [junit4]   1> Trying traversal strategy {firstLegValue=0.2184407265252787; secondLegValue=-0.30714981250962886; firstLegPlane=[A=0.0, B=1.0; C=0.0; D=-0.2184407265252787]; secondLegPlane=[A=1.0, B=0.0; C=0.0; D=0.30714981250962886]; intersectionPoint=[X=-0.30714981250962886, Y=0.2184407265252787, Z=0.9262519320737789]}\n   [junit4]   1> Applying traversal strategy...\n   [junit4]   1>  Finding whether [X=-0.30714981250962886, Y=0.2184407265252787, Z=0.9262519320737789] is in-set, based on travel from [X=0.30714981250962886, Y=0.2184407265252787, Z=-0.9262519320737786] along [A=0.0, B=1.0; C=0.0; D=-0.2184407265252787] (value=0.2184407265252787)\n   [junit4]   1>  creating sector linear crossing edge iterator\n   [junit4]   1>  failed; create full linear crossing edge iterator\n   [junit4]   1>  Constructing full linear crossing edge iterator\n   [junit4]   1> \n   [junit4]   1>  The following edges intersect the travel plane within the given bounds:\n   [junit4]   1>   Edge [lat=-1.18434322804154, lon=0.618199439360918([X=0.3071490586684479, Y=0.2184426438256418, Z=-0.9262517298864009])] --> [lat=-1.1843453737470075, lon=0.6181782206159809([X=0.30715207402261285, Y=0.21843497462105488, Z=-0.9262525386123953])]:\n   [junit4]   1>    ... intersects!!\n   [junit4]   1>   Edge [lat=-1.1843453737470075, lon=0.6181782206159809([X=0.30715207402261285, Y=0.21843497462105488, Z=-0.9262525386123953])] --> [lat=-1.1843432280405986, lon=0.6181994393547311([X=0.30714905867051, Y=0.21844264382424686, Z=-0.9262517298860461])]:\n   [junit4]   1>    ... intersects!!\n   [junit4]   1>   Edge [lat=-1.1843432280405986, lon=0.6181994393547311([X=0.30714905867051, Y=0.21844264382424686, Z=-0.9262517298860461])] --> [lat=-1.1843432280416921, lon=0.618199439357646([X=0.30714905866904785, Y=0.21844264382455517, Z=-0.9262517298864584])]:\n   [junit4]   1>    ... intersection [X=0.3071581526992726, Y=0.2184407265252787, Z=-0.9262491663831491] excluded by iterator bound (-8.786797365933907E-6)\n   [junit4]   1>    ... intersection [X=0.3071581526992726, Y=0.2184407265252787, Z=-0.9262491663831491] excluded by edge start plane (-9.641003141158677E-6)\n   [junit4]   1>    ... intersection [X=-0.9103783615736771, Y=0.2184407265252787, Z=-0.35141839418780496] excluded by edge end plane (0.9956101834689639)\n   [junit4]   1>   Edge [lat=-1.1843432280416921, lon=0.618199439357646([X=0.30714905866904785, Y=0.21844264382455517, Z=-0.9262517298864584])] --> [lat=-1.18434322804154, lon=0.618199439360918([X=0.3071490586684479, Y=0.2184426438256418, Z=-0.9262517298864009])]:\n   [junit4]   1>    ... intersection [X=0.30715011707887946, Y=0.2184407265252787, Z=-0.9262518310770235] excluded by iterator bound (-3.208781279018247E-7)\n   [junit4]   1>    ... intersection [X=0.30715011707887946, Y=0.2184407265252787, Z=-0.9262518310770235] excluded by edge start plane (-2.1923748351124206E-6)\n   [junit4]   1>    ... intersection [X=-0.49808352522711535, Y=0.2184407265252787, Z=0.8391641382306788] excluded by edge end plane (0.4702254126647571)\n   [junit4]   1>    ... intersection [X=-0.49808352522711535, Y=0.2184407265252787, Z=0.8391641382306788] excluded by edge backing plane (-0.8825463507854838)\n   [junit4]   1>  ...done\n   [junit4]   1> \n   [junit4]   1>  Edge [[lat=-1.18434322804154, lon=0.618199439360918([X=0.3071490586684479, Y=0.2184426438256418, Z=-0.9262517298864009])] --> [lat=-1.1843453737470075, lon=0.6181782206159809([X=0.30715207402261285, Y=0.21843497462105488, Z=-0.9262525386123953])]] potentially crosses travel plane [A=0.0, B=1.0; C=0.0; D=-0.2184407265252787]\n   [junit4]   1>   Edge intersects travel plane [A=0.0, B=1.0; C=0.0; D=-0.2184407265252787]\n   [junit4]   1>   Above crossings = 1; below crossings = 1\n   [junit4]   1>  Edge [[lat=-1.1843453737470075, lon=0.6181782206159809([X=0.30715207402261285, Y=0.21843497462105488, Z=-0.9262525386123953])] --> [lat=-1.1843432280405986, lon=0.6181994393547311([X=0.30714905867051, Y=0.21844264382424686, Z=-0.9262517298860461])]] potentially crosses travel plane [A=0.0, B=1.0; C=0.0; D=-0.2184407265252787]\n   [junit4]   1>   Edge intersects travel plane [A=0.0, B=1.0; C=0.0; D=-0.2184407265252787]\n   [junit4]   1>   Above crossings = 0; below crossings = 1\n   [junit4]   1>  Finding whether [-0.30714981250962886,-0.2184407265252787,0.9262519320737786] is in-set, based on travel from [X=-0.30714981250962886, Y=0.2184407265252787, Z=0.9262519320737789] along [A=1.0, B=0.0; C=0.0; D=0.30714981250962886] (value=-0.30714981250962886)\n   [junit4]   1>  creating sector linear crossing edge iterator\n   [junit4]   1>  Check point in set? false\n   [junit4]   2> NOTE: reproduce with: ant test  -Dtestcase=GeoPolygonTest -Dtests.method=testLUCENE8512 -Dtests.seed=571E0D8955849CAB -Dtests.slow=true -Dtests.badapples=true -Dtests.locale=en-GB -Dtests.timezone=Asia/Macau -Dtests.asserts=true -Dtests.file.encoding=US-ASCII\n   [junit4] FAILURE 0.17s | GeoPolygonTest.testLUCENE8512 <<<\n\n ",
            "date": "2018-09-23T06:00:50+0000"
        },
        {
            "id": "comment-16624980",
            "author": "Karl Wright",
            "content": "It looks like travel from test point 1 to test point 2 comes back as \"in set\" because test point 2 is \"in set\":\n\n\n   [junit4]   1>   Point is on the edge; in-set\n\n\n\nWe then try to count edges from test point 2 back to test point 1, and of course that doesn't work because you can't start on an edge to do counting like that.  Really, this is just a case of test point 2 being invalid, seems to me.  Gotta think of a solution though. ",
            "date": "2018-09-23T06:09:07+0000"
        },
        {
            "id": "comment-16624987",
            "author": "Karl Wright",
            "content": "Generally, we realized a while back that when a starting point is on an edge, we can't use it.  The problem is that we realized this was true for intersection points, but we never put in code that would prevent it for test points.\n\nThere is one test point that is passed into the GeoComplexPolygon constructor which is computed by the factory.  There is a second test point which is used as an alternative to the first test point for situations where the first test point doesn't work out.  There is nothing that stops us from using a bad second test point, however, and that's what the problem is with this test case.  I'm also concerned that there's no real check to be certain that the first test point is valid either \u2013 it seems to me that the constructor should throw an IllegalArgumentException in that case, and the factory should try another test point then.\n\nI'm not sure that the second test point is necessary any longer either, since we have now multiple traversal strategies available.  I'm going to try to disable it entirely and see what happens.  Our tests should be sufficient to tell us if this is a bad idea. ",
            "date": "2018-09-23T06:35:25+0000"
        },
        {
            "id": "comment-16625056",
            "author": "Karl Wright",
            "content": "I've confirmed that testPoint2 is unneeded now, and will remove that code. ",
            "date": "2018-09-23T10:29:30+0000"
        },
        {
            "id": "comment-16625064",
            "author": "ASF subversion and git services",
            "content": "Commit 63fcf2edcaa2d203a65f03365bb17001a6ee094f in lucene-solr's branch refs/heads/master from Karl Wright\n[ https://git-wip-us.apache.org/repos/asf?p=lucene-solr.git;h=63fcf2e ]\n\nLUCENE-8512: Remove second test point since no longer needed, and confirm rigorously that first test point is not on an edge. ",
            "date": "2018-09-23T10:46:10+0000"
        },
        {
            "id": "comment-16625065",
            "author": "ASF subversion and git services",
            "content": "Commit 62203f4ee0e90e92df6fdeefcdf939dfc1c4a535 in lucene-solr's branch refs/heads/branch_7x from Karl Wright\n[ https://git-wip-us.apache.org/repos/asf?p=lucene-solr.git;h=62203f4 ]\n\nLUCENE-8512: Remove second test point since no longer needed, and confirm rigorously that first test point is not on an edge. ",
            "date": "2018-09-23T10:46:44+0000"
        },
        {
            "id": "comment-16625066",
            "author": "ASF subversion and git services",
            "content": "Commit 63a90d2f9a29d51eee5e775a502169293737ec0b in lucene-solr's branch refs/heads/branch_6x from Karl Wright\n[ https://git-wip-us.apache.org/repos/asf?p=lucene-solr.git;h=63a90d2 ]\n\nLUCENE-8512: Remove second test point since no longer needed, and confirm rigorously that first test point is not on an edge. ",
            "date": "2018-09-23T10:47:14+0000"
        }
    ]
}