{
    "id": "LUCENE-855",
    "title": "MemoryCachedRangeFilter to boost performance of Range queries",
    "details": {
        "labels": "",
        "priority": "Major",
        "components": [
            "core/search"
        ],
        "type": "Improvement",
        "fix_versions": [],
        "affect_versions": "2.1",
        "resolution": "Duplicate",
        "status": "Closed"
    },
    "description": "Currently RangeFilter uses TermEnum and TermDocs to find documents that fall within the specified range.  This requires iterating through every single term in the index and can get rather slow for large document sets.\n\nMemoryCachedRangeFilter reads all <docId, value> pairs of a given field, sorts by value, and stores in a SortedFieldCache.  During bits(), binary searches are used to find the start and end indices of the lower and upper bound values.  The BitSet is populated by all the docId values that fall in between the start and end indices.\n\nTestMemoryCachedRangeFilterPerformance creates a 100K RAMDirectory-backed index with random date values within a 5 year range.  Executing bits() 1000 times on standard RangeQuery using random date intervals took 63904ms.  Using MemoryCachedRangeFilter, it took 876ms.  Performance increase is less dramatic when you have less unique terms in a field or using less number of documents.\n\nCurrently MemoryCachedRangeFilter only works with numeric values (values are stored in a long[] array) but it can be easily changed to support Strings.  A side \"benefit\" of storing the values are stored as longs, is that there's no longer the need to make the values lexographically comparable, i.e. padding numeric values with zeros.\n\nThe downside of using MemoryCachedRangeFilter is there's a fairly significant memory requirement.  So it's designed to be used in situations where range filter performance is critical and memory consumption is not an issue.  The memory requirements are: (sizeof(int) + sizeof(long)) * numDocs.  \n\nMemoryCachedRangeFilter also requires a warmup step which can take a while to run in large datasets (it took 40s to run on a 3M document corpus).  Warmup can be called explicitly or is automatically called the first time MemoryCachedRangeFilter is applied using a given field.\n\nSo in summery, MemoryCachedRangeFilter can be useful when:\n\n\tPerformance is critical\n\tMemory is not an issue\n\tField contains many unique numeric values\n\tIndex contains large amount of documents",
    "attachments": {
        "FieldCacheRangeFilter.patch": "https://issues.apache.org/jira/secure/attachment/12355105/FieldCacheRangeFilter.patch",
        "MemoryCachedRangeFilter_1.4.patch": "https://issues.apache.org/jira/secure/attachment/12355077/MemoryCachedRangeFilter_1.4.patch",
        "FieldCacheRangeFilter_Lucene_2.3.0.patch": "https://issues.apache.org/jira/secure/attachment/12374701/FieldCacheRangeFilter_Lucene_2.3.0.patch",
        "MemoryCachedRangeFilter.patch": "https://issues.apache.org/jira/secure/attachment/12354791/MemoryCachedRangeFilter.patch",
        "contrib-filters.tar.gz": "https://issues.apache.org/jira/secure/attachment/12355388/contrib-filters.tar.gz",
        "TestRangeFilterPerformanceComparison.java": "https://issues.apache.org/jira/secure/attachment/12355183/TestRangeFilterPerformanceComparison.java"
    },
    "issue_links": {},
    "comments": [
        {
            "date": "2007-04-02T21:53:43+0000",
            "content": "Patch produced from latest from SVN ",
            "author": "Andy Liu",
            "id": "comment-12486148"
        },
        {
            "date": "2007-04-04T20:11:13+0000",
            "content": "A colleague of mine is working on something similar, but possibly more efficient (less sorting and binary searching).  He'll probably attach his patch to this issue. ",
            "author": "Otis Gospodnetic",
            "id": "comment-12486758"
        },
        {
            "date": "2007-04-04T20:22:54+0000",
            "content": "There is also something from Mark Harwood:\nhttps://issues.apache.org/jira/browse/LUCENE-798 ",
            "author": "Yonik Seeley",
            "id": "comment-12486763"
        },
        {
            "date": "2007-04-04T20:48:50+0000",
            "content": "Otis, looking forward to your colleague's patch.\n\nLUCENE-798 caches RangeFilters so that if the same exact range is executed again, the cached RangeFilter is used.  However, the first time a range is encountered, you'll still have to calculate the RangeFilter, which can be slow.  I haven't looked at the patch, but I'm sure LUCENE-798 can be used in conjunction with MemoryCachedRangeFilter to further boost performance for repeated range queries. ",
            "author": "Andy Liu",
            "id": "comment-12486767"
        },
        {
            "date": "2007-04-04T21:44:04+0000",
            "content": "> LUCENE-798 caches RangeFilters so that if the same exact range is executed again [...]\n\nIt's not just the exact same range though... it can reuse parts of ranges AFAIK.\n ",
            "author": "Yonik Seeley",
            "id": "comment-12486788"
        },
        {
            "date": "2007-04-04T22:00:31+0000",
            "content": "Ah, you're right.  I didn't read closely enough! ",
            "author": "Andy Liu",
            "id": "comment-12486791"
        },
        {
            "date": "2007-04-05T21:43:51+0000",
            "content": "I am almost done with my patch and I wanted to test it against this patch so see who has the faster version \nBut the MemoryCachedRangeFilter is written using Java 1.5\n\nAnd as far as I know Lucene is still on java 1.4 \n\nLines like \nprivate static WeakHashMap<IndexReader, Map<String,SortedFieldCache>> cache = new WeakHashMap<IndexReader, Map<String, SortedFieldCache>>();\n\n\nWill not compile in java 1.4 Andy I would love to see who has the faster patch if you would convert your patch to use java 1.4 I would be happy to put them side by side ",
            "author": "Matt Ericson",
            "id": "comment-12487108"
        },
        {
            "date": "2007-04-06T13:14:53+0000",
            "content": "Here's a patch that should compile in Java 1.4 .  It includes\n\nsrc/java/org/apache/lucene/search/MemoryCachedRangeFilter.java\nsrc/test/org/apache/lucene/search/TestMemoryCachedRangeFilter.java\nsrc/test/org/apache/lucene/search/TestMemoryCachedRangeFilterPerformance.java\n\nYou can try using TestMemoryCachedRangeFilterPerformance to compare runtime speed numbers.  Let me know if you have any problem running these. ",
            "author": "Andy Liu",
            "id": "comment-12487232"
        },
        {
            "date": "2007-04-06T20:53:26+0000",
            "content": "Here is my Version of a FieldCacheRangeFilter\n\nI used different class names so both patch can be applied to lucene but they do almost the same thing so I do not think they both should be committed. \n\nThis Filter uses the Field Cache to to get values out of the index and then creates BitSets that are proxies to the field cache.  So when you do a BitSet.get(int bitIndex) It will check the Field Cache \n\nOne think to note is that since this is a proxy to the field cache it will not work with the current version of ChainedFilters.java (But I have a fix for that also) Since the Chained Filter will make a copy of the bit set and flip the bits. This bit set will not work. \n\nThis version will use less memory since there is only 1 copy if the data and the BitSet is just a proxy it has no data in it. \n\nI want to thank Andy as I have uses/ stolen all of your tests and modified them just a but so they work with my version. And since we have the same performance tests here are the numbers\n\nUsing Andy's code \n\n    [junit] ------------- Standard Output ---------------\n    [junit] Start interval: Sun Apr 07 13:49:15 PDT 2002\n    [junit] End interval: Fri Apr 06 13:49:15 PDT 2007\n    [junit] Creating RAMDirectory index...\n    [junit] Reader opened with 100000 documents.  Creating RangeFilters...\n    [junit] Standard RangeFilter finished in 58585ms\n    [junit] MemoryCachedRangeFilter inished in 825ms\n    [junit] ------------- ---------------- ---------------\n\nUsing My code \n\n    [junit] ------------- Standard Output ---------------\n    [junit] Start interval: Sun Apr 07 13:40:52 PDT 2002\n    [junit] End interval: Fri Apr 06 13:40:52 PDT 2007\n    [junit] Creating RAMDirectory index...\n    [junit] Reader opened with 100000 documents.  Creating RangeFilters...\n    [junit] Standard RangeFilter finished in 58528ms\n    [junit] FieldCacheRangeFilter inished in 30ms\n    [junit] ------------- ---------------- --------------- ",
            "author": "Matt Ericson",
            "id": "comment-12487332"
        },
        {
            "date": "2007-04-07T03:24:13+0000",
            "content": "Hey Matt,\n\nThe way you implemented FieldCacheRangeFilter is very simple and clever!  Here's a couple comments:\n\n1. My performance test that we both used is no longer valid, since FieldCacheRangeFilter.bits() only returns a wrapper around a BitSet.  The test only calls bits() .  Since you're wrapping BitSet, there's some overhead incurred when applying it to an actual search.  I reran the performance test applying the Filter to a search, and your implementation is still faster, although only slightly.\n\n2. Your filter currently doesn't work with ConstantRangeQuery.  CRQ calls bits.nextSetBit() which fails in your wrapped BitSet implementation.  Your incomplete implementation of BitSet may cause problems elsewhere.\n\nIf you can fix #2 I'd vote for your implementation since it's cleaner and faster, although I might take another stab at trying to improve my implementation. ",
            "author": "Andy Liu",
            "id": "comment-12487378"
        },
        {
            "date": "2007-04-07T04:02:50+0000",
            "content": "I will be happy to fix #2 or a to try to fix #2 \n\nThe test had the real work done out side the Timing \n\nThe other thing I like about is is that there is less data saved in cache. Some of our indexes are 10 Gigs so every bite counts at least in my application. \n\n ",
            "author": "Matt Ericson",
            "id": "comment-12487380"
        },
        {
            "date": "2007-04-08T21:45:14+0000",
            "content": "Andy was correct the 2 performance tests were bogus as they did not call get() from the bit sets. And my code does all of the work int the get() call.  I guess I should have looked a little closer at the tests before using it\n\nI changes his tests and mine to call and IndexSearcher.search(q,filter) and actually do the search \nHere are the results \n\nUsing the MemoryCachedRangeFilter\n\n    [junit] ------------- Standard Output ---------------\n    [junit] Start interval: Tue Apr 09 14:32:14 PDT 2002\n    [junit] End interval: Sun Apr 08 14:32:14 PDT 2007\n    [junit] Creating RAMDirectory index...\n    [junit] Reader opened with 100000 documents.  Creating RangeFilters...\n    [junit] Standard RangeFilter finished in 57533ms\n    [junit] MemoryCachedRangeFilter inished in 905ms\n    [junit] ------------- ---------------- ---------------\n\nUsing FieldCacheRangeFilter\n\n    [junit] ------------- Standard Output ---------------\n    [junit] Start interval: Tue Apr 09 14:30:29 PDT 2002\n    [junit] End interval: Sun Apr 08 14:30:29 PDT 2007\n    [junit] Creating RAMDirectory index...\n    [junit] Reader opened with 100000 documents.  Creating RangeFilters...\n    [junit] Standard RangeFilter finished in 58822ms\n    [junit] FieldCacheRangeFilter inished in 102ms\n    [junit] ------------- ---------------- ---------------\n\nThey are much closer this time \n\nI have fixed my BitSets to allow a user to call nextClearBit or nextSetBit ",
            "author": "Matt Ericson",
            "id": "comment-12487460"
        },
        {
            "date": "2007-04-09T16:47:50+0000",
            "content": "This version will create a real BitSet() when cloned and will allow chained filter to work correctly \n ",
            "author": "Matt Ericson",
            "id": "comment-12487578"
        },
        {
            "date": "2007-04-09T17:27:38+0000",
            "content": "OK.  I'll wait for the new performance numbers before committing.  Andy, if you see anything funky in Matt's patch or if you managed to make your version faster, let us know, please. ",
            "author": "Otis Gospodnetic",
            "id": "comment-12487587"
        },
        {
            "date": "2007-04-09T18:18:44+0000",
            "content": "Comments about the patch so far:\nCosmetics:\n\n\tYou don't want to refer to Andy's class in javadocs, as that class won't go in unless Andy makes it faster.\n\tI see some incorrect (copy/paste error) javadocs and javadocs/comments with typos in both the test classes and non-test classes.\n\tPlease configure your Lucene project in Eclipse to use 2 spaces instead of 4.  In general, once you get the code formatting settings right, it's a good practise to format your code with that setting before submitting a patch.\n\n\n\nTesting:\n\n\tYou can put the testPerformance() code from  TestFieldCacheRangeFilterPerformance  in the other unit test class you have there.\n\tYour testPerformance() doesn't actually assert...() anything, just prints out numbers to stdout.  You can keep the printing, but it would be better to also do some asserts, so we can always test that the FCRangerFilter beats the vanilla RangeFilter without looking at the stdout.\n\tYou may want to close that searcher in testPerformance() before opening a new one.  Probably won't make any difference, but still.\n\tYou may also want to just close the searcher at the end of the method.\n\n\n\n\nImpl:\n\n\tIn the inner FieldCacheBitSet class, I see:\n+        public boolean intersects(BitSet set)  {\n+            for (int i =0; i < length; i++) \nUnknown macro: {+                if (get(i) && set.get(i)) {\n+                    return true;\n+                }+            } \n+            return false;\n+        }\n\n\n\nIs there room for a small optimization?  What if BitSets are not of equal size?  Wouldn't it make sense to loop through a smaller BitSet then?  Sorry if I'm off, I hardly ever work with BitSets.\n\n\n\tI see you made *_PARSERs in FCImpl public (were private).  Is that really needed?  Would ackage protected be enough?\n\n\n\n\n\tMake sure ASL is in all test and non-test classes, I don't see it there now.\n\n\n\n\nOverall, I like it - slick and elegant usage of FC!\n\nI'd love to know what Hoss and other big Filter users think about this.  Solr makes a lof of use of (Range?)Filters, I believe. ",
            "author": "Otis Gospodnetic",
            "id": "comment-12487590"
        },
        {
            "date": "2007-04-09T18:36:32+0000",
            "content": "In your updated benchmark, you're combining the range filter with a term query that matches one document.  I don't believe that's the typical use case for a range filter.  Usually the user employs a range to filter a large document set.  \n\nI created a different benchmark to compare standard range filter, MemoryCachedRangeFilter, and Matt's FieldCacheRangeFilter using MatchAllDocsQuery, ConstantScoreQuery, and TermQuery (matching one doc like the last benchmark).  Here are the results:\n\nReader opened with 100000 documents.  Creating RangeFilters...\nRangeFilter w/MatchAllDocsQuery:\n========================\n\n\tBits: 4421\n\tSearch: 5285\n\n\n\nRangeFilter w/ConstantScoreQuery:\n========================\n\n\tBits: 4200\n\tSearch: 8694\n\n\n\nRangeFilter w/TermQuery:\n========================\n\n\tBits: 4088\n\tSearch: 4133\n\n\n\nMemoryCachedRangeFilter w/MatchAllDocsQuery:\n========================\n\n\tBits: 80\n\tSearch: 1142\n\n\n\nMemoryCachedRangeFilter w/ConstantScoreQuery:\n========================\n\n\tBits: 79\n\tSearch: 482\n\n\n\nMemoryCachedRangeFilter w/TermQuery:\n========================\n\n\tBits: 73\n\tSearch: 95\n\n\n\nFieldCacheRangeFilter w/MatchAllDocsQuery:\n========================\n\n\tBits: 0\n\tSearch: 1146\n\n\n\nFieldCacheRangeFilter w/ConstantScoreQuery:\n========================\n\n\tBits: 1\n\tSearch: 356\n\n\n\nFieldCacheRangeFilter w/TermQuery:\n========================\n\n\tBits: 0\n\tSearch: 19\n\n\n\nHere's some points:\n\n1. When searching in a filter, bits() is called, so the search time includes bits() time.\n2. Matt's FieldCacheRangeFilter is faster for ConstantScoreQuery, although not by much.  Using MatchAllDocsQuery, they run neck-and-neck.  FCRF is much faster for TermQuery since MCRF has to create the BItSet for the range before the search is executed.\n3. I get less document hits when running FieldCacheRangeFilter with ConstantScoreQuery.  Matt, there may be a bug in getNextSetBit().  Not sure if this would affect the benchmark.\n4. I'd be interested to see performance numbers when FieldCacheRangeFilter is used with ChainedFilter.  I suspect that MCRF would be faster in this case, since I'm assuming that FCRF has to reconstruct a standard BitSet during clone(). ",
            "author": "Andy Liu",
            "id": "comment-12487595"
        },
        {
            "date": "2007-04-09T18:37:46+0000",
            "content": "Here's my new benchmark. ",
            "author": "Andy Liu",
            "id": "comment-12487596"
        },
        {
            "date": "2007-04-10T18:00:21+0000",
            "content": "Andy thank you for that test \n\nI took at Moved it to contrib/miscellaneous and added a few more tests including the Chained Filter test. Here is my version. Also I fixed a few bugs in my code that I will be attaching next .\n\nI also reformatted my results I think they are a little easer to read. \nHere is what I get and your right if you use a MatchAllDocsQuery our 2 version of the code are about the same \n\n    [junit] ------------- Standard Output ---------------\n    [junit] Start interval: Thu Apr 11 10:55:02 PDT 2002\n    [junit] End interval: Tue Apr 10 10:55:02 PDT 2007\n    [junit] Creating RAMDirectory index...\n    [junit] Reader opened with 100000 documents.  Creating RangeFilters...\n\n    [junit] TermQuery\n\n    [junit] FieldCacheRangeFilter\n    [junit]   * Total: 13ms\n    [junit]   * Bits: 0ms\n    [junit]   * Search: 9ms\n    [junit] MemoryCachedRangeFilter\n    [junit]   * Total: 209ms\n    [junit]   * Bits: 90ms\n    [junit]   * Search: 115ms\n    [junit] RangeFilter\n    [junit]   * Total: 12068ms\n    [junit]   * Bits: 6009ms\n    [junit]   * Search: 6051ms\n    [junit] Chained FieldCacheRangeFilter\n    [junit]   * Total: 15ms\n    [junit]   * Bits: 1ms\n    [junit]   * Search: 10ms\n    [junit] Chained MemoryCachedRangeFilter\n    [junit]   * Total: 177ms\n    [junit]   * Bits: 83ms\n    [junit]   * Search: 90ms\n\n    [junit] ConstantScoreQuery\n\n    [junit] FieldCacheRangeFilter\n    [junit]   * Total: 480ms\n    [junit]   * Bits: 1ms\n    [junit]   * Search: 474ms\n    [junit] MemoryCachedRangeFilter\n    [junit]   * Total: 757ms\n    [junit]   * Bits: 90ms\n    [junit]   * Search: 663ms\n    [junit] RangeFilter\n    [junit]   * Total: 18749ms\n    [junit]   * Bits: 6083ms\n    [junit]   * Search: 12655ms\n    [junit] Chained FieldCacheRangeFilter\n    [junit]   * Total: 11ms\n    [junit]   * Bits: 0ms\n    [junit]   * Search: 8ms\n    [junit] Chained MemoryCachedRangeFilter\n    [junit]   * Total: 776ms\n    [junit]   * Bits: 87ms\n    [junit]   * Search: 682ms\n\n    [junit] MatchAllDocsQuery\n\n    [junit] FieldCacheRangeFilter\n    [junit]   * Total: 1344ms\n    [junit]   * Bits: 5ms\n    [junit]   * Search: 1334ms\n    [junit] MemoryCachedRangeFilter\n    [junit]   * Total: 1468ms\n    [junit]   * Bits: 81ms\n    [junit]   * Search: 1381ms\n    [junit] RangeFilter\n    [junit]   * Total: 13360ms\n    [junit]   * Bits: 6091ms\n    [junit]   * Search: 7254ms\n    [junit] Chained FieldCacheRangeFilter\n    [junit]   * Total: 924ms\n    [junit]   * Bits: 4ms\n    [junit]   * Search: 916ms\n    [junit] Chained MemoryCachedRangeFilter\n    [junit]   * Total: 1507ms\n    [junit]   * Bits: 84ms\n    [junit]   * Search: 1415ms\n    [junit] ------------- ---------------- --------------- ",
            "author": "Matt Ericson",
            "id": "comment-12487850"
        },
        {
            "date": "2007-04-10T18:04:21+0000",
            "content": "Fixed a bug with the BitSets nextSetBit and nextClearBit I wrote a test to verify that it returns the same values as a Normal BitSet . I dont use these functions if someone wants to verify my fix that would be great.\n\nAdded the ASF to the top of each file \nAnd fixed all of Otis bugs ",
            "author": "Matt Ericson",
            "id": "comment-12487856"
        },
        {
            "date": "2007-04-10T19:43:43+0000",
            "content": "Hey Matt, I get this exception when running your newest FCRF with the performance test.  Can you check to see if you get this also?\n\njava.lang.ArrayIndexOutOfBoundsException: 100000\n\tat org.apache.lucene.search.FieldCacheRangeFilter$5.get(FieldCacheRangeFilter.java:231)\n\tat org.apache.lucene.search.IndexSearcher$1.collect(IndexSearcher.java:136)\n\tat org.apache.lucene.search.Scorer.score(Scorer.java:49)\n\tat org.apache.lucene.search.IndexSearcher.search(IndexSearcher.java:146)\n\tat org.apache.lucene.search.IndexSearcher.search(IndexSearcher.java:113)\n\tat org.apache.lucene.search.Hits.getMoreDocs(Hits.java:74)\n\tat org.apache.lucene.search.Hits.<init>(Hits.java:53)\n\tat org.apache.lucene.search.Searcher.search(Searcher.java:46)\n\tat org.apache.lucene.misc.TestRangeFilterPerformanceComparison$Benchmark.go(TestRangeFilterPerformanceComparison.java:312)\n\tat org.apache.lucene.misc.TestRangeFilterPerformanceComparison.testPerformance(TestRangeFilterPerformanceComparison.java:201)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)\n\tat java.lang.reflect.Method.invoke(Method.java:585)\n\tat junit.framework.TestCase.runTest(TestCase.java:154)\n\tat junit.framework.TestCase.runBare(TestCase.java:127)\n\tat junit.framework.TestResult$1.protect(TestResult.java:106)\n\tat junit.framework.TestResult.runProtected(TestResult.java:124)\n\tat junit.framework.TestResult.run(TestResult.java:109)\n\tat junit.framework.TestCase.run(TestCase.java:118)\n\tat junit.framework.TestSuite.runTest(TestSuite.java:208)\n\tat junit.framework.TestSuite.run(TestSuite.java:203)\n\tat org.eclipse.jdt.internal.junit.runner.junit3.JUnit3TestReference.run(JUnit3TestReference.java:128)\n\tat org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:460)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:673)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:386)\n\tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:196)\n ",
            "author": "Andy Liu",
            "id": "comment-12487897"
        },
        {
            "date": "2007-04-10T20:52:52+0000",
            "content": "Lets try this again. \n\nI am very sorry to everyone for the last patch. I had some trouble with my environment  not correctly re-building.\n\nI have done ant clean before testing.\nAndy take a look at this patch and tell me what you think.\n ",
            "author": "Matt Ericson",
            "id": "comment-12487914"
        },
        {
            "date": "2007-04-11T00:28:15+0000",
            "content": "On Mon, 9 Apr 2007, Otis Gospodnetic (JIRA) wrote:\n\n: I'd love to know what Hoss and other big Filter users think about this.\n: Solr makes a lof of use of (Range?)Filters, I believe.\n\nThis is one of those Jira issues that i didn't really have time to follow when it was first opened, and so the Jira emails have just been piling up waiting ofr me to read.\n\nHere's the raw notes i took as i read through the patches...\n\n----------------\nFieldCacheRangeFilter.patch  from 10/Apr/07 01:52 PM\n\n\n\tjavadoc cut/paste errors (FieldCache)\n\tFieldCacheRangeFilter should work with simple strings\n   (using FieldCache.getStrings or FieldCache.getStringIndex)\n   just like regular RangeFilter\n\tit feels like the various parser versions should be in\n   seperate subclasses (common abstract base class?)\n\twhy does clone need to construct a raw BitSet?  what exactly didn't\n   work about ChainedFilter without this?\n   (could cause other BitSet usage problems)\n\tor/and/andNot/xor can all be implemented using convertToBitSet\n\tneed FieldCacheBitSet methods: cardinality, get(int,int)\n\tneed equals and hashCode methods in all new classes\n\tFieldCacheBitSet.clear should be UnsuppOp\n\tconvertToBitSet can be cached.\n\tFieldCacheBitSet should be abstract, requiring get(int) be implemented\n\n\n\n\nMemoryCachedRangeFilter_1.4.patch from 06/Apr/07 06:14 AM\n\n\n\t\"tuples\" should be initialized to fieldCache.length ... serious\n   ArrayList resizing going on there\n   (why is it an ArrayList, why not just Tules[] ?)\n\tdoesn't \"cache\" need synchronization? ... seems like the same\n   CreationPlaceholder pattern used in FieldCache might make sense here.\n\tthis looks wrong...\n     } else if ( (!includeLower) && (lowerIndex >= 0) ) {\n   ...consider case where lower==5, includeLower==false, and all values\n   in index are 5, binary search could leave us in the middle of hte index,\n   so we still need for move forward to the end?\n\tditto above concern for finding upperIndex\n\twhat is pathological worst case for rewind/forward when lots of\n   duplicate values in index?  should another binarySearch be used?\n\ta lot of code in MemoryCachedRangeFilter.bits for finding\n   lowerIndex/upperIndex would probably make more sense as methods in\n   SortedFieldCache\n\tonly seems to handle longs, at a minimum should deal with arbitrary\n   strings, with optional add ons for longs/ints/etc...\n\tI can't help but wonder how MemoryCachedRangeFilter would compare if it\n   used Solr's OpenBitSet (facaded to implement the BitSet API)\n\n\n\nTestRangeFilterPerformanceComparison.java   from 10/Apr/07\n\n\n\tI can't help but wonder how RangeFilter would compare if it used Solr's\n   OpenBitSet (facaded to implement the BitSet API)\n\tno test of includeLower==false or includeUpper==false\n\ti don't think the ranges being compared are the same for RangeFilter as they\n   are for the other Filters ... note the use of DateTools when building the index, \n   vs straight string usage in RangeFilter, vs Long.parseLong in \n   MemoryCachedRangeFilter and FieldCacheRangeFilter\n\tis it really a fair comparison to call MemoryCachedRangeFilter.warmup\n   or FieldCacheRangeFilter.bits outside of the timing code?\n   for indexes where the IndexReader is reopened periodicaly this may\n   be a significant number to be aware of.\n----------------\n\n\n\nQuestions about the legitimacy of the testing aside...\n\nIn general, I like the approach of FieldCacheBitSet \u2013 but it should be generalized into an \"AbstractReadOnlyBitSet\" where all methods are implemented via get(int) in subclasses \u2013 we should make sure that every method in the BitSet API works as advertised in Java1.4.  \n\nI don't really like the various hoops FieldCacheRangeFilter has to jump through to support int/float/long ... I think at it's core it should support simple Strings, with alternate/sub classes for dealing with other FieldCache formats ... i just really dislike all the crazy nested ifs to deal with the different Parser types, if there's going to be separate constructors for longs/floats/ints, they might as well be separate sub-classes.\n\nthe really nice thing this has over RangeFilter is that people can index raw numeric values without needing to massage them into lexicographically ordered Strings (since the FieldCache will take care of parsing them appropriately) \n\nMy gut tells me that the MemoryCachedRangeFilter approach will never ever be able to compete with the FieldCacheRangeFilter facading BitSet approach since it needs to build the FieldCache, then the SortedFieldCache, then a BitSet ...it seems like any optimization into that pipeline can always be beaten by using the same logic, but then facading the BitSet\n\n ",
            "author": "Hoss Man",
            "id": "comment-12487962"
        },
        {
            "date": "2007-04-11T12:38:40+0000",
            "content": "This seems very useful. Just one thing i would like to know, do this Filter could work properly with the ChainedFilter? Since some times we have to filter the result with more than one range for different field, say  search in an area by lat lon. \nI have made a simple test filter two fields with ChainedFilter and it seems that i can't find anything even there are docs in that range. \nMaybe there are some bugs in my code, i'll check it tomorrow.\nBTW the value type i used is Float. ",
            "author": "Yiqing Jin",
            "id": "comment-12488075"
        },
        {
            "date": "2007-04-11T17:31:36+0000",
            "content": "Another thing that occurred to me this morning is that the comparison test doesn't consider the performance of the various Filter's when cached and reused  (with something like CacheWrappingFilter)  ... you may actually see the stock RangeFilter be faster then either implementation when you can reuse the same exact Filter over and over on the same IndexReader \u2013 a fairly common use case.\n\nIn general the numbers that really need to be conpared are...\n\n  1) the time overhead of an implementation when opening a new IndexReader (and whether that overhead is per field)\n  2) the time overhead of an implementation the first time a specific Filter is used on an IndexReader\n  3) the time on average that it takes to use a Filter ",
            "author": "Hoss Man",
            "id": "comment-12488125"
        },
        {
            "date": "2007-04-12T02:18:48+0000",
            "content": "I made a few changes to MemoryCachedRangeFilter:\n\n\n\tSortedFieldCache's values[] now contains only sorted unique values, while docId[] has been changed to a ragged 2D array with an array of docId's corresponding to each unique value.  Since there's no longer repeated values in values[]. forward() and rewind() are no longer required.  This also addresses the O special case that Hoss brought up where every value is identical.\n\tbits() now returns OpenBitSetWrapper, a subclass of BitSet that uses Solr's OpenBitSet as a delegate.  Wrapping OpenBitSet presents some challenges.  Since the internal bits store of BitSet is private, it's difficult to perform operations between BitSet and OpenBitSet (like or, and, etc).\n\tAn in-memory OpenBitSet cache is kept.  During warmup, the global range is partitioned and OpenBitSet instances are created for each partition.  During bits(), these cached OpenBitSet instances that fall in between the lower and upper ranges are used.\n\tMoved MCRF to contrib/ due to the Solr dependancy\n\n\n\nUsing the current (and incomplete) benchmark, MemoryCachedRangeFilter is slightly faster than FCRF when used in conjuction with ConstantRangeQuery and MatchAllDocsQuery:\n\nReader opened with 100000 documents.  Creating RangeFilters...\n\nTermQuery\n\nFieldCacheRangeFilter\n\n\tTotal: 88ms\n\tBits: 0ms\n\tSearch: 14ms\n\n\n\nMemoryCachedRangeFilter\n\n\tTotal: 89ms\n\tBits: 17ms\n\tSearch: 31ms\n\n\n\nRangeFilter\n\n\tTotal: 9034ms\n\tBits: 4483ms\n\tSearch: 4521ms\n\n\n\nChained FieldCacheRangeFilter\n\n\tTotal: 33ms\n\tBits: 3ms\n\tSearch: 9ms\n\n\n\nChained MemoryCachedRangeFilter\n\n\tTotal: 77ms\n\tBits: 19ms\n\tSearch: 30ms\n\n\n\n\nConstantScoreQuery\n\nFieldCacheRangeFilter\n\n\tTotal: 541ms\n\tBits: 2ms\n\tSearch: 485ms\n\n\n\nMemoryCachedRangeFilter\n\n\tTotal: 473ms\n\tBits: 23ms\n\tSearch: 390ms\n\n\n\nRangeFilter\n\n\tTotal: 13777ms\n\tBits: 4451ms\n\tSearch: 9298ms\n\n\n\nChained FieldCacheRangeFilter\n\n\tTotal: 12ms\n\tBits: 2ms\n\tSearch: 5ms\n\n\n\nChained MemoryCachedRangeFilter\n\n\tTotal: 80ms\n\tBits: 16ms\n\tSearch: 44ms\n\n\n\n\nMatchAllDocsQuery\n\nFieldCacheRangeFilter\n\n\tTotal: 1231ms\n\tBits: 3ms\n\tSearch: 1115ms\n\n\n\nMemoryCachedRangeFilter\n\n\tTotal: 1222ms\n\tBits: 53ms\n\tSearch: 1149ms\n\n\n\nRangeFilter\n\n\tTotal: 10689ms\n\tBits: 4954ms\n\tSearch: 5583ms\n\n\n\nChained FieldCacheRangeFilter\n\n\tTotal: 937ms\n\tBits: 1ms\n\tSearch: 862ms\n\n\n\nChained MemoryCachedRangeFilter\n\n\tTotal: 921ms\n\tBits: 19ms\n\tSearch: 894ms\n\n\n\nHoss, those were great comments you made.  I'd be happy to continue on and make those changes, although if the feeling around town is that Matt's range filter is the preferred implementation, I'll stop here. ",
            "author": "Andy Liu",
            "id": "comment-12488239"
        },
        {
            "date": "2007-04-12T08:01:16+0000",
            "content": "Hi, Matt\nAs i tried the FieldCacheRangeFilter i have got problem.\n\nI added a test block at the end of TestFieldCacheRangeFilter\n\n        FieldCacheRangeFilter f1 =  new FieldCacheRangeFilter(\"id\", (float)minIP, (float)maxIP, T, F);\n        FieldCacheRangeFilter f2 =  new FieldCacheRangeFilter(\"id\", (float)minIP, (float)maxIP, F, T);\n\n        ChainedFilter f = new ChainedFilter(new Filter[]\n{f1,f2}\n,ChainedFilter.AND);\n        result = search.search(q, f);\n        assertEquals(\"all but ends\", numDocs-2, result.length());\n\nThis could not pass and in fact the result.length() is 0; Nothing could be found. \n\n\nI checked my code and traced the running but still can't get result expected. It seems the Filter won't work with the ChainedFilter. \nafter the doChain the BitSet seems to be empty.(Either 'and' or 'or' operation). \nCODE:\n[\ncase AND:\n            \tBitSet bit = filter.bits(reader);\n                result.and(bit);\n]\nThe bit is already empty before it's added to the result. ",
            "author": "Yiqing Jin",
            "id": "comment-12488291"
        },
        {
            "date": "2007-04-12T08:30:20+0000",
            "content": "After i changed the code in ChainedFilter#doChain to\ncase AND:\n            \tBitSet bit = (BitSet)filter.bits(reader).clone();\n                result.and(bit);\n                break;\nthe result is fine.  but i know that's a bad way.\nSince the FieldCacheBitSet is not a real BitSet and uses a fake get() method just get value from the FieldCache. I think the current imp is still not fit for the ChainedFilter because FieldCacheBitSet  do not have a good implementation of the logical cperotion such as 'and'. \nMaybe we could make the FieldCacheBitSet  public and implement all the methods in it's own way instead of having a convertToBitSet() to make things messed. ",
            "author": "Yiqing Jin",
            "id": "comment-12488297"
        },
        {
            "date": "2007-04-12T15:50:34+0000",
            "content": "I have done a little research and I do not think I can get my bit set to act\nthe same as a normal bit set so this will not work with  ChainedFilter as\nChainedFilter calls BitSet.and() or BitSet.or()\n\nI looked at these functions and they access private varables inside of the\nBitSet and do the 'and', 'or', 'xor' on the bits in memory. Since my BitSet\nis just a proxy for the field cache ChainedFilter will  not work unless we\nalso change ChainedFilter\n\nMatt\n ",
            "author": "Matt Ericson",
            "id": "comment-12488412"
        },
        {
            "date": "2007-04-13T01:34:26+0000",
            "content": "That's true you can't do the ''and '  or 'or'  as usual. but i am thingking  the FieldCacheBitSet  may hold some private varables to store the range and field infomation and we do the 'and', 'or', 'xor'  in a tricky way by setting the value of the varables.  And we implement the #get() using the varables as a judgement .\n\nChanging the ChainedFilter is  a good way, maybe we could have a special FieldCaheChainedFilter _. \n\ni'm having a busy day but i'll try to do some experiment on it if had time. ",
            "author": "Yiqing Jin",
            "id": "comment-12488547"
        },
        {
            "date": "2007-04-15T17:44:52+0000",
            "content": "This version if the Field Cache Range filter has a new AbstractGetOnlyBitSet a base BitSet that will use all of its functions like nextClearBit using get() \n\nI have also added a RuntimeChainedFilter this will work just like the normal chained filter but it does not do the AND or OR or XOR until you call the get() function this will allow for the BitSets that the FieldCacheRangeFilter create to be chained correctly. \n\nThere are also testes for all of my new code. The FieldCacheRangeFilter still has the nested If statements to allow for Long, Ints and Floats. I think these are not that complicated and it allows users to pick the type of filter they want while saving space. In My application we use Ints for dates even though we know it will only support dates going up to 2038 as right now we need the memory. \nThis code will give the flexibility to the user creating the filters so they can tune their app just they way they want it.\n\nI hope you all like it. Please let me know what you think  ",
            "author": "Matt Ericson",
            "id": "comment-12488952"
        },
        {
            "date": "2007-04-25T15:55:31+0000",
            "content": "Can someone take a look at the code I attached and let me know if there is anything we need to change?\nOr did it get added to lucene?\n\nI don't really know how long this should take? \n\nMatt ",
            "author": "Matt Ericson",
            "id": "comment-12491677"
        },
        {
            "date": "2008-01-21T02:25:03+0000",
            "content": "Any plans to have this part of Lucene 2.3? ",
            "author": "vivek",
            "id": "comment-12560912"
        },
        {
            "date": "2008-02-04T19:21:37+0000",
            "content": "I have changed the FiledCacheRangeFilter so that it now works with Lucene 2.3.0 \nIT does not have to change the FieldCache since It can just use Extended Field Cache \n\nHere are the performance numbers again\n\n    [junit] ------------- Standard Output ---------------\n    [junit] Start interval: Tue Feb 04 22:34:22 PST 2003\n    [junit] End interval: Sun Feb 03 22:34:22 PST 2008\n    [junit] Creating RAMDirectory index...\n    [junit] Reader opened with 100000 documents.  Creating RangeFilters...\n    [junit] Standard RangeFilter finished in 41111ms\n    [junit] FieldCacheRangeFilter finished in 112ms\n    [junit] ------------- ---------------- ---------------\n\n\nI hope this helps and I hope this gets added to Lucene ",
            "author": "Matt Ericson",
            "id": "comment-12565483"
        },
        {
            "date": "2008-02-06T02:35:04+0000",
            "content": "Can somebody have a look and commit?  I believe this is a good patch - it was good when I looked at it when Eric first contributed it.  Thanks (behind on too many fronts) ",
            "author": "Otis Gospodnetic",
            "id": "comment-12565996"
        },
        {
            "date": "2008-11-30T15:29:12+0000",
            "content": "On the face of it, this has some overlap with the recent FieldCacheRangeFilter of LUCENE-1461 .\nAny comments? ",
            "author": "Paul Elschot",
            "id": "comment-12651837"
        },
        {
            "date": "2008-12-04T19:12:17+0000",
            "content": "Matt, Andy,\n\nPlease take a look at LUCENE-1461. As far as I can tell it is identical in purpose and design to this patch.\n\nMatt,\n\nI would like to add you to the CHANGES.txt credits for LUCENE-1461. Are you OK with that?\n ",
            "author": "Tim Sturge",
            "id": "comment-12653414"
        },
        {
            "date": "2008-12-04T20:10:04+0000",
            "content": "Yes, it looks the same.  Glad this will finally make it to the source! ",
            "author": "Andy Liu",
            "id": "comment-12653450"
        },
        {
            "date": "2008-12-05T05:32:46+0000",
            "content": "Looks similar to what I wrote but it uses a more data structures. I  \nliked the what I built as it just has direct access to the Field Cache  \nand there are no other data structures and that if once you load the  \ndata in the FC you can do any other search on that field and not have  \nto rebuild anything you can just re-use the data.\n\nBut I think all 3 are improvements on what's there but as I am  \nprejudiced and I really like they one I wrote and I think it will  \nstack up faster then the 1461 if you do load tests on it.\n\nJust my $0.02\n\nMatt\n\n\n ",
            "author": "Matt Ericson",
            "id": "comment-12653635"
        },
        {
            "date": "2008-12-05T19:19:01+0000",
            "content": "Hi Matt! \n\nTim, want to benchmark the two? (since you already benchmarked 1461, you should be able to plug in Matt's thing and see how it compares) ",
            "author": "Otis Gospodnetic",
            "id": "comment-12653900"
        },
        {
            "date": "2011-01-25T15:49:54+0000",
            "content": "We already have FieldCacheRangeFilter (introduced in LUCENE-1461), so closing as duplicate. ",
            "author": "Shai Erera",
            "id": "comment-12986450"
        }
    ]
}