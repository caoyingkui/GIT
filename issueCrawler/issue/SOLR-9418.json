{
    "id": "SOLR-9418",
    "title": "Statistical Phrase Identifier",
    "details": {
        "components": [],
        "type": "New Feature",
        "labels": "",
        "fix_versions": [
            "7.5",
            "master (8.0)"
        ],
        "affect_versions": "None",
        "status": "Closed",
        "resolution": "Fixed",
        "priority": "Major"
    },
    "description": "Summary:\n\nThe Statistical Phrase Identifier\u00a0is a Solr contribution that takes\u00a0in a string of text and then leverages a language model (an Apache Lucene/Solr inverted index) to predict how the inputted text should be divided into phrases. The intended purpose of this tool is to parse short-text queries into phrases prior to executing a keyword search (as opposed parsing out each keyword as a single term).\n\nIt\u00a0is\u00a0being generously donated to the Solr project by CareerBuilder, with the original source code and a quickly demo-able\u00a0version located here:\u00a0\u00a0https://github.com/careerbuilder/statistical-phrase-identifier\nPurpose:\n\nAssume you're building a job search engine, and one of your users searches for the following:\n machine learning research and development Portland, OR software engineer AND hadoop, java\n\nMost search engines will natively parse this query into the following boolean representation:\n (machine AND learning AND research AND development AND Portland) OR (software AND engineer AND hadoop AND java)\n\nWhile this query may still yield relevant results, it is clear that the intent of the user wasn't understood very well at all. By leveraging the Statistical Phrase Identifier on this string prior to query parsing, you can instead expect the following parsing:\n\n_\n{machine learning}\n {and} {research and development} {Portland, OR} {software engineer} {AND} {hadoop,} {java}_\n\nIt is then possile to modify all the multi-word phrases prior to executing the search:\n \"machine learning\" and \"research and development\" \"Portland, OR\" \"software engineer\" AND hadoop, java\n\nOf course, you could do your own query parsing to specifically handle the boolean syntax, but the following would eventually be interpreted correctly by Apache Solr and most other search engines:\n \"machine learning\" AND \"research and development\" AND \"Portland, OR\" AND \"software engineer\" AND hadoop AND java\u00a0\nHistory:\n\nThis project was originally implemented by the search team at CareerBuilder in the summer of 2015 for use as part of their semantic search system. In the summer of 2016, Akash Mehta,\u00a0implemented\u00a0a much simpler version as a proof of concept based upon publicly available information about the CareerBuilder implementation (the first attached patch).\u00a0\u00a0In July of 2018, CareerBuilder open sourced their original version (https://github.com/careerbuilder/statistical-phrase-identifier),\u00a0and agreed to also donate the code to the Apache Software foundation as a Solr contribution. An Solr patch with the CareerBuilder version was added to this issue on September 5th, 2018, and community feedback and contributions are encouraged.\n\nThis issue was originally titled the \"Probabilistic Query Parser\", but the name has now been updated to \"Statistical Phrase Identifier\" to avoid ambiguity with Solr's query parsers (per some of the feedback on this issue), as the implementation is actually just a mechanism for identifying phrases statistically from a string and is NOT a Solr query parser.\u00a0\nExample usage:\n(See contrib readme or configuration files in the patch for full configuration details)\nRequest:\n\nhttp://localhost:8983/solr/spi/parse?q=darth vader obi wan kenobi anakin skywalker toad x men magneto professor xavier\n\nResponse:\u00a0\n\n{\n\u00a0 \"responseHeader\":{\n\u00a0 \u00a0 \"status\":0,\n\u00a0 \u00a0 \"QTime\":25},\n\u00a0 \u00a0 \"top_parsed_query\":\"{darth vader} {obi wan kenobi} {anakin skywalker} {toad} {x men} {magneto} {professor xavier}\",\n\u00a0 \u00a0 \"top_parsed_phrases\":[\n\u00a0 \u00a0 \u00a0 \"darth vader\",\n\u00a0 \u00a0 \u00a0 \"obi wan kenobi\",\n\u00a0 \u00a0 \u00a0 \"anakin skywalker\",\n\u00a0 \u00a0 \u00a0 \"toad\",\n\u00a0 \u00a0 \u00a0 \"x-men\",\n\u00a0 \u00a0 \u00a0 \"magneto\",\n\u00a0 \u00a0 \u00a0 \"professor xavier\"],\n\u00a0 \u00a0 \u00a0 \"potential_parsings\":[{\n\u00a0 \u00a0 \u00a0 \"parsed_phrases\":[\"darth vader\",\n\u00a0 \u00a0 \u00a0 \"obi wan kenobi\",\n\u00a0 \u00a0 \u00a0 \"anakin skywalker\",\n\u00a0 \u00a0 \u00a0 \"toad\",\n\u00a0 \u00a0 \u00a0 \"x-men\",\n\u00a0 \u00a0 \u00a0 \"magneto\",\n\u00a0 \u00a0 \u00a0 \"professor xavier\"],\n\u00a0 \u00a0 \u00a0 \"parsed_query\":\"{darth vader} {obi wan kenobi} {anakin skywalker} {toad} {x-men} {magneto} {professor xavier}\",\n\u00a0 \u00a0 \"score\":0.0}]}",
    "attachments": {
        "SOLR-9418.patch": "https://issues.apache.org/jira/secure/attachment/12938474/SOLR-9418.patch",
        "SOLR-9418.zip": "https://issues.apache.org/jira/secure/attachment/12824036/SOLR-9418.zip"
    },
    "issue_links": {},
    "comments": [
        {
            "date": "2016-08-17T00:45:51+0000",
            "author": "Akash Mehta",
            "content": "This is the work done on it till now.\nAll of the description is given in the readme.\nThe testQueries class is just a way of tuning parameters for better learning. ",
            "id": "comment-15423680"
        },
        {
            "date": "2016-10-20T14:14:32+0000",
            "author": "Doug Turnbull",
            "content": "Looking at your patch (I'm not a committer just curious about the patch). A few things jump out in a shallow reading that would probably need to change for this to be accepted:\n\n\n\tField names and thresholds likely need to be configurable, as most folks won't nescesarilly have a field named exactly \"title\" or \"content.\"\n\tCan this be a qparser plugin instead of a request handler? It's likely I'd want to use it alongside other qparsers and SearchComponents (like highlighting or facets).\n\tCan you provide some documentation on how the thresholds work/can be configured?\n\n ",
            "id": "comment-15591921"
        },
        {
            "date": "2018-09-05T16:07:56+0000",
            "author": "Trey Grainger",
            "content": "I uploaded an updated patch today for this issue, contributing the CareerBuilder version of this initial patch for this issue was loosely based upon (thanks for the contribution, CareerBuilder!). I've had several people ask about this feature recently, and others have proposed some alternative implementations of this, as well.\n\nGetting this posted as a reference implementation for future development. ",
            "id": "comment-16604608"
        },
        {
            "date": "2018-09-05T16:57:12+0000",
            "author": "Hoss Man",
            "content": "Trey showed me the careerbuilder repo a while back, and I've been working on reviewing/refactoring/generalizing/adapating the concepts in it into a general purpose reusable SearchComponent (but I've held off on discussing publicly until he had a chance to finalize the official careerbuild contribution patch today).\n\nMy updated patch doesn't directly re-use any of the code from the career builder patch, but is heavily inspired by the ideas in it. Rather then implementing a RequestHandler, it adds this functionality as a (distributed) SearchComponent that can be used by itself in a SearchHandler, or in conjunction with QueryComponent (similar to the way SuggestComponent can be used) to parse the \"q\" (or alternative \"phrases.q\" param) and try to identify phrases in the input, and return metadata about those phrases.\n\nSimilar to the career builder patch, the root data for how this component scores candidate phrases is all driven by the use of ShingleFilter in an index/query analyzer. But unlike the original careerbuilder code, there are no hard coded assumptions about the field names, or shingle sizes, or how to tokenize the input string:\n\n\tMultiple weighted fields can be used (as long as they use the same / compatible analyzers)\n\tThe larger the index time shingles used for these fields, the more accurately the code can score phrases based on the term stats (using a baysian model) of those indexed shingles.\n\tThe query time analyzer is used for parsing the input, and can dicate larger sized shingles to identify the largest possible candidate phrases that will be considered \u2013 the code will estimate how likely those longer phrases may be based on the stats of the overlapping indexed shingles that it is composed of.\n\tThe \"total score\" for each (candidate) phrase comes from user supplied weights against each field's scores, but the per-field scores are returned as well, so that clients can make informed choices based on where a phrase is more common \u2013 ie: if \"Isaac Asimov\" is a very common phrase in an \"author\" field, but less common in a \"title\" field, a client app may want to suggest it as a filter/facet against that field in a subsequent query)\n\n\n\nConsider the following configuration...\nsolrconfig.xml\n  <searchComponent class=\"solr.PhrasesIdentificationComponent\" name=\"phrases\" />\n  <requestHandler name=\"/phrases\" class=\"solr.SearchHandler\">\n    <arr name=\"components\">\n      <str>phrases</str>\n    </arr>\n    <lst name=\"defaults\">\n      <str name=\"echoParams\">explicit</str>\n      <str name=\"indent\">true</str>\n      <bool name=\"phrases\">true</bool>\n      <str name=\"phrases.fields\">multigrams_body multigrams_title^2</str>\n    </lst>\n  </requestHandler>\n\n\nschema.xml\n  <field name=\"multigrams_title\" type=\"multigrams_3_7\" indexed=\"true\" stored=\"false\" />\n  <field name=\"multigrams_body\"  type=\"multigrams_3_7\" indexed=\"true\" stored=\"false\" />\n  \n  <fieldType name=\"multigrams_3_7\" class=\"solr.TextField\" positionIncrementGap=\"100\">\n    <analyzer type=\"index\">\n      <tokenizer class=\"solr.StandardTokenizerFactory\"/>\n      <filter class=\"solr.ASCIIFoldingFilterFactory\"/>\n      <filter class=\"solr.LowerCaseFilterFactory\"/>\n      <filter class=\"solr.ShingleFilterFactory\" minShingleSize=\"2\" maxShingleSize=\"3\" outputUnigrams=\"true\"/>\n    </analyzer>\n    <analyzer type=\"query\">\n      <tokenizer class=\"solr.StandardTokenizerFactory\"/>\n      <filter class=\"solr.ASCIIFoldingFilterFactory\"/>\n      <filter class=\"solr.LowerCaseFilterFactory\"/>\n      <filter class=\"solr.ShingleFilterFactory\" minShingleSize=\"2\" maxShingleSize=\"7\" outputUnigramsIfNoShingles=\"true\" outputUnigrams=\"true\"/>\n    </analyzer>\n  </fieldType>\n\n\nThen a request like this...\n http://localhost:8983/solr/phrase-demo/phrases?q=is+anakin+skywalker+the+kid+in+star+wars+phantom+menace\n\n...might return results like the example below (assuming we've indexed Q&A documents about science fiction)...\n\n{\n  \"responseHeader\":{\n    \"status\":0,\n    \"QTime\":21,\n    \"params\":{\n      \"q\":\"is anakin skywalker the kid in star wars phantom menace\"}},\n  \"phrases\":{\n    \"input\":\"is anakin skywalker the kid in star wars phantom menace\",\n    \"summary\":\"is {anakin skywalker} the {kid in} {star wars} {phantom menace}\",\n    \"details\":[{\n        \"text\":\"phantom menace\",\n        \"offset_start\":41,\n        \"offset_end\":55,\n        \"score\":0.07991913047151764,\n        \"field_scores\":{\n          \"multigrams_body\":0.16328680317925878,\n          \"multigrams_title\":0.03823529411764706}},\n      {\n        \"text\":\"anakin skywalker\",\n        \"offset_start\":3,\n        \"offset_end\":19,\n        \"score\":0.06451071736995491,\n        \"field_scores\":{\n          \"multigrams_body\":0.06449989404534859,\n          \"multigrams_title\":0.06451612903225806}},\n      {\n        \"text\":\"star wars\",\n        \"offset_start\":31,\n        \"offset_end\":40,\n        \"score\":0.05346181438317064,\n        \"field_scores\":{\n          \"multigrams_body\":0.08329261539254754,\n          \"multigrams_title\":0.03854641387848219}},\n      {\n        \"text\":\"kid in\",\n        \"offset_start\":24,\n        \"offset_end\":30,\n        \"score\":0.016470309145309624,\n        \"field_scores\":{\n          \"multigrams_body\":0.01567598767689273,\n          \"multigrams_title\":0.016867469879518072}}]},\n\n\n...if this component is configured as a last-component (in combination with the normal default SerachComponents) the same \"phrases\" results would be returned in addition to the normal search/facet/highlight/etc... results.\n\nThe scoring model in this patch is far from perfect \u2013 the \"recommended\" scoring approach in the career builder patch was heavily dependent on some magic constants that made several assumptions about index size and term distribution. I tried to avoid all of that with a more general baysian model, but I'm certain there is still a lot of improvements that could be made (see comments in the code).\n\nThat said: I think what's here is a really good start that's usable as is, and would like to suggest that unless anyone has any major concerns about the current API (which i've tried to keep very limited so we don't overcommit to specifics on the soring), I'd like to include this as an experimental feature in 7.5, and encourace people try it out and give feedback so we can work on improving/refining the scoring and add more tuning knobs in future releases. ",
            "id": "comment-16604670"
        },
        {
            "date": "2018-09-05T19:05:23+0000",
            "author": "David Smiley",
            "content": "Super cool! \u00a0I don't have time for a real review, though I'm comfortable with it being committed quickly in part because it's not modifying anything existing (thus regressions are impossible), and\u00a0is very much opt-in. ",
            "id": "comment-16604806"
        },
        {
            "date": "2018-09-05T19:16:36+0000",
            "author": "Hoss Man",
            "content": "Yep yep \u2013 it's a fully optional \"opt in\" Search Component\n\n\u00a0\n\nI've updated the patch with some slight improvements to the javadocs ",
            "id": "comment-16604816"
        },
        {
            "date": "2018-09-05T21:17:49+0000",
            "author": "Lucene/Solr QA",
            "content": "\n\n\n  -1 overall \n\n\n\n\n\n\n\n\n\n Vote \n Subsystem \n Runtime \n Comment \n\n\n\u00a0\n\u00a0\n\u00a0\n  Prechecks  \n\n\n +1 \n  test4tests  \n   0m  0s \n  The patch appears to include 2 new or modified test files.  \n\n\n\u00a0\n\u00a0\n\u00a0\n  master Compile Tests  \n\n\n +1 \n  compile  \n   3m 12s \n  master passed  \n\n\n\u00a0\n\u00a0\n\u00a0\n  Patch Compile Tests  \n\n\n +1 \n  compile  \n   4m 30s \n  the patch passed  \n\n\n +1 \n  javac  \n   4m 30s \n  the patch passed  \n\n\n +1 \n  Release audit (RAT)  \n   4m 30s \n  the patch passed  \n\n\n +1 \n  Check forbidden APIs  \n   4m 30s \n  the patch passed  \n\n\n +1 \n  Validate source patterns  \n   4m 30s \n  the patch passed  \n\n\n\u00a0\n\u00a0\n\u00a0\n  Other Tests  \n\n\n -1 \n  unit  \n  83m 43s \n  core in the patch failed.  \n\n\n  \n   \n  95m 26s \n   \n\n\n\n\n\n\n\n\n\n Reason \n Tests \n\n\n Failed junit tests \n solr.cloud.autoscaling.sim.TestSimTriggerIntegration \n\n\n\n\n\n\n\n\n\n Subsystem \n Report/Notes \n\n\n JIRA Issue \n SOLR-9418 \n\n\n JIRA Patch URL \n https://issues.apache.org/jira/secure/attachment/12938525/SOLR-9418.patch \n\n\n Optional Tests \n  compile  javac  unit  ratsources  checkforbiddenapis  validatesourcepatterns  \n\n\n uname \n Linux lucene2-us-west.apache.org 4.4.0-112-generic #135-Ubuntu SMP Fri Jan 19 11:48:36 UTC 2018 x86_64 x86_64 x86_64 GNU/Linux \n\n\n Build tool \n ant \n\n\n Personality \n /home/jenkins/jenkins-slave/workspace/PreCommit-SOLR-Build/sourcedir/dev-tools/test-patch/lucene-solr-yetus-personality.sh \n\n\n git revision \n master / b4a1548 \n\n\n ant \n version: Apache Ant(TM) version 1.9.6 compiled on July 20 2018 \n\n\n Default Java \n 1.8.0_172 \n\n\n unit \n https://builds.apache.org/job/PreCommit-SOLR-Build/177/artifact/out/patch-unit-solr_core.txt \n\n\n  Test Results \n https://builds.apache.org/job/PreCommit-SOLR-Build/177/testReport/ \n\n\n modules \n C: solr/core U: solr/core \n\n\n Console output \n https://builds.apache.org/job/PreCommit-SOLR-Build/177/console \n\n\n Powered by \n Apache Yetus 0.7.0   http://yetus.apache.org \n\n\n\n\n\n\nThis message was automatically generated.\n ",
            "id": "comment-16604964"
        },
        {
            "date": "2018-09-06T17:51:09+0000",
            "author": "ASF subversion and git services",
            "content": "Commit 597bd5db77465e1282ebf722264423d631861596 in lucene-solr's branch refs/heads/master from Chris Hostetter\n[ https://git-wip-us.apache.org/repos/asf?p=lucene-solr.git;h=597bd5d ]\n\nSOLR-9418: Added a new (experimental) PhrasesIdentificationComponent for identifying potential phrases in query input based on overlapping shingles in the index ",
            "id": "comment-16606169"
        },
        {
            "date": "2018-09-06T18:04:42+0000",
            "author": "ASF subversion and git services",
            "content": "Commit 3f5c8d7e83055ab4d2e313ab7909505a75a30ae6 in lucene-solr's branch refs/heads/branch_7x from Chris Hostetter\n[ https://git-wip-us.apache.org/repos/asf?p=lucene-solr.git;h=3f5c8d7 ]\n\nSOLR-9418: Added a new (experimental) PhrasesIdentificationComponent for identifying potential phrases in query input based on overlapping shingles in the index\n\n(cherry picked from commit 597bd5db77465e1282ebf722264423d631861596) ",
            "id": "comment-16606190"
        }
    ]
}