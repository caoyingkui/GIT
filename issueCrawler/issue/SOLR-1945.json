{
    "id": "SOLR-1945",
    "title": "Add support for child docs in DocumentObjectBinder",
    "details": {
        "affect_versions": "None",
        "status": "Closed",
        "fix_versions": [
            "5.1",
            "6.0"
        ],
        "components": [],
        "type": "Improvement",
        "priority": "Minor",
        "labels": "",
        "resolution": "Fixed"
    },
    "description": "see http://search.lucidimagination.com/search/document/d909d909420aeb4e/does_solrj_support_nested_annotated_beans\n\nWould be nice to be able to pass an object graph to solrj with @field annotations rather than just a top level class",
    "attachments": {
        "SOLR-1945.patch": "https://issues.apache.org/jira/secure/attachment/12446879/SOLR-1945.patch"
    },
    "issue_links": {},
    "comments": [
        {
            "author": "Mark Miller",
            "id": "comment-12877853",
            "date": "2010-06-11T16:51:00+0000",
            "content": "Started playing around with this on the plane yesterday - here is a pretty rough first draft.\n\nYou annotate members that should be drilled into with @FieldObject (need to think of the right name here)\n\neg:\n\n\n  public static class ItemHolder {\n    @Field\n    String superfield;\n    @FieldObject\n    Item item;\n    @FieldObject\n    Item2 item2;\n\n    public Item getItem() {\n      return item;\n    }\n\n    public void setItem(Item item) {\n      this.item = item;\n    }\n    \n  }\n  \n  public static class Item {\n    @Field\n    String id;\n\n    @Field(\"cat\")\n    String[] categories;\n\n    @Field\n    List<String> features;\n\n    @Field\n    Date timestamp;\n\n    @Field(\"highway_mileage\")\n    int mwyMileage;\n\n    boolean inStock = false;\n\n    @Field(\"supplier_*\")\n    Map<String, List<String>> supplier;\n    \n    @Field(\"sup_simple_*\")\n    Map<String, String> supplier_simple;\n\n    private String[] allSuppliers;\n\n    @Field(\"supplier_*\")\n    public void setAllSuppliers(String[] allSuppliers){\n      this.allSuppliers = allSuppliers;  \n    }\n\n    public String[] getAllSuppliers(){\n      return this.allSuppliers;\n    }\n\n    @Field\n    public void setInStock(Boolean b) {\n      inStock = b;\n    }\n    \n    // required if you want to fill SolrDocuments with the same annotaion...\n    public boolean isInStock()\n    {\n      return inStock;\n    }\n  }\n  \n  public static class Item2 {\n    @Field\n    String sensai;\n    \n    @FieldObject\n    Item3 item3;\n    \n  }\n  \n  public static class Item3 {\n    @Field\n    String server;\n\n    @Field(\"type\")\n    String[] types;\n  }\n  \n\n "
        },
        {
            "author": "Paul Sheldon",
            "id": "comment-13021222",
            "date": "2011-04-18T20:12:51+0000",
            "content": "I think you are on the right track here with @Field and @FieldObject ideas.  \n\nI'm coming from a compass/lucene environment, getting ready to ditch compass and implement solr.  compass has a mature set of annotations for things such as @SearchableProperty, @SearchableComponent, @SearchableDynamicProperty, and so on.  It would be great if solr supported concepts like these as well!  we have quite a large object tree for marshalling an entity-managed pojo from the db to the lucene index.  it has a lot of one-to-many and many-to-many relationships (i.e. collections) that are 'flattened' out during the marshalling process.  this is currently handled automagically by compass using the simple compass annotations.  in my planning and design for the conversion to solr, it looks like i'm going to have to code all that 'flattening' logic myself, fetching and consolidating data from the db to a pojo, and then marshalling the pojo to solr.\n\nHow far do you think your implementation will go?  will it just marshall one-to-one object graph relationships, or will it also go so far as to handle the one-to-many and many-to-many (collections) relationships too? "
        },
        {
            "author": "Robert Muir",
            "id": "comment-13043736",
            "date": "2011-06-03T16:46:49+0000",
            "content": "Bulk move 3.2 -> 3.3 "
        },
        {
            "author": "Monica Storfjord",
            "id": "comment-13061129",
            "date": "2011-07-07T08:18:44+0000",
            "content": "What is the status on this proposal? It would be a great feature and very beneficial to my current project!  Do you have a full solution on this and witch version do you think this feature will be released in?\n\n\n\tMonica\n\n "
        },
        {
            "author": "Mark Miller",
            "id": "comment-13061183",
            "date": "2011-07-07T10:11:48+0000",
            "content": "hmmm...I don't remember. I'll take a look again. "
        },
        {
            "author": "Mark Miller",
            "id": "comment-13061728",
            "date": "2011-07-08T02:38:30+0000",
            "content": "Yeah, I guess it depends on what you mean by full solution. \n\nWhat I have works for what it does - which is let you specify if you should dig down deeper into an object to look for more @Field annotations.\n\nNot really sure how we would flatten one-to-many or many-to-many relationships...other than allowing digging into objects within collections to look for more @Field annotations as well. "
        },
        {
            "author": "Robert Muir",
            "id": "comment-13106286",
            "date": "2011-09-16T14:50:24+0000",
            "content": "3.4 -> 3.5 "
        },
        {
            "author": "Hoss Man",
            "id": "comment-13412198",
            "date": "2012-07-11T22:26:18+0000",
            "content": "bulk fixing the version info for 4.0-ALPHA and 4.0 all affected issues have \"hoss20120711-bulk-40-change\" in comment "
        },
        {
            "author": "Robert Muir",
            "id": "comment-13429799",
            "date": "2012-08-07T03:43:08+0000",
            "content": "rmuir20120906-bulk-40-change "
        },
        {
            "author": "Robert Muir",
            "id": "comment-13452216",
            "date": "2012-09-10T17:41:58+0000",
            "content": "moving all 4.0 issues not touched in a month to 4.1 "
        },
        {
            "author": "Mark S",
            "id": "comment-13607635",
            "date": "2013-03-20T14:15:52+0000",
            "content": "\nI thought I would just share workaround code until this issue is resolved.\n\nThe SolrMapperForSimplePojoList class should do the following:\n\n\tSimple List<?> -> Solr @Field Map -> Solr Document\n\tSolr Document -> Solr @Field Map ->  Simple List<?>\n\n\n\n ->\n\n\n\tList<ShoppingItem> shoppingItems = ...\n\n\n\n <- ->\n\n\npublic static class ShoppingList {\n\n        @Field(\"id\")\n        private String id;\n\n        @Field(\"shopping_items*\")\n        protected Map<String, Object> shoppingItemMap = new LinkedHashMap<String, Object>(16);\n\t\t\n\t\t// ...\n}\n\n\n\n\npublic static class ShoppingItem {\n\n\tprivate Float quantity;\n\n\tprivate String product;\n\n\tprivate String description;\n}\n\n\n\n\n <- ->\n\n\nSolrInputDocument[\n    id=1,\n    shopping_items[0].quantity_f=1.0,\n    shopping_items[0].product_s=25W SOLDERING IRON STARTER KIT WITH DMM,\n    shopping_items[0].description_s=This kit contains everything needed for basic electronics work.,\n    shopping_items[1].quantity_f=2.0,\n    shopping_items[1].product_s=Standard Microphone Insert,\n    shopping_items[1].description_s=Replacement electret mic inserts for tape recorders, etc,\n    shopping_items[2].quantity_f=1.0,\n    shopping_items[2].product_s=11 DIGIT FLUORO DISPLAY,\n    shopping_items[2].description_s=Vacuum fluorescent display,\n    shopping_items[3].quantity_f=1.0,\n    shopping_items[3].product_s=LEAD FREE SOLDER 0.71MM 200G ROLL,\n    shopping_items[3].description_s=99.3% tin, 0.7% copper lead-free.\n]\n\n\t\t \n\n <-\n\nNote*:  Also includes workaround ordering issue outlined here: https://issues.apache.org/jira/browse/SOLR-4422\n\n\nThe Workaround:  SolrMapperForSimplePojoList\n\npackage test;\n\nimport java.lang.reflect.Method;\nimport java.util.ArrayList;\nimport java.util.Comparator;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.SortedSet;\nimport java.util.TreeSet;\n\n/**\n * This will only work for a POJO that contains simple fields, such as String, Integer etc.\n * It will not work for complex field types such as a Collection, List, Map etc.\n *\n * This class exists because in SOLRJ @Field annotations cannot exist inside nested classes (Simple Types Only).\n *\n *\n * @see https://issues.apache.org/jira/browse/SOLR-1945\n * @author user\n *\n */\npublic class SolrMapperForSimplePojoList {\n\n    private SolrMapperForSimplePojoList(){\n\n    }\n\n    public static <T> Map<String, Object> convertPojoListToSolrjDynamicFieldMap(\n            List<T> pojoList, List<String> pojoFieldNames,\n            List<String> solrjFieldNameTemplates  ) {\n\n        try{\n\n            Map<String, Object> solrjDynamicFieldMap = new LinkedHashMap<String, Object>();\n\n            for (int pojoIndex = 0; pojoIndex < pojoList.size(); pojoIndex++) {\n\n                T pojo = pojoList.get(pojoIndex);\n\n                for (int pojoFieldNameIndex = 0; pojoFieldNameIndex < pojoFieldNames.size(); pojoFieldNameIndex++) {\n\n                    String pojoFieldName = pojoFieldNames.get(pojoFieldNameIndex);\n                    Object pojoFieldObject = getFieldValue(pojo, pojoFieldName);\n\n                    solrjDynamicFieldMap.put(getSolrjFieldName(pojoIndex, solrjFieldNameTemplates.get(pojoFieldNameIndex) ), pojoFieldObject);\n                }\n\n            }\n\n            return solrjDynamicFieldMap;\n        }catch(Exception e){\n            throw new RuntimeException(e);\n        }\n    }\n\n    private static String getSolrjFieldName(Integer index, String solrjFieldNameTemplate ){\n        StringBuffer solrjDynamicFieldName = new StringBuffer();\n\n        solrjDynamicFieldName.append(solrjFieldNameTemplate.substring(0, solrjFieldNameTemplate.indexOf(\"[\") + 1) );\n        solrjDynamicFieldName.append(index);\n        solrjDynamicFieldName.append(solrjFieldNameTemplate.substring(solrjFieldNameTemplate.indexOf(\"]\")) );\n\n        return solrjDynamicFieldName.toString();\n    }\n\n    private static Object getFieldValue(Object pojo, String pojoFieldName){\n\n\n        try {\n\n//          Field pojoField = pojo.getClass().getField(pojoFieldName);\n//          pojoField.setAccessible(true);\n//          Object pojoFieldObject = pojoField.get(pojo);\n\n            Method method = pojo.getClass().getMethod(\"get\" + pojoFieldName.substring(0, 1).toUpperCase() + pojoFieldName.substring(1));\n            Object pojoFieldObject = method.invoke(pojo, (Object[]) null);\n            return pojoFieldObject;\n        } catch (Exception e) {\n            // Ignore\n        }\n        return null;\n\n    }\n\n\n    /**\n     * Unfortunately, the DocumentObjectBinder creates a HashMap for Map fields annotated with @Field, so order is lost.\n     *\n     * @see https://issues.apache.org/jira/browse/SOLR-4422\n     *\n     *\n     * @see org.apache.solr.client.solrj.beans.DocumentObjectBinder\n     *\n     * @param solrjDynamicFieldMap\n     * @param solrjFieldNameTemplates\n     * @param pojoClass\n     * @param pojoFieldNames\n     * @return\n     */\n    public static <T> List<T> convertSolrjDynamicFieldMapToPojoList(\n            Map<String, Object> solrjDynamicFieldMap, List<String> solrjFieldNameTemplates,\n            Class<T> pojoClass, List<String> pojoFieldNames ){\n\n        try{\n\n            solrjDynamicFieldMap = getMapSortedByIndexValue(solrjDynamicFieldMap);\n\n            List<T> pojoList = new ArrayList<T>();\n\n            int pojoIndex = 0;\n            T pojo = null;\n\n\n            for (Map.Entry<String, Object> solrjDynamicFieldMapEntry : solrjDynamicFieldMap.entrySet()) {\n                String solrjDynamicFieldMapEntryKey = solrjDynamicFieldMapEntry.getKey();\n                Object solrjDynamicFieldMapEntryValue = solrjDynamicFieldMapEntry.getValue();\n\n\n                Integer pojoIndexFound = extractIndexValue(solrjDynamicFieldMapEntryKey);\n\n                if (pojoIndexFound == null){\n                    // A non expected value. (Non-Collection value)\n                    // Value accidentally picked up by @Field regex, such as \"shopping_items_grouping_count_i\"\n                    continue;\n                }\n\n\n                if (pojoList.size() == 0){\n                    pojo = pojoClass.newInstance();\n                    pojoList.add(pojo);\n                }\n\n                if ( pojoIndexFound > pojoIndex ){\n                    pojo = pojoClass.newInstance();\n                    pojoList.add(pojo);\n                    pojoIndex++;\n                }\n\n\n                for (int solrjFieldNameIndex = 0; solrjFieldNameIndex < solrjFieldNameTemplates.size(); solrjFieldNameIndex++) {\n\n                    String solrFieldName = getSolrjFieldName(pojoIndex, solrjFieldNameTemplates.get(solrjFieldNameIndex) );\n\n                    if (solrjDynamicFieldMapEntryKey.equals(solrFieldName)){\n                        String pojoFieldName = pojoFieldNames.get(solrjFieldNameIndex);\n                        setFieldValue(pojo, pojoFieldName, solrjDynamicFieldMapEntryValue);\n                    }\n\n                }\n\n\n            }\n\n            return pojoList;\n        }catch(Exception e){\n            throw new RuntimeException(e);\n        }\n    }\n\n    private static Integer extractIndexValue( String value ){\n        int pojoIndexStart = value.indexOf(\"[\");\n        int pojoIndexEnd = value.indexOf(\"]\");\n\n        if ( pojoIndexStart == -1 || pojoIndexEnd == -1 || pojoIndexStart >= pojoIndexEnd ){\n            return null;\n        }\n\n        String indexStringValue =  value.substring(pojoIndexStart + 1, pojoIndexEnd );\n\n        if (indexStringValue == null || indexStringValue.trim().length() == 0){\n            return null;\n        }\n\n        try{\n            return Integer.parseInt(indexStringValue);\n        }catch(NumberFormatException e ){\n            return null;\n        }\n    }\n\n    private static void setFieldValue(Object pojo, String pojoFieldName, Object value){\n\n        try {\n\n//          Field pojoField = pojo.getClass().getField(pojoFieldName);\n//          pojoField.setAccessible(true);\n//          pojoField.set(pojo, solrjDynamicFieldMapEntryValue);\n\n            Method method = pojo.getClass().getMethod(\"set\" + pojoFieldName.substring(0, 1).toUpperCase() + pojoFieldName.substring(1), value.getClass() );\n            method.invoke(pojo, value);\n        } catch (Exception e) {\n            // Ignore\n        }\n\n    }\n\n    private static Map<String, Object> getMapSortedByIndexValue( Map<String, Object> unsortedMap ){\n\n         final int BEFORE = -1;\n//         final int SAME = 0;  // This will result in one value replacing the other..\n         final int AFTER = 1;\n\n         Comparator<String> comparator = new Comparator<String>() {\n             public int compare(String s1, String s2) {\n\n\n//            \t  BEFORE: A negative number if s1 comes before s2;\n//            \t  AFTER:  A positive number if s1 comes after s2;\n//            \t  SAME:   0.  Only if you want to replace a value.\n\n                 Integer s1IndexValue = extractIndexValue(s1);\n                 Integer s2IndexValue = extractIndexValue(s2);\n\n                 final int DEFAULT = BEFORE;\n\n                 if (s1IndexValue == null && s2IndexValue == null) {\n                     return DEFAULT;\n                 } else if (s1IndexValue != null && s2IndexValue == null) {\n                     return AFTER;\n                 } else if (s1IndexValue == null && s2IndexValue != null) {\n                     return BEFORE;\n                 } else {\n\n                     if  (s1IndexValue > s2IndexValue){\n                         return AFTER;\n                     }else if (s1IndexValue < s2IndexValue){\n                         return BEFORE;\n                     }else{\n                         return DEFAULT;\n                     }\n                 }\n             }\n         };\n         SortedSet<String> sortedSet = new TreeSet<String>(comparator);\n         sortedSet.addAll(unsortedMap.keySet());\n\n         Map<String, Object> sortedMap = new LinkedHashMap<String, Object>();\n         for (String key : sortedSet) {\n             sortedMap.put(key, unsortedMap.get(key));\n         }\n\n         return sortedMap;\n\n    }\n\n}\n\n\n\n\n\nThe Test class:  SolrMapperForSimplePojoListTest\n\npackage test;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Random;\n\nimport org.apache.solr.client.solrj.SolrQuery;\nimport org.apache.solr.client.solrj.beans.DocumentObjectBinder;\nimport org.apache.solr.client.solrj.beans.Field;\nimport org.apache.solr.client.solrj.impl.HttpSolrServer;\nimport org.apache.solr.client.solrj.response.QueryResponse;\nimport org.apache.solr.client.solrj.response.UpdateResponse;\nimport org.apache.solr.client.solrj.util.ClientUtils;\nimport org.apache.solr.common.SolrDocument;\nimport org.apache.solr.common.SolrInputDocument;\nimport org.apache.solr.common.SolrInputField;\nimport org.junit.After;\nimport org.junit.Assert;\nimport org.junit.Before;\nimport org.junit.Test;\n\nimport test.HttpSolrServerTestSupport;\n\npublic class SolrMapperForSimplePojoListTest {\n\n    private static SolrTestClient solrTestClient = new SolrHttpTestClient();\n//    private static SolrTestClient solrTestClient = new SolrMockTestClient();\n\n    private List<ShoppingItem> getDefaultShoppingItems() {\n        return Arrays.asList(\n                new ShoppingItem(1F, \"25W SOLDERING IRON STARTER KIT WITH DMM\", \"This kit contains everything needed for basic electronics work.\"),\n                new ShoppingItem(2F, \"Standard Microphone Insert\", \"Replacement electret mic inserts for tape recorders, etc\"),\n                new ShoppingItem(1F, \"11 DIGIT FLUORO DISPLAY\", \"Vacuum fluorescent display\"),\n                new ShoppingItem(1F, \"LEAD FREE SOLDER 0.71MM 200G ROLL\", \"99.3% tin, 0.7% copper lead-free.\")\n                );\n    }\n\n\n    private ShoppingList getDefaultShoppingList() {\n\n        ShoppingList shoppingList = new ShoppingList();\n        shoppingList.setId(\"1\");\n        List<ShoppingItem> shoppingItems = getDefaultShoppingItems();\n        ShoppingItemMapper.setShoppingListItems(shoppingList, shoppingItems);\n\n        return shoppingList;\n\n    }\n\n    private SolrInputDocument getDefaultShoppingListSolrInputDocument() {\n\n        SolrInputDocument solrInputDocument = new SolrInputDocument();\n\n        solrInputDocument.addField(\"id\", \"1\");\n        solrInputDocument.addField(\"shopping_items[0].quantity_f\", 1.0F);\n        solrInputDocument.addField(\"shopping_items[0].product_s\", \"25W SOLDERING IRON STARTER KIT WITH DMM\");\n        solrInputDocument.addField(\"shopping_items[0].description_s\", \"This kit contains everything needed for basic electronics work.\");\n        solrInputDocument.addField(\"shopping_items[1].quantity_f\", 2.0F);\n        solrInputDocument.addField(\"shopping_items[1].product_s\", \"Standard Microphone Insert\");\n        solrInputDocument.addField(\"shopping_items[1].description_s\", \"Replacement electret mic inserts for tape recorders ,etc\");\n        solrInputDocument.addField(\"shopping_items[2].quantity_f\", 1.0F);\n        solrInputDocument.addField(\"shopping_items[2].product_s\", \"11 DIGIT FLUORO DISPLAY\");\n        solrInputDocument.addField(\"shopping_items[2].description_s\", \"Vacuum fluorescent display\");\n        solrInputDocument.addField(\"shopping_items[3].quantity_f\", 1.0F);\n        solrInputDocument.addField(\"shopping_items[3].product_s\", \"LEAD FREE SOLDER 0.71MM 200G ROLL\");\n        solrInputDocument.addField(\"shopping_items[3].description_s\", \"99.3% tin, 0.7% copper lead-free.\");\n\n        return solrInputDocument;\n\n    }\n\n    @Before\n    public void setUp() throws Exception {\n        solrTestClient.deleteById(\"1\");\n    }\n\n\n    @After\n    public void tearDown() throws Exception {\n        solrTestClient.deleteById(\"1\");\n    }\n\n    @Test\n    public void testSaveAndRetrieve() throws Exception {\n\n        ShoppingList shoppingListIn = getDefaultShoppingList();\n        ShoppingList shoppingListOut = solrTestClient.saveAndRetrieve(ShoppingList.class, shoppingListIn, true);\n\n        Assert.assertEquals(shoppingListIn.getId(), shoppingListOut.getId());\n\n        Assert.assertEquals(\n                ShoppingItemMapper.getShoppingListItems(shoppingListIn).toString(),\n                ShoppingItemMapper.getShoppingListItems(shoppingListOut).toString());\n\n        // https://issues.apache.org/jira/browse/SOLR-4422\n        Assert.assertFalse(\n                String.valueOf(shoppingListIn.getShoppingItemMap()).equals(\n                String.valueOf(shoppingListOut.getShoppingItemMap())));\n\n        System.out.println(\"shoppingListIn[\" + String.valueOf(shoppingListIn.getShoppingItemMap()) + \"]\");\n        System.out.println(\"shoppingListOut[\" +String.valueOf(shoppingListOut.getShoppingItemMap()) + \"]\");\n\n        Assert.assertFalse(\n                String.valueOf(String.valueOf(shoppingListIn.getShoppingItemMap())).equals(\n                String.valueOf(String.valueOf(shoppingListOut.getShoppingItemMap()))));\n\n\n        Assert.assertFalse(shoppingListIn.toString().equals(shoppingListOut.toString()));\n    }\n\n    @Test\n    public void testDetailedMapperOrdering() throws Exception {\n\n        SolrInputDocument solrInputDocument = getDefaultShoppingListSolrInputDocument();\n        StringBuffer solrInputDocumentString = new StringBuffer();\n\n        {\n            for (Map.Entry<String, SolrInputField> solrInputDocumentMapEntry : solrInputDocument.entrySet()) {\n\n                if (\"id\".equals(solrInputDocumentMapEntry.getKey())) {\n                    continue;\n                }\n\n                solrInputDocumentString.append(solrInputDocumentMapEntry.getKey())\n                    .append(\"=\\\"\").append(solrInputDocumentMapEntry.getValue().getValue()).append(\"\\\", \");\n            }\n        }\n\n\n        // RELOAD\n        ShoppingList shoppingListOut = solrTestClient.saveAndRetrieve(ShoppingList.class, solrInputDocument, true);\n\n        List<ShoppingItem> shoppingItemsOut = ShoppingItemMapper.getShoppingListItems(shoppingListOut);\n        StringBuffer shoppingItemsOutString = new StringBuffer();\n\n        {\n            for (int i = 0; i < shoppingItemsOut.size(); i++) {\n\n                ShoppingItem shoppingItem = shoppingItemsOut.get(i);\n\n                // This order is defined in ShoppingItemMapper\n                // Note:  Arrays.asList(\"quantity\", \"product\", \"description\")\n\n                shoppingItemsOutString.append(\"shopping_items[\" + i + \"].quantity_f\")\n                    .append(\"=\\\"\").append(shoppingItem.getQuantity()).append(\"\\\", \");\n\n                shoppingItemsOutString.append(\"shopping_items[\" + i + \"].product_s\")\n                    .append(\"=\\\"\").append(shoppingItem.getProduct()).append(\"\\\", \");\n\n                shoppingItemsOutString.append(\"shopping_items[\" + i + \"].description_s\")\n                    .append(\"=\\\"\").append(shoppingItem.getDescription()).append(\"\\\", \");\n            }\n        }\n\n\n        Assert.assertEquals(solrInputDocumentString.toString(), shoppingItemsOutString.toString());\n\n    }\n\n\n//    private static void assertTrue(Boolean value) {\n//        if (value == null || !value) {\n//            throw new AssertionError();\n//        }\n//    }\n//\n//    private static void assertEquals(Object expected, Object actual) {\n//        if (expected == null && actual == null) {\n//            return;\n//        }\n//\n//        if (expected == null && actual != null) {\n//            throw new AssertionError();\n//        }\n//\n//        if (!expected.equals(actual)) {\n//            throw new AssertionError();\n//        }\n//    }\n\n\n    public static class ShoppingList {\n\n        @Field(\"id\")\n        private String id;\n\n        @Field(\"shopping_items*\")\n        protected Map<String, Object> shoppingItemMap = new LinkedHashMap<String, Object>(16);\n\n        public String getId() {\n            return id;\n        }\n\n        public void setId(String id) {\n            this.id = id;\n        }\n\n        public Map<String, Object> getShoppingItemMap() {\n            return shoppingItemMap;\n        }\n\n        public void setShoppingItemMap(Map<String, Object> shoppingItemMap) {\n            this.shoppingItemMap = shoppingItemMap;\n        }\n\n        @Override\n        public String toString() {\n            return \"ShoppingList [id=\" + id + \", shoppingItemMap=\" + shoppingItemMap + \"]\";\n        }\n\n    }\n\n    public static class ShoppingItem {\n\n        private Float quantity;\n\n        private String product;\n\n        private String description;\n\n\n        public ShoppingItem(){\n\n        }\n\n        public ShoppingItem(Float quantity, String product, String description) {\n            super();\n            this.quantity = quantity;\n            this.product = product;\n            this.description = description;\n        }\n\n        public Float getQuantity() {\n            return quantity;\n        }\n\n        public void setQuantity(Float quantity) {\n            this.quantity = quantity;\n        }\n\n        public String getProduct() {\n            return product;\n        }\n\n        public void setProduct(String product) {\n            this.product = product;\n        }\n\n        public String getDescription() {\n            return description;\n        }\n\n        public void setDescription(String description) {\n            this.description = description;\n        }\n\n        @Override\n        public String toString() {\n            return \"ShoppingItem [quantity=\" + quantity + \", product=\" + product + \", description=\" + description + \"]\";\n        }\n\n    }\n\n    public static class ShoppingItemMapper {\n\n        public static void setShoppingListItems(ShoppingList shoppingList, List<ShoppingItem> shoppingItems) {\n\n            Map<String, Object> solrjDynamicFieldMap = SolrMapperForSimplePojoList.convertPojoListToSolrjDynamicFieldMap(\n                    shoppingItems, Arrays.asList(\"quantity\", \"product\", \"description\"),\n                    Arrays.asList(\"shopping_items[].quantity_f\", \"shopping_items[].product_s\", \"shopping_items[].description_s\"));\n\n            shoppingList.setShoppingItemMap(solrjDynamicFieldMap);\n        }\n\n        public static List<ShoppingItem> getShoppingListItems(ShoppingList shoppingList) {\n\n            Map<String, Object> solrjDynamicFieldMap = shoppingList.getShoppingItemMap();\n            Assert.assertTrue(solrjDynamicFieldMap != null);\n\n            List<ShoppingItem> shoppingItems = SolrMapperForSimplePojoList.convertSolrjDynamicFieldMapToPojoList(\n                solrjDynamicFieldMap, Arrays.asList(\"shopping_items[].quantity_f\", \"shopping_items[].product_s\", \"shopping_items[].description_s\") ,\n                ShoppingItem.class, Arrays.asList(\"quantity\", \"product\", \"description\") );\n\n            return shoppingItems;\n        }\n    }\n\n    public static interface SolrTestClient {\n\n        public void deleteById(String id) throws Exception;\n\n        public <T> T saveAndRetrieve(Class<T> type, T beanIn, boolean shuffleSolrInputFields) throws Exception;\n\n        public <T> T saveAndRetrieve(Class<T> type, SolrInputDocument solrInputDocument, boolean shuffleSolrInputFields) throws Exception;\n    }\n\n    public static class SolrHttpTestClient implements SolrTestClient {\n\n        private static HttpSolrServer server = HttpSolrServerTestSupport.getInstance().getServer();\n\n        public void deleteById(String id) throws Exception {\n\n             UpdateResponse updateResponse = server.deleteById(id);\n             Assert.assertEquals(0, updateResponse.getStatus());\n\n             server.commit();\n        }\n\n        public <T> T saveAndRetrieve(Class<T> type, T beanIn, boolean shuffleSolrInputFields) throws Exception {\n\n            String docId = null;\n\n            if (ShoppingList.class.isAssignableFrom(type)) {\n                docId = ((ShoppingList) beanIn).getId();\n            }\n\n            if (docId == null) {\n                return null;\n            }\n\n            UpdateResponse updateResponse = server.addBean(beanIn);\n            Assert.assertEquals(0, updateResponse.getStatus());\n            server.commit();\n\n            return getBeanById(type, docId);\n\n        }\n\n        public <T> T saveAndRetrieve(Class<T> type, SolrInputDocument solrInputDocument, boolean shuffleSolrInputFields) throws Exception {\n\n            String docId = String.valueOf(solrInputDocument.get(\"id\").getValue());\n\n            UpdateResponse updateResponse = server.add(solrInputDocument);\n            Assert.assertEquals(0, updateResponse.getStatus());\n            server.commit();\n\n            return getBeanById(type, docId);\n        }\n\n        private <T> T getBeanById(Class<T> type, String id) throws Exception {\n\n            SolrQuery solrQuery = new SolrQuery();\n            solrQuery.setQuery(\"*:*\");\n            solrQuery.addFilterQuery(\"id:\" + id);\n            QueryResponse queryResponse = server.query(solrQuery);\n            Assert.assertEquals(0, queryResponse.getStatus());\n\n            List<T> beanOutList = queryResponse.getBeans(type);\n\n            if (beanOutList == null || beanOutList.size() == 0) {\n                return null;\n            }\n\n            T beanOut = beanOutList.get(0);\n\n            return beanOut;\n        }\n\n    }\n\n    public static class SolrMockTestClient implements SolrTestClient {\n\n\n        public void deleteById(String id) throws Exception {\n            // Do nothing - in memory only\n        }\n\n        /**\n         * Should return the same results as using a Solr instance directly.\n         *\n         * @param solrInputDocument\n         * @return\n         */\n        public <T> T saveAndRetrieve(Class<T> type, T beanIn, boolean shuffleSolrInputFields) {\n\n            DocumentObjectBinder documentObjectBinder = new DocumentObjectBinder();\n\n            // Store Pojo\n\n            SolrInputDocument solrInputDocument = documentObjectBinder.toSolrInputDocument(beanIn);\n\n            /*\n             * SolrInputDocument[\n             *     id=1,\n             *     shopping_items[0].quantity_f=1.0,\n             *     shopping_items[0].product_s=25W SOLDERING IRON STARTER KIT WITH DMM,\n             *     shopping_items[0].description_s=This kit contains everything needed for basic electronics work.,\n             *     shopping_items[1].quantity_f=2.0,\n             *     shopping_items[1].product_s=Standard Microphone Insert,\n             *     shopping_items[1].description_s=Replacement electret mic inserts for tape recorders, etc,\n             *     shopping_items[2].quantity_f=1.0,\n             *     shopping_items[2].product_s=11 DIGIT FLUORO DISPLAY,\n             *     shopping_items[2].description_s=Vacuum fluorescent display,\n             *     shopping_items[3].quantity_f=1.0,\n             *     shopping_items[3].product_s=LEAD FREE SOLDER 0.71MM 200G ROLL,\n             *     shopping_items[3].description_s=99.3% tin, 0.7% copper lead-free.]\n             *\n             *\n             */\n\n            // Retrieve Pojo\n//            SolrDocument solrDocument = ClientUtils.toSolrDocument(solrInputDocument); // (Slightly Mocked)\n//            T beanOut = documentObjectBinder.getBean(type, solrDocument);\n\n            T beanOut = saveAndRetrieve(type, solrInputDocument, shuffleSolrInputFields);\n\n            return beanOut;\n        }\n\n        public <T> T saveAndRetrieve(Class<T> type, SolrInputDocument solrInputDocument, boolean shuffleSolrInputFields) {\n\n            DocumentObjectBinder documentObjectBinder = new DocumentObjectBinder();\n\n            SolrDocument solrDocument;\n\n            if (shuffleSolrInputFields) {\n                // Shuffle\n                // Unfortunately, the DocumentObjectBinder creates a HashMap for Map fields annotated with @Field, so order is lost.\n                // https://issues.apache.org/jira/browse/SOLR-4422\n                // Replicate this behaviour below.\n\n                SolrInputDocument solrInputDocumentShuffled = new SolrInputDocument();\n                {\n                    List<SolrInputField> solrInputFieldList = new ArrayList<SolrInputField>(solrInputDocument.values());\n\n                    long seed = System.nanoTime();\n                    Collections.shuffle(solrInputFieldList, new Random(seed));\n\n                    for (SolrInputField solrInputField : solrInputFieldList) {\n                        solrInputDocumentShuffled.addField(solrInputField.getName(), solrInputField.getValue());\n                    }\n                }\n\n                solrDocument = ClientUtils.toSolrDocument(solrInputDocumentShuffled); // (Slightly Mocked)\n            } else {\n                solrDocument = ClientUtils.toSolrDocument(solrInputDocument); // (Slightly Mocked)\n            }\n\n\n            T beanOut = documentObjectBinder.getBean(type, solrDocument);\n\n            return beanOut;\n\n        }\n\n    }\n}\n\n\n "
        },
        {
            "author": "Sandeep J",
            "id": "comment-14313153",
            "date": "2015-02-09T23:28:56+0000",
            "content": "Hey Mark Miller are there any plans to bring this feature in near future. We have a similar use case and it would be really helpful to be able to annotate the child object.  "
        },
        {
            "author": "Noble Paul",
            "id": "comment-14317889",
            "date": "2015-02-12T09:34:30+0000",
            "content": "This adds a new attribute to the existing @Field annotation\n\n\npublic @interface Field {\n  public static final String DEFAULT =\"#default\";\n  String value() default DEFAULT;\n  boolean child() default false;\n}\n\n\nexamples:\n\npublic class Child {\n    @Field\n    String id;\n\n    @Field\n    String name;\n\n  }\n\n  public  class SingleValueChild {\n    @Field\n    String id;\n\n    @Field(child = true)\n    Child child;\n  }\n\n  public static class ListChild{\n    @Field\n    String id;\n\n    @Field(child = true)\n    List<Child> child;\n\n  }\n  public  class ArrayChild{\n    @Field\n    String id;\n\n    @Field(child = true)\n    Child[] child;\n  }\n\n "
        },
        {
            "author": "Noble Paul",
            "id": "comment-14317917",
            "date": "2015-02-12T09:54:24+0000",
            "content": "I shall commit this soon "
        },
        {
            "author": "ASF subversion and git services",
            "id": "comment-14321644",
            "date": "2015-02-14T19:06:55+0000",
            "content": "Commit 1659845 from Noble Paul in branch 'dev/trunk'\n[ https://svn.apache.org/r1659845 ]\n\nSOLR-1945: Add support for child docs in DocumentObjectBinder "
        },
        {
            "author": "Mark Miller",
            "id": "comment-14321653",
            "date": "2015-02-14T19:16:36+0000",
            "content": "+1, looks good. "
        },
        {
            "author": "ASF subversion and git services",
            "id": "comment-14321660",
            "date": "2015-02-14T19:23:46+0000",
            "content": "Commit 1659847 from Noble Paul in branch 'dev/branches/branch_5x'\n[ https://svn.apache.org/r1659847 ]\n\nSOLR-1945: Add support for child docs in DocumentObjectBinder "
        },
        {
            "author": "ASF subversion and git services",
            "id": "comment-14321698",
            "date": "2015-02-14T20:44:06+0000",
            "content": "Commit 1659858 from Noble Paul in branch 'dev/branches/branch_5x'\n[ https://svn.apache.org/r1659858 ]\n\nSOLR-1945: Using java8 API causing error "
        },
        {
            "author": "Timothy Potter",
            "id": "comment-14495368",
            "date": "2015-04-15T00:30:49+0000",
            "content": "Bulk close after 5.1 release "
        },
        {
            "author": "Preetam Dwivedi",
            "id": "comment-14660778",
            "date": "2015-08-06T20:56:03+0000",
            "content": "I am getting following error when I am using @Field(child=true)\n\n\nException in thread \"main\" org.apache.solr.client.solrj.impl.HttpSolrClient$RemoteSolrException: Error from server at http://localhost:8983/solr: undefined field: \"child\"\n\tat org.apache.solr.client.solrj.impl.HttpSolrClient.executeMethod(HttpSolrClient.java:560)\n\tat org.apache.solr.client.solrj.impl.HttpSolrClient.request(HttpSolrClient.java:235)\n\tat org.apache.solr.client.solrj.impl.HttpSolrClient.request(HttpSolrClient.java:227)\n\tat org.apache.solr.client.solrj.SolrRequest.process(SolrRequest.java:135)\n\tat org.apache.solr.client.solrj.SolrClient.add(SolrClient.java:174)\n\tat org.apache.solr.client.solrj.SolrClient.addBean(SolrClient.java:278)\n\tat com.portal.job.services.solr.TestSolrService.test(TestSolrService.java:27)\n\tat com.portal.job.services.solr.TestSolrService.main(TestSolrService.java:14)\n\n\n\nCode:\n\n\nimport java.io.IOException;\n\nimport org.apache.solr.client.solrj.SolrClient;\nimport org.apache.solr.client.solrj.SolrServerException;\nimport org.apache.solr.client.solrj.beans.Field;\nimport org.apache.solr.client.solrj.impl.HttpSolrClient;\n\npublic class TestSolrService {\n\n\tpublic static void main(String[] args) throws IOException,\n\t\t\tSolrServerException {\n\t\tnew TestSolrService().test();\n\t}\n\n\tpublic void test() throws IOException, SolrServerException {\n\n\t\tSolrClient client = new HttpSolrClient(\"http://localhost:8983/solr/\");\n\n\t\tTest test = new Test();\n\t\ttest.setId(\"2\");\n\t\tChild c = new Child();\n\t\tc.child = true;\n\t\tc.id = \"1\";\n\t\ttest.setChild(c);\n\t\tclient.addBean(\"test\", test, 10);\n\n\t\tclient.close();\n\n\t}\n\n\tpublic class Child {\n\t\t@Field\n\t\tpublic String id;\n\t\t@Field\n\t\tpublic boolean child;\n\t}\n\n\tpublic class Test {\n\n\t\t@Field\n\t\tprivate String id;\n\n\t\t@Field(child = true)\n\t\tprivate Child child;\n\n\t\tpublic String getId() {\n\t\t\treturn id;\n\t\t}\n\n\t\tpublic void setId(String id) {\n\t\t\tthis.id = id;\n\t\t}\n\n\t\tpublic Child getChild() {\n\t\t\treturn child;\n\t\t}\n\n\t\tpublic void setChild(Child child) {\n\t\t\tthis.child = child;\n\t\t}\n\n\t}\n}\n\n "
        },
        {
            "author": "Noble Paul",
            "id": "comment-14661283",
            "date": "2015-08-07T04:16:16+0000",
            "content": "Preetam Dwivedi\n\nThis is a feature released already in 5.1. If you think there is a problem , we need to open a new ticket and discuss it there "
        },
        {
            "author": "Preetam Dwivedi",
            "id": "comment-14661291",
            "date": "2015-08-07T04:31:48+0000",
            "content": "Noble Paul I guess it was an issue with my code as it didn't added the type for this field.\n\n\n@Field\npublic boolean child;\n\n "
        }
    ]
}