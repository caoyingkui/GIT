{
    "id": "SOLR-10503",
    "title": "CurrencyField should be changed from TrieLongField to LongPointField for underlying raw-polyfield",
    "details": {
        "labels": "",
        "priority": "Major",
        "components": [],
        "type": "Sub-task",
        "fix_versions": [
            "6.7",
            "7.0"
        ],
        "affect_versions": "None",
        "resolution": "Fixed",
        "status": "Resolved"
    },
    "description": "",
    "attachments": {
        "SOLR-10503.patch": "https://issues.apache.org/jira/secure/attachment/12873189/SOLR-10503.patch"
    },
    "issue_links": {},
    "comments": [
        {
            "date": "2017-04-18T01:27:39+0000",
            "content": "doing this will be a back compat nightmare, but seems prudent in the long run.\n\nperhaps the best solution would be to deprecate CurrencyField and add a CurrencyPointField to replace it \u2013 fixing SOLR-10502 at the same time? ",
            "author": "Hoss Man",
            "id": "comment-15971959"
        },
        {
            "date": "2017-05-26T23:45:14+0000",
            "content": "perhaps the best solution would be to deprecate CurrencyField and add a CurrencyPointField to replace it \u2013 fixing SOLR-10502 at the same time?\n\n+1 ",
            "author": "Steve Rowe",
            "id": "comment-16027031"
        },
        {
            "date": "2017-06-15T23:20:25+0000",
            "content": "Patch deprecating CurrencyField in favor of a new points-based CurrencyPointField.\n\nI had to pull some top-level classes out of CurrencyField (CurrencyValue and FileExchangeRateProvider) in order to share them between the new and old classes.  Similarly, I moved CurrencyField.getCurrency() to CurrencyValue, so that the two classes didn't have to refer to CurrencyField.\n\nI fixed up the ref guide, and changed all example schemas to use only the new CurrencyPointField.\n\nPrecommit and all Solr tests pass.\n\nI think it's ready to go. ",
            "author": "Steve Rowe",
            "id": "comment-16051197"
        },
        {
            "date": "2017-06-16T18:20:28+0000",
            "content": "\n\n\twhy copy so much of AbstractCurrencyFieldTest into a new CurrencyPointFieldTest instead of just refactoring/extending it?\n\t\n\t\teven with the junit paramaterization, could we just do something like...\n\npublic class CurrencyPointFieldTest extends AbstractCurrencyFieldTest {\n  private final String fieldName;\n  public CurrencyPointFieldTest(String fieldName) { \n    this.fieldName = fieldName;\n  }\n  @ParametersFactory\n  public static Iterable<Object[]> parameters() {\n    return Arrays.asList(new Object[][] { {\"oer_amount_p\"}, {\"amount_p\"} });\n  }\n  @Override\n  public abstract String field() { return fieldName; }\n  ...\n}\n** actually: can't we just add that junit field parametrization to the existing subclasses of bstractCurrencyFieldTest w/o needing a new test at all?\n\n\n\t\n\t\n\t\"I moved CurrencyField.getCurrency() to CurrencyValue...\"\n\t\n\t\tthere's still a copy in CurrencyPointField\n\t\n\t\n\t\"I had to pull some top-level classes out of CurrencyField\"\n\t\n\t\tin general, maybe instead of refactoring these various inner classes into top level classes, we should add an abstract class CurrencyFieldType as a superclass of CurrencyField && CurrencyPointField \u2013 and leave most of the existing code there, only overriding the subfield type specific bits in the subclasses?\n\t\tthis would also simplify the changes need in ValueSourceParser (just refer to the abstract base class in the instanceof / exception) and some of the misc javadoc changes.\n\t\n\t\n\tCurrencPointField still seems to suffer from SOLR-10502?\n\t\n\t\tCurrencPointField.createDynamicCurrencyField(...) is also creating the dynamicFields w/o docValues\n\t\t...and in general these sub-fields used fixed options hte user can't configure.\n\t\tthis seems like a deal breaker to me...\n\t\n\t\n\n\n\nI think if we're deprecating CurrencyField and creating it's replacement, now is the time when we really should to do something about fixing the root issues of SOLR-10502:\n\n\tGood defaults for the sub fields.\n\tGiving the user control over the underlying sub-fields to override those defaults\n\n\n\nFixing #1 is a good idea, fixing #2 seems really important to ensure we don't have more headaches like this down the road the next time we realize the \"hardcoded\" defaults are terrible.  (ie: i think we should care more about #2 then #1 if we have to make a choice)\n\n\n\nIn SOLR-1050 I hypothosized changing to use docValues by default on the subfields and letting the options on the \"parent\" field override the indexed/docValues options on the subfields \u2013 I still think that's viable and would not be opposed to it, but In hindsight I think a better model would be to follow in the example of LatLonField & PointType and allow/force the user to configure a codeStrSuffix and amountLongSuffix that must have corrisponding dynamicFields defined in the schema.  Our inform method can then validate that they exist and map to StrField and LongValueFieldType.\n\nIf we do this, then maybe we don't even need an explicitly named CurrencyPointField ?  We can just have a (non-abstract) CurrencyFieldType that works with any LongValueFieldType (trie, points, whatever comes next in a few years) ....\n\n\n<fieldType name=\"currency\" class=\"solr.CurrencyFieldType\" defaultCurrency=\"USD\" currencyConfig=\"currency.xml\"\n           codeStrSuffix=\"_poly_s\" amountLongSuffix=\"_poly_l\"\n\t   multiValued=\"false\" stord=\"true\" />\n...\n<dynamicField name=\"*_poly_l\"  type=\"long\"   indexed=\"false\" stored=\"false\" docValues=\"true\" />\n<dynamicField name=\"*_poly_s\"  type=\"string\" indexed=\"false\" stored=\"false\" docValues=\"true\" />\n\n\n\n...and make the (deprecated) CurrencyField a subclass of CurrencyFieldType that inject it's hardcoded suffixes into the init params, and creates them directly in inform...\n\n\n@Deprecated\npublic class CurrencyField extends CurrencyFieldType {\n  @Override\n  protected void init(IndexSchema schema, Map<String, String> args) {\n    super.init(schema, args);\n    // Initialize field type for amount\n    fieldTypeAmountRaw = new TrieLongField();\n    fieldTypeAmountRaw.setTypeName(\"amount_raw_type_tlong\");\n    Map<String,String> map = new HashMap<>(1);\n    map.put(\"precisionStep\", precisionStepString);\n    fieldTypeAmountRaw.init(schema, map);\n    \n    // Initialize field type for currency string\n    fieldTypeCurrency = new StrField();\n    fieldTypeCurrency.setTypeName(\"currency_type_string\");\n    fieldTypeCurrency.init(schema, new HashMap<String,String>());\n  }\n  @Override\n  public void inform(IndexSchema schema) {\n    createDynamicCurrencyField(FIELD_SUFFIX_CURRENCY,   fieldTypeCurrency);\n    createDynamicCurrencyField(FIELD_SUFFIX_AMOUNT_RAW, fieldTypeAmountRaw);\n    super.inform(schema);\n  }\n  ...  \n\n\n\nEven if I'm in the minority and most folks don't like the idea of requiring users to configure a codeStrSuffix and amountLongSuffix on the new FieldType, i think it's important that we allow them to be configured \u2013 we can still do roughly the same as i suggested above, but CurrencyFieldType could have some init/inform logic like...\n\n\n// init\nif (! configuredSubTypeSuffixes) {\n  createDefaultSubFieldTypes(IndexSchema schema);\n}\n...\n// inform\nif (! configuredSubTypeSuffixes) {\n  createDefaultSubFieldDynamicFields(IndexSchema schema);\n}\n\n\n\n...where those methods in the superclass use LongPointField & docValues=\"true\" by default, but in the (deprecated) subclass (where configuredSubTypeSuffixes is always false) they use Trie & docValues=false\n\n\nWDYT? ",
            "author": "Hoss Man",
            "id": "comment-16052220"
        },
        {
            "date": "2017-06-16T19:04:56+0000",
            "content": "Thanks for the review, Hoss Man.\n\nIn general, I assumed that CurrencyField would go away eventually (in 8.0 I assume), and if CurrencyPointField and CurrencyField are tangled in various ways, then removing CurrencyField would either leave unnecessary abstractions in place, or require post-removal simplification.\n\nwhy copy so much of AbstractCurrencyFieldTest into a new CurrencyPointFieldTest instead of just refactoring/extending it?\n\nIn a few places, AbstractCurrencyFieldTest directly refers to CurrencyField or its members.  Making it work with both would require both to implement/extend a common thing.  See above.\n\n\n\"I had to pull some top-level classes out of CurrencyField\"\nin general, maybe instead of refactoring these various inner classes into top level classes,\n\nThose top-level classes were not inner classes; they were, as I said, top-level.  In general though I see your point.\n\nCurrencPointField still seems to suffer from SOLR-10502?\n\nYes, I forgot about it, thanks for the reminder.\n\nIn SOLR-1050 I hypothosized changing to use docValues by default on the subfields and letting the options on the \"parent\" field override the indexed/docValues options on the subfields \u2013 I still think that's viable and would not be opposed to it, but In hindsight I think a better model would be to follow in the example of LatLonField & PointType and allow/force the user to configure a codeStrSuffix and amountLongSuffix that must have corrisponding dynamicFields defined in the schema.\n\nI like it.  LatLonField & PointType also include an alternative to the subFieldSuffix (via AbstractSubTypeFieldType): subFieldType.  I'm inclined not to support both, and the suffix approach allows users more freedom.  Making them optional seems like a good idea to me.\n\nI'll work on refactoring the patch. ",
            "author": "Steve Rowe",
            "id": "comment-16052278"
        },
        {
            "date": "2017-06-17T02:05:05+0000",
            "content": "Patch folding in Hoss Man's feedback, and fixing SOLR-10502. ",
            "author": "Steve Rowe",
            "id": "comment-16052634"
        },
        {
            "date": "2017-06-19T17:47:09+0000",
            "content": "\n\n\tnow that CurrencyField extends CurrencyFieldType, can't we move CurrencyValue and FileExchangeRateProvider back into CurrencyFieldType.java (or make them static inner classes of CurrencyFieldType) ?\n\tyou removed the error checking from ValueSourceParser.java? ... if someone tries to use the currency() function on a non CurrencyFieldType it should still through a clean error, not a ClassCastException\n\tdo we need to bother parameterizing fieldTypeClass in CurrencyFieldTypeTest? isn't it enough to just assert that it's an instanceof CurrencyFieldType? ... the test methods really shouldn't be affected at all by this distinction\n\t\n\t\tIf we're going to consolidate the existing tests like this, it seems better to parameterize the expected provider class, and add a getter to CurrencyFieldType for that.\n\t\tthen we could also fix the assume in testAsymmetricPointQuery so it isn't dependent on us remembering to keep the list of field names accurate.\n\t\n\t\n\tI think these (2) comments are suppose to refer to subclass (not superclass) ??...\n// Don't initialize if superclass already has done so\n\tFWIW: I'm still -0 to CurrencyFieldType having hardcoded defalts for these...\n\n      fieldSuffixAmountRaw = args.get(PARAM_FIELD_SUFFIX_AMOUNT_RAW);\n      if (fieldSuffixAmountRaw == null) {  // not specified; use default raw field type\n        fieldSuffixAmountRaw = DEFAULT_FIELD_SUFFIX_AMOUNT_RAW;\n        fieldTypeAmountRaw = new LongPointField();\n...\n      fieldSuffixCurrency = args.get(PARAM_FIELD_SUFFIX_CURRENCY);\n      if (fieldSuffixCurrency == null) {   // not specified; use default currency field type\n        fieldSuffixCurrency = DEFAULT_FIELD_SUFFIX_CURRENCY;\n        fieldTypeCurrency = new StrField();\n\n\n...I think it would be a lot better if the suffixes were mandatory in this new class\n\t\n\t\tIf we did that, then the CurrencyFieldType.inform logic would be simpler as well: all it would have to worry about is ensuring the suffixes exist (the subclass can do it's own createDynamicCurrencyField before calling super.inform())\n\t\n\t\n\tThe existence of the dynamicFieldDocValuesArg() method feels more awkward and clunky then just making createDynamicCurrencyField() a protected method that the subclass can override.\n\t\n\t\tof course: if I can convince you to eliminte the  DEFAULT_FIELD_SUFFIX_AMOUNT_* logic from the CurrencyFieldType parent class, that gets much simpler: only the CurrencyField subclass needs to bother implementing/calling createDynamicCurrencyField()\n\t\n\t\n\n ",
            "author": "Hoss Man",
            "id": "comment-16054453"
        },
        {
            "date": "2017-06-22T02:22:21+0000",
            "content": "Patch folding in Hoss Man's latest feedback.  \n\nI was pulling out my hair trying to figure out why Solrj example tests were failing when performing an atomic update on a currency field, e.g.:\n\n\n  [junit4]   2> NOTE: reproduce with: ant test  -Dtestcase=SolrExampleXMLTest -Dtests.method=testUpdateField -Dtests.seed=82002888280BD61E -Dtests.slow=true -Dtests.locale=lv -Dtests.timezone=Asia/Kamchatka -Dtests.asserts=true -Dtests.file.encoding=US-ASCII\n   [junit4] ERROR   0.56s J10 | SolrExampleXMLTest.testUpdateField <<<\n   [junit4]    > Throwable #1: org.apache.solr.client.solrj.impl.HttpSolrClient$RemoteSolrException: Error from server at http://127.0.0.1:50840/solr/collection1: ERROR: [doc=unique] multiple values encountered for non multiValued field price_c____l: [10000, 100]\n\n\n\nI eventually traced this to stored=\"true\" used on the dynamic sub-fields in CurrencyFieldType-based field types in example schemas; this causes Atomic Update indexing to fail; see https://lucene.apache.org/solr/guide/6_6/updating-parts-of-documents.html#UpdatingPartsofDocuments-FieldStorage.  I added information about this to the example schemas and to the ref guide.\n\nComments inline below:\n\nnow that CurrencyField extends CurrencyFieldType, can't we move CurrencyValue and FileExchangeRateProvider back into CurrencyFieldType.java (or make them static inner classes of CurrencyFieldType) ?\n\nI made them static inner classes, but as a result had to add exceptional classloader logic to load  CurrencyFieldType inner classes (currently only FileExchangeRateProvider).\n\nyou removed the error checking from ValueSourceParser.java? ... if someone tries to use the currency() function on a non CurrencyFieldType it should still through a clean error, not a ClassCastException\n\nFixed.\n\ndo we need to bother parameterizing fieldTypeClass in CurrencyFieldTypeTest? isn't it enough to just assert that it's an instanceof CurrencyFieldType? ... the test methods really shouldn't be affected at all by this distinction\n\nAgreed, removed the fieldTypeClass parameter.\n\nIf we're going to consolidate the existing tests like this, it seems better to parameterize the expected provider class, and add a getter to CurrencyFieldType for that. then we could also fix the assume in testAsymmetricPointQuery so it isn't dependent on us remembering to keep the list of field names accurate.\n\nDone. (CurrencyFieldType already had getProvider().)\n\nI think these (2) comments are suppose to refer to subclass (not superclass) ??... // Don't initialize if superclass already has done so\n\nRight, fixed.\n\nFWIW: I'm still -0 to CurrencyFieldType having hardcoded defalts for [the field suffixes] ...I think it would be a lot better if the suffixes were mandatory in this new class\n\nI've made this change.  I think the user experience would be better with defaults for the majority of folks who I'm guessing won't care about sub-field details.  But I'm ok with not providing them.\n\nThe existence of the dynamicFieldDocValuesArg() method feels more awkward and clunky then just making createDynamicCurrencyField() a protected method that the subclass can override....of course: if I can convince you to eliminte the DEFAULT_FIELD_SUFFIX_AMOUNT_* logic from the CurrencyFieldType parent class, that gets much simpler: only the CurrencyField subclass needs to bother implementing/calling createDynamicCurrencyField()\n\nSince only CurrencyField uses createDynamicCurrencyField(), I moved it there. ",
            "author": "Steve Rowe",
            "id": "comment-16058617"
        },
        {
            "date": "2017-06-22T16:55:04+0000",
            "content": "I made them static inner classes, but as a result had to add exceptional classloader logic to load CurrencyFieldType inner classes (currently only FileExchangeRateProvider).\n\nOh ... uck ... i'm sorry, i hadn't even thought about that \u2013 I was just trying to avoid \"polluting\" the schema package with what felt like implementation details, I didn't even think about the fact that those classes can be configured by name...  Please ignore that suggestion and go back to the simpler code you had before unless you think this is better for some reason.\n\nI've made this change. I think the user experience would be better with defaults for the majority of folks who I'm guessing won't care about sub-field details. But I'm ok with not providing them.\n\nMy take is that I'd rather we provide those \"defaults\" in our sample configsets where they are more obvious to users who want to tweak them, and we can trivially change them overtime w/o breaking backcompat for users who upgrade w/their existing configs \u2013 having \"defaults in code\" are much harder for us to change.\n\nOther notes...\n\n\n\twhy do we need MethodHandles.lookup() in CurrencyFieldType.init and checkSchemaField \u2013 wouldn't this.getClass() work just as well?\n\tCurrencyField.inform(IndexSchema) should be calling super.inform() as it's last step (and as a result doesn't need to explicitly assign this.schema\n\n ",
            "author": "Hoss Man",
            "id": "comment-16059682"
        },
        {
            "date": "2017-06-22T23:58:45+0000",
            "content": "Patch folding in Hoss Man's latest feedback.\n\nComments inline below:\n\n\nI made them static inner classes, but as a result had to add exceptional classloader logic to load CurrencyFieldType inner classes (currently only FileExchangeRateProvider).\n\nOh ... uck ... i'm sorry, i hadn't even thought about that \u2013 I was just trying to avoid \"polluting\" the schema package with what felt like implementation details, I didn't even think about the fact that those classes can be configured by name... Please ignore that suggestion and go back to the simpler code you had before unless you think this is better for some reason.\n\nI left CurrencyValue as an inner class, moved FileExchangeRateProvider out to its own .java file, and removed the exception classloader logic.\n\n\nI've made this change. I think the user experience would be better with defaults for the majority of folks who I'm guessing won't care about sub-field details. But I'm ok with not providing them.\n\nMy take is that I'd rather we provide those \"defaults\" in our sample configsets where they are more obvious to users who want to tweak them, and we can trivially change them overtime w/o breaking backcompat for users who upgrade w/their existing configs \u2013 having \"defaults in code\" are much harder for us to change.\n\nGood arguments.\n\nwhy do we need MethodHandles.lookup() in CurrencyFieldType.init and checkSchemaField \u2013 wouldn't this.getClass() work just as well?\n\nWe don't.  I replaced them with getClass().\n\nCurrencyField.inform(IndexSchema) should be calling super.inform() as it's last step (and as a result doesn't need to explicitly assign this.schema\n\nDone.  I had to introduce a boolean configuredSubFieldSuffixes (name suggested by you earlier) to avoid calling the dynamic field validation in CurrencyFieldType.inform() when called from CurrencyField.inform() via super.inform(). ",
            "author": "Steve Rowe",
            "id": "comment-16060213"
        },
        {
            "date": "2017-06-23T00:22:07+0000",
            "content": "... I had to introduce a boolean configuredSubFieldSuffixes (name suggested by you earlier) ...\n\nHmm, that suggestion was made in the context of \"Even if I'm in the minority and most folks don't like the idea of requiring users to configure...\"  \u2013 ie: if that single class needed to support both configurable suffixes and implicit suffixes.\n\nAs things stand now, can't we eliminate that variable and just do...\n\n\n  public void inform(IndexSchema schema) {\n    this.schema = schema;\n    if (null == fieldTypeAmountRaw) {\n      assert null != fieldSuffixAmountRaw : \"How did we get here?\";\n      SchemaField field = schema.getFieldOrNull(POLY_FIELD_SEPARATOR + fieldSuffixAmountRaw);\n      if (field == null) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Field type \\\"\" + this.getTypeName()\n            + \"\\\": Undefined dynamic field for \" + PARAM_FIELD_SUFFIX_AMOUNT_RAW + \"=\\\"\" + fieldSuffixAmountRaw + \"\\\"\");\n      }\n      fieldTypeAmountRaw = field.getType();\n      if (!(fieldTypeAmountRaw instanceof LongValueFieldType)) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Field type \\\"\" + this.getTypeName()\n            + \"\\\": Dynamic field for \" + PARAM_FIELD_SUFFIX_AMOUNT_RAW + \"=\\\"\" + fieldSuffixAmountRaw\n            + \"\\\" must have type class extending LongValueFieldType\");\n      }\n    }\n    if (null == fieldTypeCurrency) {\n      assert null != fieldSuffixCurrency : \"How did we get here?\";\n      SchemaField field = schema.getFieldOrNull(POLY_FIELD_SEPARATOR + fieldSuffixCurrency);\n      if (field == null) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Field type \\\"\" + this.getTypeName()\n            + \"\\\": Undefined dynamic field for \" + PARAM_FIELD_SUFFIX_CURRENCY + \"=\\\"\" + fieldSuffixCurrency + \"\\\"\");\n      }\n      fieldTypeCurrency = field.getType();\n      if (!(fieldTypeCurrency instanceof StrField)) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Field type \\\"\" + this.getTypeName()\n            + \"\\\": Dynamic field for \" + PARAM_FIELD_SUFFIX_CURRENCY + \"=\\\"\" + fieldSuffixCurrency\n            + \"\\\" must have type class of (or extending) StrField\");\n      }\n    }\n  }\n\n\n\n? ",
            "author": "Hoss Man",
            "id": "comment-16060239"
        },
        {
            "date": "2017-06-23T00:36:01+0000",
            "content": "\n... I had to introduce a boolean configuredSubFieldSuffixes (name suggested by you earlier) ...\n\nAs things stand now, can't we eliminate that variable and just do...\n\nYes, that works, thanks.  Patch attached. ",
            "author": "Steve Rowe",
            "id": "comment-16060245"
        },
        {
            "date": "2017-06-23T00:53:15+0000",
            "content": "+1 ",
            "author": "Hoss Man",
            "id": "comment-16060255"
        },
        {
            "date": "2017-06-23T14:14:40+0000",
            "content": "Commit 5232b2ce5a6c92f57a75031ffb273c799ab7f5c7 in lucene-solr's branch refs/heads/branch_6x from Steve Rowe\n[ https://git-wip-us.apache.org/repos/asf?p=lucene-solr.git;h=5232b2c ]\n\nSOLR-10503,SOLR-10502: Deprecate CurrencyField in favor of new CurrencyFieldType, which works with point fields and provides control over dynamic fields used for the raw amount and currency code sub-fields.\n\n Conflicts:\n\tsolr/core/src/java/org/apache/solr/schema/CurrencyField.java\n\tsolr/core/src/test-files/solr/collection1/conf/schema.xml ",
            "author": "ASF subversion and git services",
            "id": "comment-16060950"
        },
        {
            "date": "2017-06-23T14:14:44+0000",
            "content": "Commit a6f4f2dd9ce33a0aa3597e73a5ced0b96302c847 in lucene-solr's branch refs/heads/master from Steve Rowe\n[ https://git-wip-us.apache.org/repos/asf?p=lucene-solr.git;h=a6f4f2d ]\n\nSOLR-10503,SOLR-10502: Deprecate CurrencyField in favor of new CurrencyFieldType, which works with point fields and provides control over dynamic fields used for the raw amount and currency code sub-fields. ",
            "author": "ASF subversion and git services",
            "id": "comment-16060952"
        },
        {
            "date": "2017-06-23T14:17:30+0000",
            "content": "Thanks for the reviews Hoss Man. ",
            "author": "Steve Rowe",
            "id": "comment-16060960"
        }
    ]
}