{
    "id": "SOLR-8514",
    "title": "Implement StatementImpl.execute(String sql), StatementImpl.getResultSet(), and StatementImpl.getUpdateCount()",
    "details": {
        "components": [
            "SolrJ"
        ],
        "type": "Sub-task",
        "labels": "",
        "fix_versions": [],
        "affect_versions": "6.0",
        "status": "Closed",
        "resolution": "Fixed",
        "priority": "Major"
    },
    "description": "Currently only StatementImpl.executeQuery is implemented.",
    "attachments": {
        "SOLR-8514.patch": "https://issues.apache.org/jira/secure/attachment/12781239/SOLR-8514.patch"
    },
    "issue_links": {},
    "comments": [
        {
            "date": "2016-01-08T16:05:37+0000",
            "author": "Kevin Risden",
            "content": "Added initial implementation. This reuses executeQuery() and just stores the last SQL statement to come in. Solr doesn't have a way to currently execute a query and then get the results back later. ",
            "id": "comment-15089417"
        },
        {
            "date": "2016-01-15T19:23:16+0000",
            "author": "Joel Bernstein",
            "content": "Currently the way the StatementImpl works is that you can reuse it after it's been closed. This patch doesn't alllow that. I'm not sure actually what the correct behavior should be. ",
            "id": "comment-15102337"
        },
        {
            "date": "2016-01-15T19:26:11+0000",
            "author": "Kevin Risden",
            "content": "How does this patch prevent reuse? It has some additional checks to see if the statement has been closed but doesn't close the statement. If getResultSet is executed again, that will execute another query. If execute is called again with a different SQL string that will be stored and getResultSet will execute with the new SQL string. These are all OK for statement reuse. ",
            "id": "comment-15102342"
        },
        {
            "date": "2016-01-15T19:35:45+0000",
            "author": "Joel Bernstein",
            "content": "From the javadocs:\n\n\"By default, only one ResultSet object per Statement object can be open at the same time. Therefore, if the reading of one ResultSet object is interleaved with the reading of another, each must have been generated by different Statement objects. All execution methods in the Statement interface implicitly close a statment's current ResultSet object if an open one exists.\"\n\nSo, I'd like to keep on reopening the statement. I'll see if I can add the implicit close as part of this ticket as well. ",
            "id": "comment-15102357"
        },
        {
            "date": "2016-01-15T19:36:51+0000",
            "author": "Joel Bernstein",
            "content": "\n public boolean execute(String sql) throws SQLException {\n    if(isClosed()) {\n      throw new SQLException(\"Statement is closed\");\n    }\n\n    // TODO Add logic when update statements are added to JDBC.\n    this.currentSQL = sql;\n    return true;\n  }\n\n ",
            "id": "comment-15102359"
        },
        {
            "date": "2016-01-15T19:40:30+0000",
            "author": "Kevin Risden",
            "content": "Hmmm so what if we kept a reference to the current ResultSet and in execute do currentResultSet.close() before creating a new ResultSet. This would prevent interleaving of reading ResultSets and handle the closing of a ResultSet if it is currently open. ",
            "id": "comment-15102363"
        },
        {
            "date": "2016-01-15T19:42:54+0000",
            "author": "Joel Bernstein",
            "content": "Sounds like a good plan. I believe this should happen on all the execute methods. ",
            "id": "comment-15102365"
        },
        {
            "date": "2016-01-15T19:56:47+0000",
            "author": "Kevin Risden",
            "content": "Added closing of current ResultSet. Need to add some tests for this still. Going to rely on test framework from SOLR-8515. ",
            "id": "comment-15102377"
        },
        {
            "date": "2016-01-19T21:17:00+0000",
            "author": "Kevin Risden",
            "content": "Added tests. Requires SOLR-8516 be merged first. ",
            "id": "comment-15107452"
        },
        {
            "date": "2016-01-19T21:57:50+0000",
            "author": "Kevin Risden",
            "content": "Joel Bernstein This patch should apply cleanly now that SOLR-8516 was merged. It should be good to go. ",
            "id": "comment-15107538"
        },
        {
            "date": "2016-01-20T00:52:42+0000",
            "author": "Joel Bernstein",
            "content": "I' m still seeing this in the patch:\n\n\nif(isClosed()) {\n      throw new SQLException(\"Statement is closed\");\n}\n\n\n\nI believe we should pull out any of these exceptions and re-open the statement. ",
            "id": "comment-15107764"
        },
        {
            "date": "2016-01-20T02:04:33+0000",
            "author": "Joel Bernstein",
            "content": "New patch that removes the close checks and automatically closes the open SolrStream if the stmt is reused while opened.  ",
            "id": "comment-15107825"
        },
        {
            "date": "2016-01-20T02:12:31+0000",
            "author": "ASF subversion and git services",
            "content": "Commit 1725662 from Joel Bernstein in branch 'dev/trunk'\n[ https://svn.apache.org/r1725662 ]\n\nSOLR-8514, SOLR-8502: Implement StatementImpl.execute(String sql), StatementImpl.getResultSet(), and StatementImpl.getUpdateCount() ",
            "id": "comment-15107828"
        },
        {
            "date": "2016-01-20T16:03:28+0000",
            "author": "Kevin Risden",
            "content": "Joel Bernstein According to the JavaDoc for Statement (excerpts below), I think the isClosed() check needs to be there to comply with the interface.\n\nFrom the JavaDoc for Statement#executeQuery\n\n\n\t@exception SQLException if a database access error occurs,\n\tthis method is called on a closed <code>Statement</code>, the given\n\tSQL statement produces anything other than a single\n\t<code>ResultSet</code> object, the method is called on a\n\t<code>PreparedStatement</code> or <code>CallableStatement</code>\n\n\n\nFrom the JavaDoc for Statement#execute\n\n\n\t@exception SQLException if a database access error occurs,\n\tthis method is called on a closed <code>Statement</code>,\n\tthe method is called on a\n\t<code>PreparedStatement</code> or <code>CallableStatement</code>\n\n ",
            "id": "comment-15108790"
        },
        {
            "date": "2016-01-20T16:47:38+0000",
            "author": "Joel Bernstein",
            "content": "Ok,  I've been confused about how to achieve Statement reuse. I guess to reuse a statement you must leave it open. Iit will clean up resources by queitly closing any open resources from the previous result set. I'll make this change. ",
            "id": "comment-15108888"
        }
    ]
}