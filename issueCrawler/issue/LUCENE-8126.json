{
    "id": "LUCENE-8126",
    "title": "Spatial prefix tree based on S2 geometry",
    "details": {
        "labels": "",
        "priority": "Major",
        "resolution": "Fixed",
        "affect_versions": "None",
        "status": "Closed",
        "type": "New Feature",
        "components": [
            "modules/spatial-extras"
        ],
        "fix_versions": [
            "7.3",
            "master (8.0)"
        ]
    },
    "description": "Hi David Smiley,\n\nI have been working on a prefix tree based on goggle S2 geometry (https://s2geometry.io/) to be used mainly with Geo3d shapes with very promising results, in particular for complex shapes (e.g polygons). Using this pixelization scheme reduces the size of the index, improves the performance of the queries and reduces the loading time for non-point shapes. \n\nIf you are ok with this contribution and before providing any code I would like to understand what is the correct/prefered approach:\n\n1) Add new depency to the S2 library (https://mvnrepository.com/artifact/io.sgr/s2-geometry-library-java). It has Apache 2.0 license so it should be ok.\n\n2) Create a utility class with all methods necessary to navigate the S2 tree and create shapes from S2 cells (basically port what we need from the library into Lucene).\n\nWhat do you think?",
    "attachments": {
        "SPT-cell.pdf": "https://issues.apache.org/jira/secure/attachment/12910360/SPT-cell.pdf",
        "SPT-query.jpeg": "https://issues.apache.org/jira/secure/attachment/12910358/SPT-query.jpeg"
    },
    "issue_links": {},
    "comments": [
        {
            "id": "comment-16318439",
            "date": "2018-01-09T13:49:48+0000",
            "content": "Ignacio Vera, which Lucene module would have this dependency? ",
            "author": "Karl Wright"
        },
        {
            "id": "comment-16318444",
            "date": "2018-01-09T13:52:42+0000",
            "content": "module spatial-extras. I do not plan/want to add any dependency in spatial3d. ",
            "author": "Ignacio Vera"
        },
        {
            "id": "comment-16318449",
            "date": "2018-01-09T13:55:35+0000",
            "content": "Still I might want to add a new GeoShape that represents a S2 cell. It is basically a convex polygon with 4 sides and a footprint/performance similar to GeoRectangle.  ",
            "author": "Ignacio Vera"
        },
        {
            "id": "comment-16318453",
            "date": "2018-01-09T14:00:09+0000",
            "content": "Sounds reasonable. ",
            "author": "Karl Wright"
        },
        {
            "id": "comment-16319669",
            "date": "2018-01-10T04:10:12+0000",
            "content": "This sounds very interesting Ignacio!  In spatial-extras, you can add a dependency on s2.  Start that way and we can change our minds if it seems we're using a super small piece of s2.\n\nI don't completely understand what you are proposing though.  My understanding of s2 is that it's sort of a competitor/alternative to Lucene Geo3d.  But come to think of it, I do recall there was some indexing primitives in there that was apart from the surface-of-sphere shape implementations.  Ultimately, I assume we're talking about indexing interesting shapes such as polygons (and surface-of-sphere ones at that); right?  And I figure that this index technique you have in mind wouldn't replace the need to store the vector/raw implementation to check for a precise match as we're doing now with Geo3d + RPT, right?  So we're talking about a faster RPT of sorts using some techniques in s2, using it's code in fact, and of course using Lucene's terms dictionary (or do you have in mind the Points API) ?\n\nBTW have you seen this benchmark?: http://home.apache.org/~mikemccand/geobench.html  It's just point data so it's not completely apt here but thought I'd share anyway. ",
            "author": "David Smiley"
        },
        {
            "id": "comment-16320448",
            "date": "2018-01-10T15:35:37+0000",
            "content": "GitHub user iverase opened a pull request:\n\n    https://github.com/apache/lucene-solr/pull/302\n\n    LUCENE-8126:  Spatial prefix tree based on S2 geometry\n\n\n\nYou can merge this pull request into a Git repository by running:\n\n    $ git pull https://github.com/iverase/lucene-solr master\n\nAlternatively you can review and apply these changes as the patch at:\n\n    https://github.com/apache/lucene-solr/pull/302.patch\n\nTo close this pull request, make a commit to your master/trunk branch\nwith (at least) the following in the commit message:\n\n    This closes #302\n\n\ncommit ed57d35c3896c61b8e7af31bce66650800225a34\nAuthor: ivera <ivera@...>\nDate:   2018-01-10T15:29:40Z\n\n    LUCENE-8126: first commit of S2 RPT\n\ncommit 9d00f003a0c980ca9eccaff8d4b2e9eebf1e77e2\nAuthor: ivera <ivera@...>\nDate:   2018-01-10T15:31:39Z\n\n    LUCENE-8126: first commit of S2 RPT\n\ncommit 6aa0199f07f7c8e23be8ff550fc3fd0aefc5554a\nAuthor: ivera <ivera@...>\nDate:   2018-01-10T15:33:36Z\n\n    LUCENE-8126: Performance test classes. They are included to show the increae of performance using the new RPT.\n\n ",
            "author": "ASF GitHub Bot"
        },
        {
            "id": "comment-16320485",
            "date": "2018-01-10T15:55:05+0000",
            "content": "Hi David Smiley,\n\nI created a pull request that hopefully clarifies most of your questions. I am interested in how S2 geometry pixelates the sphere, using polygons instead of coordinate ranges.  ",
            "author": "Ignacio Vera"
        },
        {
            "id": "comment-16320909",
            "date": "2018-01-10T19:22:34+0000",
            "content": "Github user dsmiley commented on a diff in the pull request:\n\n    https://github.com/apache/lucene-solr/pull/302#discussion_r160766117\n\n    \u2014 Diff: lucene/spatial-extras/src/java/org/apache/lucene/spatial/prefix/tree/S2PrefixTreeCell.java \u2014\n    @@ -0,0 +1,285 @@\n    +/*\n    + * Licensed to the Apache Software Foundation (ASF) under one or more\n    + * contributor license agreements.  See the NOTICE file distributed with\n    + * this work for additional information regarding copyright ownership.\n    + * The ASF licenses this file to You under the Apache License, Version 2.0\n    + * (the \"License\"); you may not use this file except in compliance with\n    + * the License.  You may obtain a copy of the License at\n    + *\n    + *     http://www.apache.org/licenses/LICENSE-2.0\n    + *\n    + * Unless required by applicable law or agreed to in writing, software\n    + * distributed under the License is distributed on an \"AS IS\" BASIS,\n    + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    + * See the License for the specific language governing permissions and\n    + * limitations under the License.\n    + */\n    +\n    +package org.apache.lucene.spatial.prefix.tree;\n    +\n    +import java.util.ArrayList;\n    +import java.util.HashMap;\n    +import java.util.List;\n    +import java.util.Map;\n    +\n    +import com.google.common.geometry.S2CellId;\n    +import org.apache.lucene.util.BytesRef;\n    +import org.locationtech.spatial4j.shape.Shape;\n    +import org.locationtech.spatial4j.shape.SpatialRelation;\n    +\n    +/**\n    + * This class represents a S2 pixel in the RPT.\n    + *\n    + * @lucene.internal\n    + */\n    +class S2PrefixTreeCell implements Cell {\n    +\n    +    //Faces of S2 Geometry\n    +    private static S2CellId[] FACES = new S2CellId[6];\n    +    static \n{\n    +        FACES[0] = S2CellId.fromFacePosLevel(0, 0, 0);\n    +        FACES[1] = S2CellId.fromFacePosLevel(1, 0, 0);\n    +        FACES[2] = S2CellId.fromFacePosLevel(2, 0, 0);\n    +        FACES[3] = S2CellId.fromFacePosLevel(3, 0, 0);\n    +        FACES[4] = S2CellId.fromFacePosLevel(4, 0, 0);\n    +        FACES[5] = S2CellId.fromFacePosLevel(5, 0, 0);\n    +    }\n    +\n    +    /Special character to define a cell leaf/\n    +    private static final byte LEAF = '+';\n    +\n    +    /Tokens are used to serialize cells/\n    +    private static final byte[] TOKENS;\n    +    /Map containing mapping between tokens and integer values/\n    +    private static final Map<Byte,Integer> PIXELS;\n    +    static {\n    +        TOKENS = new byte[]\n{'0', '1', '2', '3', '4', '5'}\n;\n    +        PIXELS = new HashMap<>(6);\n    +        PIXELS.put(TOKENS[0], 0);\n    +        PIXELS.put(TOKENS[1], 1);\n    +        PIXELS.put(TOKENS[2], 2);\n    +        PIXELS.put(TOKENS[3], 3);\n    +        PIXELS.put(TOKENS[4], 4);\n    +        PIXELS.put(TOKENS[5], 5);\n    +    }\n    +\n    +    S2CellId cellId;\n    +    int level; //cache level\n    +    S2PrefixTree tree;\n    +\n    +    SpatialRelation shapeRel= null;\n    +    boolean isLeaf;\n    +    Shape shape = null;\n    +\n    +    S2PrefixTreeCell(S2PrefixTree tree, S2CellId cellId){\n    +        this.cellId= cellId;\n    +        this.tree = tree;\n    +        setLevel();\n    +        if (getLevel() == tree.getMaxLevels()) \n{\n    +            setLeaf();\n    +        }\n    +    }\n    +\n    +    void readCell(S2PrefixTree tree, BytesRef ref){\n    +        isLeaf = false;\n    +        shape = null;\n    +        shapeRel = null;\n    +        this.tree = tree;\n    +        cellId = getS2CellIdFromBytesRef(ref);\n    +        setLevel();\n    +        if (isLeaf(ref) || getLevel() == tree.getMaxLevels()){    +            setLeaf();    +        }\n    +    }\n    +\n    +    @Override\n    +    public SpatialRelation getShapeRel() \n{\n    +        return shapeRel;\n    +    }\n    +\n    +    @Override\n    +    public void setShapeRel(SpatialRelation rel) \n{\n    +        shapeRel = rel;\n    +    }\n    +\n    +    @Override\n    +    public boolean isLeaf() \n{\n    +        return isLeaf;\n    +    }\n    +\n    +    @Override\n    +    public void setLeaf() \n{\n    +        isLeaf = true;\n    +    }\n    +\n    +    @Override\n    +    public BytesRef getTokenBytesWithLeaf(BytesRef result) {\n    +        result = getTokenBytesNoLeaf(result);\n    +        //max levels do not have leaf\n    +        if (isLeaf() && !(getLevel() == tree.getMaxLevels()))\n{\n    +            //Add leaf byte\n    +            result.bytes[result.offset + result.length] = LEAF;\n    +            result.length++;\n    +        }\n    +        return result;\n    +    }\n    +\n    +    @Override\n    +    public BytesRef getTokenBytesNoLeaf(BytesRef result) {\n    +        if (result == null)\n{\n    +            result = new BytesRef();\n    +        }\n    +        getBytesRefFromS2CellId(cellId, result);\n    +        return result;\n    +    }\n    +\n    +    @Override\n    +    public int getLevel() \n{\n    +        return this.level;\n    +    }\n    +\n    +    /**\n    +     * Cache level of cell.\n    +     */\n    +    private void setLevel() {\n    +        if (this.cellId == null) \n{\n    +            this.level = 0;\n    +        }\n    +        else \n{\n    +            this.level = this.cellId.level() + 1;\n    +        }\n    +    }\n    +\n    +    @Override\n    +    public CellIterator getNextLevelCells(Shape shapeFilter) {\n    +        S2CellId[] children;\n    +        if (cellId == null)\n{ // this is the world cell\n    +            children =  FACES;\n    +        }\n    +        else \n{\n    +            children = new S2CellId[4];\n    +            children[0] = cellId.childBegin();\n    +            children[1] = children[0].next();\n    +            children[2] = children[1].next();\n    +            children[3] = children[2].next();\n    +        }\n    +        List<Cell> cells = new ArrayList<>(children.length);\n    +        for (S2CellId pixel : children) \n{\n    +            cells.add(new S2PrefixTreeCell(tree, pixel));\n    +        }\n    +        return new FilterCellIterator(cells.iterator(), shapeFilter);\n    +    }\n    +\n    +    @Override\n    +    public Shape getShape(){\n    +        if (shape==null){\n    +            if (cellId == null) \n{ //World cell\n    +                return tree.getSpatialContext().getWorldBounds();\n    +            }\n    +            return tree.s2ShapeFactory.getS2CellShape(cellId);\n    \u2014 End diff \u2013\n\n    I think you meant to cache to this.shape instead? ",
            "author": "ASF GitHub Bot"
        },
        {
            "id": "comment-16320910",
            "date": "2018-01-10T19:22:34+0000",
            "content": "Github user dsmiley commented on a diff in the pull request:\n\n    https://github.com/apache/lucene-solr/pull/302#discussion_r160768230\n\n    \u2014 Diff: lucene/spatial-extras/src/java/org/apache/lucene/spatial/prefix/tree/S2PrefixTree.java \u2014\n    @@ -0,0 +1,111 @@\n    +/*\n    + * Licensed to the Apache Software Foundation (ASF) under one or more\n    + * contributor license agreements.  See the NOTICE file distributed with\n    + * this work for additional information regarding copyright ownership.\n    + * The ASF licenses this file to You under the Apache License, Version 2.0\n    + * (the \"License\"); you may not use this file except in compliance with\n    + * the License.  You may obtain a copy of the License at\n    + *\n    + *     http://www.apache.org/licenses/LICENSE-2.0\n    + *\n    + * Unless required by applicable law or agreed to in writing, software\n    + * distributed under the License is distributed on an \"AS IS\" BASIS,\n    + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    + * See the License for the specific language governing permissions and\n    + * limitations under the License.\n    + */\n    +\n    +package org.apache.lucene.spatial.prefix.tree;\n    +\n    +import java.util.ArrayList;\n    +import java.util.List;\n    +\n    +import com.google.common.geometry.S2CellId;\n    +import com.google.common.geometry.S2LatLng;\n    +import com.google.common.geometry.S2Projections;\n    +import org.apache.lucene.util.BytesRef;\n    +import org.locationtech.spatial4j.context.SpatialContext;\n    +import org.locationtech.spatial4j.distance.DistanceUtils;\n    +import org.locationtech.spatial4j.shape.Point;\n    +import org.locationtech.spatial4j.shape.Shape;\n    +\n    +/**\n    + * Spatial prefix tree for S2 Geometry. Shape factories for the given \n{@link SpatialContext}\n must\n    + * implement the interface \n{@link S2ShapeFactory}\n.\n    + *\n    + * @lucene.experimental\n    + */\n    +public class S2PrefixTree extends SpatialPrefixTree {\n    +\n    +    /**\n    +     * Factory for creating \n{@link S2PrefixTree}\n instances with useful defaults\n    +     */\n    +    public static class Factory extends SpatialPrefixTreeFactory {\n    +\n    +        @Override\n    +        protected int getLevelForDistance(double degrees) \n{\n    +            S2PrefixTree grid = new S2PrefixTree(ctx, S2PrefixTree.MAX_LEVELS);\n    +            return grid.getLevelForDistance(degrees);\n    +        }\n    +\n    +        @Override\n    +        protected SpatialPrefixTree newSPT() \n{\n    +            return new S2PrefixTree(ctx,\n    +                maxLevels != null ? maxLevels : S2PrefixTree.MAX_LEVELS);\n    +        }\n    +    }\n    +\n    +    //factory to generate S2 cell shapes\n    +    protected final S2ShapeFactory s2ShapeFactory;\n    +    public static final int MAX_LEVELS = S2CellId.MAX_LEVEL + 1;\n    +\n    +    public S2PrefixTree(SpatialContext ctx, int maxLevels) {\n    +        super(ctx, maxLevels);\n    +        if (!(ctx.getShapeFactory() instanceof S2ShapeFactory)) \n{\n    +            throw new IllegalArgumentException(\"Spatial context does not support S2 spatial index.\");\n    +        }\n    +        this.s2ShapeFactory = (S2ShapeFactory) ctx.getShapeFactory();\n    +    }\n    +\n    +    @Override\n    +    public int getLevelForDistance(double dist) {\n    +        if (dist ==0)\n{\n    +            return maxLevels;\n    +        }\n    +        return Math.min(maxLevels, S2Projections.MAX_WIDTH.getClosestLevel(dist * DistanceUtils.DEGREES_TO_RADIANS) +1);\n    +    }\n    +\n    +    @Override\n    +    public double getDistanceForLevel(int level) \n{\n    +        return S2Projections.MAX_WIDTH.getValue(level -1) * DistanceUtils.RADIANS_TO_DEGREES;\n    +    }\n    +\n    +    @Override\n    +    public Cell getWorldCell() \n{\n    +        return  new S2PrefixTreeCell(this, null);\n    +    }\n    +\n    +    @Override\n    +    public Cell readCell(BytesRef term, Cell scratch) {\n    +        S2PrefixTreeCell cell = (S2PrefixTreeCell) scratch;\n    +        if (cell == null)\n    +            cell = (S2PrefixTreeCell) getWorldCell();\n    \u2014 End diff \u2013\n\n    nitpick: our code style in Lucene/Solr is to always use braces ",
            "author": "ASF GitHub Bot"
        },
        {
            "id": "comment-16320911",
            "date": "2018-01-10T19:22:34+0000",
            "content": "Github user dsmiley commented on a diff in the pull request:\n\n    https://github.com/apache/lucene-solr/pull/302#discussion_r160766597\n\n    \u2014 Diff: lucene/spatial-extras/src/java/org/apache/lucene/spatial/prefix/tree/S2PrefixTreeCell.java \u2014\n    @@ -0,0 +1,285 @@\n    +/*\n    + * Licensed to the Apache Software Foundation (ASF) under one or more\n    + * contributor license agreements.  See the NOTICE file distributed with\n    + * this work for additional information regarding copyright ownership.\n    + * The ASF licenses this file to You under the Apache License, Version 2.0\n    + * (the \"License\"); you may not use this file except in compliance with\n    + * the License.  You may obtain a copy of the License at\n    + *\n    + *     http://www.apache.org/licenses/LICENSE-2.0\n    + *\n    + * Unless required by applicable law or agreed to in writing, software\n    + * distributed under the License is distributed on an \"AS IS\" BASIS,\n    + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    + * See the License for the specific language governing permissions and\n    + * limitations under the License.\n    + */\n    +\n    +package org.apache.lucene.spatial.prefix.tree;\n    +\n    +import java.util.ArrayList;\n    +import java.util.HashMap;\n    +import java.util.List;\n    +import java.util.Map;\n    +\n    +import com.google.common.geometry.S2CellId;\n    +import org.apache.lucene.util.BytesRef;\n    +import org.locationtech.spatial4j.shape.Shape;\n    +import org.locationtech.spatial4j.shape.SpatialRelation;\n    +\n    +/**\n    + * This class represents a S2 pixel in the RPT.\n    + *\n    + * @lucene.internal\n    + */\n    +class S2PrefixTreeCell implements Cell {\n    +\n    +    //Faces of S2 Geometry\n    +    private static S2CellId[] FACES = new S2CellId[6];\n    +    static \n{\n    +        FACES[0] = S2CellId.fromFacePosLevel(0, 0, 0);\n    +        FACES[1] = S2CellId.fromFacePosLevel(1, 0, 0);\n    +        FACES[2] = S2CellId.fromFacePosLevel(2, 0, 0);\n    +        FACES[3] = S2CellId.fromFacePosLevel(3, 0, 0);\n    +        FACES[4] = S2CellId.fromFacePosLevel(4, 0, 0);\n    +        FACES[5] = S2CellId.fromFacePosLevel(5, 0, 0);\n    +    }\n    +\n    +    /Special character to define a cell leaf/\n    +    private static final byte LEAF = '+';\n    +\n    +    /Tokens are used to serialize cells/\n    +    private static final byte[] TOKENS;\n    +    /Map containing mapping between tokens and integer values/\n    +    private static final Map<Byte,Integer> PIXELS;\n    +    static {\n    +        TOKENS = new byte[]\n{'0', '1', '2', '3', '4', '5'}\n;\n    +        PIXELS = new HashMap<>(6);\n    +        PIXELS.put(TOKENS[0], 0);\n    +        PIXELS.put(TOKENS[1], 1);\n    +        PIXELS.put(TOKENS[2], 2);\n    +        PIXELS.put(TOKENS[3], 3);\n    +        PIXELS.put(TOKENS[4], 4);\n    +        PIXELS.put(TOKENS[5], 5);\n    +    }\n    +\n    +    S2CellId cellId;\n    +    int level; //cache level\n    +    S2PrefixTree tree;\n    +\n    +    SpatialRelation shapeRel= null;\n    +    boolean isLeaf;\n    +    Shape shape = null;\n    +\n    +    S2PrefixTreeCell(S2PrefixTree tree, S2CellId cellId){\n    +        this.cellId= cellId;\n    +        this.tree = tree;\n    +        setLevel();\n    +        if (getLevel() == tree.getMaxLevels()) \n{\n    +            setLeaf();\n    +        }\n    +    }\n    +\n    +    void readCell(S2PrefixTree tree, BytesRef ref){\n    +        isLeaf = false;\n    +        shape = null;\n    +        shapeRel = null;\n    +        this.tree = tree;\n    +        cellId = getS2CellIdFromBytesRef(ref);\n    +        setLevel();\n    +        if (isLeaf(ref) || getLevel() == tree.getMaxLevels()){    +            setLeaf();    +        }\n    +    }\n    +\n    +    @Override\n    +    public SpatialRelation getShapeRel() \n{\n    +        return shapeRel;\n    +    }\n    +\n    +    @Override\n    +    public void setShapeRel(SpatialRelation rel) \n{\n    +        shapeRel = rel;\n    +    }\n    +\n    +    @Override\n    +    public boolean isLeaf() \n{\n    +        return isLeaf;\n    +    }\n    +\n    +    @Override\n    +    public void setLeaf() \n{\n    +        isLeaf = true;\n    +    }\n    +\n    +    @Override\n    +    public BytesRef getTokenBytesWithLeaf(BytesRef result) {\n    +        result = getTokenBytesNoLeaf(result);\n    +        //max levels do not have leaf\n    +        if (isLeaf() && !(getLevel() == tree.getMaxLevels()))\n{\n    +            //Add leaf byte\n    +            result.bytes[result.offset + result.length] = LEAF;\n    +            result.length++;\n    +        }\n    +        return result;\n    +    }\n    +\n    +    @Override\n    +    public BytesRef getTokenBytesNoLeaf(BytesRef result) {\n    +        if (result == null)\n{\n    +            result = new BytesRef();\n    +        }\n    +        getBytesRefFromS2CellId(cellId, result);\n    +        return result;\n    +    }\n    +\n    +    @Override\n    +    public int getLevel() \n{\n    +        return this.level;\n    +    }\n    +\n    +    /**\n    +     * Cache level of cell.\n    +     */\n    +    private void setLevel() {\n    \u2014 End diff \u2013\n\n    it'd be simpler of getLevel had this logic.... is the s2's cellId.level() not trivially fast and so you want to effectively cache it? ",
            "author": "ASF GitHub Bot"
        },
        {
            "id": "comment-16320912",
            "date": "2018-01-10T19:22:34+0000",
            "content": "Github user dsmiley commented on a diff in the pull request:\n\n    https://github.com/apache/lucene-solr/pull/302#discussion_r160768053\n\n    \u2014 Diff: lucene/spatial-extras/src/java/org/apache/lucene/spatial/prefix/tree/S2PrefixTreeCell.java \u2014\n    @@ -0,0 +1,285 @@\n    +/*\n    + * Licensed to the Apache Software Foundation (ASF) under one or more\n    + * contributor license agreements.  See the NOTICE file distributed with\n    + * this work for additional information regarding copyright ownership.\n    + * The ASF licenses this file to You under the Apache License, Version 2.0\n    + * (the \"License\"); you may not use this file except in compliance with\n    + * the License.  You may obtain a copy of the License at\n    + *\n    + *     http://www.apache.org/licenses/LICENSE-2.0\n    + *\n    + * Unless required by applicable law or agreed to in writing, software\n    + * distributed under the License is distributed on an \"AS IS\" BASIS,\n    + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    + * See the License for the specific language governing permissions and\n    + * limitations under the License.\n    + */\n    +\n    +package org.apache.lucene.spatial.prefix.tree;\n    +\n    +import java.util.ArrayList;\n    +import java.util.HashMap;\n    +import java.util.List;\n    +import java.util.Map;\n    +\n    +import com.google.common.geometry.S2CellId;\n    +import org.apache.lucene.util.BytesRef;\n    +import org.locationtech.spatial4j.shape.Shape;\n    +import org.locationtech.spatial4j.shape.SpatialRelation;\n    +\n    +/**\n    + * This class represents a S2 pixel in the RPT.\n    + *\n    + * @lucene.internal\n    + */\n    +class S2PrefixTreeCell implements Cell {\n    +\n    +    //Faces of S2 Geometry\n    +    private static S2CellId[] FACES = new S2CellId[6];\n    +    static \n{\n    +        FACES[0] = S2CellId.fromFacePosLevel(0, 0, 0);\n    +        FACES[1] = S2CellId.fromFacePosLevel(1, 0, 0);\n    +        FACES[2] = S2CellId.fromFacePosLevel(2, 0, 0);\n    +        FACES[3] = S2CellId.fromFacePosLevel(3, 0, 0);\n    +        FACES[4] = S2CellId.fromFacePosLevel(4, 0, 0);\n    +        FACES[5] = S2CellId.fromFacePosLevel(5, 0, 0);\n    +    }\n    +\n    +    /Special character to define a cell leaf/\n    +    private static final byte LEAF = '+';\n    +\n    +    /Tokens are used to serialize cells/\n    +    private static final byte[] TOKENS;\n    +    /Map containing mapping between tokens and integer values/\n    +    private static final Map<Byte,Integer> PIXELS;\n    \u2014 End diff \u2013\n\n    Since this map has a small set of fixed values that have numeric equivalents, perhaps we can do direct addressing into an array? ",
            "author": "ASF GitHub Bot"
        },
        {
            "id": "comment-16320913",
            "date": "2018-01-10T19:22:34+0000",
            "content": "Github user dsmiley commented on a diff in the pull request:\n\n    https://github.com/apache/lucene-solr/pull/302#discussion_r160768405\n\n    \u2014 Diff: lucene/spatial-extras/src/java/org/apache/lucene/spatial/prefix/tree/S2PrefixTreeCell.java \u2014\n    @@ -0,0 +1,285 @@\n    +/*\n    + * Licensed to the Apache Software Foundation (ASF) under one or more\n    + * contributor license agreements.  See the NOTICE file distributed with\n    + * this work for additional information regarding copyright ownership.\n    + * The ASF licenses this file to You under the Apache License, Version 2.0\n    + * (the \"License\"); you may not use this file except in compliance with\n    + * the License.  You may obtain a copy of the License at\n    + *\n    + *     http://www.apache.org/licenses/LICENSE-2.0\n    + *\n    + * Unless required by applicable law or agreed to in writing, software\n    + * distributed under the License is distributed on an \"AS IS\" BASIS,\n    + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    + * See the License for the specific language governing permissions and\n    + * limitations under the License.\n    + */\n    +\n    +package org.apache.lucene.spatial.prefix.tree;\n    +\n    +import java.util.ArrayList;\n    +import java.util.HashMap;\n    +import java.util.List;\n    +import java.util.Map;\n    +\n    +import com.google.common.geometry.S2CellId;\n    +import org.apache.lucene.util.BytesRef;\n    +import org.locationtech.spatial4j.shape.Shape;\n    +import org.locationtech.spatial4j.shape.SpatialRelation;\n    +\n    +/**\n    + * This class represents a S2 pixel in the RPT.\n    + *\n    + * @lucene.internal\n    + */\n    +class S2PrefixTreeCell implements Cell {\n    +\n    +    //Faces of S2 Geometry\n    +    private static S2CellId[] FACES = new S2CellId[6];\n    +    static \n{\n    +        FACES[0] = S2CellId.fromFacePosLevel(0, 0, 0);\n    +        FACES[1] = S2CellId.fromFacePosLevel(1, 0, 0);\n    +        FACES[2] = S2CellId.fromFacePosLevel(2, 0, 0);\n    +        FACES[3] = S2CellId.fromFacePosLevel(3, 0, 0);\n    +        FACES[4] = S2CellId.fromFacePosLevel(4, 0, 0);\n    +        FACES[5] = S2CellId.fromFacePosLevel(5, 0, 0);\n    +    }\n    +\n    +    /Special character to define a cell leaf/\n    +    private static final byte LEAF = '+';\n    +\n    +    /Tokens are used to serialize cells/\n    +    private static final byte[] TOKENS;\n    +    /Map containing mapping between tokens and integer values/\n    +    private static final Map<Byte,Integer> PIXELS;\n    +    static {\n    +        TOKENS = new byte[]\n{'0', '1', '2', '3', '4', '5'}\n;\n    +        PIXELS = new HashMap<>(6);\n    +        PIXELS.put(TOKENS[0], 0);\n    +        PIXELS.put(TOKENS[1], 1);\n    +        PIXELS.put(TOKENS[2], 2);\n    +        PIXELS.put(TOKENS[3], 3);\n    +        PIXELS.put(TOKENS[4], 4);\n    +        PIXELS.put(TOKENS[5], 5);\n    +    }\n    +\n    +    S2CellId cellId;\n    +    int level; //cache level\n    +    S2PrefixTree tree;\n    +\n    +    SpatialRelation shapeRel= null;\n    +    boolean isLeaf;\n    +    Shape shape = null;\n    +\n    +    S2PrefixTreeCell(S2PrefixTree tree, S2CellId cellId){\n    +        this.cellId= cellId;\n    +        this.tree = tree;\n    +        setLevel();\n    +        if (getLevel() == tree.getMaxLevels()) \n{\n    +            setLeaf();\n    +        }\n    +    }\n    +\n    +    void readCell(S2PrefixTree tree, BytesRef ref){\n    +        isLeaf = false;\n    +        shape = null;\n    +        shapeRel = null;\n    +        this.tree = tree;\n    +        cellId = getS2CellIdFromBytesRef(ref);\n    +        setLevel();\n    +        if (isLeaf(ref) || getLevel() == tree.getMaxLevels()){    +            setLeaf();    +        }\n    +    }\n    +\n    +    @Override\n    +    public SpatialRelation getShapeRel() \n{\n    +        return shapeRel;\n    +    }\n    +\n    +    @Override\n    +    public void setShapeRel(SpatialRelation rel) \n{\n    +        shapeRel = rel;\n    +    }\n    +\n    +    @Override\n    +    public boolean isLeaf() \n{\n    +        return isLeaf;\n    +    }\n    +\n    +    @Override\n    +    public void setLeaf() \n{\n    +        isLeaf = true;\n    +    }\n    +\n    +    @Override\n    +    public BytesRef getTokenBytesWithLeaf(BytesRef result) {\n    +        result = getTokenBytesNoLeaf(result);\n    +        //max levels do not have leaf\n    +        if (isLeaf() && !(getLevel() == tree.getMaxLevels()))\n{\n    +            //Add leaf byte\n    +            result.bytes[result.offset + result.length] = LEAF;\n    +            result.length++;\n    +        }\n    +        return result;\n    +    }\n    +\n    +    @Override\n    +    public BytesRef getTokenBytesNoLeaf(BytesRef result) {\n    +        if (result == null)\n{\n    +            result = new BytesRef();\n    +        }\n    +        getBytesRefFromS2CellId(cellId, result);\n    +        return result;\n    +    }\n    +\n    +    @Override\n    +    public int getLevel() \n{\n    +        return this.level;\n    +    }\n    +\n    +    /**\n    +     * Cache level of cell.\n    +     */\n    +    private void setLevel() {\n    +        if (this.cellId == null) \n{\n    +            this.level = 0;\n    +        }\n    +        else \n{\n    +            this.level = this.cellId.level() + 1;\n    +        }\n    +    }\n    +\n    +    @Override\n    +    public CellIterator getNextLevelCells(Shape shapeFilter) {\n    +        S2CellId[] children;\n    +        if (cellId == null)\n{ // this is the world cell\n    +            children =  FACES;\n    +        }\n    +        else {\n    \u2014 End diff \u2013\n\n    nitpick: our code style in Lucene/Solr is for an else statement to be on the same line as the previous closing brace ",
            "author": "ASF GitHub Bot"
        },
        {
            "id": "comment-16320914",
            "date": "2018-01-10T19:22:34+0000",
            "content": "Github user dsmiley commented on a diff in the pull request:\n\n    https://github.com/apache/lucene-solr/pull/302#discussion_r160773175\n\n    \u2014 Diff: lucene/spatial-extras/src/java/org/apache/lucene/spatial/prefix/tree/S2PrefixTree.java \u2014\n    @@ -0,0 +1,111 @@\n    +/*\n    + * Licensed to the Apache Software Foundation (ASF) under one or more\n    + * contributor license agreements.  See the NOTICE file distributed with\n    + * this work for additional information regarding copyright ownership.\n    + * The ASF licenses this file to You under the Apache License, Version 2.0\n    + * (the \"License\"); you may not use this file except in compliance with\n    + * the License.  You may obtain a copy of the License at\n    + *\n    + *     http://www.apache.org/licenses/LICENSE-2.0\n    + *\n    + * Unless required by applicable law or agreed to in writing, software\n    + * distributed under the License is distributed on an \"AS IS\" BASIS,\n    + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    + * See the License for the specific language governing permissions and\n    + * limitations under the License.\n    + */\n    +\n    +package org.apache.lucene.spatial.prefix.tree;\n    +\n    +import java.util.ArrayList;\n    +import java.util.List;\n    +\n    +import com.google.common.geometry.S2CellId;\n    +import com.google.common.geometry.S2LatLng;\n    +import com.google.common.geometry.S2Projections;\n    +import org.apache.lucene.util.BytesRef;\n    +import org.locationtech.spatial4j.context.SpatialContext;\n    +import org.locationtech.spatial4j.distance.DistanceUtils;\n    +import org.locationtech.spatial4j.shape.Point;\n    +import org.locationtech.spatial4j.shape.Shape;\n    +\n    +/**\n    + * Spatial prefix tree for S2 Geometry. Shape factories for the given \n{@link SpatialContext}\n must\n    + * implement the interface \n{@link S2ShapeFactory}\n.\n    + *\n    + * @lucene.experimental\n    + */\n    +public class S2PrefixTree extends SpatialPrefixTree {\n    +\n    +    /**\n    +     * Factory for creating \n{@link S2PrefixTree}\n instances with useful defaults\n    +     */\n    +    public static class Factory extends SpatialPrefixTreeFactory {\n    +\n    +        @Override\n    +        protected int getLevelForDistance(double degrees) \n{\n    +            S2PrefixTree grid = new S2PrefixTree(ctx, S2PrefixTree.MAX_LEVELS);\n    +            return grid.getLevelForDistance(degrees);\n    +        }\n    +\n    +        @Override\n    +        protected SpatialPrefixTree newSPT() \n{\n    +            return new S2PrefixTree(ctx,\n    +                maxLevels != null ? maxLevels : S2PrefixTree.MAX_LEVELS);\n    +        }\n    +    }\n    +\n    +    //factory to generate S2 cell shapes\n    +    protected final S2ShapeFactory s2ShapeFactory;\n    +    public static final int MAX_LEVELS = S2CellId.MAX_LEVEL + 1;\n    +\n    +    public S2PrefixTree(SpatialContext ctx, int maxLevels) {\n    +        super(ctx, maxLevels);\n    +        if (!(ctx.getShapeFactory() instanceof S2ShapeFactory)) \n{\n    +            throw new IllegalArgumentException(\"Spatial context does not support S2 spatial index.\");\n    +        }\n    +        this.s2ShapeFactory = (S2ShapeFactory) ctx.getShapeFactory();\n    +    }\n    +\n    +    @Override\n    +    public int getLevelForDistance(double dist) {\n    +        if (dist ==0)\n{\n    +            return maxLevels;\n    +        }\n    +        return Math.min(maxLevels, S2Projections.MAX_WIDTH.getClosestLevel(dist * DistanceUtils.DEGREES_TO_RADIANS) +1);\n    +    }\n    +\n    +    @Override\n    +    public double getDistanceForLevel(int level) {\n    +        return S2Projections.MAX_WIDTH.getValue(level -1) * DistanceUtils.RADIANS_TO_DEGREES;\n    \u2014 End diff \u2013\n\n    nitpick: put space after that minus operator ",
            "author": "ASF GitHub Bot"
        },
        {
            "id": "comment-16320915",
            "date": "2018-01-10T19:22:34+0000",
            "content": "Github user dsmiley commented on a diff in the pull request:\n\n    https://github.com/apache/lucene-solr/pull/302#discussion_r160769274\n\n    \u2014 Diff: lucene/spatial-extras/src/java/org/apache/lucene/spatial/prefix/tree/S2PrefixTreeCell.java \u2014\n    @@ -0,0 +1,285 @@\n    +/*\n    + * Licensed to the Apache Software Foundation (ASF) under one or more\n    + * contributor license agreements.  See the NOTICE file distributed with\n    + * this work for additional information regarding copyright ownership.\n    + * The ASF licenses this file to You under the Apache License, Version 2.0\n    + * (the \"License\"); you may not use this file except in compliance with\n    + * the License.  You may obtain a copy of the License at\n    + *\n    + *     http://www.apache.org/licenses/LICENSE-2.0\n    + *\n    + * Unless required by applicable law or agreed to in writing, software\n    + * distributed under the License is distributed on an \"AS IS\" BASIS,\n    + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    + * See the License for the specific language governing permissions and\n    + * limitations under the License.\n    + */\n    +\n    +package org.apache.lucene.spatial.prefix.tree;\n    +\n    +import java.util.ArrayList;\n    +import java.util.HashMap;\n    +import java.util.List;\n    +import java.util.Map;\n    +\n    +import com.google.common.geometry.S2CellId;\n    +import org.apache.lucene.util.BytesRef;\n    +import org.locationtech.spatial4j.shape.Shape;\n    +import org.locationtech.spatial4j.shape.SpatialRelation;\n    +\n    +/**\n    + * This class represents a S2 pixel in the RPT.\n    + *\n    + * @lucene.internal\n    + */\n    +class S2PrefixTreeCell implements Cell {\n    +\n    +    //Faces of S2 Geometry\n    +    private static S2CellId[] FACES = new S2CellId[6];\n    +    static \n{\n    +        FACES[0] = S2CellId.fromFacePosLevel(0, 0, 0);\n    +        FACES[1] = S2CellId.fromFacePosLevel(1, 0, 0);\n    +        FACES[2] = S2CellId.fromFacePosLevel(2, 0, 0);\n    +        FACES[3] = S2CellId.fromFacePosLevel(3, 0, 0);\n    +        FACES[4] = S2CellId.fromFacePosLevel(4, 0, 0);\n    +        FACES[5] = S2CellId.fromFacePosLevel(5, 0, 0);\n    +    }\n    +\n    +    /Special character to define a cell leaf/\n    +    private static final byte LEAF = '+';\n    +\n    +    /Tokens are used to serialize cells/\n    +    private static final byte[] TOKENS;\n    +    /Map containing mapping between tokens and integer values/\n    +    private static final Map<Byte,Integer> PIXELS;\n    +    static {\n    +        TOKENS = new byte[]\n{'0', '1', '2', '3', '4', '5'}\n;\n    +        PIXELS = new HashMap<>(6);\n    +        PIXELS.put(TOKENS[0], 0);\n    +        PIXELS.put(TOKENS[1], 1);\n    +        PIXELS.put(TOKENS[2], 2);\n    +        PIXELS.put(TOKENS[3], 3);\n    +        PIXELS.put(TOKENS[4], 4);\n    +        PIXELS.put(TOKENS[5], 5);\n    +    }\n    +\n    +    S2CellId cellId;\n    +    int level; //cache level\n    +    S2PrefixTree tree;\n    +\n    +    SpatialRelation shapeRel= null;\n    +    boolean isLeaf;\n    +    Shape shape = null;\n    +\n    +    S2PrefixTreeCell(S2PrefixTree tree, S2CellId cellId){\n    +        this.cellId= cellId;\n    +        this.tree = tree;\n    +        setLevel();\n    +        if (getLevel() == tree.getMaxLevels()) \n{\n    +            setLeaf();\n    +        }\n    +    }\n    +\n    +    void readCell(S2PrefixTree tree, BytesRef ref){\n    +        isLeaf = false;\n    +        shape = null;\n    +        shapeRel = null;\n    +        this.tree = tree;\n    +        cellId = getS2CellIdFromBytesRef(ref);\n    +        setLevel();\n    +        if (isLeaf(ref) || getLevel() == tree.getMaxLevels()){    +            setLeaf();    +        }\n    +    }\n    +\n    +    @Override\n    +    public SpatialRelation getShapeRel() \n{\n    +        return shapeRel;\n    +    }\n    +\n    +    @Override\n    +    public void setShapeRel(SpatialRelation rel) \n{\n    +        shapeRel = rel;\n    +    }\n    +\n    +    @Override\n    +    public boolean isLeaf() \n{\n    +        return isLeaf;\n    +    }\n    +\n    +    @Override\n    +    public void setLeaf() \n{\n    +        isLeaf = true;\n    +    }\n    +\n    +    @Override\n    +    public BytesRef getTokenBytesWithLeaf(BytesRef result) {\n    +        result = getTokenBytesNoLeaf(result);\n    +        //max levels do not have leaf\n    +        if (isLeaf() && !(getLevel() == tree.getMaxLevels()))\n{\n    +            //Add leaf byte\n    +            result.bytes[result.offset + result.length] = LEAF;\n    +            result.length++;\n    +        }\n    +        return result;\n    +    }\n    +\n    +    @Override\n    +    public BytesRef getTokenBytesNoLeaf(BytesRef result) {\n    +        if (result == null)\n{\n    +            result = new BytesRef();\n    +        }\n    +        getBytesRefFromS2CellId(cellId, result);\n    +        return result;\n    +    }\n    +\n    +    @Override\n    +    public int getLevel() \n{\n    +        return this.level;\n    +    }\n    +\n    +    /**\n    +     * Cache level of cell.\n    +     */\n    +    private void setLevel() {\n    +        if (this.cellId == null) \n{\n    +            this.level = 0;\n    +        }\n    +        else \n{\n    +            this.level = this.cellId.level() + 1;\n    +        }\n    +    }\n    +\n    +    @Override\n    +    public CellIterator getNextLevelCells(Shape shapeFilter) {\n    +        S2CellId[] children;\n    +        if (cellId == null)\n{ // this is the world cell\n    +            children =  FACES;\n    +        }\n    +        else \n{\n    +            children = new S2CellId[4];\n    +            children[0] = cellId.childBegin();\n    +            children[1] = children[0].next();\n    +            children[2] = children[1].next();\n    +            children[3] = children[2].next();\n    +        }\n    +        List<Cell> cells = new ArrayList<>(children.length);\n    +        for (S2CellId pixel : children) \n{\n    +            cells.add(new S2PrefixTreeCell(tree, pixel));\n    +        }\n    +        return new FilterCellIterator(cells.iterator(), shapeFilter);\n    +    }\n    +\n    +    @Override\n    +    public Shape getShape(){\n    +        if (shape==null){\n    +            if (cellId == null) \n{ //World cell\n    +                return tree.getSpatialContext().getWorldBounds();\n    +            }\n    +            return tree.s2ShapeFactory.getS2CellShape(cellId);\n    +        }\n    +        return shape;\n    +    }\n    +\n    +    @Override\n    +    public boolean isPrefixOf(Cell c) {\n    +        if (cellId == null) \n{\n    +            return true;\n    +        }\n    +        S2PrefixTreeCell cell =(S2PrefixTreeCell)c;\n    +        return cellId.contains(cell.cellId);\n    +    }\n    +\n    +    @Override\n    +    public int compareToNoLeaf(Cell fromCell) {\n    +        if (cellId == null) \n{\n    +            return 1;\n    +        }\n    +        S2PrefixTreeCell cell = (S2PrefixTreeCell)fromCell;\n    +        return cellId.compareTo(cell.cellId);\n    +    }\n    +\n    +    /**\n    +     * Check if a cell is a leaf.\n    +     *\n    +     * @param ref The Byteref of the leaf\n    +     * @return true if it is a leaf, e.g last byte is the special Character.\n    +     */\n    +    private boolean isLeaf(BytesRef ref)\n{\n    +        return (ref.bytes[ref.offset + ref.length - 1] == LEAF);\n    +    }\n    +\n    +    /**\n    +     * Get the \n{@link S2CellId} from the {@link BytesRef} representation.\n    +     *\n    +     * @param ref The bytes.\n    +     * @return the corresponding S2 cell.\n    +     */\n    +    private S2CellId getS2CellIdFromBytesRef(BytesRef ref){\n    +        int length = ref.length;\n    +        if (isLeaf(ref)){\n    +            length--;\n    +        }\n    +        if (length == 0) {\n    +            return null; //world cell\n    +        }\n    +        int face = PIXELS.get(ref.bytes[ref.offset]);\n    +        S2CellId cellId = FACES[face];\n    +        //we will do it directly with cell ids for performance\n    +        long id = cellId.id();\n    +        for (int i=ref.offset+1; i<ref.offset + length; i++){\n    +            int pos = PIXELS.get(ref.bytes[i]);\n    +            long oldLsb = id & -id;\n    +            id  = id - oldLsb + (oldLsb >>> 2);\n    +            id  = id + pos * ((id & -id) << 1);\n    +        }\n    +        return new S2CellId(id);\n    +    }\n    +\n    +    /**\n    +     * Codify a {@link S2CellId}\n into its \n{@link BytesRef}\n representation.\n    +     *\n    +     * @param cellId The S2 Cell id to codify.\n    +     * @param bref The byteref representation.\n    +     */\n    +    private void getBytesRefFromS2CellId(S2CellId cellId, BytesRef bref){\n    +        if (cellId == null) \n{//world cell\n    +            bref.length=0;\n    +            return;\n    +        }\n    +        int length = getLevel() + 1;\n    +        byte[] b = new byte[length];\n    \u2014 End diff \u2013\n\n    the bref parameter may already have bytes that is of this length.  If it is, reuse it thus avoiding object allocation.  BytesRef exists to avoid object allocation and copying. ",
            "author": "ASF GitHub Bot"
        },
        {
            "id": "comment-16320916",
            "date": "2018-01-10T19:22:34+0000",
            "content": "Github user dsmiley commented on a diff in the pull request:\n\n    https://github.com/apache/lucene-solr/pull/302#discussion_r160769685\n\n    \u2014 Diff: lucene/spatial-extras/src/java/org/apache/lucene/spatial/prefix/tree/S2PrefixTreeCell.java \u2014\n    @@ -0,0 +1,285 @@\n    +/*\n    + * Licensed to the Apache Software Foundation (ASF) under one or more\n    + * contributor license agreements.  See the NOTICE file distributed with\n    + * this work for additional information regarding copyright ownership.\n    + * The ASF licenses this file to You under the Apache License, Version 2.0\n    + * (the \"License\"); you may not use this file except in compliance with\n    + * the License.  You may obtain a copy of the License at\n    + *\n    + *     http://www.apache.org/licenses/LICENSE-2.0\n    + *\n    + * Unless required by applicable law or agreed to in writing, software\n    + * distributed under the License is distributed on an \"AS IS\" BASIS,\n    + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    + * See the License for the specific language governing permissions and\n    + * limitations under the License.\n    + */\n    +\n    +package org.apache.lucene.spatial.prefix.tree;\n    +\n    +import java.util.ArrayList;\n    +import java.util.HashMap;\n    +import java.util.List;\n    +import java.util.Map;\n    +\n    +import com.google.common.geometry.S2CellId;\n    +import org.apache.lucene.util.BytesRef;\n    +import org.locationtech.spatial4j.shape.Shape;\n    +import org.locationtech.spatial4j.shape.SpatialRelation;\n    +\n    +/**\n    + * This class represents a S2 pixel in the RPT.\n    + *\n    + * @lucene.internal\n    + */\n    +class S2PrefixTreeCell implements Cell {\n    +\n    +    //Faces of S2 Geometry\n    +    private static S2CellId[] FACES = new S2CellId[6];\n    +    static \n{\n    +        FACES[0] = S2CellId.fromFacePosLevel(0, 0, 0);\n    +        FACES[1] = S2CellId.fromFacePosLevel(1, 0, 0);\n    +        FACES[2] = S2CellId.fromFacePosLevel(2, 0, 0);\n    +        FACES[3] = S2CellId.fromFacePosLevel(3, 0, 0);\n    +        FACES[4] = S2CellId.fromFacePosLevel(4, 0, 0);\n    +        FACES[5] = S2CellId.fromFacePosLevel(5, 0, 0);\n    +    }\n    +\n    +    /Special character to define a cell leaf/\n    +    private static final byte LEAF = '+';\n    +\n    +    /Tokens are used to serialize cells/\n    +    private static final byte[] TOKENS;\n    +    /Map containing mapping between tokens and integer values/\n    +    private static final Map<Byte,Integer> PIXELS;\n    +    static {\n    +        TOKENS = new byte[]\n{'0', '1', '2', '3', '4', '5'}\n;\n    +        PIXELS = new HashMap<>(6);\n    +        PIXELS.put(TOKENS[0], 0);\n    +        PIXELS.put(TOKENS[1], 1);\n    +        PIXELS.put(TOKENS[2], 2);\n    +        PIXELS.put(TOKENS[3], 3);\n    +        PIXELS.put(TOKENS[4], 4);\n    +        PIXELS.put(TOKENS[5], 5);\n    +    }\n    +\n    +    S2CellId cellId;\n    +    int level; //cache level\n    +    S2PrefixTree tree;\n    +\n    +    SpatialRelation shapeRel= null;\n    +    boolean isLeaf;\n    +    Shape shape = null;\n    +\n    +    S2PrefixTreeCell(S2PrefixTree tree, S2CellId cellId){\n    +        this.cellId= cellId;\n    +        this.tree = tree;\n    +        setLevel();\n    +        if (getLevel() == tree.getMaxLevels()) \n{\n    +            setLeaf();\n    +        }\n    +    }\n    +\n    +    void readCell(S2PrefixTree tree, BytesRef ref){\n    +        isLeaf = false;\n    +        shape = null;\n    +        shapeRel = null;\n    +        this.tree = tree;\n    +        cellId = getS2CellIdFromBytesRef(ref);\n    +        setLevel();\n    +        if (isLeaf(ref) || getLevel() == tree.getMaxLevels()){    +            setLeaf();    +        }\n    +    }\n    +\n    +    @Override\n    +    public SpatialRelation getShapeRel() \n{\n    +        return shapeRel;\n    +    }\n    +\n    +    @Override\n    +    public void setShapeRel(SpatialRelation rel) \n{\n    +        shapeRel = rel;\n    +    }\n    +\n    +    @Override\n    +    public boolean isLeaf() \n{\n    +        return isLeaf;\n    +    }\n    +\n    +    @Override\n    +    public void setLeaf() \n{\n    +        isLeaf = true;\n    +    }\n    +\n    +    @Override\n    +    public BytesRef getTokenBytesWithLeaf(BytesRef result) {\n    +        result = getTokenBytesNoLeaf(result);\n    +        //max levels do not have leaf\n    +        if (isLeaf() && !(getLevel() == tree.getMaxLevels()))\n{\n    +            //Add leaf byte\n    +            result.bytes[result.offset + result.length] = LEAF;\n    +            result.length++;\n    +        }\n    +        return result;\n    +    }\n    +\n    +    @Override\n    +    public BytesRef getTokenBytesNoLeaf(BytesRef result) {\n    +        if (result == null)\n{\n    +            result = new BytesRef();\n    +        }\n    +        getBytesRefFromS2CellId(cellId, result);\n    +        return result;\n    +    }\n    +\n    +    @Override\n    +    public int getLevel() \n{\n    +        return this.level;\n    +    }\n    +\n    +    /**\n    +     * Cache level of cell.\n    +     */\n    +    private void setLevel() {\n    +        if (this.cellId == null) \n{\n    +            this.level = 0;\n    +        }\n    +        else \n{\n    +            this.level = this.cellId.level() + 1;\n    +        }\n    +    }\n    +\n    +    @Override\n    +    public CellIterator getNextLevelCells(Shape shapeFilter) {\n    +        S2CellId[] children;\n    +        if (cellId == null)\n{ // this is the world cell\n    +            children =  FACES;\n    +        }\n    +        else \n{\n    +            children = new S2CellId[4];\n    +            children[0] = cellId.childBegin();\n    +            children[1] = children[0].next();\n    +            children[2] = children[1].next();\n    +            children[3] = children[2].next();\n    +        }\n    +        List<Cell> cells = new ArrayList<>(children.length);\n    +        for (S2CellId pixel : children) \n{\n    +            cells.add(new S2PrefixTreeCell(tree, pixel));\n    +        }\n    +        return new FilterCellIterator(cells.iterator(), shapeFilter);\n    +    }\n    +\n    +    @Override\n    +    public Shape getShape(){\n    +        if (shape==null){\n    +            if (cellId == null) \n{ //World cell\n    +                return tree.getSpatialContext().getWorldBounds();\n    +            }\n    +            return tree.s2ShapeFactory.getS2CellShape(cellId);\n    +        }\n    +        return shape;\n    +    }\n    +\n    +    @Override\n    +    public boolean isPrefixOf(Cell c) {\n    +        if (cellId == null) \n{\n    +            return true;\n    +        }\n    +        S2PrefixTreeCell cell =(S2PrefixTreeCell)c;\n    +        return cellId.contains(cell.cellId);\n    +    }\n    +\n    +    @Override\n    +    public int compareToNoLeaf(Cell fromCell) {\n    +        if (cellId == null) \n{\n    +            return 1;\n    +        }\n    +        S2PrefixTreeCell cell = (S2PrefixTreeCell)fromCell;\n    +        return cellId.compareTo(cell.cellId);\n    +    }\n    +\n    +    /**\n    +     * Check if a cell is a leaf.\n    +     *\n    +     * @param ref The Byteref of the leaf\n    +     * @return true if it is a leaf, e.g last byte is the special Character.\n    +     */\n    +    private boolean isLeaf(BytesRef ref)\n{\n    +        return (ref.bytes[ref.offset + ref.length - 1] == LEAF);\n    +    }\n    +\n    +    /**\n    +     * Get the \n{@link S2CellId} from the {@link BytesRef} representation.\n    +     *\n    +     * @param ref The bytes.\n    +     * @return the corresponding S2 cell.\n    +     */\n    +    private S2CellId getS2CellIdFromBytesRef(BytesRef ref){\n    +        int length = ref.length;\n    +        if (isLeaf(ref)){\n    +            length--;\n    +        }\n    +        if (length == 0) {\n    +            return null; //world cell\n    +        }\n    +        int face = PIXELS.get(ref.bytes[ref.offset]);\n    +        S2CellId cellId = FACES[face];\n    +        //we will do it directly with cell ids for performance\n    +        long id = cellId.id();\n    +        for (int i=ref.offset+1; i<ref.offset + length; i++){\n    +            int pos = PIXELS.get(ref.bytes[i]);\n    +            long oldLsb = id & -id;\n    +            id  = id - oldLsb + (oldLsb >>> 2);\n    +            id  = id + pos * ((id & -id) << 1);\n    +        }\n    +        return new S2CellId(id);\n    +    }\n    +\n    +    /**\n    +     * Codify a {@link S2CellId}\n into its \n{@link BytesRef}\n representation.\n    +     *\n    +     * @param cellId The S2 Cell id to codify.\n    +     * @param bref The byteref representation.\n    +     */\n    +    private void getBytesRefFromS2CellId(S2CellId cellId, BytesRef bref){\n    +        if (cellId == null) \n{//world cell\n    +            bref.length=0;\n    +            return;\n    +        }\n    +        int length = getLevel() + 1;\n    +        byte[] b = new byte[length];\n    +        b[0] = TOKENS[cellId.face()];\n    +        for (int i =1; i < getLevel(); i++) \n{\n    +            b[i] = TOKENS[cellId.childPosition(i)];\n    +        }\n    +        bref.bytes = b;\n    +        bref.length = getLevel();\n    +        bref.offset = 0;\n    +    }\n    +\n    +    @Override\n    +    public int hashCode() {\n    +        if (cellId == null) \n{\n    +            return super.hashCode();\n    +        }\n    +        return this.cellId.hashCode();\n    +    }\n    +\n    +    @Override\n    +    public boolean equals(Object o) {\n    +        S2PrefixTreeCell cell = (S2PrefixTreeCell)o;\n    +        if (cellId == null) {\n    \u2014 End diff \u2013\n\n    see Objects.equals(...) ",
            "author": "ASF GitHub Bot"
        },
        {
            "id": "comment-16320917",
            "date": "2018-01-10T19:22:35+0000",
            "content": "Github user dsmiley commented on a diff in the pull request:\n\n    https://github.com/apache/lucene-solr/pull/302#discussion_r160773587\n\n    \u2014 Diff: lucene/spatial-extras/src/java/org/apache/lucene/spatial/prefix/tree/S2PrefixTree.java \u2014\n    @@ -0,0 +1,111 @@\n    +/*\n    + * Licensed to the Apache Software Foundation (ASF) under one or more\n    + * contributor license agreements.  See the NOTICE file distributed with\n    + * this work for additional information regarding copyright ownership.\n    + * The ASF licenses this file to You under the Apache License, Version 2.0\n    + * (the \"License\"); you may not use this file except in compliance with\n    + * the License.  You may obtain a copy of the License at\n    + *\n    + *     http://www.apache.org/licenses/LICENSE-2.0\n    + *\n    + * Unless required by applicable law or agreed to in writing, software\n    + * distributed under the License is distributed on an \"AS IS\" BASIS,\n    + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    + * See the License for the specific language governing permissions and\n    + * limitations under the License.\n    + */\n    +\n    +package org.apache.lucene.spatial.prefix.tree;\n    +\n    +import java.util.ArrayList;\n    +import java.util.List;\n    +\n    +import com.google.common.geometry.S2CellId;\n    +import com.google.common.geometry.S2LatLng;\n    +import com.google.common.geometry.S2Projections;\n    +import org.apache.lucene.util.BytesRef;\n    +import org.locationtech.spatial4j.context.SpatialContext;\n    +import org.locationtech.spatial4j.distance.DistanceUtils;\n    +import org.locationtech.spatial4j.shape.Point;\n    +import org.locationtech.spatial4j.shape.Shape;\n    +\n    +/**\n    + * Spatial prefix tree for S2 Geometry. Shape factories for the given \n{@link SpatialContext}\n must\n    + * implement the interface \n{@link S2ShapeFactory}\n.\n    + *\n    + * @lucene.experimental\n    + */\n    +public class S2PrefixTree extends SpatialPrefixTree {\n    +\n    +    /**\n    +     * Factory for creating \n{@link S2PrefixTree}\n instances with useful defaults\n    +     */\n    +    public static class Factory extends SpatialPrefixTreeFactory {\n    +\n    +        @Override\n    +        protected int getLevelForDistance(double degrees) \n{\n    +            S2PrefixTree grid = new S2PrefixTree(ctx, S2PrefixTree.MAX_LEVELS);\n    +            return grid.getLevelForDistance(degrees);\n    +        }\n    +\n    +        @Override\n    +        protected SpatialPrefixTree newSPT() \n{\n    +            return new S2PrefixTree(ctx,\n    +                maxLevels != null ? maxLevels : S2PrefixTree.MAX_LEVELS);\n    +        }\n    +    }\n    +\n    +    //factory to generate S2 cell shapes\n    +    protected final S2ShapeFactory s2ShapeFactory;\n    +    public static final int MAX_LEVELS = S2CellId.MAX_LEVEL + 1;\n    +\n    +    public S2PrefixTree(SpatialContext ctx, int maxLevels) {\n    +        super(ctx, maxLevels);\n    +        if (!(ctx.getShapeFactory() instanceof S2ShapeFactory)) \n{\n    +            throw new IllegalArgumentException(\"Spatial context does not support S2 spatial index.\");\n    +        }\n    +        this.s2ShapeFactory = (S2ShapeFactory) ctx.getShapeFactory();\n    +    }\n    +\n    +    @Override\n    +    public int getLevelForDistance(double dist) {\n    +        if (dist ==0)\n{\n    +            return maxLevels;\n    +        }\n    +        return Math.min(maxLevels, S2Projections.MAX_WIDTH.getClosestLevel(dist * DistanceUtils.DEGREES_TO_RADIANS) +1);\n    +    }\n    +\n    +    @Override\n    +    public double getDistanceForLevel(int level) \n{\n    +        return S2Projections.MAX_WIDTH.getValue(level -1) * DistanceUtils.RADIANS_TO_DEGREES;\n    +    }\n    +\n    +    @Override\n    +    public Cell getWorldCell() \n{\n    +        return  new S2PrefixTreeCell(this, null);\n    +    }\n    +\n    +    @Override\n    +    public Cell readCell(BytesRef term, Cell scratch) \n{\n    +        S2PrefixTreeCell cell = (S2PrefixTreeCell) scratch;\n    +        if (cell == null)\n    +            cell = (S2PrefixTreeCell) getWorldCell();\n    +        cell.readCell(this, term);\n    +        return cell;\n    +    }\n    +\n    +    @Override\n    +    public CellIterator getTreeCellIterator(Shape shape, int detailLevel) {\n    +        if (!(shape instanceof Point)) \n{\n    +            return  super.getTreeCellIterator(shape, detailLevel);\n    +        }\n    +        Point p = (Point) shape;\n    +        S2CellId id = S2CellId.fromLatLng(S2LatLng.fromDegrees(p.getY(), p.getX())).parent(detailLevel-1);\n    +        List<Cell> cells = new ArrayList<>(detailLevel);\n    +        for (int i=0; i < detailLevel -1; i++) {\n    \u2014 End diff \u2013\n\n    nitpick: put a space after that minus operator ",
            "author": "ASF GitHub Bot"
        },
        {
            "id": "comment-16320976",
            "date": "2018-01-10T20:02:03+0000",
            "content": "(an aside: I wish the JIRA GitHub integration didn't put so much code context around the feedback text!)\n\nIt's nice to see a new RPT SpatialPrefixTree implementation   The API is a little crusty; perhaps sometime we could kick around some ideas to make it nicer.\n\nIt'll be interesting to see how well this performs.  This appears to be a 6-ary tree, as opposed to 4-ary (quad) or 32-ary (geohash).  One could build a variable arity prefixTree by the way (i.e. first level has 256, next 128, etc.), and I recently tweaked one of ours to do that (not contributed back yet).\n\nFor point data, the higher the arity, the smaller the index but slower search as it must scan more.\n\nFor non-point data, it's not clear since distErrPct caps the resolution of a shape relative to its size, and I believe (though not 100% sure) that it yields a roughly normal distribution around a certain number of cells (given fixed distErrPct, random shape type & size, near equator, random tree arity).  It'd be neat to empirically validate my theory.  If I'm right, then the optimal arity is probably 4 for non-point shapes, and we have two of those implementations. RE \"near equator\" above, see LUCENE-5056 though it has an easy fix in my last comment.\n\nGiven the way S2 divides a world into 6 sides recursively, it seems it would place shapes at a balanced depth in the tree no matter where in the world the data is.  That's a nice benefit... making the cell depth for a shape a bit more shallow than the probable depth in the other tree implementations (assuming a target precision for a given shape).  That's a bonus.\n\nCC Nicholas Knize you may find this issue interesting ",
            "author": "David Smiley"
        },
        {
            "id": "comment-16321726",
            "date": "2018-01-11T05:36:10+0000",
            "content": "Github user iverase commented on a diff in the pull request:\n\n    https://github.com/apache/lucene-solr/pull/302#discussion_r160868387\n\n    \u2014 Diff: lucene/spatial-extras/src/java/org/apache/lucene/spatial/prefix/tree/S2PrefixTreeCell.java \u2014\n    @@ -0,0 +1,285 @@\n    +/*\n    + * Licensed to the Apache Software Foundation (ASF) under one or more\n    + * contributor license agreements.  See the NOTICE file distributed with\n    + * this work for additional information regarding copyright ownership.\n    + * The ASF licenses this file to You under the Apache License, Version 2.0\n    + * (the \"License\"); you may not use this file except in compliance with\n    + * the License.  You may obtain a copy of the License at\n    + *\n    + *     http://www.apache.org/licenses/LICENSE-2.0\n    + *\n    + * Unless required by applicable law or agreed to in writing, software\n    + * distributed under the License is distributed on an \"AS IS\" BASIS,\n    + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    + * See the License for the specific language governing permissions and\n    + * limitations under the License.\n    + */\n    +\n    +package org.apache.lucene.spatial.prefix.tree;\n    +\n    +import java.util.ArrayList;\n    +import java.util.HashMap;\n    +import java.util.List;\n    +import java.util.Map;\n    +\n    +import com.google.common.geometry.S2CellId;\n    +import org.apache.lucene.util.BytesRef;\n    +import org.locationtech.spatial4j.shape.Shape;\n    +import org.locationtech.spatial4j.shape.SpatialRelation;\n    +\n    +/**\n    + * This class represents a S2 pixel in the RPT.\n    + *\n    + * @lucene.internal\n    + */\n    +class S2PrefixTreeCell implements Cell {\n    +\n    +    //Faces of S2 Geometry\n    +    private static S2CellId[] FACES = new S2CellId[6];\n    +    static \n{\n    +        FACES[0] = S2CellId.fromFacePosLevel(0, 0, 0);\n    +        FACES[1] = S2CellId.fromFacePosLevel(1, 0, 0);\n    +        FACES[2] = S2CellId.fromFacePosLevel(2, 0, 0);\n    +        FACES[3] = S2CellId.fromFacePosLevel(3, 0, 0);\n    +        FACES[4] = S2CellId.fromFacePosLevel(4, 0, 0);\n    +        FACES[5] = S2CellId.fromFacePosLevel(5, 0, 0);\n    +    }\n    +\n    +    /Special character to define a cell leaf/\n    +    private static final byte LEAF = '+';\n    +\n    +    /Tokens are used to serialize cells/\n    +    private static final byte[] TOKENS;\n    +    /Map containing mapping between tokens and integer values/\n    +    private static final Map<Byte,Integer> PIXELS;\n    +    static {\n    +        TOKENS = new byte[]\n{'0', '1', '2', '3', '4', '5'}\n;\n    +        PIXELS = new HashMap<>(6);\n    +        PIXELS.put(TOKENS[0], 0);\n    +        PIXELS.put(TOKENS[1], 1);\n    +        PIXELS.put(TOKENS[2], 2);\n    +        PIXELS.put(TOKENS[3], 3);\n    +        PIXELS.put(TOKENS[4], 4);\n    +        PIXELS.put(TOKENS[5], 5);\n    +    }\n    +\n    +    S2CellId cellId;\n    +    int level; //cache level\n    +    S2PrefixTree tree;\n    +\n    +    SpatialRelation shapeRel= null;\n    +    boolean isLeaf;\n    +    Shape shape = null;\n    +\n    +    S2PrefixTreeCell(S2PrefixTree tree, S2CellId cellId){\n    +        this.cellId= cellId;\n    +        this.tree = tree;\n    +        setLevel();\n    +        if (getLevel() == tree.getMaxLevels()) \n{\n    +            setLeaf();\n    +        }\n    +    }\n    +\n    +    void readCell(S2PrefixTree tree, BytesRef ref){\n    +        isLeaf = false;\n    +        shape = null;\n    +        shapeRel = null;\n    +        this.tree = tree;\n    +        cellId = getS2CellIdFromBytesRef(ref);\n    +        setLevel();\n    +        if (isLeaf(ref) || getLevel() == tree.getMaxLevels()){    +            setLeaf();    +        }\n    +    }\n    +\n    +    @Override\n    +    public SpatialRelation getShapeRel() \n{\n    +        return shapeRel;\n    +    }\n    +\n    +    @Override\n    +    public void setShapeRel(SpatialRelation rel) \n{\n    +        shapeRel = rel;\n    +    }\n    +\n    +    @Override\n    +    public boolean isLeaf() \n{\n    +        return isLeaf;\n    +    }\n    +\n    +    @Override\n    +    public void setLeaf() \n{\n    +        isLeaf = true;\n    +    }\n    +\n    +    @Override\n    +    public BytesRef getTokenBytesWithLeaf(BytesRef result) {\n    +        result = getTokenBytesNoLeaf(result);\n    +        //max levels do not have leaf\n    +        if (isLeaf() && !(getLevel() == tree.getMaxLevels()))\n{\n    +            //Add leaf byte\n    +            result.bytes[result.offset + result.length] = LEAF;\n    +            result.length++;\n    +        }\n    +        return result;\n    +    }\n    +\n    +    @Override\n    +    public BytesRef getTokenBytesNoLeaf(BytesRef result) {\n    +        if (result == null)\n{\n    +            result = new BytesRef();\n    +        }\n    +        getBytesRefFromS2CellId(cellId, result);\n    +        return result;\n    +    }\n    +\n    +    @Override\n    +    public int getLevel() \n{\n    +        return this.level;\n    +    }\n    +\n    +    /**\n    +     * Cache level of cell.\n    +     */\n    +    private void setLevel() {\n    \u2014 End diff \u2013\n\n    The method cellId.level() is probably efficient but because it can be called several times I think we are saving some ticks on the clock by caching it.  ",
            "author": "ASF GitHub Bot"
        },
        {
            "id": "comment-16321747",
            "date": "2018-01-11T06:22:05+0000",
            "content": "Note that S2 geometry has 6-arity for the first level, after that divides every cell in 4 so it has in fact 4-arity.\n\nKarl Wright : I have added in the pull request a new Shape (GeoS2shape) which is a very fast implementation of a 4 points polygon. I do not perform any argument checking, is that ok? purpose of the shape is speed. In addition I have implemented it as a polygon and added a method in the polygon factory, is that approach ok?\n\n\n\n\n ",
            "author": "Ignacio Vera"
        },
        {
            "id": "comment-16325523",
            "date": "2018-01-14T11:48:23+0000",
            "content": "I committed a new version of the SPT with variable arity. First level is always divided by 6 (faces), and the following levels are divided either in 4 sub-cells, 16 sub-cells or 64 sub-cells.\n\nPerformance of the tree can be checked using test classes. There are two conclusions:\n\n\n\tFor polygons you should always use 4-arity.\n\tFor points only, users might want to use 16-arity. you loose a bit of query performance but decrease of loading time and index size.\n\n ",
            "author": "Ignacio Vera"
        },
        {
            "id": "comment-16355439",
            "date": "2018-02-07T13:35:24+0000",
            "content": "I would like to move these forward, any comment David Smiley, Karl Wright or it is ready to be merged? ",
            "author": "Ignacio Vera"
        },
        {
            "id": "comment-16355494",
            "date": "2018-02-07T14:17:19+0000",
            "content": "Ignacio Vera, I think this is great, but I haven't been following the details. ",
            "author": "Karl Wright"
        },
        {
            "id": "comment-16355620",
            "date": "2018-02-07T15:51:46+0000",
            "content": "Overall looks good Ignacio Vera. \u00a0I think it's ready to be committed, notwithstanding some \"ant precommit\" stuff regarding the new dependency I'm sure you'll bump into.\n\nThe main question in my mind is how we communicate when someone should use this SPT. \u00a0 For the other 3 I know when they are most appropriate. \u00a0But for this; I just don't know. \u00a0In the description you state:\nUsing this pixelization scheme reduces the size of the index, improves the performance of the queries and reduces the loading time for non-point shapes.\nCould you please share some numbers?\n\nBTW GitHub-Jira integration now puts code review comments into the \"Worklog\" tab in Jira which doesn't flood the comments with noisy stuff or send redundant email notifications. \u00a0If someone interested wants to follow the activity and be notified, I believe they need to \"subscribe\" to the PR in GitHub. ",
            "author": "David Smiley"
        },
        {
            "id": "comment-16356757",
            "date": "2018-02-08T10:07:12+0000",
            "content": "I have added the performance test classes on the branch in case you want to have a look to check results are not bias.\n\nI have done two test (They do not include index size as I have no found a reliable way of getting that info), I can only show you for now some tipical results.\n\n1) Indexing 5k random polygons and executing 50 Random queries. Trees have precision set to 1e-4 and distErrPct to 5%:\n\nload geohash : 132,15 indexed shapes per second\n query geohash recursive : 10,88 queries per second\n query geohash composite : 7,29 queries per second\n\nload quad : 299,04 indexed shapes per second\n query quad recursive : 15,13 queries per second\n query quad composite : 10,89 queries per second\n\nload s2 arity 4 : 623,67 indexed shapes per second\n query s2 arity 4 recursive : 40,00 queries per second\n query s2 arity 4 composite : 21,51 queries per second\n\nload s2 arity 16 : 283,46 indexed shapes per second\n query s2 arity 16 recursive : 12,22 queries per second\n query s2 arity 16 composite : 9,99 queries per second\n\nload s2 arity 64 : 159,05 indexed shapes per second\n query s2 arity 64 recursive : 5,13 queries per second\n query s2 arity 64 composite : 3,58 queries per second\n\n\u00a0\n\n1) Indexing 50k random points and executing 50 Random queries. Trees have precision set to 1e-6 and distErrPct to 0%:\n\nload geohash : 14898,69 indexed shapes per second\n query geohash recursive : 2,31 queries per second\n query geohash composite : 2,29 queries per second\n\nload quad : 5068,42 indexed shapes per second\n query quad recursive : 5,10 queries per second\n query quad composite : 5,11 queries per second\n\nload s2 arity 4 : 9748,49 indexed shapes per second\n query s2 arity 4 recursive : 11,34 queries per second\n query s2 arity 4 composite : 11,38 queries per second\n\nload s2 arity 16 : 15513,50 indexed shapes per second\n query s2 arity 16 recursive : 3,86 queries per second\n query s2 arity 16 composite : 3,83 queries per second\n\nload s2 arity 64 : 16886,19 indexed shapes per second\n query s2 arity 64 recursive : 1,56 queries per second\n query s2 arity 64 composite : 1,56 queries per second\n\n\u00a0\n\nSome data of my use case: I need to index ~3M\u00a0 documents. 2M are points, 0.5M polygons and 0.5M multi-polygons with an averge size of 20. They need to be indexed on the celestial sphere (unit sphere). All polygons are squared (4 points) with different sizes, from 1 square degree to very tiny ones, all distributed mainly on the south hemisphere of the sphere. Moving from Geohash to S2 has provided the following benefits:\n\n1) 20% reduccion of index size.\n\n2) 75% reduccion on indexing time (yuhu!).\n\n3) 2.5 times faster queries.\n\n\u00a0\n\nAnyway what we need is a benchmark for SPT the same way that there is one for BKD tree. Probably my next mini-project.\n\nConclusion: If you use Geo3D, you probably want to use S2 \n\n\u00a0 ",
            "author": "Ignacio Vera"
        },
        {
            "id": "comment-16357202",
            "date": "2018-02-08T16:50:32+0000",
            "content": "These are fantastic results Ignacio Vera! ",
            "author": "David Smiley"
        },
        {
            "id": "comment-16360632",
            "date": "2018-02-12T11:38:42+0000",
            "content": "David Smiley, indeed I have to iterate a few times with ant precommit but now it seems happy. Last two doubts:\n\n1) In which branches should I commit this change? I pressume that it is needed in Master and 7.x. (Karl Wright changes in geo3d should be commited as well in 6.x?)\n\n2) CHANGES.txt: I have added the reference under new features. I suppose this file needs to be updated in all committed braches.\n\nThanks in advance!\n\n\u00a0 ",
            "author": "Ignacio Vera"
        },
        {
            "id": "comment-16361161",
            "date": "2018-02-12T17:51:26+0000",
            "content": "These are significant speedups and reduction of the index size! Do we have any clue as to what with S2 triggers these improvements? The benchmark description says about the polygons that they are \"all distributed mainly on the south hemisphere of the sphere\", does it matter or would one get similar speedups for northern polygons? ",
            "author": "Adrien Grand"
        },
        {
            "id": "comment-16362014",
            "date": "2018-02-13T08:57:27+0000",
            "content": "Adrien Grand, the important thing here is if the shape is close to the equator and close to the poles. When using bounding boxes, the further away you are from the equator, the more cells you need to describe a shape. S2 cells are more constant around the globe so it should use the similar number of cells regardless where you are on the sphere.\n\nI put together an example (attached) where I index a square polygon on the equator and at a 60 degrees latitude with trees with same set-up. You can see that geohash tree is the more inneficient as it needs quite a lot of cells to describe the polygon, 260 at the equator and 390 at 60 degrees. S2 and Quad trees use the same number of cells to describe the polygon at the equator (108) but at 60 degrees, S2 uses a similar number of cells\u00a0 and Quad tree almost double the number of cells required. Here is where the benefit comes.\n\nI have attached as well a small graph showing query performance of my data depending on the SPT. The queries use composite strategy and are random cone searches (query shape is a random circle). Horizontal axis represents the number of hits of the query and the vertical axis the query execution time.\n\n\u00a0\n\n\u00a0 ",
            "author": "Ignacio Vera"
        },
        {
            "id": "comment-16363013",
            "date": "2018-02-13T20:47:54+0000",
            "content": "BTW I\u2019m on vacation with almost no Internet thru the 21st ",
            "author": "David Smiley"
        },
        {
            "id": "comment-16363593",
            "date": "2018-02-14T07:47:11+0000",
            "content": "Thanks for the explanation Ignacio Vera. ",
            "author": "Adrien Grand"
        },
        {
            "id": "comment-16369716",
            "date": "2018-02-20T04:41:57+0000",
            "content": "Thanks for investing the time into the illustrations Ignacio Vera.  The diagram of the 3 prefix trees is very illustrative.  Usually when I think of people indexing \"squares\" I believe the square is aligned to lines of longitude and latitude... but this is not true for the so-called \"squares\" for your use-case?  Regardless of that, people index all kinds of shapes, e.g. circles, polygons and they will look differently at different latitudes.  I didn't know that it affects the cell count this much \u2013 thanks for enlightening me.  I knew it could in what I thought was some extreme cases but your diagram seems to show it's typical.  Hmm.  I wonder if similar results could be achieved by internally using the web-mercator projection?  Of course some scheme is needed to handle the polar caps which that projection doesn't even cover but whatever.  The web-mercator projection increases the overall size of the shape both latitudinally and longitudinally equally, and thus would probably yield roughly similar numbers of cells at all latitudes; wouldn't it?\n\nRE index size \u2013 you probably had difficulty benchmarking the differences because you used Lucene defaults.  Switch to a doc count based index writer flush (instead of memory based), and use SerialMergeScheduler to get predictable segments, albeit slower throughput that you wouldn't normally do in production.  This stuff can have a big impact on benchmark results, not just for index size but sometimes also benchmarking queries depending on how \"lucky\" one of the benchmark runs got if a big merge occurred to yield much fewer segments.\n\nI'm having difficulty finding the benchmark; can you provide a link to the GH file?\n\nAt first I was unsure how S2 might improve point query performance but after some thought I figure that the cell count discussion for indexed shapes would apply as well for the cells a query shape might have to traverse.  Again; I wonder if a web-mercator projection would get similar improvements?  \n\nAnother nice thing about web-mercator based underlying coordinate system is that the index-time heatmap feature would produce a grid of numbers that are nice squares to be displayed in a web-mercator map client-side.  Today they tend to be horizontal rectangles that get flatter as you go to the poles.  It's not just about visual preference of squares; it's also about trying to ensure that any secondary processing of the raw heatmap data doesn't unintentionally skew/misrepresent data due to an assumption of a uniform grid when it's not actually uniform.  Sorry to get a little side-tracked but it's related. ",
            "author": "David Smiley"
        },
        {
            "id": "comment-16369955",
            "date": "2018-02-20T11:27:00+0000",
            "content": "They are in reality spherical polygons with 4 edges not \"squares\" (aka coordinate ranges which close to the poles are more like triangles). You can see in the diagram that at 60 degrees horizontal lines are big circles (they are slighltly curved on the equirectangular projection).\u00a0 I am not sure that a different projection will help on this case, projection distorts the shapes as well as the cells so not sure how much much benefit we will get.\n\nHeatmaps are fantastic to represent data but users needs to be careful as cells can represent different areas so results might be bias. In our case we do have heatmaps on the sphere but we are using Healpix (https://healpix.jpl.nasa.gov/) to have equal area cells.\n\nI am currently looking into a way to have a benchmark for STP similar to the geobenchmark for BKD trees. The difficult part here is all the different parameters you can set on a SPT.\n\n\n\nI'm having difficulty finding the benchmark; can you provide a link to the GH file?\n\n\nwhat are you looking for exactly?\n\n\u00a0\n\nAnyway, it would be nice to have this SPT commited, so my question is which branches should I commit it? Not sure what is the policy here.\n\n\u00a0\n\n\u00a0\n\n\u00a0\n\n\u00a0\n\n\u00a0 ",
            "author": "Ignacio Vera"
        },
        {
            "id": "comment-16371423",
            "date": "2018-02-21T13:52:19+0000",
            "content": "I am not sure that a different projection will help on this case, projection distorts the shapes as well as the cells so not sure how much much benefit we will get.\n\nAn experiment for another day I guess.  I'm more hopeful web-mercator will help.  Yes there is always distortion, but if the distortion is just overall size, then I think the cell-count shouldn't change.\n\nHealpix\n\nThanks for the reference; this looks cool!\n\nRE benchmark; you said exactly this, which I can't track down but maybe I just don't know what to look for:\n\nI have added the performance test classes on the branch in case you want to have a look to check results are not bias.\n\nAnyway, it would be nice to have this SPT commited, so my question is which branches should I commit it? Not sure what is the policy here.\n\n+1.  Do so to master & branch_7x.  This is standard practice for the vast majority of work.  If you changed something that would break back-compat in unacceptable ways then such changes would belong only in master; but it's negotiable. ",
            "author": "David Smiley"
        },
        {
            "id": "comment-16383398",
            "date": "2018-03-02T09:38:41+0000",
            "content": "Commit 1e86af061e41f1a7df1740f34ef58a1110626d96 in lucene-solr's branch refs/heads/branch_7x from Ignacio Vera\n[ https://git-wip-us.apache.org/repos/asf?p=lucene-solr.git;h=1e86af0 ]\n\nLUCENE-8126: new spatial prefix tree (SPT) based on google S2 geometry ",
            "author": "ASF subversion and git services"
        },
        {
            "id": "comment-16383399",
            "date": "2018-03-02T09:39:06+0000",
            "content": "Commit e3032dd3fcc28570c5f9d2dab4961b5b07555912 in lucene-solr's branch refs/heads/master from Ignacio Vera\n[ https://git-wip-us.apache.org/repos/asf?p=lucene-solr.git;h=e3032dd ]\n\nLUCENE-8126: New spatial prefix tree (SPT) based on google S2 geometry ",
            "author": "ASF subversion and git services"
        },
        {
            "id": "comment-16383422",
            "date": "2018-03-02T10:14:15+0000",
            "content": "Commit a281177f256fedddd4758b99306f74dc39c1bf82 in lucene-solr's branch refs/heads/master from Ignacio Vera\n[ https://git-wip-us.apache.org/repos/asf?p=lucene-solr.git;h=a281177 ]\n\nLUCENE-8126: fix precommit ",
            "author": "ASF subversion and git services"
        },
        {
            "id": "comment-16383627",
            "date": "2018-03-02T14:25:57+0000",
            "content": "I see this on the automatic tests:\n\n\u00a0\n\nBUILD FAILED\n\n/home/jenkins/workspace/Lucene-Solr-master-Linux/build.xml:618: The following error occurred while executing this line:\n\n/home/jenkins/workspace/Lucene-Solr-master-Linux/build.xml:491: The following error occurred while executing this line:\n\n/home/jenkins/workspace/Lucene-Solr-master-Linux/build.xml:479: Source checkout is modified!!! Offending files:\n\n\n\tlucene/licenses/s2-geometry-library-java-1.0.0.jar.sha1\n\n ",
            "author": "Ignacio Vera"
        },
        {
            "id": "comment-16383657",
            "date": "2018-03-02T14:43:47+0000",
            "content": "Commit ca2131573de4c8d127ea80fdb2bd37e00c87bbcc in lucene-solr's branch refs/heads/master from Ignacio Vera\n[ https://git-wip-us.apache.org/repos/asf?p=lucene-solr.git;h=ca21315 ]\n\nLUCENE-8126: fixed jar checksum ",
            "author": "ASF subversion and git services"
        },
        {
            "id": "comment-16383671",
            "date": "2018-03-02T15:07:02+0000",
            "content": "Commit fc51c1f2ef983ce4d8ba4894f822cc6f8fbc643d in lucene-solr's branch refs/heads/branch_7x from Ignacio Vera\n[ https://git-wip-us.apache.org/repos/asf?p=lucene-solr.git;h=fc51c1f ]\n\nLUCENE-8126: fixed jar checksum ",
            "author": "ASF subversion and git services"
        },
        {
            "id": "comment-16384273",
            "date": "2018-03-02T22:46:57+0000",
            "content": "Nice to finally see this in!\n\nI was trying to use this from Solr to try it out.  I went to one of our tests \u2013 TestSolr4Spatial2 and ran it, after changing schema-spatial.xml so that the srtpgeom_geo3d field type looked as follows:\n\n  <fieldType name=\"srptgeom_geo3d\" class=\"solr.RptWithGeometrySpatialField\"\n             spatialContextFactory=\"Geo3D\" planetModel=\"wgs84\"\n             prefixTree=\"org.apache.lucene.spatial.prefix.tree.S2PrefixTree$Factory\"\n  />\n\n\n\nBut it doesn't work when given a non-point shape to index because of the default pruneLeafyBranches setting in RecursivePrefixTreeStrategy which only works with \"LegacyPrefixTree\" grids (the other 3 do).  Hmm.  Looking at the notes I put here long ago it seems that RPT Strategy should be modified to have it's constructor set this.pruneLeafyBranches = (grid instanceof LegacyPrefixTree)?\n\nThe actual exception thrown is here recursiveTraverseAndPrune:\n\n  /** Returns true if cell was added as a leaf. If it wasn't it recursively descends. */\n  private boolean recursiveTraverseAndPrune(Cell cell, Shape shape, int detailLevel, List<Cell> result) {\n    // Important: this logic assumes Cells don't share anything with other cells when\n    // calling cell.getNextLevelCells(). This is only true for LegacyCell.\n    if (!(cell instanceof LegacyCell))\n      throw new IllegalStateException(\"pruneLeafyBranches must be disabled for use with grid \"+grid);\n...\n\n\nThe comment about \"This is only true for LegacyCell\" should perhaps read \"We know this is so for LegacyCell but don't know for other things.\"  Do you know if it's true for S2 Ignacio Vera?  Perhaps regardless better safe to not do this than do this pruning when it's not safe. ",
            "author": "David Smiley"
        },
        {
            "id": "comment-16384663",
            "date": "2018-03-03T13:41:43+0000",
            "content": "I have come across this problem as well and it was in my next things to do.\n\nS2 prefix tree has the same properties of the other trees : Cells at the same level are disjoint and a cell contains all child cells so it could be possible to prune bunchy leaves (and it will make the index lighter).\n\nUnfortunately the current implementation only allows this for legacy cells. So my proposal is the following:\n\nCreate a new interface, that implements the Cell interface, and adds one method:\n\n\u00a0\n\n/**\n * Grid cells that share nothing with other cells when calling cell.getNextLevelCells() might\n * implement this interface. They will be eligible for prune bunchy leaves.\n *\n * @lucene.experimental\n */\npublic interface CellCanPrune extends Cell{\n\n  /**\n   * Return the number of children for the current cell.\n   *\n   * @return the number of children cell.\n   */\n  int getSubCellsSize();\n}\n\n\u00a0\n\nThat is the only method required for prune bunchy leaves. Implementation for S2 cells is trivial:\n\n\u00a0\n\n@Override\npublic int getSubCellsSize() {\n    if (cellId == null) { //root node\n        return 6;\n    }\n    return (int) Math.pow(4, tree.arity);\n}\n\n\u00a0\n\nMake prune code depend on this interface and not legacyCell. What do you think? ",
            "author": "Ignacio Vera"
        },
        {
            "id": "comment-16384757",
            "date": "2018-03-03T17:59:12+0000",
            "content": "Make prune code depend on this interface and not legacyCell. What do you think?\n\n+1 \u2013 lets get this simple change into 7.3; ehh? ",
            "author": "David Smiley"
        },
        {
            "id": "comment-16385020",
            "date": "2018-03-04T08:37:49+0000",
            "content": "\u00a0David Smiley, I have opened https://issues.apache.org/jira/browse/LUCENE-8190 for tracking the change we were discussing. ",
            "author": "Ignacio Vera"
        },
        {
            "id": "comment-16386195",
            "date": "2018-03-05T15:19:16+0000",
            "content": "Ignacio Vera can you also please add a 2-line change to SpatialPrefixTreeFactory so that \"s2\" resolves to this new SPT Factory?\n\nPerhaps in the future this class could be refactored to use the Java Service Provider framework like Lucene already uses it for codecs and various parts. ",
            "author": "David Smiley"
        },
        {
            "id": "comment-16386196",
            "date": "2018-03-05T15:20:04+0000",
            "content": "I'll just do it; no point in asking you \u2013 sorry ",
            "author": "David Smiley"
        },
        {
            "id": "comment-16386251",
            "date": "2018-03-05T15:52:08+0000",
            "content": "Commit e0d6465af94b6c6f7b8d570dee97c98de572c876 in lucene-solr's branch refs/heads/master from David Smiley\n[ https://git-wip-us.apache.org/repos/asf?p=lucene-solr.git;h=e0d6465 ]\n\nLUCENE-8126: Add \"s2\" to SpatialPrefixTreeFactory lookup table ",
            "author": "ASF subversion and git services"
        },
        {
            "id": "comment-16386261",
            "date": "2018-03-05T15:57:56+0000",
            "content": "Commit c50a05becd62d620fcb2b39e8ac00eaee5e7f8f8 in lucene-solr's branch refs/heads/branch_7x from David Smiley\n[ https://git-wip-us.apache.org/repos/asf?p=lucene-solr.git;h=c50a05b ]\n\nLUCENE-8126: Add \"s2\" to SpatialPrefixTreeFactory lookup table\n\n(cherry picked from commit e0d6465) ",
            "author": "ASF subversion and git services"
        },
        {
            "id": "comment-16405005",
            "date": "2018-03-19T15:49:14+0000",
            "content": "Ignacio Vera Can you set the \"Fix Version/s\" on this issue? ",
            "author": "Adrien Grand"
        }
    ]
}