{
    "id": "SOLR-1568",
    "title": "Implement Spatial Filter",
    "details": {
        "affect_versions": "None",
        "status": "Closed",
        "fix_versions": [
            "3.1",
            "4.0-ALPHA"
        ],
        "components": [],
        "type": "New Feature",
        "priority": "Minor",
        "labels": "",
        "resolution": "Fixed"
    },
    "description": "Given an index with spatial information (either as a geohash, SpatialTileField (see SOLR-1586) or just two lat/lon pairs), we should be able to pass in a filter query that takes in the field name, lat, lon and distance and produces an appropriate Filter (i.e. one that is aware of the underlying field type for use by Solr. \n\nThe interface could look like:\n\n&fq={!sfilt dist=20}location:49.32,-79.0\n\n\nor it could be:\n\n&fq={!sfilt lat=49.32 lat=-79.0 f=location dist=20}\n\n\nor:\n\n&fq={!sfilt p=49.32,-79.0 f=location dist=20}\n\n\nor:\n\n&fq={!sfilt lat=49.32,-79.0 fl=lat,lon dist=20}",
    "attachments": {
        "SOLR-1568.Mattmann.031010.patch.txt": "https://issues.apache.org/jira/secure/attachment/12438476/SOLR-1568.Mattmann.031010.patch.txt",
        "CartesianTierQParserPlugin.java": "https://issues.apache.org/jira/secure/attachment/12425352/CartesianTierQParserPlugin.java",
        "SOLR-1568.patch": "https://issues.apache.org/jira/secure/attachment/12434809/SOLR-1568.patch"
    },
    "issue_links": {},
    "comments": [
        {
            "author": "Grant Ingersoll",
            "id": "comment-12779189",
            "date": "2009-11-17T23:03:10+0000",
            "content": "This should be solved by having a tier field type. "
        },
        {
            "author": "Grant Ingersoll",
            "id": "comment-12779536",
            "date": "2009-11-18T17:21:57+0000",
            "content": "Here's the start of a QParserPlugin for this functionality.  It's just the Java code and is not integrated with Solr yet.\n\nIt works using the Lucene spatial stuff, but it should not be committed at this point, b/c I want to make it work with Tier based field types so that the end user need not even think about what the field name structure is (i.e. tier_).\n\nCan query with it as something like:  \n{!tier x=32 y=-79 dist=20 prefix=tier_}\n.  If you did want to use it, you would need to add it to your solrconfig.xml. "
        },
        {
            "author": "Chris Male",
            "id": "comment-12779543",
            "date": "2009-11-18T17:42:42+0000",
            "content": "Hi,\n\nI'm just wondering why you have created your own TierFilter instead of using the CartesianShapeFilter from the Lucene spatial contrib?\n\nCheers "
        },
        {
            "author": "Grant Ingersoll",
            "id": "comment-12779662",
            "date": "2009-11-18T21:00:44+0000",
            "content": "Honestly, it's a bit tricky and I'm not sure how best to resolve it (keep in mind that I'm not recommending the above piece be committed).  There are a few pieces that can be improved in the CartesianShapeFilter to perform better (I still need to fix them in Lucene) but if I go that route, then I need to update the Lucene JARs associated with that in Solr.  I can't really do that, b/c that likely means one of two things:\n\n1. Patching the 2.9.1 branch and packaging up that JAR for Solr or wait for a 2.9.2 release from Lucene which isn't likely.\n2. Patching trunk and including it.  This would be a huge undertaking for Solr\n\nSo, in the end, my decision was based on the fact that the code for it was pretty simple and wouldn't be a big deal to fix.  Longer term, I will fix the issue in trunk of Lucene and then over time Solr can adapt to use that once we are on 3.x "
        },
        {
            "author": "Chris A. Mattmann",
            "id": "comment-12779670",
            "date": "2009-11-18T21:12:56+0000",
            "content": "So, in the end, my decision was based on the fact that the code for it was pretty simple and wouldn't be a big deal to fix. Longer term, I will fix the issue in trunk of Lucene and then over time Solr can adapt to use that once we are on 3.x\n\n+1 on this. My group at JPL has gone the route of trying to co-develop Lucene and SOLR patches for this without much success. I think the best way is to maintain the code pieces in SOLR, try and flow them back into Lucene (those updates needed there), and then flow back into SOLR as releases in Lucene-ville are made. "
        },
        {
            "author": "Ryan McKinley",
            "id": "comment-12779726",
            "date": "2009-11-18T23:22:07+0000",
            "content": "\n\n\n I think the best way is to maintain the code pieces in SOLR, try and flow them back into Lucene (those updates needed there), and then flow back into SOLR as releases in Lucene-ville are made.\n\n\n\n\n\n+1\n "
        },
        {
            "author": "patrick o'leary",
            "id": "comment-12795014",
            "date": "2009-12-29T06:00:44+0000",
            "content": "I would be concerned that this starts making it more complex for users to implement.\nwe're going from  \n\n&lat=49.45&long=-77.33&radius=10\n\n\nto :\n\n&fq={!sfilt p=49.32,-79.0 f=location dist=20}\n\n\n\nWhat do you get out of it?\nI remember FAST tm, a subsidiary of microsoft (think I got all that right), used have\n\ngeo_location:{-79.0,49.32,10)\n\n\n\nAnd that was unnecessarily awkward to explain to folks, again because different folks viewed GIS calculations in different manors\n\nRemember GIS is often like an Abbot and Costello sketch, who's on first, lat or long?\nKeep it simple, and please don't obscure it\n\n--1  "
        },
        {
            "author": "Grant Ingersoll",
            "id": "comment-12796249",
            "date": "2010-01-04T17:26:19+0000",
            "content": "Here's the thing I keep coming back to with this issue.  For all the field types other than SpatialTile (Cartesian Tier), filters are already easily creatable.  It seems odd to have to write this special QParserPlugin that has all this syntax support, etc. to create filters for all of the other cases beside the spatial tile.  For instance, pure radial distance filtering is easily handled through the FunctionRangeQParserPlugin and the various distance functions.  In fact, going this route is more convoluted for those cases b/c now you need a way to pass in what distance function you want to use. "
        },
        {
            "author": "Ryan McKinley",
            "id": "comment-12796280",
            "date": "2010-01-04T18:30:06+0000",
            "content": "I'm torn on this also...\n\nThe function query syntax (and all local params really) are a bit cryptic.  When I look into it though they are really powerful, and i see an advantage to having that level of control. (and it works in solr now)\n\nI wonder if there is a simple way to add query rewriting that would convert:\n &lat=49&long=-77&radius=10\nto:\n &fq=\n{!sfilt p=49,-77 f=location dist=10}\n\nPerhaps a RequestRewrite component?  \n\nI doubt adding something like http://tuckey.org/urlrewrite/ would work off-the-shelf, but it could go a long way to hide the ugly innards for a simple case like this, yet still allow the power of the function query syntax. "
        },
        {
            "author": "Grant Ingersoll",
            "id": "comment-12796282",
            "date": "2010-01-04T18:36:27+0000",
            "content": "Keep in mind distance functions are about more than just lat/lon, although there is no reason why we can't support both. "
        },
        {
            "author": "Yonik Seeley",
            "id": "comment-12796289",
            "date": "2010-01-04T19:02:56+0000",
            "content": "The examples are not of equivalent power.  What field are we working off of?  Are we filtering by bounding box or by distance, sorting by distance, or boosting by distance?\n\nFurther, given that query parsers default to grabbing global params if local ones aren't specified this\n\n&fq={!sfilt p=49,-77 d=1000 f=location}\n\n\n\ncould be written as \n\n&fq={!sfilt f=location}\n&p=49,-77\n&d=1000\n\n\n\nWhich I assumed people would do anyway to make it easier for clients to construct queries and do filtering + sorting w/o repeating parameters. "
        },
        {
            "author": "Grant Ingersoll",
            "id": "comment-12796299",
            "date": "2010-01-04T19:22:42+0000",
            "content": "Are we filtering by bounding box or by distance, sorting by distance, or boosting by distance? \n\nI see this as a filtering only issue.  To me, all the other capabilities other than filtering by a Spatial Tile Field are already covered through normal Solr capabilities, so I don't see much benefit to inventing new syntax and more code to maintain even if it is slightly easier for the app designer to consume. "
        },
        {
            "author": "Grant Ingersoll",
            "id": "comment-12796308",
            "date": "2010-01-04T19:32:37+0000",
            "content": "Also, in all of these proposals, how do we intend to specify what distance calculation to use?  Which is another reason for not going down the path of a generic QParser for this, since if we use the FunctionRangeQParser, it's inherent in the passing in of the function. "
        },
        {
            "author": "Yonik Seeley",
            "id": "comment-12796348",
            "date": "2010-01-04T20:46:31+0000",
            "content": "Also, in all of these proposals, how do we intend to specify what distance calculation to use?\n\nIMO, the user shouldn't have to.  The vast majority of users want \"normal\" spatial search... fast yet good enough.   They won't know the details and won't want to know (except perhaps that it's accurate to x meters).\n\nFor those super-advanced users that wish to specify their own distance function, we could allow an optional parameter on sfilt that specifies an arbitrary function. "
        },
        {
            "author": "Ryan McKinley",
            "id": "comment-12796352",
            "date": "2010-01-04T20:56:41+0000",
            "content": "\ncould be written as \n\n&fq={!sfilt f=location}\n&p=49,-77\n&d=1000\n\n\n\nJeez \u2013 I had no idea...  then I think (most?) cases are taken care of...\n\nWith this, a handler could be defined with the default param: 'fq=\n{!sfilt f=location}\n' and the 'end user' could simply call:\n  &p=49,-77&d=1000\nnever needing to grock the local-params/function syntax. "
        },
        {
            "author": "Yonik Seeley",
            "id": "comment-12796457",
            "date": "2010-01-05T00:38:57+0000",
            "content": "since if we use the FunctionRangeQParser, it's inherent in the passing in of the function.\n\nIt's not clear exactly what you're proposing - can you give an example request so we can compare? "
        },
        {
            "author": "Grant Ingersoll",
            "id": "comment-12796476",
            "date": "2010-01-05T01:38:59+0000",
            "content": "\nfq={!frange l=0 u=400}hsin(0.57, -1.3, lat_rad, lon_rad, 3963.205)\n\n\n "
        },
        {
            "author": "Yonik Seeley",
            "id": "comment-12796478",
            "date": "2010-01-05T01:48:43+0000",
            "content": "While it's nice that this works (to double-check results, etc), this isn't particularly scalable as it calculates the distance (the expensive part) for every document.  Or are you suggesting some other kind of implementation in conjunction with this syntax? "
        },
        {
            "author": "Grant Ingersoll",
            "id": "comment-12796485",
            "date": "2010-01-05T02:09:17+0000",
            "content": "For those who only want pure radial search, it is the only way, scalable or not, unless I'm missing something.  \n\nAs I see, it there are several options for filtering that already work out of the box and that someone may want to use:\n1. Radial distance as above\n2. Range query (i.e. bounding box)\n\nThe one remaining that isn't implemented is the tile stuff.  \n\nNow, obviously, we can provide tools to make these slightly easier to consume.  I've already prototyped most of it, but in doing so, I just couldn't shake the sense that it is a waste of time for anything but the tile stuff and that it hides too much in terms of what the tradeoffs are going to be.  I just think it is easy enough for an app designer to use their existing toolbox (#1 and #2) while throwing in one more lightweight, easy to use new tool (tile support.) "
        },
        {
            "author": "Yonik Seeley",
            "id": "comment-12796491",
            "date": "2010-01-05T02:28:45+0000",
            "content": "For those who only want pure radial search, it is the only way, scalable or not, unless I'm missing something.\n\nA smart spatial filter, at a minimum, only does the distance calculation for those documents that lie within the bounding box.  That's the main point to the bounding box.  I had assumed this is what Patrick's local-solr already did?\nAlthough I do think it's a good idea to also allow a user to specify only a bounding box if they don't want to pay the price for the distance calculation at all.\n\n2. Range query (i.e. bounding box)\n\nAnd how would that be specified out of the box? (example please?)  You're not suggesting that be delegated to the user do you?  That's very hard, very field specific, and will often result in multiple range queries, not one. "
        },
        {
            "author": "patrick o'leary",
            "id": "comment-12796524",
            "date": "2010-01-05T04:09:53+0000",
            "content": "A smart spatial filter, at a minimum, only does the distance calculation for those documents that lie within the bounding box. That's the main point to the bounding box. I had assumed this is what Patrick's local-solr already did?\n\nIt's a little more contrived - I actually executed the lucene query as part of the filter, \n\n\tBounded box\n\tText query standard query\n\tAnd bitset\n\tPass in that bitset to radial filter to only calculate distances of both text search, and bounded box\n\n\n\nThus only doc's matching the query within the bounding box have their distances calculated.\nCheck out \nDistanceQueryBuilder\n\n\npublic Filter getFilter(Query query) {\n    // Chain the Query (as filter) with our distance filter\n    if (distanceFilter != null) {\n      distanceFilter.reset();\n    }\n    QueryWrapperFilter qf = new QueryWrapperFilter(query);\n    return new ChainedFilter(new Filter[] {qf, filter},\n                             ChainedFilter.AND);\n  }\n\npublic Query getQuery(Query query){\n    return new ConstantScoreQuery(getFilter(query));\n  }\n\n\n "
        },
        {
            "author": "Grant Ingersoll",
            "id": "comment-12804759",
            "date": "2010-01-25T22:46:26+0000",
            "content": "And how would that be specified out of the box? \n\nIt's just a simple range query:  point:[33.5,-80 TO 35.0,-81]  or some other similar thing.  The point is that Solr already supports this, so I don't see a lot to be gained by actually doing it in Solr.\n\n(example please?) You're not suggesting that be delegated to the user do you? That's very hard, very field specific, and will often result in multiple range queries, not one.\n\nIt doesn't strike me as that hard, but perhaps I'm missing something.  Many times this stuff is automatically generated by a user clicking on a map or via other, application side calculations.\n\nI actually executed the lucene query as part of the filter\n\nThat's interesting.  So, you end up calculating it twice, once for scoring and once for filtering?  I can see why that would speed things up. "
        },
        {
            "author": "Grant Ingersoll",
            "id": "comment-12829598",
            "date": "2010-02-04T12:53:45+0000",
            "content": "A totally NON WORKING patch.  The only thing really defined is the interface, per earlier discussions.  I doubt it even compiles.  I'm putting it up here for something to talk about eventually.\n\nI'd like to achieve at least 2 things:\n\n1. Good defaults for the filters based on the FieldType\n2. Pluggable implementations for the filters based on the FieldType.  I've seen enough of these now that just hardcoding bounding box to the PointType is not sufficient.  I think we need a bit looser coupling.  I have that now as an abstract class called SpatialFilterable (will rename to SpatialFilter) which my plan is to have the QParserPlugin load up from the Solr Config.  This way, if people want to implement there own, they can\n\nAs I said, this totally NON WORKING. "
        },
        {
            "author": "Grant Ingersoll",
            "id": "comment-12831140",
            "date": "2010-02-08T21:46:07+0000",
            "content": "So, one of the things I'm not sure on here is how best to associate the filtering information with the FieldType.  On the one hand, we could have  a base class or a small interface that defines the filter call back on the FieldType and then the PointType and other spatial FieldTypes could implement/extend that capability.  Going this approach means that if someone wants to provide a different way of filtering for a FieldType, they would have to implement a derived class overriding the method.  For instance, on the PointType, the base implementation may be to just generate a range query for each field based on distance.  However, if someone wanted a different approach, they would then have to extend PointType and register a whole other FieldType, let's call it NewFilterPointType.\n\nAn alternative approach would be to separate the filter calculation in a different class and then somehow associate it with the FieldType (maybe as a map).  I've started this to some extent on the last NON WORKING patch, but don't feel great about the actual implementation just yet.  In the case above, Solr would provide a default implementation (automatically registered) and then it could be overridden by configuring in solrconfig.xml.\n\nI'm also open to other suggestions.  I still am pretty open to taking baby steps here by defining the API as Yonik described above (more or less, see my last patch) but only providing a single implementation right now for the Spatial Tile Field Type (Cartesian Tier).\n\nThoughts and suggestions welcome?  I'd like to get something in Solr pretty soon. "
        },
        {
            "author": "Grant Ingersoll",
            "id": "comment-12831611",
            "date": "2010-02-09T19:34:15+0000",
            "content": "Actually, in thinking some more about this, it seems like it is just as easy to extend the FieldType to override a method as it is to invent new syntax to support configuring these things.  I'm going to go that route, which is, of course, what Yonik suggested all along  "
        },
        {
            "author": "Yonik Seeley",
            "id": "comment-12835347",
            "date": "2010-02-18T19:22:47+0000",
            "content": "I'm not a fan of optional units... I think we should just standardize on something (meters perhaps) and stick with it.\nThis is a programmatic API, not a user API, and it's not a hardship for a programmer to convert to whatever units are appropriate.\n "
        },
        {
            "author": "Grant Ingersoll",
            "id": "comment-12839333",
            "date": "2010-02-27T23:24:26+0000",
            "content": "More progress.  Don't think it even compiles, but putting it up for others to start to look at and for me to get it off of my hard drive.  Just going down the FieldType route. "
        },
        {
            "author": "Chris A. Mattmann",
            "id": "comment-12843883",
            "date": "2010-03-11T02:53:02+0000",
            "content": "Hey Grant:\n\nI'll take a look at your latest patch and try to iterate on it (at least make sure it compiles, and take a pass with javadocs, run the unit tests, etc.). Should have something up in the next few hours.\n\nCheers,\nChris "
        },
        {
            "author": "Chris A. Mattmann",
            "id": "comment-12843902",
            "date": "2010-03-11T04:26:19+0000",
            "content": "OK, this guy compiles, and I tried to guess in a couple areas (e.g., please look at Haversine) where variables were missing. One nice thing you can take out of this is the normalize functions for lat and lon in DistanceUtils \u2013 those will probably be generally useful.\n\nI'll also look to bring some of this over to SIS, as we start to flesh it out.\n\nI saw an error during unit tests in org.apache.solr.client.solrj.embedded.SolrExampleEmbeddedTest, but it seems unrelated (so suspicious \u2013 is this a real bug?):\n\n\n[chipotle:solr/build/test-results] mattmann% more TEST-org.apache.solr.client.solrj.embedded.SolrExampleEmbeddedTest.txt \nTestsuite: org.apache.solr.client.solrj.embedded.SolrExampleEmbeddedTest\nTests run: 1, Failures: 0, Errors: 1, Time elapsed: 0 sec\n\nTestcase: testContentStreamRequest took 0.003 sec\n        Caused an ERROR\nForked Java VM exited abnormally. Please note the time in the report does not re\nflect the time until the VM exit.\njunit.framework.AssertionFailedError: Forked Java VM exited abnormally. Please n\note the time in the report does not reflect the time until the VM exit.\n\n[chipotle:solr/build/test-results] mattmann% \n\n "
        },
        {
            "author": "Grant Ingersoll",
            "id": "comment-12848738",
            "date": "2010-03-23T15:04:43+0000",
            "content": "Here's what I have in my trunk now.  Chris, haven't had a chance to work on yours, but am going to look today, as well as move over to the new trunk.  Just putting this up here in case I do something stupid on my local drive. "
        },
        {
            "author": "Grant Ingersoll",
            "id": "comment-12850358",
            "date": "2010-03-26T21:24:51+0000",
            "content": "Compiles and is much closer, but still doesn't work exactly right.  Currently focusing on filtering for LatLonType.  Haven't tested filter creation for the other types yet.  Need to write unit tests. "
        },
        {
            "author": "Yonik Seeley",
            "id": "comment-12851154",
            "date": "2010-03-29T23:10:46+0000",
            "content": "Things are looking good!  I like the SpatialQueryable interface and the SpatialOptions class, which should allow us to use an interface and slowly migrate by changing SpatialOptions w/o breaking back compat.  I haven't looked much at the implementations of geohash or tier stuff yet - more the basic point type and user interfaces.\n\nHigh Level Interface:\n\n\tunits: if we do specify units, more standard abbreviations would probably be \"km\" and \"mi\" rather than \"K\" and \"M\"\n\tjust standardizing on units might be the best option, as I think it would be simplest to use (and client conversion is trivial)\n\tExamples of confusion and complications that \"units\" can case:\n\t\n\t\tWhen filtering and sorting, what happens if there is a units mismatch?\n\t\tdoes \"units\" apply to the optional \"radius\" argument?\n\t\twhat are the units for calculated and returned distances?  People might assume that because they filtered using \"km\", that a distance sort or other function queries would be in \"km\" or \"mi\"\n\t\tif returned distances can be in any unit, it complicates client code that may not know the exact request, and hence the units\n\t\tboosting or adding in a function of distance to the relevancy score: changing the units would unexpectedly change how this worked.\n\t\n\t\n\tfl should probably just be \"f\" (fl stands for \"field list\")?   Update: looking at the code again, it seems that the idea is to allow specifying lat,lon separately too?\n   we have point and latlon fields for this though... shouldn't it always just be a single field?\n\t\"radius\" parameter is likely to confuse people... (i.e. I specified radius=1 because I wanted to search within a 1 mile radius), while in reality this represents the radius of the earth.  Since 99.99% of people should not use this parameter, perhaps rename to \"planet_radius\" or \"sphere_radius\"?\n\tSeems like it would be really nice to be able to do both distance filtering and bounding box filtering.\n\t\n\t\tDistance filtering would normally be implemented as a combination of a bounding box + distance calculations for points within that box.\n\t\tDistance filtering could get even more efficient in the future... we could also calculate an \"inner\" box within the bounding box.\n     Any points in the inner box would be guaranteed to be less than the distance, hence no need to calculate exact distance.\n\t\tIt looks like the current implementation(s) does bounding box only?\n\t\n\t\n\n\n\nCode:\n\n\tSpatialFilterQParserPlugin should probably just be a standard parser - no need to explicitly register in solrconfig.xml\n\t\n\t\toops, I see that this is already done under \"sfilt\" currently - so it can just be removed from solrconfig.xml\n\t\tis there a reason why it's ResourceLoaderAware?\n\t\n\t\n\tfor the implementation that creates a single range query for lattitude and a single one for longitude: we actually need multiple ranges (or multiple boxes) to handle boxes that cross the 180 meridian, as well as boxes that cross the poles.\n\n\n\nTests:\n\n\tSpatialQParserPluginTest - it might be nice (and easier to maintain) if this were slightly higher level - test that the produced filter successfully filters out points outside the box, rather than testing that a specific type of query is returned (currently the test does \"query instanceof NumericRangeQuery\").\n\n\n\nExample schema:\n\n\tbefore release, we'll prob want to cut down the spatial field types to just one recommended one that people can use w/o having to figure out the difference between all the types.  OK to keep multiple in during development though... makes for easier ad hoc testing.\n\n\n\nWith an eye toward the end game, here's an example of what we might want to shoot for:\n\n\n// use case: filter by distance, sort by distance\n&point=49,-77\n&dist=1000\n&fq={!sfilt fl=location}\n&sort=dist($point,location) asc\n  // we can't quite do this yet with function query syntax, but it seems nice?\n\n// use case: filter by distance, boost relevance score by a function of distance\n&point=49,-77\n&dist=1000\n&fq={!sfilt fl=location}\n&boost=recip(dist($point,location),1,$dist,$dist)) \n  // \"boost\" is an edismax param.\n  // function will yield values between .5 and 1\n\n "
        },
        {
            "author": "Lance Norskog",
            "id": "comment-12851726",
            "date": "2010-03-31T04:45:22+0000",
            "content": "Dublin Core includes conventions for encoding points & \"rectangles\":\nDCMI Point Encoding Scheme\nDCMI Box Encoding Scheme\n\nThese are maybe too high-level for the spatial tools, but are an interesting packaging of metadata & coordinates. "
        },
        {
            "author": "Grant Ingersoll",
            "id": "comment-12852009",
            "date": "2010-03-31T18:13:04+0000",
            "content": "Thanks for the thorough feedback, Yonik.  Some thoughts inline.\n\n\n\n\tunits: if we do specify units, more standard abbreviations would probably be \"km\" and \"mi\" rather than \"K\" and \"M\"\n\tjust standardizing on units might be the best option, as I think it would be simplest to use (and client conversion is trivial)\n\tExamples of confusion and complications that \"units\" can case:\n\n\n\n\n\tWhen filtering and sorting, what happens if there is a units mismatch?\n\tdoes \"units\" apply to the optional \"radius\" argument?\n\twhat are the units for calculated and returned distances? People might assume that because they filtered using \"km\", that a distance sort or other function queries would be in \"km\" or \"mi\"\n\tif returned distances can be in any unit, it complicates client code that may not know the exact request, and hence the units\n\tboosting or adding in a function of distance to the relevancy score: changing the units would unexpectedly change how this worked.\n\n\n\n\nAgreed on abbreviations.  The units mostly come into play with picking the radius.  Lucene spatial seems to assume miles in a lot of places, but I imagine this is actually kind of silly given that the majority of the world uses metric.  I guess ideally, I want people to be able to save on conversion, but it's probably silly to try to engineer that in.  I suppose we could have a whole discussion on whether to assume English or Metric.  I'm still on the fence.\n\n\nfl should probably just be \"f\" (fl stands for \"field list\")? Update: looking at the code again, it seems that the idea is to allow specifying lat,lon separately too?\nwe have point and latlon fields for this though... shouldn't it always just be a single field?\n\nI was thinking that I might support multiple fields for those people who are already indexing lat/lon as two fields.  That way they could get the benefits of this code w/o re-indexing.  That being said, it is still unimplemented and I'm not sure how to implement it.\n\n\n\"radius\" parameter is likely to confuse people... (i.e. I specified radius=1 because I wanted to search within a 1 mile radius), while in reality this represents the radius of the earth. Since 99.99% of people should not use this parameter, perhaps rename to \"planet_radius\" or \"sphere_radius\"?\n\nsphere_radius it is.\n\n\nSeems like it would be really nice to be able to do both distance filtering and bounding box filtering.\n\n\n\tDistance filtering would normally be implemented as a combination of a bounding box + distance calculations for points within that box.\n\tDistance filtering could get even more efficient in the future... we could also calculate an \"inner\" box within the bounding box.\n      Any points in the inner box would be guaranteed to be less than the distance, hence no need to calculate exact distance.\n\tIt looks like the current implementation(s) does bounding box only?\n\n\n\n\nLatLonType will implement bounding box + distance filtering.  I imagine people will want to override the FieldTypes for their specifics on creating the Filter.  Right now, PointType really is designed for a rectangular coordinate system.  Most people will likely use LatLonType, which will be geared towards spherical (i.e. Earth).   But, agreed, we will be able to optimize over time.\n\nis there a reason why it's ResourceLoaderAware?\n\nArtifact of earlier design.  Removed.\n\nSpatialQParserPluginTest \n\nAlready changed and \"higher\" level, just haven't posted the patch.  I actually renamed it too.\n\noops, I see that this is already done under \"sfilt\" currently - so it can just be removed from solrconfig.xml\n\nDone.\n\nbefore release, we'll prob want to cut down the spatial field types to just one recommended one that people can use w/o having to figure out the difference between all the types. OK to keep multiple in during development though... makes for easier ad hoc testing.\n\nFor now, I have a comment in the schema that says something to the effect that you likely will not need all of these.  I think this gets to a bigger discussion we should have on dev@ about what the example should be.  I'd like the example to be more self contained and more self explanatory.  We could have a light version and a full featured one.\n\nWith an eye toward the end game, here's an example of what we might want to shoot for:\n\nAgreed the syntax is nice.  I don't think I will do that as part of this patch.  Otherwise, I think all of those use cases are covered.\n "
        },
        {
            "author": "Grant Ingersoll",
            "id": "comment-12852804",
            "date": "2010-04-02T13:04:21+0000",
            "content": "Got some tests and most of the rework from Yonik's comments.  Some of the tests explicitly fail due to bugs in the underlying tile stuff in Lucene.\n\nAdded support for handling the poles and the prime and 180th meridian to the LatLonType.  I think we're in pretty good shape now, assuming the underlying Lucene bits get fixed soon. "
        },
        {
            "author": "Grant Ingersoll",
            "id": "comment-12852807",
            "date": "2010-04-02T13:07:23+0000",
            "content": "Not an absolute blocker, but would be good to get this fixed. "
        },
        {
            "author": "Grant Ingersoll",
            "id": "comment-12853125",
            "date": "2010-04-03T12:13:09+0000",
            "content": "Unit test that shows problems at the pole. "
        },
        {
            "author": "Chris Male",
            "id": "comment-12853369",
            "date": "2010-04-05T14:17:01+0000",
            "content": "Hi,\n\nI have taken a look at the latest patch and it seems fine.  Any TODOs and problems with the poles can be tackled as separate/sub-issues.  Particularly the pole bugs.  I'd prefer to see this committed soon so we can take a look at the overall architecture, and see what parts we want to move into a module. "
        },
        {
            "author": "Grant Ingersoll",
            "id": "comment-12853376",
            "date": "2010-04-05T14:28:40+0000",
            "content": "changing SpatialOptions w/o breaking back compat\n\nI wonder if we shouldn't also pass along the request parameters on this, so that if one is extending a FieldType for spatial, which I think will be somewhat common, they can have access to the params. "
        },
        {
            "author": "Yonik Seeley",
            "id": "comment-12853377",
            "date": "2010-04-05T14:31:43+0000",
            "content": "I wonder if we shouldn't also pass along the request parameters on this,\n\nIIRC, you pass along the QParser, and that has pointers to the complete context - stuff like the request object. "
        },
        {
            "author": "Grant Ingersoll",
            "id": "comment-12853380",
            "date": "2010-04-05T14:36:10+0000",
            "content": "even better.  Patch soon "
        },
        {
            "author": "Yonik Seeley",
            "id": "comment-12853401",
            "date": "2010-04-05T15:23:35+0000",
            "content": "even better. Patch soon \n\nI meant, you already do pass along the QParser, so no patch should be necessary?\n\n\npublic interface SpatialQueryable {\n  public Query createSpatialQuery(QParser parser, SpatialOptions options);\n}\n\n\n\nOr perhaps you mean somewhere else?\n\nThat extra request context is why I started adding QParser to many of the new FieldType methods such as FieldType.getRangeQuery() too. "
        },
        {
            "author": "Grant Ingersoll",
            "id": "comment-12853406",
            "date": "2010-04-05T15:39:34+0000",
            "content": "No, you are right.  I wasn't thinking clearly. "
        },
        {
            "author": "Grant Ingersoll",
            "id": "comment-12853496",
            "date": "2010-04-05T19:18:11+0000",
            "content": "small updates, started working on the multi-field solution.  Almost ready "
        },
        {
            "author": "Chris A. Mattmann",
            "id": "comment-12853556",
            "date": "2010-04-05T21:58:26+0000",
            "content": "+1 on the latest patch with the following caveat:\n\nWhy not put:\n\n\n   public static final double DEGREES_TO_RADIANS = Math.PI / 180.0;\n   public static final double RADIANS_TO_DEGREES = 180.0 / Math.PI;\n+  public static final double DEG_45 = Math.PI / 4.0;\n+  public static final double DEG_225 = 5 * DEG_45;\n+  public static final double DEG_90 = Math.PI / 2;\n+  public static final double DEG_180 = Math.PI;\n+  public static final double SIN_45 = Math.sin(DEG_45);\n\n\n\ninto  solr/src/java/org/apache/solr/search/function/distance/Constants.java, and then make DistanceUtils implement (or static import) those constants?\n\nCheers,\nChris "
        },
        {
            "author": "Brainski",
            "id": "comment-12856411",
            "date": "2010-04-13T12:51:12+0000",
            "content": "Hi\n\nI tested the last patch. I was able to apply it to the latest dev subversion check out and I was able to recompile the whole thing (kind of difficult for a non java programmer g).\n\nFinally I modified my schema.xml and was able to use the sfilt in my range query. Its working quite well with my data.\n\nMy wishes:\n\nPlease update the wiki according to the changes:\nhttp://wiki.apache.org/solr/SpatialSearch\n\nUnder Filtering:\nfq=\n{!sfilt fl=store_lat_lon units=km}\n&pt=47.508249,8.731969&d=12\n\nThe units parameter and the meas parameter is not explained. \nThe dist parameter is renamed to d\n\nUnder Scoring:\nAn example for a boost function is the following. Please add this also to the boost functions, because it took me hours to find out the correct syntax without whitespaces.\nqt=dismax&bf=recip(2,store,vector(40.7143,-74.006)),1,1,1)^30\n "
        },
        {
            "author": "Grant Ingersoll",
            "id": "comment-12863533",
            "date": "2010-05-03T21:46:39+0000",
            "content": "not much changed, but just putting what I have up, so that it is captured. "
        },
        {
            "author": "David Smiley",
            "id": "comment-12865154",
            "date": "2010-05-07T13:43:03+0000",
            "content": "I've finally tried this out successfully.  But I needed a lat-lon box search, not a circle.  It wasn't hard to modify the code to offer a lower-left point and upper-right point.  I only implemented this for the Spatial Tiers point implementation.  The odd part was that the code internally wanted to know the diameter of a circle based search in miles.  So I translated this to the distance from one corner of the box search to the oppose one... then divided by the square root of 2 to reduce this amount to what the diameter would be of a circle fitting within the box search.\n\nI haven't bothered with any scoring modification, I'm most interested in filtering. "
        },
        {
            "author": "Kyle Wilkinson",
            "id": "comment-12865543",
            "date": "2010-05-09T05:59:00+0000",
            "content": "I was able to get this up and running with the latest patch, but I had to add a dynamicField to my schema to get everything working: \n    <field name=\"latlon\"                        type=\"latLon\"    indexed=\"true\"    stored=\"true\"/>\n    <dynamicField name=\"*_latLon\"               type=\"tdouble\"   indexed=\"true\"     stored=\"false\"/>    \n\nIs this expected?  If so, can you add it to the wiki to save the next person the trouble?  Also, some feedback from trying to write boost and sort functions: The LatLon type is great and it is very convenient that it handles calculating spherical distances (there's probably a better term for this) for you.  However, I could not figure out how to take advantage of writing my own boost function that uses this distance using the LatLon field.  Both the hsin and dist functions require the the components of the point  / don't accept a LatLon (at least as documented).  To use them, I ended up having to store separate fields in my document for latitude and longitude, as well as a LatLon.  Also, it would be very convenient to not have to pass in the radius of the earth into the hsin function.  There's a good chance with my feedback that I'm just not doing something right or don't fully understand the capabilities offered.  Overall this functionality is very useful and saved me a ton of time.  Thanks! "
        },
        {
            "author": "David Smiley",
            "id": "comment-12865938",
            "date": "2010-05-10T21:32:45+0000",
            "content": "I commented too soon before.  The results seemed erroneous so I reverted the Solr code to r941377 from last week when Solr's tests passed (as reported by Hudson) then applied a clean patch downloaded from this issue.  SpatialFilterTest fails its tests except for testPoints().  I was most interested in testTiles which failed.  Have others gotten these tests to work? "
        },
        {
            "author": "Grant Ingersoll",
            "id": "comment-12865942",
            "date": "2010-05-10T21:51:16+0000",
            "content": "Sorry for the confusion.  The tests for this are still broken \"by design\", namely b/c of the pole bugs.  Thus, while I believe most of the patch works, the Solr tests will fail. "
        },
        {
            "author": "Hoss Man",
            "id": "comment-12872580",
            "date": "2010-05-27T22:08:13+0000",
            "content": "Bulk updating 240 Solr issues to set the Fix Version to \"next\" per the process outlined in this email...\n\nhttp://mail-archives.apache.org/mod_mbox/lucene-dev/201005.mbox/%3Calpine.DEB.1.10.1005251052040.24672@radix.cryptio.net%3E\n\nSelection criteria was \"Unresolved\" with a Fix Version of 1.5, 1.6, 3.1, or 4.0.  email notifications were suppressed.\n\nA unique token for finding these 240 issues in the future: hossversioncleanup20100527 "
        },
        {
            "author": "David Smiley",
            "id": "comment-12876279",
            "date": "2010-06-07T15:41:22+0000",
            "content": "I have been testing the capabilities of this patch further.  I am using LatLonType and I have multiple points per document.  It doesn't appear that the logic in LatLonType properly handles multi-value fields since its doing range queries for the latitude and longitude separately.  I have a document with a couple points it, Copenhagen Denmark and Ethiopia.    If I query for points in the box Lat: 10.8 - 5.4, and Lon: 9.50 - 14.23 then I find this document when I shouldn't.  This box is at a place south of Copenhagen and West of Ethiopia.\n\nOh by the way, I made some modifications after applying the patch so that I could query by a lat-lon box instead of a point-radius.  It was very easy. "
        },
        {
            "author": "Darren Govoni",
            "id": "comment-12876527",
            "date": "2010-06-08T03:06:14+0000",
            "content": "Yeah, I brought this issue up on the mailing list. Its a problem that originates in other blogs circulating about doing ranged queries on SQL tables to achieve spatial. In that context it works because the lat and lot are constrained together in the row. In solr documents you can have numerous free floating lats and lons values so a range query cannot be used alone. The intermediate lat lon results from a ranged calculus need to be constrained together otherwise false positives can occur (e.g. separate points have a lat and lon that individually satisfy the range but the point does not).\n\nStill waiting to understand how it will work. Currently, it is not entirely spatial.\n\nAlso, the distance parameter for points. How is it to be used for bounding box, where the distance varies? In that case, calculating distance across the extent of the box is a waste of cpu - a different calculation is needed for that - and a joined ranged could work.\n\nI have a proposal to fix this if its needed. "
        },
        {
            "author": "Grant Ingersoll",
            "id": "comment-12881713",
            "date": "2010-06-23T15:08:38+0000",
            "content": "RE: multivalued.\n\nYes, this isn't necessarily a spatial issue.   Best solution would be a position based query that took into account a specific position kind of like SpanFirstQuery.\n\n\nAlso, the distance parameter for points. How is it to be used for bounding box, where the distance varies? In that case, calculating distance across the extent of the box is a waste of cpu - a different calculation is needed for that - and a joined ranged could work.\n\nI have a proposal to fix this if its needed.\n\nSure, it would be useful to have a proposal for this.  Hasn't been my focus for now, but open to suggestions. "
        },
        {
            "author": "Grant Ingersoll",
            "id": "comment-12882547",
            "date": "2010-06-25T12:29:54+0000",
            "content": "Up to date with trunk, also now reuses the CartesianShapeFilter instead of rolling my own.  Still fails tests, etc. around the poles.  Otherwise, I think it is usable for those who don't have data around the poles. "
        },
        {
            "author": "Grant Ingersoll",
            "id": "comment-12883177",
            "date": "2010-06-28T15:12:40+0000",
            "content": "OK, here's my take on dealing w/ the poles.\n\nI know how to determine when we crossed the pole (you can use angular distance and latitude), so my proposal is that we handle the poles in a slightly different way than the typical \"bounding box\" approach b/c the queries get too complicated.  \n\nI have two proposals for dealing with the Poles:\n\n\n\tDocument that we do not deal with the poles and throw an exception.  Someone who needs calculations around the pole can implement their own projection and likely come up w/ a far better way of handling things than I have time for at the moment.\n\tInstead of a bounding box, create a bounding bowl by taking the smaller (closer to the equator) latitude (i.e. the lower left latitude) and then get all points that are above this latitude.  Obviously, this is inaccurate when considered in light of the bounding box model, but it will be faster/simpler and will mainly be a documentation issue and is better than simply throwing an exception.\n\n\n\nThoughts?  I'm also open to others who have more knowledge about dealing with the Poles to produce a patch. "
        },
        {
            "author": "Grant Ingersoll",
            "id": "comment-12883181",
            "date": "2010-06-28T15:14:51+0000",
            "content": "So, the correct name for approach 2 above is spherical cap: http://mathworld.wolfram.com/SphericalCap.html "
        },
        {
            "author": "Grant Ingersoll",
            "id": "comment-12883241",
            "date": "2010-06-28T18:29:59+0000",
            "content": "Note, this bowl approach also has benefits for the LatLonType in that we don't have to do a range query on the longitude, just the latitude, which translates to one less field query "
        },
        {
            "author": "Lance Norskog",
            "id": "comment-12883290",
            "date": "2010-06-28T20:57:50+0000",
            "content": "Use quaternions: http://local.wasp.uwa.edu.au/~pbourke/miscellaneous/quaternions/\n\nQuaternions allow you to embed 3D & polar in a 4-number mathematical space. You can do all of the spatial manipulations without zero points. For example, geohash fails in London because the Greenwich line is the zero point. Quats give you a basis for a geohash format that works everywhere.\n "
        },
        {
            "author": "Uwe Schindler",
            "id": "comment-12883312",
            "date": "2010-06-28T21:33:01+0000",
            "content": "Grant: Spherical Cap is the way almost all Map-based solutions work to clip out the current map viewport. If you e.g. Look with Google Earth on the north pole and use viewport based KML reloading, GE will send a BBOX to your KML producing servlet only with the south latitude filled and all others are complete open. So as soon as you cross the pole, it just gets a lessThan/greaterThan.\n\nFor crossing the date line, you get a \"inverse\" BBOX, with EastBoundLongitude < WestBoundLongitude.\n\nThese are the only two special cases in the BBOX model used by maps applications (Google Earth, Google Maps, WMS/WFS). "
        },
        {
            "author": "Grant Ingersoll",
            "id": "comment-12883952",
            "date": "2010-06-30T15:24:16+0000",
            "content": "This version passes all tests, but I have not tried the example yet.\n\nI removed SpatialTileField (see http://search.lucidimagination.com/search/document/db59ada859289cfa/spatial_rethinking_cartesian_tiers_implementation#c32e81783642df47) and reverted all changes to the tiers package.  Tiers are simply too broken to justify putting them into Solr\n\nStill a fair amount of clean up, review, testing, etc. to be done. "
        },
        {
            "author": "Grant Ingersoll",
            "id": "comment-12883976",
            "date": "2010-06-30T16:45:12+0000",
            "content": "Renames SpatialQParser to SpatialFilterQParser to be in line with the Plugin name.\n\nCleans up some of the SpatialFitlerTest class and adds explicit checking of doc ids. "
        },
        {
            "author": "Grant Ingersoll",
            "id": "comment-12884008",
            "date": "2010-06-30T18:19:29+0000",
            "content": "Minor doc fixes. \n\nI think this is ready to go. "
        },
        {
            "author": "Yonik Seeley",
            "id": "comment-12884028",
            "date": "2010-06-30T19:26:26+0000",
            "content": "Configurable units may look like a convenience at first blush, but I think they will end up just adding significant burden or confusion to clients (for many of the reasons I already listed). "
        },
        {
            "author": "Grant Ingersoll",
            "id": "comment-12884032",
            "date": "2010-06-30T19:30:53+0000",
            "content": "FYI: after committing, I intend to immediately move DistanceUtils up one package, as there is nothing tier specific about them.  I'm leaving them where they are now due to the fact that I don't think SVN will work very nicely with a change, delete and add. "
        },
        {
            "author": "Grant Ingersoll",
            "id": "comment-12886954",
            "date": "2010-07-10T00:13:41+0000",
            "content": "Committed revision 962727. "
        },
        {
            "author": "Grant Ingersoll",
            "id": "comment-12909298",
            "date": "2010-09-14T15:59:45+0000",
            "content": "Committed to 3.x too. "
        },
        {
            "author": "Bill Bell",
            "id": "comment-12912780",
            "date": "2010-09-20T23:47:06+0000",
            "content": "The calculations of distance appears to be off.\n\nNote: \"The radius of the sphere to be used when calculating distances on a sphere (i.e. haversine). Default is the Earth's mean radius in kilometers (see org.apache.solr.search.function.distance.Constants.EARTH_MEAN_RADIUS_KM) which is set to 3,958.761458084784856. Most applications will not need to set this.\"\n\nThe radius of the earth in KM is  6371.009 km (\u22483958.761 mi).\n\nAlso filtering distance appears to be off - example data:\n\n45.17614,-93.87341 to 44.9369054,-91.3929348 Approx 137 miles Google. 169 miles = 220 kilometers\n\nhttp://....../solr/select?fl=*,score&start=0&rows=10&q=\n{!sfilt%20fl=store_lat_lon}\n&qt=standard&pt=44.9369054,-91.3929348&d=280&sort=dist(2,store,vector(44.9369054,-91.3929348)) asc \n\nNothing shows. d=285 shows results. This is off by a lot.\n\nBill\n\n\n "
        },
        {
            "author": "Grant Ingersoll",
            "id": "comment-12912955",
            "date": "2010-09-21T12:58:20+0000",
            "content": "Default is the Earth's mean radius in kilometers (see org.apache.solr.search.function.distance.Constants.EARTH_MEAN_RADIUS_KM) which is set to 3,958.761458084784856\n\nThat's a typo.  I'll fix.\n\nI think Yonik just fixed this on rev 999175.  Can you try trunk?\n "
        },
        {
            "author": "Yonik Seeley",
            "id": "comment-12912968",
            "date": "2010-09-21T13:23:49+0000",
            "content": "Didn't fix things (it was just a pole check) - the bounding box calc is off... see SOLR-2125 "
        },
        {
            "author": "Yonik Seeley",
            "id": "comment-12914174",
            "date": "2010-09-23T19:11:35+0000",
            "content": "Here's a patch that changes sfilt to use getParam() which first gets from local params, but then also checks global request params if missing.  I also added \"sfield\" since getting \"fl\" from global params as the spatial field is obviously wrong.\n\nSince a single solr request may have multiple spatial related things (distance function, sort by distance, filter) it allows easier sharing.\n\nexample:  sfield=store&pt=10,20&d=200&fq=\n{!sfilt}\n&sort=sdist() asc\n\n(I made up sdist, it doesn't exist yet... but you get the idea). "
        },
        {
            "author": "Yonik Seeley",
            "id": "comment-12914319",
            "date": "2010-09-24T02:59:28+0000",
            "content": "Hmmm, I'm not understanding the purpose of the checks for if we cross the equator, and\naddEquatorialBoundary().  It looks like it creates two ranges... [min TO 0] and [0 to max], where\n[min TO max] should always work.  Is there something special about the equator I'm missing? "
        },
        {
            "author": "Yonik Seeley",
            "id": "comment-12914321",
            "date": "2010-09-24T03:46:55+0000",
            "content": "I'm further confused by the following:\n\n   else if (ll[LONG] < 0.0 && ur[LONG] > 0.0) {//prime meridian (0 degrees\n\n\n\nI don't see what's special about crossing the 0 deg longitude line here.\nIt seems like the only special-case for longitude is if ll > ur, in which case you went over the +-180 line and need two ranges to cover that [ur TO -180] OR [ll TO 180] ? "
        },
        {
            "author": "Yonik Seeley",
            "id": "comment-12914324",
            "date": "2010-09-24T04:04:49+0000",
            "content": "FYI, I'm in the middle of refactoring this code, so please give feedback as comments, not patches for now... "
        },
        {
            "author": "Chris Male",
            "id": "comment-12914326",
            "date": "2010-09-24T04:37:02+0000",
            "content": "Yonik, I recommend you glance over http://janmatuschek.de/LatitudeLongitudeBoundingCoordinates (which I think Bill mentioned earlier).  In addition to proposing quite a nice bounding box algorithm, he also discusses how to handle the poles and the 180 degree line.  I recommend we follow the behaviour that he suggests. "
        },
        {
            "author": "Yonik Seeley",
            "id": "comment-12914339",
            "date": "2010-09-24T05:47:43+0000",
            "content": "OK, so I didn't touch the current math, but I heavily re-factored (and fixed I hope) the logic.\n\nIt breaks down like this:  we always have exactly one latitude constraint, and between 0 and 2 longitude constraints.  (0 when doing a polar cap, 1 normal, 2 when we cross the +-180 long line)\n\nThe part of the code that calculates the ranges and builds the query is now much shorter (ignore the other work in progress, SpatialDistanceQuery, for now). "
        },
        {
            "author": "Yonik Seeley",
            "id": "comment-12914340",
            "date": "2010-09-24T05:55:43+0000",
            "content": "I recommend we follow the behaviour that he suggests.\n\nLooks like a really nice page.  I don't have time to figure out and redo any math right now, but I hope in the future that we can have random tests to verify this stuff. "
        },
        {
            "author": "Chris Male",
            "id": "comment-12914410",
            "date": "2010-09-24T11:00:51+0000",
            "content": "Yeah it is a nice page, and its math I think we should follow, but I'll attack that in another issue. "
        },
        {
            "author": "Grant Ingersoll",
            "id": "comment-12914411",
            "date": "2010-09-24T11:08:47+0000",
            "content": "Yonik,  you are right on the equator and 0 meridian.  I think I was just so into the tile thing at the time, that I carried it over.  We just need the 180 meridian and the poles.\n\nAs for the math on the box, I think that works, but what we have now is pretty simple too and covers the whole circle of the radius specified by the distance. "
        },
        {
            "author": "Yonik Seeley",
            "id": "comment-12914671",
            "date": "2010-09-24T22:01:54+0000",
            "content": "Here's a refresh (still uncompleted stuff in there).\n\n\n\tadds a bbox query for \"bounding box\" (or basically, fast but may include points outside the actual distance/shape)\n\tchanges sfilt to filter out all points outside of the distance (for latlon type) - I think this matches users expectations better.\n\n\n\nSo when you ask for a box, you get a range query on the underlying tri-range fields of course.\nBut when you ask for a filter (i.e. distance must be calculated to tell if it truly matches) then I actually use the value sources and check against the box, since those values will be needed sometimes to calculate the radius anyway.\n\nNot sure what I think about that... it will be faster if the main query doesn't select many documents (I plan on executing this in parallel with the query), but slower if it does. "
        },
        {
            "author": "Yonik Seeley",
            "id": "comment-12914735",
            "date": "2010-09-25T01:43:11+0000",
            "content": "Here's a patch with SpatialDistanceQuery working pretty well now, including nice explains / toString.\nIt also produces scores (the distance) so it can be used as the main query if desired.\n\nWe also really need a way to get these more expensive filters to run in parallel with the main query. "
        },
        {
            "author": "Yonik Seeley",
            "id": "comment-12915628",
            "date": "2010-09-28T05:54:28+0000",
            "content": "Here's a patch that implements a more user friendly distance function called \"sdist\".\nWay back, the original plan was to dispatch function queries as well as filters through the SpatialQueryable interface - but for now this is hardcoded to haversine on vector value sources.\n\nLike sfilt, if needed, it can read arguments from the global params \"pt\" and \"sfield\".  This will make it easy for a user to set these once in a request and still use a number of filter and distance operations w/o repeating those params.\n\nExamples:\n  sfilt(1,2,3,4)\n  sfilt($a,$b)&a=1,2&b=3,4\n  sfilt(1,2)&pt=3,4\n  sfilt(1,2)&sfield=store\n  sfilt()&pt=1,2&sfield=store\n  sfilt(store1,store2)\n  sfilt(vector(mylat,mylon),3,4)\n  sfilt(mylat,mylon,3,4)\n\nIf it detects that one of the points is constant, and the other is a vector value source (the standard case)\n it uses a slightly more optimized version of haversine that avoids one cosine call and also avoids getting multiple values through an array.\n\nedit: oh, and everything is in degrees (users really don't want radians), distances are on earth (i.e. the sphere radius is not specified), and calculated distance values are in km. "
        },
        {
            "author": "Grant Ingersoll",
            "id": "comment-12915706",
            "date": "2010-09-28T10:49:52+0000",
            "content": "Note, we have a strdist.  sdist sounds a lot like string distance to me.\n\nAlso, I'm not sure, but perhaps you forget to add some new files to the patch?  I don't see a new haversine call in the file, but maybe it's b/c it's too early in the morning. "
        },
        {
            "author": "Yonik Seeley",
            "id": "comment-12915762",
            "date": "2010-09-28T14:33:06+0000",
            "content": "OK, here's the patch again (after I did \"svn add\" on the missing files).\n\nAny suggestions other than \"sdist\"?\nI would have preferred \"dist\", but it's taken.\ngdist (geo distance)?  I just thought it was strange to have an \"sfilt\" but a \"gdist\". "
        },
        {
            "author": "Grant Ingersoll",
            "id": "comment-12915768",
            "date": "2010-09-28T14:41:07+0000",
            "content": "I could go for \"gfilt\" and \"gdist\" or \"llfilt\" and \"lldist\" (that's two lower case \"L\"s, as in lat-lon) "
        },
        {
            "author": "Yonik Seeley",
            "id": "comment-12915899",
            "date": "2010-09-28T20:04:49+0000",
            "content": "OK, final patch - this changes stuff to geofilt/geodist. "
        },
        {
            "author": "Lance Norskog",
            "id": "comment-12915920",
            "date": "2010-09-28T20:54:21+0000",
            "content": "1- There are no unit tests. One thing that has become apparent during the checkered history of Solr GIS projects is that this stuff needs really comprehensive testing. Barbie says \"GIS is hard!\".\n\n2- What is 'f' instead of CommonParams.FL ? "
        },
        {
            "author": "Yonik Seeley",
            "id": "comment-12915922",
            "date": "2010-09-28T21:03:52+0000",
            "content": "1- There are no unit tests.\n\nWhat's missing unit tests?\n\nWhat is 'f' instead of CommonParams.FL ?\n\nSince we fall back to global params, \"fl\" was not an option, so I changed it to \"sfield\".\nAs a shortcut, local-param only, I changed \"fl\" to \"f\" for consistency with all of the other QParsers that use \"f\" for the field. "
        },
        {
            "author": "Lance Norskog",
            "id": "comment-12915930",
            "date": "2010-09-28T21:33:48+0000",
            "content": "I made a mistake in my text search, never mind. All I can find are nits about comparing doubles and printed doubles directly. This makes the test cases brittle. Perhaps SolrTestCaseJ4 could include 'compare double&float with epsilon' methods?\n\nLance "
        },
        {
            "author": "Yonik Seeley",
            "id": "comment-12915968",
            "date": "2010-09-28T23:21:57+0000",
            "content": "All I can find are nits about comparing doubles and printed doubles directly.\n\nYep - me too.  Not an easy fix currently (junit can compare w/ epsilon, but you need the actual double values, which we don't have).\nI don't think xpath has epsilon comparison methods, but I was thinking of somehow adding epsilon support (maybe just global to start) to the json-testing framework I've been slowly building out.  Prob won't get to it until tests break due to the brittleness  "
        },
        {
            "author": "Yonik Seeley",
            "id": "comment-12916203",
            "date": "2010-09-29T17:05:43+0000",
            "content": "committed, w/ additional javadoc updates. "
        },
        {
            "author": "Yonik Seeley",
            "id": "comment-12916652",
            "date": "2010-09-30T20:53:07+0000",
            "content": "Hmmm, I just discovered that our LatLon type doesn't support point queries or range queries!\nI'll see if I can rectify that quickly... "
        },
        {
            "author": "Yonik Seeley",
            "id": "comment-12916668",
            "date": "2010-09-30T21:09:00+0000",
            "content": "Here's the patch so you can do exact point matches (field queries) and manual bounding boxes (range queries) with our LatLonType. "
        },
        {
            "author": "Grant Ingersoll",
            "id": "comment-12966272",
            "date": "2010-12-02T20:41:47+0000",
            "content": "FYI, I believe I have backported this to 3.x "
        },
        {
            "author": "Grant Ingersoll",
            "id": "comment-13013190",
            "date": "2011-03-30T15:45:49+0000",
            "content": "Bulk close for 3.1.0 release "
        }
    ]
}