{
    "id": "SOLR-8323",
    "title": "Add CollectionWatcher API to ZkStateReader",
    "details": {
        "components": [],
        "type": "Improvement",
        "labels": "",
        "fix_versions": [
            "6.1"
        ],
        "affect_versions": "6.0",
        "status": "Closed",
        "resolution": "Fixed",
        "priority": "Major"
    },
    "description": "An API to watch for changes to collection state would be a generally useful thing, both internally and for client use.",
    "attachments": {
        "SOLR-8323.patch": "https://issues.apache.org/jira/secure/attachment/12773532/SOLR-8323.patch"
    },
    "issue_links": {},
    "comments": [
        {
            "date": "2015-11-20T15:55:43+0000",
            "author": "Alan Woodward",
            "content": "Patch outlining the basic idea.\n\nThis adds two new interfaces, CollectionStateWatcher and CollectionStatePredicate.  The first can be registered for a particular collection with ZkStateReader and is called when the state of that collection changes (as determined by the internal watcher of that collection's state.json node).  The second is used in a new ZkStateReader.waitForState() method, and is called on a state change to see if the state of a collection matches a predicate.  There are also forwarding methods on CloudSolrClient for use by SolrJ clients, and a couple of helper methods on DocCollection and Replica to easily check for collection liveness.\n\nThe new interfaces lend themselves nicely to use as Java 8 functional interfaces, and the TestCollectionStateWatchers test demonstrate both lambdas and method references here.\n\nThis should make it easy to replace some of the helper methods (eg waitForThingsToLevelOut, waitForRecoveriesToFinish) in our tests with methods available to SolrJ.\n\nA caveat: this is only implemented for collections with their own state.json.  I think it should be relatively easy to extend it to stateformat=1 collections as well if people think that's worth it. ",
            "id": "comment-15018193"
        },
        {
            "date": "2015-11-20T19:10:46+0000",
            "author": "Mark Miller",
            "content": "waitForThingsToLevelOut\n\nThat one is pretty test specific.\n\nI think it should be relatively easy to extend it to stateformat=1 collections as well if people think that's worth it.\n\nSomeone should remove stateformat=1 for Solr 6 in an ideal world. ",
            "id": "comment-15018564"
        },
        {
            "date": "2015-11-23T09:02:18+0000",
            "author": "Alan Woodward",
            "content": "Someone should remove stateformat=1 for Solr 6 in an ideal world\n\nAbsolutely.  Maybe this new API should just go into trunk for now?  If Solr 6 is coming early in the new year it makes sense to start adding things that don't need to worry about back-compatibility. ",
            "id": "comment-15021785"
        },
        {
            "date": "2016-02-29T11:55:45+0000",
            "author": "Alan Woodward",
            "content": "Updated patch, using the SolrCloudTestCase from SOLR-8758.\n\nThis has required a couple of tweaks to the collection-watching code in ZkStateReader, to allow for watching of non-existent collections. ",
            "id": "comment-15171785"
        },
        {
            "date": "2016-03-04T18:56:31+0000",
            "author": "Scott Blum",
            "content": "\n\tWhy is DocCollection.isFullyActive() static?\n\n\n\nstateWatchers.putIfAbsent(collection, Collections.synchronizedList(new ArrayList<>()));\n\n\n\tYou want computeIfAbsent() here to avoid the allocations.\n\n\n\n\n\tIf waitForState() exits with the TimeoutException, the watcher never gets removed.\n\n\n\n\n\tThere is a fundamental problem with how interestingCollections is getting managed now; there are external controls on that set, but now it's mixed up with the CollectionStateWatcher API.  As an example, CollectionStateWatcher adds but never removes; and an external caller could call removeZkWatcher on a collection that there's a listener for.\n\n\n\n\n\tThe way the code is structured with setCreationWatch and refreshAndWatch doesn't make sense to me. Why in the heck are they recursive?  I don't think you need all this.  I suspect what you really want is to move the call to notifyStateWatchers() and handle it more intelligently to not fire events if the state hasn't actually changed.  Basically, you want to call notifyStateWatchers() from within updateWatchedCollection() exactly at the 3 points we're emitting log messages.\n\n ",
            "id": "comment-15180368"
        },
        {
            "date": "2016-03-09T10:00:38+0000",
            "author": "Alan Woodward",
            "content": "Thanks for the review, Scott!  Here's an update patch.\n\nWhy is DocCollection.isFullyActive() static?\n\nBecause the DocCollection passed to onStateChanged() may be null if the collection doesn't exist, or has been deleted.\n\nIf waitForState() exits with the TimeoutException, the watcher never gets removed.\n\nFixed.\n\nBasically, you want to call notifyStateWatchers() from within updateWatchedCollection() exactly at the 3 points we're emitting log messages\n\nDone, thanks - that's considerably simpler.\n\nThere is a fundamental problem with how interestingCollections is getting managed now\n\nI've restructured this entirely.  Watches keep track of a) how many cores they have interested in them, and b) how many state watchers there are.  Changes to a CollectionWatch state are always done inside a ConcurrentHashMap.compute() method to keep them atomic.  This simplifies the watch handling in ZKController as well, and removes the abstraction leak where external objects controlled when to remove watches. ",
            "id": "comment-15186883"
        },
        {
            "date": "2016-03-21T20:51:11+0000",
            "author": "Scott Blum",
            "content": "I haven't forgotten this one, going to give the new patch a look this week (today or tomorrow) ",
            "id": "comment-15205105"
        },
        {
            "date": "2016-04-12T22:43:56+0000",
            "author": "Scott Blum",
            "content": "Looking at this now.  BTW, a Github PR might actually make this way easier.... ",
            "id": "comment-15238145"
        },
        {
            "date": "2016-04-12T22:46:21+0000",
            "author": "Scott Blum",
            "content": "I like the scheme of reference counting the ZkController core references ",
            "id": "comment-15238148"
        },
        {
            "date": "2016-04-12T22:47:13+0000",
            "author": "Scott Blum",
            "content": "Could collectionWatches and interestingCollections be unified into a single thing?\ncollectionWatches.keySet should always be equal to interestingCollections, so I don't a reason to have both ",
            "id": "comment-15238149"
        },
        {
            "date": "2016-04-12T22:50:52+0000",
            "author": "Scott Blum",
            "content": "nit: make the static type of collectionWatchers be ConcurrentMap?  Conveys intent better and plays nicer in IDE. ",
            "id": "comment-15238166"
        },
        {
            "date": "2016-04-12T22:54:16+0000",
            "author": "Scott Blum",
            "content": "unregisterCore needs a better guard against under-referencing, since it can be called from the outside.\nA caller could call unregisterCore enough times to make coreRefCount negative, offsetting a positive stateWatchers.size() and prematurely removing.\nMight even be advisable to throw an exception here on under reference. ",
            "id": "comment-15238170"
        },
        {
            "date": "2016-04-12T22:57:49+0000",
            "author": "Scott Blum",
            "content": "\nLOG.info(\"Deleting data for [{}]\", coll);\nnotifyStateWatchers(coll, newState);\n\n\n\nnewState is always null (IDE warning) so maybe just pass in null ",
            "id": "comment-15238178"
        },
        {
            "date": "2016-04-12T22:59:38+0000",
            "author": "Scott Blum",
            "content": "\n    if (watchers.size() == 0)\n      return;\n\n\n\nNo need to early exit here, the loop will do it anyway ",
            "id": "comment-15238180"
        },
        {
            "date": "2016-04-12T23:00:52+0000",
            "author": "Scott Blum",
            "content": "In notifyStateWatchers you can avoid some copies but just re-assigning the instance variable to a new empty set, and taking ownership of the existing set to fire events on. ",
            "id": "comment-15238183"
        },
        {
            "date": "2016-04-12T23:02:52+0000",
            "author": "Scott Blum",
            "content": "In getStateWatchers() you probably still want to wrap in a compute function to avoid weird race conditions and memory-visibility problems.  In particular there's absolutely no ordering guarantees on the reference to watch.stateWatchers ",
            "id": "comment-15238186"
        },
        {
            "date": "2016-04-12T23:09:23+0000",
            "author": "Scott Blum",
            "content": "fetchCollectionState() expectExists parameter doesn't make sense to me... I would have thought that if a non-null watcher is passed in, you always want to setup an exists watch if the node doesn't exist.  And if a null watcher is passed in, calling exists() is a waste of energy. ",
            "id": "comment-15238207"
        },
        {
            "date": "2016-04-12T23:11:55+0000",
            "author": "Scott Blum",
            "content": "registerCore/ unregisterCore should probably retain the previous doc:\n\n/** This is not a public API. Only used by ZkController */ ",
            "id": "comment-15238210"
        },
        {
            "date": "2016-04-12T23:13:36+0000",
            "author": "Scott Blum",
            "content": "getStateWatchers() could return null vs. empty set to differentiate between whether or not the collection is being watched, which would improve the precision of test assertions. ",
            "id": "comment-15238214"
        },
        {
            "date": "2016-04-12T23:30:57+0000",
            "author": "Scott Blum",
            "content": "I did get one failure on a test run:\n\"Did not see a fully active cluster after 30 seconds\"\n\nBut second run it passed. ",
            "id": "comment-15238243"
        },
        {
            "date": "2016-04-18T14:35:28+0000",
            "author": "Alan Woodward",
            "content": "Wow, thanks for the very thorough review Scott!  Here's an updated patch.\n\nCould collectionWatches and interestingCollections be unified into a single thing?\n\nUnfortunately not, as it's needed to detect collections which have migrated from state format 1 to state format 2.  There's almost certainly a nicer way of doing that, though - maybe in a follow-up issue?\n\nmake the static type of collectionWatchers be ConcurrentMap?\n\nI disagree here - we don't use any of the concurrent methods, so I think just using Map is fine?\n\nunregisterCore needs a better guard against under-referencing\n\nAdded.  I don't think throwing an exception is necessary, although maybe we should log a warning in this case?\n\nnewState is always null\n\nchanged\n\nNo need to early exit here\n\nchanged\n\nIn notifyStateWatchers you can avoid some copies...\n\nI think this ends up as a wash, given that you may end up creating multiple HashSets?  And we're only copying references, after all.\n\nIn getStateWatchers() you probably still want to wrap in a compute function...\n\nCompute() doesn't help here, I don't think?  And given that it's a test-only method, I'm not too concerned about accuracy.  I've made it return a copy rather than return the original set, which should stop weird things happening to it once it's been returned, though.\n\nfetchCollectionState() expectExists parameter doesn't make sense to me\n\nAgain, this is due to state format 1 - a collection state might be in clusterstate.json, so the collection-specific state might not exist.  I agree about the null watcher though, and have added a check around the exists call for that.\n\nregisterCore/ unregisterCore should probably retain the previous doc:\n\nAdded back\n\ngetStateWatchers() could return null vs. empty set\n\nNice idea, added.\n\nI've also added an explicit test for state format 1 collections, and updated the code so that it actually works  ",
            "id": "comment-15245755"
        },
        {
            "date": "2016-04-18T23:45:20+0000",
            "author": "Scott Blum",
            "content": "Don't suppose I could convince you to open a github PR?  Would make it much easier to review.  ",
            "id": "comment-15246778"
        },
        {
            "date": "2016-04-20T17:52:26+0000",
            "author": "ASF GitHub Bot",
            "content": "GitHub user romseygeek opened a pull request:\n\n    https://github.com/apache/lucene-solr/pull/32\n\n    SOLR-8323\n\n    Adds a CollectionStateWatcher API to listen for changes to collection state (SOLR-8323)\n\nYou can merge this pull request into a Git repository by running:\n\n    $ git pull https://github.com/romseygeek/lucene-solr SOLR-8323\n\nAlternatively you can review and apply these changes as the patch at:\n\n    https://github.com/apache/lucene-solr/pull/32.patch\n\nTo close this pull request, make a commit to your master/trunk branch\nwith (at least) the following in the commit message:\n\n    This closes #32\n\n\n\n ",
            "id": "comment-15250364"
        },
        {
            "date": "2016-04-20T17:54:00+0000",
            "author": "Alan Woodward",
            "content": "Pull request opened, review away!  I see that you've already committed some changes to the way legacy collections are dealt with, so we may well be able to remove the 'interestingcollections' list - will give it a go. ",
            "id": "comment-15250369"
        },
        {
            "date": "2016-04-27T14:39:02+0000",
            "author": "Alan Woodward",
            "content": "Scott Blum any comments on the pull request?  I'd like to get this in soon, as it will make it easier to clean up a bunch of tests. ",
            "id": "comment-15260262"
        },
        {
            "date": "2016-04-27T17:19:18+0000",
            "author": "Scott Blum",
            "content": "Sorry! I'll look at it today. Been swamped with other stuff.  ",
            "id": "comment-15260519"
        },
        {
            "date": "2016-04-28T21:15:06+0000",
            "author": "ASF GitHub Bot",
            "content": "Github user dragonsinth commented on a diff in the pull request:\n\n    https://github.com/apache/lucene-solr/pull/32#discussion_r61503724\n\n    \u2014 Diff: solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrClient.java \u2014\n    @@ -572,6 +574,40 @@ public void downloadConfig(String configName, Path downloadPath) throws IOExcept\n         zkStateReader.getConfigManager().downloadConfigDir(configName, downloadPath);\n       }\n\n    +  /**\n    +   * Block until a collection state matches a predicate, or a timeout\n    +   *\n    +   * Note that the predicate may be called again even after it has returned true, so\n    +   * implementors should avoid changing state within the predicate call itself.\n    +   *\n    +   * @param collection the collection to watch\n    +   * @param wait       how long to wait\n    +   * @param unit       the units of the wait parameter\n    +   * @param predicate  a \n{@link CollectionStatePredicate}\n to check the collection state\n    +   * @throws InterruptedException on interrupt\n    +   * @throws TimeoutException on timeout\n    +   */\n    +  public void waitForState(String collection, long wait, TimeUnit unit, CollectionStatePredicate predicate)\n    +      throws InterruptedException, TimeoutException \n{\n    +    connect();\n    +    zkStateReader.waitForState(collection, wait, unit, predicate);\n    +  }\n    +\n    +  /**\n    +   * Register a CollectionStateWatcher to be called when the cluster state for a collection changes\n    +   *\n    +   * Note that the watcher is unregistered after it has been called once.  To make a watcher persistent,\n    +   * it should re-register itself in its \n{@link CollectionStateWatcher#onStateChanged(Set, DocCollection)}\n    +   * call\n    +   *\n    +   * @param collection the collection to watch\n    +   * @param watcher    a watcher that will be called when the state changes\n    +   */\n    +  public void registerCollectionStateWatcher(String collection, CollectionStateWatcher watcher) \n{\n    +    connect();\n    +    zkStateReader.registerCollectionStateWatcher(collection, watcher);\n    +  }\n    +\n    \u2014 End diff \u2013\n\n    I would note that getZkStateReader() is a public method, is there value in adding these forwarding methods? ",
            "id": "comment-15263015"
        },
        {
            "date": "2016-04-28T21:17:07+0000",
            "author": "ASF GitHub Bot",
            "content": "Github user dragonsinth commented on a diff in the pull request:\n\n    https://github.com/apache/lucene-solr/pull/32#discussion_r61504017\n\n    \u2014 Diff: solr/solrj/src/java/org/apache/solr/common/cloud/CollectionStatePredicate.java \u2014\n    @@ -0,0 +1,41 @@\n    +package org.apache.solr.common.cloud;\n    +\n    +/*\n    + * Licensed to the Apache Software Foundation (ASF) under one or more\n    + * contributor license agreements.  See the NOTICE file distributed with\n    + * this work for additional information regarding copyright ownership.\n    + * The ASF licenses this file to You under the Apache License, Version 2.0\n    + * (the \"License\"); you may not use this file except in compliance with\n    + * the License.  You may obtain a copy of the License at\n    + *\n    + *     http://www.apache.org/licenses/LICENSE-2.0\n    + *\n    + * Unless required by applicable law or agreed to in writing, software\n    + * distributed under the License is distributed on an \"AS IS\" BASIS,\n    + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    + * See the License for the specific language governing permissions and\n    + * limitations under the License.\n    + */\n    +\n    +import java.util.Set;\n    +import java.util.concurrent.TimeUnit;\n    +\n    +/**\n    + * Interface to determine if a collection state matches a required state\n    + *\n    + * @see ZkStateReader#waitForState(String, long, TimeUnit, CollectionStatePredicate)\n    + */\n    +public interface CollectionStatePredicate {\n    +\n    +  /**\n    +   * Check the collection state matches a required state\n    +   *\n    +   * The collectionState parameter may be null if the collection does not exist\n    +   * or has been deleted\n    \u2014 End diff \u2013\n\n    This wants to be `@param collectionState the current collection state, or null if the collection doesn't exist or has been deleted` ",
            "id": "comment-15263020"
        },
        {
            "date": "2016-04-28T21:21:53+0000",
            "author": "ASF GitHub Bot",
            "content": "Github user dragonsinth commented on a diff in the pull request:\n\n    https://github.com/apache/lucene-solr/pull/32#discussion_r61504670\n\n    \u2014 Diff: solr/solrj/src/java/org/apache/solr/common/cloud/CollectionStateWatcher.java \u2014\n    @@ -0,0 +1,42 @@\n    +package org.apache.solr.common.cloud;\n    +\n    +/*\n    + * Licensed to the Apache Software Foundation (ASF) under one or more\n    + * contributor license agreements.  See the NOTICE file distributed with\n    + * this work for additional information regarding copyright ownership.\n    + * The ASF licenses this file to You under the Apache License, Version 2.0\n    + * (the \"License\"); you may not use this file except in compliance with\n    + * the License.  You may obtain a copy of the License at\n    + *\n    + *     http://www.apache.org/licenses/LICENSE-2.0\n    + *\n    + * Unless required by applicable law or agreed to in writing, software\n    + * distributed under the License is distributed on an \"AS IS\" BASIS,\n    + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    + * See the License for the specific language governing permissions and\n    + * limitations under the License.\n    +*/\n    +\n    +import java.util.Set;\n    +\n    +/**\n    + * Callback registered with \n{@link ZkStateReader#registerCollectionStateWatcher(String, CollectionStateWatcher)}\n    + * and called whenever the collection state changes.\n    + */\n    +public interface CollectionStateWatcher \n{\n    +\n    +  /**\n    +   * Called when the collection we are registered against has a change of state\n    +   *\n    +   * Note that, due to the way Zookeeper watchers are implemented, a single call may be\n    +   * the result of several state changes\n    +   *\n    +   * A watcher is unregistered after it has been called once.  To make a watcher persistent,\n    +   * implementors should re-register during this call.\n    +   *\n    +   * @param liveNodes       the set of live nodes\n    +   * @param collectionState the new collection state\n    +   */\n    +  void onStateChanged(Set<String> liveNodes, DocCollection collectionState);\n    +\n    +}\n    \u2014 End diff \u2013\n\n    I just want to toss out an idea here after looking at this some more.  I notice that CollectionStateWatcher and CollectionStatePredicate are nearly identical.  What would you think about combining the two into a single interface?\n\n    The signature could be e.g.:\n\n    bool stateChanged(liveNodes, collectionState)\n\n    In a watch context, the return value means \"keep watching?\".  So return true to reset the watcher and continue getting updates, or return false to stop watching.\n\n    In a predicate context, the return value means \"keep waiting?\".  So return true to keep waiting, or return false if you've finally seen what you were waiting for.\n\n    They'll both have the same semantic meaning either way. ",
            "id": "comment-15263034"
        },
        {
            "date": "2016-04-28T21:23:02+0000",
            "author": "ASF GitHub Bot",
            "content": "Github user dragonsinth commented on a diff in the pull request:\n\n    https://github.com/apache/lucene-solr/pull/32#discussion_r61504824\n\n    \u2014 Diff: solr/solrj/src/java/org/apache/solr/common/cloud/DocCollection.java \u2014\n    @@ -210,6 +213,38 @@ public Replica getReplica(String coreNodeName) \n{\n         return null;\n       }\n\n    +  /**\n    +   * Check that all replicas in a collection are live\n    +   *\n    +   * @see CollectionStatePredicate\n    +   */\n    +  public static boolean isFullyActive(Set<String> liveNodes, DocCollection collectionState) {\n    +    Objects.requireNonNull(liveNodes);\n    +    if (collectionState == null)\n    +      return false;\n    +    for (Slice slice : collectionState) {\n    +      for (Replica replica : slice) \n{\n    +        if (replica.isActive(liveNodes) == false)\n    +          return false;\n    +      }\n    +    }\n    +    return true;\n    +  }\n    +\n    +  /**\n    +   * Returns true if the passed in DocCollection is null\n    +   *\n    +   * @see CollectionStatePredicate\n    +   */\n    +  public static boolean isDeleted(Set<String> liveNodes, DocCollection collectionState) \n{\n    +    return collectionState == null;\n    +  }\n    \u2014 End diff \u2013\n\n    maybe `exists`? isDeleted implies that it used to exist, but it may have never been created ",
            "id": "comment-15263038"
        },
        {
            "date": "2016-04-28T21:41:12+0000",
            "author": "ASF GitHub Bot",
            "content": "Github user dragonsinth commented on a diff in the pull request:\n\n    https://github.com/apache/lucene-solr/pull/32#discussion_r61507382\n\n    \u2014 Diff: solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader.java \u2014\n    @@ -484,6 +498,12 @@ private void refreshLegacyClusterState(Watcher watcher)\n             }\n             this.legacyCollectionStates = loadedData.getCollectionStates();\n             this.legacyClusterStateVersion = stat.getVersion();\n    +        for (Map.Entry<String, ClusterState.CollectionRef> entry : this.legacyCollectionStates.entrySet()) {\n    +          if (entry.getValue().isLazilyLoaded() == false) \n{\n    +            // a watched collection - trigger notifications\n    +            notifyStateWatchers(entry.getKey(), entry.getValue().get());\n    +          }\n    +        }\n    \u2014 End diff \u2013\n\n    I think it would add a lot of value here to actually check differences.  There really wouldn't be much computational work since you could restrict it to watched collections.  Something like:\n\n    ```\n            for (Map.Entry<String, CollectionWatch> watchEntry : this.collectionWatches.entrySet()) {\n              String coll = watchEntry.getKey();\n              CollectionWatch collWatch = watchEntry.getValue();\n              DocCollection newState = this.legacyCollectionStates.get(coll).get();\n              if (!collWatch.stateWatchers.isEmpty()\n                  && !Objects.equals(oldCollectionStates.get(coll).get(), newState)) \n{\n                notifyStateWatchers(coll, newState);\n              }\n            }\n    ```\n ",
            "id": "comment-15263080"
        },
        {
            "date": "2016-04-28T21:45:44+0000",
            "author": "ASF GitHub Bot",
            "content": "Github user dragonsinth commented on a diff in the pull request:\n\n    https://github.com/apache/lucene-solr/pull/32#discussion_r61507961\n\n    \u2014 Diff: solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader.java \u2014\n    @@ -131,6 +132,19 @@\n\n       private final Runnable securityNodeListener;\n\n    +  private Map<String, CollectionWatch> collectionWatches = new ConcurrentHashMap<>();\n    \u2014 End diff \u2013\n\n    The reason I made a comment about using the concrete type here is that it makes it much easier to work with as a developer.  When you can see that the static type of this variable is ConcurrentHashMap, that helps you evaluate the code that touches it.\n\n    For example, when you use IDE features to 'click through' a method call or view the javadoc on a called method, you get the ConcurrentHashMap version of the javadoc/method instead of the Map version, which helps you more easily evaluate the correctness. ",
            "id": "comment-15263087"
        },
        {
            "date": "2016-04-28T21:53:53+0000",
            "author": "ASF GitHub Bot",
            "content": "Github user dragonsinth commented on a diff in the pull request:\n\n    https://github.com/apache/lucene-solr/pull/32#discussion_r61508998\n\n    \u2014 Diff: solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader.java \u2014\n    @@ -1066,32 +1079,201 @@ public static String getCollectionPath(String coll) \n{\n         return COLLECTIONS_ZKNODE+\"/\"+coll + \"/state.json\";\n       }\n\n\n\tpublic void addCollectionWatch(String coll) {\n\tif (interestingCollections.add(coll)) {\n\tLOG.info(\"addZkWatch [{}]\", coll);\n\tnew StateWatcher(coll).refreshAndWatch(false);\n    +  /**\n    +   * Notify this reader that a local Core is a member of a collection, and so that collection\n    +   * state should be watched.\n    +   *\n    +   * Not a public API.  This method should only be called from ZkController.\n    +   *\n    +   * The number of cores per-collection is tracked, and adding multiple cores from the same\n    +   * collection does not increase the number of watches.\n    +   *\n    +   * @param collection the collection that the core is a member of\n    +   *\n    +   * @see ZkStateReader#unregisterCore(String)\n    +   */\n    +  public void registerCore(String collection) {\n    +    AtomicBoolean reconstructState = new AtomicBoolean(false);\n    +    collectionWatches.compute(collection, (k, v) -> \nUnknown macro: {    +      if (v == null) {\n    +        reconstructState.set(true);\n    +        v = new CollectionWatch();\n    +      }    +      v.coreRefCount++;    +      return v;    +    } \n);\n    +    if (reconstructState.get()) \nUnknown macro: {    +      new StateWatcher(collection).refreshAndWatch();    +      synchronized (getUpdateLock()) {\n    +        constructState();\n    +      }\n    +    }\n    +  }\n    +\n    +  /**\n    +   * Notify this reader that a local core that is a member of a collection has been closed.\n    +   *\n    +   * Not a public API.  This method should only be called from ZkController.\n    +   *\n    +   * If no cores are registered for a collection, and there are no {@link CollectionStateWatcher}s\n    +   * for that collection either, the collection watch will be removed.\n    +   *\n    +   * @param collection the collection that the core belongs to\n    +   */\n    +  public void unregisterCore(String collection) {\n    +    AtomicBoolean reconstructState = new AtomicBoolean(false);\n    +    collectionWatches.compute(collection, (k, v) -> {\n    +      if (v == null)\n    +        return null;\n    +      if (v.coreRefCount > 0)\n    +        v.coreRefCount--;\n    +      if (v.canBeRemoved()) {\n    +        watchedCollectionStates.remove(collection);\n    +        lazyCollectionStates.put(collection, new LazyCollectionRef(collection));\n    +        reconstructState.set(true);\n    +        return null;\n    +      }\n    +      return v;\n    +    });\n    +    if (reconstructState.get()) {\n    +      synchronized (getUpdateLock()) {    +        constructState();    +      }    +    } \n    +  }\n    +\n    +  /**\n    +   * Register a CollectionStateWatcher to be called when the state of a collection changes\n    +   *\n    +   * A given CollectionStateWatcher will be only called once.  If you want to have a persistent watcher,\n    +   * it should register itself again in its \n{@link CollectionStateWatcher#onStateChanged(Set, DocCollection)}\n    +   * method.\n    +   */\n    +  public void registerCollectionStateWatcher(String collection, CollectionStateWatcher stateWatcher) {\n    +    AtomicBoolean watchSet = new AtomicBoolean(false);\n    +    collectionWatches.compute(collection, (k, v) -> \nUnknown macro: {    +      if (v == null) {\n    +        v = new CollectionWatch();\n    +        watchSet.set(true);\n    +      }    +      v.stateWatchers.add(stateWatcher);    +      return v;    +    } \n);\n    +    if (watchSet.get()) \nUnknown macro: {    +      new StateWatcher(collection).refreshAndWatch();           synchronized (getUpdateLock()) {\n             constructState();\n           }         } \n       }\n\n\n\n    +  /**\n    +   * Block until a CollectionStatePredicate returns true, or the wait times out\n    +   *\n    +   * Note that the predicate may be called again even after it has returned true, so\n    +   * implementors should avoid changing state within the predicate call itself.\n    +   *\n    +   * @param collection the collection to watch\n    +   * @param wait       how long to wait\n    +   * @param unit       the units of the wait parameter\n    +   * @param predicate  the predicate to call on state changes\n    +   * @throws InterruptedException on interrupt\n    +   * @throws TimeoutException on timeout\n    +   */\n    +  public void waitForState(final String collection, long wait, TimeUnit unit, CollectionStatePredicate predicate)\n    \u2014 End diff \u2013\n\n    @shalinmangar this is what I was referring to, I know you're working on getting Overseer to not peg ZK polling for state changes on unwatched collections, this PR provides an easy mechanism to temporarily watch collections of interest. ",
            "id": "comment-15263094"
        },
        {
            "date": "2016-04-28T21:59:09+0000",
            "author": "ASF GitHub Bot",
            "content": "Github user dragonsinth commented on a diff in the pull request:\n\n    https://github.com/apache/lucene-solr/pull/32#discussion_r61509699\n\n    \u2014 Diff: solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader.java \u2014\n    @@ -1066,32 +1079,201 @@ public static String getCollectionPath(String coll) \n{\n         return COLLECTIONS_ZKNODE+\"/\"+coll + \"/state.json\";\n       }\n\n\n\tpublic void addCollectionWatch(String coll) {\n\tif (interestingCollections.add(coll)) {\n\tLOG.info(\"addZkWatch [{}]\", coll);\n\tnew StateWatcher(coll).refreshAndWatch(false);\n    +  /**\n    +   * Notify this reader that a local Core is a member of a collection, and so that collection\n    +   * state should be watched.\n    +   *\n    +   * Not a public API.  This method should only be called from ZkController.\n    +   *\n    +   * The number of cores per-collection is tracked, and adding multiple cores from the same\n    +   * collection does not increase the number of watches.\n    +   *\n    +   * @param collection the collection that the core is a member of\n    +   *\n    +   * @see ZkStateReader#unregisterCore(String)\n    +   */\n    +  public void registerCore(String collection) {\n    +    AtomicBoolean reconstructState = new AtomicBoolean(false);\n    +    collectionWatches.compute(collection, (k, v) -> \nUnknown macro: {    +      if (v == null) {\n    +        reconstructState.set(true);\n    +        v = new CollectionWatch();\n    +      }    +      v.coreRefCount++;    +      return v;    +    } \n);\n    +    if (reconstructState.get()) \nUnknown macro: {    +      new StateWatcher(collection).refreshAndWatch();    +      synchronized (getUpdateLock()) {\n    +        constructState();\n    +      }\n    +    }\n    +  }\n    +\n    +  /**\n    +   * Notify this reader that a local core that is a member of a collection has been closed.\n    +   *\n    +   * Not a public API.  This method should only be called from ZkController.\n    +   *\n    +   * If no cores are registered for a collection, and there are no {@link CollectionStateWatcher}s\n    +   * for that collection either, the collection watch will be removed.\n    +   *\n    +   * @param collection the collection that the core belongs to\n    +   */\n    +  public void unregisterCore(String collection) {\n    +    AtomicBoolean reconstructState = new AtomicBoolean(false);\n    +    collectionWatches.compute(collection, (k, v) -> {\n    +      if (v == null)\n    +        return null;\n    +      if (v.coreRefCount > 0)\n    +        v.coreRefCount--;\n    +      if (v.canBeRemoved()) {\n    +        watchedCollectionStates.remove(collection);\n    +        lazyCollectionStates.put(collection, new LazyCollectionRef(collection));\n    +        reconstructState.set(true);\n    +        return null;\n    +      }\n    +      return v;\n    +    });\n    +    if (reconstructState.get()) {\n    +      synchronized (getUpdateLock()) {    +        constructState();    +      }    +    } \n    +  }\n    +\n    +  /**\n    +   * Register a CollectionStateWatcher to be called when the state of a collection changes\n    +   *\n    +   * A given CollectionStateWatcher will be only called once.  If you want to have a persistent watcher,\n    +   * it should register itself again in its \n{@link CollectionStateWatcher#onStateChanged(Set, DocCollection)}\n    +   * method.\n    +   */\n    +  public void registerCollectionStateWatcher(String collection, CollectionStateWatcher stateWatcher) {\n    +    AtomicBoolean watchSet = new AtomicBoolean(false);\n    +    collectionWatches.compute(collection, (k, v) -> \nUnknown macro: {    +      if (v == null) {\n    +        v = new CollectionWatch();\n    +        watchSet.set(true);\n    +      }    +      v.stateWatchers.add(stateWatcher);    +      return v;    +    } \n);\n    +    if (watchSet.get()) \nUnknown macro: {    +      new StateWatcher(collection).refreshAndWatch();           synchronized (getUpdateLock()) {\n             constructState();\n           }         } \n       }\n\n\n\n    +  /**\n    +   * Block until a CollectionStatePredicate returns true, or the wait times out\n    +   *\n    +   * Note that the predicate may be called again even after it has returned true, so\n    +   * implementors should avoid changing state within the predicate call itself.\n    \u2014 End diff \u2013\n\n    I think we could tighten this code up to ensure that predicate never gets call concurrently from two different threads at the same time, this would simplify things for clients and handle the case of calling it twice when it succeeds immediately. ",
            "id": "comment-15263108"
        },
        {
            "date": "2016-04-28T22:00:56+0000",
            "author": "ASF GitHub Bot",
            "content": "Github user dragonsinth commented on a diff in the pull request:\n\n    https://github.com/apache/lucene-solr/pull/32#discussion_r61509937\n\n    \u2014 Diff: solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader.java \u2014\n    @@ -1066,32 +1079,201 @@ public static String getCollectionPath(String coll) \n{\n         return COLLECTIONS_ZKNODE+\"/\"+coll + \"/state.json\";\n       }\n\n\n\tpublic void addCollectionWatch(String coll) {\n\tif (interestingCollections.add(coll)) {\n\tLOG.info(\"addZkWatch [{}]\", coll);\n\tnew StateWatcher(coll).refreshAndWatch(false);\n    +  /**\n    +   * Notify this reader that a local Core is a member of a collection, and so that collection\n    +   * state should be watched.\n    +   *\n    +   * Not a public API.  This method should only be called from ZkController.\n    +   *\n    +   * The number of cores per-collection is tracked, and adding multiple cores from the same\n    +   * collection does not increase the number of watches.\n    +   *\n    +   * @param collection the collection that the core is a member of\n    +   *\n    +   * @see ZkStateReader#unregisterCore(String)\n    +   */\n    +  public void registerCore(String collection) {\n    +    AtomicBoolean reconstructState = new AtomicBoolean(false);\n    +    collectionWatches.compute(collection, (k, v) -> \nUnknown macro: {    +      if (v == null) {\n    +        reconstructState.set(true);\n    +        v = new CollectionWatch();\n    +      }    +      v.coreRefCount++;    +      return v;    +    } \n);\n    +    if (reconstructState.get()) \nUnknown macro: {    +      new StateWatcher(collection).refreshAndWatch();    +      synchronized (getUpdateLock()) {\n    +        constructState();\n    +      }\n    +    }\n    +  }\n    +\n    +  /**\n    +   * Notify this reader that a local core that is a member of a collection has been closed.\n    +   *\n    +   * Not a public API.  This method should only be called from ZkController.\n    +   *\n    +   * If no cores are registered for a collection, and there are no {@link CollectionStateWatcher}s\n    +   * for that collection either, the collection watch will be removed.\n    +   *\n    +   * @param collection the collection that the core belongs to\n    +   */\n    +  public void unregisterCore(String collection) {\n    +    AtomicBoolean reconstructState = new AtomicBoolean(false);\n    +    collectionWatches.compute(collection, (k, v) -> {\n    +      if (v == null)\n    +        return null;\n    +      if (v.coreRefCount > 0)\n    +        v.coreRefCount--;\n    +      if (v.canBeRemoved()) {\n    +        watchedCollectionStates.remove(collection);\n    +        lazyCollectionStates.put(collection, new LazyCollectionRef(collection));\n    +        reconstructState.set(true);\n    +        return null;\n    +      }\n    +      return v;\n    +    });\n    +    if (reconstructState.get()) {\n    +      synchronized (getUpdateLock()) {    +        constructState();    +      }    +    } \n    +  }\n    +\n    +  /**\n    +   * Register a CollectionStateWatcher to be called when the state of a collection changes\n    +   *\n    +   * A given CollectionStateWatcher will be only called once.  If you want to have a persistent watcher,\n    +   * it should register itself again in its \n{@link CollectionStateWatcher#onStateChanged(Set, DocCollection)}\n    +   * method.\n    +   */\n    +  public void registerCollectionStateWatcher(String collection, CollectionStateWatcher stateWatcher) {\n    +    AtomicBoolean watchSet = new AtomicBoolean(false);\n    +    collectionWatches.compute(collection, (k, v) -> \nUnknown macro: {    +      if (v == null) {\n    +        v = new CollectionWatch();\n    +        watchSet.set(true);\n    +      }    +      v.stateWatchers.add(stateWatcher);    +      return v;    +    } \n);\n    +    if (watchSet.get()) \nUnknown macro: {    +      new StateWatcher(collection).refreshAndWatch();           synchronized (getUpdateLock()) {\n             constructState();\n           }         } \n       }\n\n\n\n    +  /**\n    +   * Block until a CollectionStatePredicate returns true, or the wait times out\n    +   *\n    +   * Note that the predicate may be called again even after it has returned true, so\n    +   * implementors should avoid changing state within the predicate call itself.\n    +   *\n    +   * @param collection the collection to watch\n    +   * @param wait       how long to wait\n    +   * @param unit       the units of the wait parameter\n    +   * @param predicate  the predicate to call on state changes\n    +   * @throws InterruptedException on interrupt\n    +   * @throws TimeoutException on timeout\n    +   */\n    +  public void waitForState(final String collection, long wait, TimeUnit unit, CollectionStatePredicate predicate)\n    +      throws InterruptedException, TimeoutException {\n    +\n    +    final CountDownLatch latch = new CountDownLatch(1);\n    +\n    +    CollectionStateWatcher watcher = new CollectionStateWatcher() {\n    +      @Override\n    +      public void onStateChanged(Set<String> liveNodes, DocCollection collectionState) {\n    +        if (predicate.matches(liveNodes, collectionState)) \n{\n    +          latch.countDown();\n    +        }\n else \n{\n    +          registerCollectionStateWatcher(collection, this);\n    +        }\n    +      }\n    +    };\n    +    registerCollectionStateWatcher(collection, watcher);\n    +\n    +    try \n{\n    +      // check the current state\n    +      DocCollection dc = clusterState.getCollectionOrNull(collection);\n    +      if (predicate.matches(liveNodes, dc))\n    +        return;\n    +\n    +      // wait for the watcher predicate to return true, or time out\n    +      if (!latch.await(wait, unit))\n    +        throw new TimeoutException();\n    +\n    +    }\n    +    finally \n{\n    +      removeCollectionStateWatcher(collection, watcher);\n    +    }\n    +  }\n    +\n    +  /**\n    +   * Remove a watcher from a collection's watch list.\n    +   *\n    +   * This allows Zookeeper watches to be removed if there is no interest in the\n    +   * collection.\n    +   *\n    +   * @param collection the collection\n    +   * @param watcher    the watcher\n    +   */\n    +  public void removeCollectionStateWatcher(String collection, CollectionStateWatcher watcher) {\n    +    collectionWatches.compute(collection, (k, v) -> \n{\n    +      if (v == null)\n    +        return null;\n    +      v.stateWatchers.remove(watcher);\n    +      if (v.canBeRemoved())\n    +        return null;\n    +      return v;\n    +    }\n);\n    +  }\n    +\n    +  private void notifyStateWatchers(String collection, DocCollection collectionState) {\n    \u2014 End diff \u2013\n\n    I think we should pass in liveNodes; particularly in cases where we're firing a bunch of watchers, or even firing watchers on a bunch of collections at once, we can avoid the repeated volatile reads. ",
            "id": "comment-15263112"
        },
        {
            "date": "2016-04-28T22:02:50+0000",
            "author": "ASF GitHub Bot",
            "content": "Github user dragonsinth commented on a diff in the pull request:\n\n    https://github.com/apache/lucene-solr/pull/32#discussion_r61510100\n\n    \u2014 Diff: solr/solrj/src/java/org/apache/solr/common/cloud/CollectionStateWatcher.java \u2014\n    @@ -0,0 +1,42 @@\n    +package org.apache.solr.common.cloud;\n    +\n    +/*\n    + * Licensed to the Apache Software Foundation (ASF) under one or more\n    + * contributor license agreements.  See the NOTICE file distributed with\n    + * this work for additional information regarding copyright ownership.\n    + * The ASF licenses this file to You under the Apache License, Version 2.0\n    + * (the \"License\"); you may not use this file except in compliance with\n    + * the License.  You may obtain a copy of the License at\n    + *\n    + *     http://www.apache.org/licenses/LICENSE-2.0\n    + *\n    + * Unless required by applicable law or agreed to in writing, software\n    + * distributed under the License is distributed on an \"AS IS\" BASIS,\n    + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    + * See the License for the specific language governing permissions and\n    + * limitations under the License.\n    +*/\n    +\n    +import java.util.Set;\n    +\n    +/**\n    + * Callback registered with \n{@link ZkStateReader#registerCollectionStateWatcher(String, CollectionStateWatcher)}\n    + * and called whenever the collection state changes.\n    + */\n    \u2014 End diff \u2013\n\n    If we're not going to be firing events on all watchers whenever live_nodes changes, we should be very clear about this. ",
            "id": "comment-15263119"
        },
        {
            "date": "2016-04-28T22:03:22+0000",
            "author": "ASF GitHub Bot",
            "content": "Github user dragonsinth commented on a diff in the pull request:\n\n    https://github.com/apache/lucene-solr/pull/32#discussion_r61510208\n\n    \u2014 Diff: solr/test-framework/src/java/org/apache/solr/cloud/MiniSolrCloudCluster.java \u2014\n    @@ -348,7 +358,13 @@ public JettySolrRunner stopJettySolrRunner(int index) throws Exception \n{\n         return jetty;\n       }\n\n\n\tprotected JettySolrRunner startJettySolrRunner(JettySolrRunner jetty) throws Exception {\n    +  /**\n    +   * Add a previously stopped node back to the cluster\n    +   * @param jetty a \n{@link JettySolrRunner}\n previously returned by \n{@link #stopJettySolrRunner(int)}\n    +   * @return the started node\n    +   * @throws Exception on error\n    +   */\n    +  public JettySolrRunner startJettySolrRunner(JettySolrRunner jetty) throws Exception {\n\t\n\t\t\n\t\t\n\t\t\tEnd diff \u2013\n\t\t\n\t\t\n\t\n\t\n\n\n\n    Are the changes in this file related to this PR? ",
            "id": "comment-15263120"
        },
        {
            "date": "2016-04-28T22:05:25+0000",
            "author": "ASF GitHub Bot",
            "content": "Github user dragonsinth commented on the pull request:\n\n    https://github.com/apache/lucene-solr/pull/32#issuecomment-215576790\n\n    Looking good, a little more high-level feedback.  @shalinmangar I think you should take a look also.\n\n    Have you run the tests extensively?  The first time I ran I got a failure, but after that it's been fairly reliable, but I haven't beasted. ",
            "id": "comment-15263122"
        },
        {
            "date": "2016-04-29T07:20:19+0000",
            "author": "ASF GitHub Bot",
            "content": "Github user romseygeek commented on a diff in the pull request:\n\n    https://github.com/apache/lucene-solr/pull/32#discussion_r61541687\n\n    \u2014 Diff: solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrClient.java \u2014\n    @@ -572,6 +574,40 @@ public void downloadConfig(String configName, Path downloadPath) throws IOExcept\n         zkStateReader.getConfigManager().downloadConfigDir(configName, downloadPath);\n       }\n\n    +  /**\n    +   * Block until a collection state matches a predicate, or a timeout\n    +   *\n    +   * Note that the predicate may be called again even after it has returned true, so\n    +   * implementors should avoid changing state within the predicate call itself.\n    +   *\n    +   * @param collection the collection to watch\n    +   * @param wait       how long to wait\n    +   * @param unit       the units of the wait parameter\n    +   * @param predicate  a \n{@link CollectionStatePredicate}\n to check the collection state\n    +   * @throws InterruptedException on interrupt\n    +   * @throws TimeoutException on timeout\n    +   */\n    +  public void waitForState(String collection, long wait, TimeUnit unit, CollectionStatePredicate predicate)\n    +      throws InterruptedException, TimeoutException \n{\n    +    connect();\n    +    zkStateReader.waitForState(collection, wait, unit, predicate);\n    +  }\n    +\n    +  /**\n    +   * Register a CollectionStateWatcher to be called when the cluster state for a collection changes\n    +   *\n    +   * Note that the watcher is unregistered after it has been called once.  To make a watcher persistent,\n    +   * it should re-register itself in its \n{@link CollectionStateWatcher#onStateChanged(Set, DocCollection)}\n    +   * call\n    +   *\n    +   * @param collection the collection to watch\n    +   * @param watcher    a watcher that will be called when the state changes\n    +   */\n    +  public void registerCollectionStateWatcher(String collection, CollectionStateWatcher watcher) \n{\n    +    connect();\n    +    zkStateReader.registerCollectionStateWatcher(collection, watcher);\n    +  }\n    +\n    \u2014 End diff \u2013\n\n    TBH, I don't think getZkStateReader() should be a public method - client code that's using CloudSolrClient shouldn't need to interact with low-level stuff like the state reader.  Maybe we only need to expose waitForState() here though. ",
            "id": "comment-15263665"
        },
        {
            "date": "2016-04-29T07:23:40+0000",
            "author": "ASF GitHub Bot",
            "content": "Github user romseygeek commented on a diff in the pull request:\n\n    https://github.com/apache/lucene-solr/pull/32#discussion_r61541928\n\n    \u2014 Diff: solr/test-framework/src/java/org/apache/solr/cloud/MiniSolrCloudCluster.java \u2014\n    @@ -348,7 +358,13 @@ public JettySolrRunner stopJettySolrRunner(int index) throws Exception \n{\n         return jetty;\n       }\n\n\n\tprotected JettySolrRunner startJettySolrRunner(JettySolrRunner jetty) throws Exception {\n    +  /**\n    +   * Add a previously stopped node back to the cluster\n    +   * @param jetty a \n{@link JettySolrRunner}\n previously returned by \n{@link #stopJettySolrRunner(int)}\n    +   * @return the started node\n    +   * @throws Exception on error\n    +   */\n    +  public JettySolrRunner startJettySolrRunner(JettySolrRunner jetty) throws Exception {\n\t\n\t\t\n\t\t\n\t\t\tEnd diff \u2013\n\t\t\n\t\t\n\t\n\t\n\n\n\n    Yes, they're needed to ensure that the cluster is in the same state for all tests. ",
            "id": "comment-15263669"
        },
        {
            "date": "2016-04-29T07:24:27+0000",
            "author": "ASF GitHub Bot",
            "content": "Github user romseygeek commented on the pull request:\n\n    https://github.com/apache/lucene-solr/pull/32#issuecomment-215646194\n\n    Thanks for the comments! I'll try and incorporate your suggestions and see how far we get. ",
            "id": "comment-15263670"
        },
        {
            "date": "2016-04-29T12:19:59+0000",
            "author": "ASF GitHub Bot",
            "content": "Github user romseygeek commented on a diff in the pull request:\n\n    https://github.com/apache/lucene-solr/pull/32#discussion_r61568081\n\n    \u2014 Diff: solr/solrj/src/java/org/apache/solr/common/cloud/CollectionStateWatcher.java \u2014\n    @@ -0,0 +1,42 @@\n    +package org.apache.solr.common.cloud;\n    +\n    +/*\n    + * Licensed to the Apache Software Foundation (ASF) under one or more\n    + * contributor license agreements.  See the NOTICE file distributed with\n    + * this work for additional information regarding copyright ownership.\n    + * The ASF licenses this file to You under the Apache License, Version 2.0\n    + * (the \"License\"); you may not use this file except in compliance with\n    + * the License.  You may obtain a copy of the License at\n    + *\n    + *     http://www.apache.org/licenses/LICENSE-2.0\n    + *\n    + * Unless required by applicable law or agreed to in writing, software\n    + * distributed under the License is distributed on an \"AS IS\" BASIS,\n    + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    + * See the License for the specific language governing permissions and\n    + * limitations under the License.\n    +*/\n    +\n    +import java.util.Set;\n    +\n    +/**\n    + * Callback registered with \n{@link ZkStateReader#registerCollectionStateWatcher(String, CollectionStateWatcher)}\n    + * and called whenever the collection state changes.\n    + */\n    \u2014 End diff \u2013\n\n    Hm, that's a good point.  Maybe we should be doing just that? ",
            "id": "comment-15263973"
        },
        {
            "date": "2016-04-29T12:31:25+0000",
            "author": "ASF GitHub Bot",
            "content": "Github user romseygeek commented on a diff in the pull request:\n\n    https://github.com/apache/lucene-solr/pull/32#discussion_r61569303\n\n    \u2014 Diff: solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader.java \u2014\n    @@ -1066,32 +1079,201 @@ public static String getCollectionPath(String coll) \n{\n         return COLLECTIONS_ZKNODE+\"/\"+coll + \"/state.json\";\n       }\n\n\n\tpublic void addCollectionWatch(String coll) {\n\tif (interestingCollections.add(coll)) {\n\tLOG.info(\"addZkWatch [{}]\", coll);\n\tnew StateWatcher(coll).refreshAndWatch(false);\n    +  /**\n    +   * Notify this reader that a local Core is a member of a collection, and so that collection\n    +   * state should be watched.\n    +   *\n    +   * Not a public API.  This method should only be called from ZkController.\n    +   *\n    +   * The number of cores per-collection is tracked, and adding multiple cores from the same\n    +   * collection does not increase the number of watches.\n    +   *\n    +   * @param collection the collection that the core is a member of\n    +   *\n    +   * @see ZkStateReader#unregisterCore(String)\n    +   */\n    +  public void registerCore(String collection) {\n    +    AtomicBoolean reconstructState = new AtomicBoolean(false);\n    +    collectionWatches.compute(collection, (k, v) -> \nUnknown macro: {    +      if (v == null) {\n    +        reconstructState.set(true);\n    +        v = new CollectionWatch();\n    +      }    +      v.coreRefCount++;    +      return v;    +    } \n);\n    +    if (reconstructState.get()) \nUnknown macro: {    +      new StateWatcher(collection).refreshAndWatch();    +      synchronized (getUpdateLock()) {\n    +        constructState();\n    +      }\n    +    }\n    +  }\n    +\n    +  /**\n    +   * Notify this reader that a local core that is a member of a collection has been closed.\n    +   *\n    +   * Not a public API.  This method should only be called from ZkController.\n    +   *\n    +   * If no cores are registered for a collection, and there are no {@link CollectionStateWatcher}s\n    +   * for that collection either, the collection watch will be removed.\n    +   *\n    +   * @param collection the collection that the core belongs to\n    +   */\n    +  public void unregisterCore(String collection) {\n    +    AtomicBoolean reconstructState = new AtomicBoolean(false);\n    +    collectionWatches.compute(collection, (k, v) -> {\n    +      if (v == null)\n    +        return null;\n    +      if (v.coreRefCount > 0)\n    +        v.coreRefCount--;\n    +      if (v.canBeRemoved()) {\n    +        watchedCollectionStates.remove(collection);\n    +        lazyCollectionStates.put(collection, new LazyCollectionRef(collection));\n    +        reconstructState.set(true);\n    +        return null;\n    +      }\n    +      return v;\n    +    });\n    +    if (reconstructState.get()) {\n    +      synchronized (getUpdateLock()) {    +        constructState();    +      }    +    } \n    +  }\n    +\n    +  /**\n    +   * Register a CollectionStateWatcher to be called when the state of a collection changes\n    +   *\n    +   * A given CollectionStateWatcher will be only called once.  If you want to have a persistent watcher,\n    +   * it should register itself again in its \n{@link CollectionStateWatcher#onStateChanged(Set, DocCollection)}\n    +   * method.\n    +   */\n    +  public void registerCollectionStateWatcher(String collection, CollectionStateWatcher stateWatcher) {\n    +    AtomicBoolean watchSet = new AtomicBoolean(false);\n    +    collectionWatches.compute(collection, (k, v) -> \nUnknown macro: {    +      if (v == null) {\n    +        v = new CollectionWatch();\n    +        watchSet.set(true);\n    +      }    +      v.stateWatchers.add(stateWatcher);    +      return v;    +    } \n);\n    +    if (watchSet.get()) \nUnknown macro: {    +      new StateWatcher(collection).refreshAndWatch();           synchronized (getUpdateLock()) {\n             constructState();\n           }         } \n       }\n\n\n\n    +  /**\n    +   * Block until a CollectionStatePredicate returns true, or the wait times out\n    +   *\n    +   * Note that the predicate may be called again even after it has returned true, so\n    +   * implementors should avoid changing state within the predicate call itself.\n    \u2014 End diff \u2013\n\n    I'm not talking about concurrent calls here, rather it's the race between adding the watcher, checking if the predicate matches the current state, and state changes arriving.\n\n    There are two scenarios here (T1 = client thread, Z1 = zkCallback thread):\n\n    T1 -> watcher added\n    Z1 -> state changes, watcher called\n    T1 -> watcher called for initial check\n\n    Or, if we do things the other way round\n    T1 -> watcher called for initial check and doesn't trigger\n    Z1 -> state changes\n    T1 -> watcher added, but isn't updated\n\n    Absent adding locks all over the place, which I'm really reluctant to do here as it would be far too easy to end up in a deadlock, I think we have to accept that a predicate may get called twice.  I don't think it matters too much though?  This is generally just going to be used for waiting. ",
            "id": "comment-15263985"
        },
        {
            "date": "2016-04-29T18:16:24+0000",
            "author": "ASF GitHub Bot",
            "content": "Github user dragonsinth commented on a diff in the pull request:\n\n    https://github.com/apache/lucene-solr/pull/32#discussion_r61622572\n\n    \u2014 Diff: solr/solrj/src/java/org/apache/solr/common/cloud/CollectionStateWatcher.java \u2014\n    @@ -0,0 +1,42 @@\n    +package org.apache.solr.common.cloud;\n    +\n    +/*\n    + * Licensed to the Apache Software Foundation (ASF) under one or more\n    + * contributor license agreements.  See the NOTICE file distributed with\n    + * this work for additional information regarding copyright ownership.\n    + * The ASF licenses this file to You under the Apache License, Version 2.0\n    + * (the \"License\"); you may not use this file except in compliance with\n    + * the License.  You may obtain a copy of the License at\n    + *\n    + *     http://www.apache.org/licenses/LICENSE-2.0\n    + *\n    + * Unless required by applicable law or agreed to in writing, software\n    + * distributed under the License is distributed on an \"AS IS\" BASIS,\n    + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    + * See the License for the specific language governing permissions and\n    + * limitations under the License.\n    +*/\n    +\n    +import java.util.Set;\n    +\n    +/**\n    + * Callback registered with \n{@link ZkStateReader#registerCollectionStateWatcher(String, CollectionStateWatcher)}\n    + * and called whenever the collection state changes.\n    + */\n    \u2014 End diff \u2013\n\n    Not sure! \u00af_(\u30c4)_/\u00af ",
            "id": "comment-15264473"
        },
        {
            "date": "2016-04-29T20:56:26+0000",
            "author": "ASF GitHub Bot",
            "content": "Github user dragonsinth commented on a diff in the pull request:\n\n    https://github.com/apache/lucene-solr/pull/32#discussion_r61643539\n\n    \u2014 Diff: solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader.java \u2014\n    @@ -1066,32 +1079,201 @@ public static String getCollectionPath(String coll) \n{\n         return COLLECTIONS_ZKNODE+\"/\"+coll + \"/state.json\";\n       }\n\n\n\tpublic void addCollectionWatch(String coll) {\n\tif (interestingCollections.add(coll)) {\n\tLOG.info(\"addZkWatch [{}]\", coll);\n\tnew StateWatcher(coll).refreshAndWatch(false);\n    +  /**\n    +   * Notify this reader that a local Core is a member of a collection, and so that collection\n    +   * state should be watched.\n    +   *\n    +   * Not a public API.  This method should only be called from ZkController.\n    +   *\n    +   * The number of cores per-collection is tracked, and adding multiple cores from the same\n    +   * collection does not increase the number of watches.\n    +   *\n    +   * @param collection the collection that the core is a member of\n    +   *\n    +   * @see ZkStateReader#unregisterCore(String)\n    +   */\n    +  public void registerCore(String collection) {\n    +    AtomicBoolean reconstructState = new AtomicBoolean(false);\n    +    collectionWatches.compute(collection, (k, v) -> \nUnknown macro: {    +      if (v == null) {\n    +        reconstructState.set(true);\n    +        v = new CollectionWatch();\n    +      }    +      v.coreRefCount++;    +      return v;    +    } \n);\n    +    if (reconstructState.get()) \nUnknown macro: {    +      new StateWatcher(collection).refreshAndWatch();    +      synchronized (getUpdateLock()) {\n    +        constructState();\n    +      }\n    +    }\n    +  }\n    +\n    +  /**\n    +   * Notify this reader that a local core that is a member of a collection has been closed.\n    +   *\n    +   * Not a public API.  This method should only be called from ZkController.\n    +   *\n    +   * If no cores are registered for a collection, and there are no {@link CollectionStateWatcher}s\n    +   * for that collection either, the collection watch will be removed.\n    +   *\n    +   * @param collection the collection that the core belongs to\n    +   */\n    +  public void unregisterCore(String collection) {\n    +    AtomicBoolean reconstructState = new AtomicBoolean(false);\n    +    collectionWatches.compute(collection, (k, v) -> {\n    +      if (v == null)\n    +        return null;\n    +      if (v.coreRefCount > 0)\n    +        v.coreRefCount--;\n    +      if (v.canBeRemoved()) {\n    +        watchedCollectionStates.remove(collection);\n    +        lazyCollectionStates.put(collection, new LazyCollectionRef(collection));\n    +        reconstructState.set(true);\n    +        return null;\n    +      }\n    +      return v;\n    +    });\n    +    if (reconstructState.get()) {\n    +      synchronized (getUpdateLock()) {    +        constructState();    +      }    +    } \n    +  }\n    +\n    +  /**\n    +   * Register a CollectionStateWatcher to be called when the state of a collection changes\n    +   *\n    +   * A given CollectionStateWatcher will be only called once.  If you want to have a persistent watcher,\n    +   * it should register itself again in its \n{@link CollectionStateWatcher#onStateChanged(Set, DocCollection)}\n    +   * method.\n    +   */\n    +  public void registerCollectionStateWatcher(String collection, CollectionStateWatcher stateWatcher) {\n    +    AtomicBoolean watchSet = new AtomicBoolean(false);\n    +    collectionWatches.compute(collection, (k, v) -> \nUnknown macro: {    +      if (v == null) {\n    +        v = new CollectionWatch();\n    +        watchSet.set(true);\n    +      }    +      v.stateWatchers.add(stateWatcher);    +      return v;    +    } \n);\n    +    if (watchSet.get()) \nUnknown macro: {    +      new StateWatcher(collection).refreshAndWatch();           synchronized (getUpdateLock()) {\n             constructState();\n           }         } \n       }\n\n\n\n    +  /**\n    +   * Block until a CollectionStatePredicate returns true, or the wait times out\n    +   *\n    +   * Note that the predicate may be called again even after it has returned true, so\n    +   * implementors should avoid changing state within the predicate call itself.\n    \u2014 End diff \u2013\n\n    It seems like it would be nice to shield callers from doing any kind of similar mutexing.  If you don't want to bother right now, I can come back and see if I can do something not yucky looking here. ",
            "id": "comment-15264723"
        },
        {
            "date": "2016-04-29T20:58:19+0000",
            "author": "ASF GitHub Bot",
            "content": "Github user dragonsinth commented on a diff in the pull request:\n\n    https://github.com/apache/lucene-solr/pull/32#discussion_r61643749\n\n    \u2014 Diff: solr/solrj/src/java/org/apache/solr/common/cloud/CollectionStatePredicate.java \u2014\n    @@ -30,8 +30,9 @@\n       /**\n\n\tCheck the collection state matches a required state\n        *\n\n\n\t* The collectionState parameter may be null if the collection does not exist\n\t* or has been deleted\n    +   * @param liveNodes the current set of live nodes\n    +   * @param collectionState the latest collection state, or null if the collection\n    +   *                        does not exist\n\t\n\t\t\n\t\t\n\t\t\tEnd diff \u2013\n\t\t\n\t\t\n\t\n\t\n\n\n\n    I think this needs to be below the \"Note\" lines to get formatted right. ",
            "id": "comment-15264726"
        },
        {
            "date": "2016-04-29T20:58:53+0000",
            "author": "ASF GitHub Bot",
            "content": "Github user dragonsinth commented on a diff in the pull request:\n\n    https://github.com/apache/lucene-solr/pull/32#discussion_r61643877\n\n    \u2014 Diff: solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader.java \u2014\n    @@ -256,9 +257,10 @@ public void updateClusterState() throws KeeperException, InterruptedException {\n           refreshLegacyClusterState(null);\n           // Need a copy so we don't delete from what we're iterating over.\n           Collection<String> safeCopy = new ArrayList<>(watchedCollectionStates.keySet());\n    +      Set<String> liveNodes = new HashSet<>(this.liveNodes);\n    \u2014 End diff \u2013\n\n    You don't actually need a copy here, since `liveNodes` is an immutable set. ",
            "id": "comment-15264728"
        },
        {
            "date": "2016-04-29T21:05:57+0000",
            "author": "ASF GitHub Bot",
            "content": "Github user dragonsinth commented on a diff in the pull request:\n\n    https://github.com/apache/lucene-solr/pull/32#discussion_r61644721\n\n    \u2014 Diff: solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader.java \u2014\n    @@ -491,19 +493,28 @@ private void refreshLegacyClusterState(Watcher watcher)\n           final Stat stat = new Stat();\n           final byte[] data = zkClient.getData(CLUSTER_STATE, watcher, stat, true);\n           final ClusterState loadedData = ClusterState.load(stat.getVersion(), data, emptySet(), CLUSTER_STATE);\n    +      final Set<String> liveNodes = new HashSet<>(this.liveNodes);\n           synchronized (getUpdateLock()) {\n             if (this.legacyClusterStateVersion >= stat.getVersion()) \n{\n               // Nothing to do, someone else updated same or newer.\n               return;\n             }\n\n\tthis.legacyCollectionStates = loadedData.getCollectionStates();\n\tthis.legacyClusterStateVersion = stat.getVersion();\n\tfor (Map.Entry<String, ClusterState.CollectionRef> entry : this.legacyCollectionStates.entrySet()) {\n\tif (entry.getValue().isLazilyLoaded() == false) {\n\t// a watched collection - trigger notifications\n\tnotifyStateWatchers(entry.getKey(), entry.getValue().get());\n    +        LOG.info(\"Updating legacy cluster state - {} entries in legacyCollectionStates\", legacyCollectionStates.size());\n    +        for (Map.Entry<String, CollectionWatch> watchEntry : this.collectionWatches.entrySet()) {\n    +          String coll = watchEntry.getKey();\n    +          CollectionWatch collWatch = watchEntry.getValue();\n    +          ClusterState.CollectionRef ref = this.legacyCollectionStates.get(coll);\n    +          if (ref == null)\n    +            continue;\n    +          // watched collection, so this will always be local\n    +          DocCollection newState = ref.get();\n    +          if (!collWatch.stateWatchers.isEmpty()\n    +              && !Objects.equals(loadedData.getCollectionStates().get(coll).get(), newState)) {\n    +            notifyStateWatchers(liveNodes, coll, newState);\n\t\n\t\t\n\t\t\n\t\t\tEnd diff \u2013\n\t\t\n\t\t\n\t\n\t\n\n\n\n    I just realized you don't want to call user code while holding the update lock.  I think you're going to need to move this out of the synchronized block.  In fact.... this is really nasty now that I think about it.  In general, you're going to want to defer calling any user code until the current constuctState() operation finishes.  Otherwise, the user code is potentially going to see a stale copy of the state that you haven't finished updating yet.\n\n    I think we're going to have to build a queue of outstanding state watchers to notify and always call them later, probably in an executor.  I know that sounds like a bit of work, but I'm not sure I can see how it would be safe otherwise.\n\n    @markrmiller any thoughts? ",
            "id": "comment-15264743"
        },
        {
            "date": "2016-04-29T21:20:22+0000",
            "author": "David Smiley",
            "content": "Pardon the distraction to the fine work going on here but I'd like to possibly emulate this code review process on other issue(s).  Is it necessary to create a branch on some other/personal repo and then issue a pull request (as was done here I see) or is it possible for someone to review commits to a branch on our repo/mirror?  I'm thinking SOLR-5750 \u2013 https://github.com/apache/lucene-solr/commits/solr-5750   (feel free to make a comment to test). ",
            "id": "comment-15264767"
        },
        {
            "date": "2016-05-02T18:11:22+0000",
            "author": "ASF GitHub Bot",
            "content": "Github user romseygeek commented on a diff in the pull request:\n\n    https://github.com/apache/lucene-solr/pull/32#discussion_r61777874\n\n    \u2014 Diff: solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader.java \u2014\n    @@ -1066,32 +1079,201 @@ public static String getCollectionPath(String coll) \n{\n         return COLLECTIONS_ZKNODE+\"/\"+coll + \"/state.json\";\n       }\n\n\n\tpublic void addCollectionWatch(String coll) {\n\tif (interestingCollections.add(coll)) {\n\tLOG.info(\"addZkWatch [{}]\", coll);\n\tnew StateWatcher(coll).refreshAndWatch(false);\n    +  /**\n    +   * Notify this reader that a local Core is a member of a collection, and so that collection\n    +   * state should be watched.\n    +   *\n    +   * Not a public API.  This method should only be called from ZkController.\n    +   *\n    +   * The number of cores per-collection is tracked, and adding multiple cores from the same\n    +   * collection does not increase the number of watches.\n    +   *\n    +   * @param collection the collection that the core is a member of\n    +   *\n    +   * @see ZkStateReader#unregisterCore(String)\n    +   */\n    +  public void registerCore(String collection) {\n    +    AtomicBoolean reconstructState = new AtomicBoolean(false);\n    +    collectionWatches.compute(collection, (k, v) -> \nUnknown macro: {    +      if (v == null) {\n    +        reconstructState.set(true);\n    +        v = new CollectionWatch();\n    +      }    +      v.coreRefCount++;    +      return v;    +    } \n);\n    +    if (reconstructState.get()) \nUnknown macro: {    +      new StateWatcher(collection).refreshAndWatch();    +      synchronized (getUpdateLock()) {\n    +        constructState();\n    +      }\n    +    }\n    +  }\n    +\n    +  /**\n    +   * Notify this reader that a local core that is a member of a collection has been closed.\n    +   *\n    +   * Not a public API.  This method should only be called from ZkController.\n    +   *\n    +   * If no cores are registered for a collection, and there are no {@link CollectionStateWatcher}s\n    +   * for that collection either, the collection watch will be removed.\n    +   *\n    +   * @param collection the collection that the core belongs to\n    +   */\n    +  public void unregisterCore(String collection) {\n    +    AtomicBoolean reconstructState = new AtomicBoolean(false);\n    +    collectionWatches.compute(collection, (k, v) -> {\n    +      if (v == null)\n    +        return null;\n    +      if (v.coreRefCount > 0)\n    +        v.coreRefCount--;\n    +      if (v.canBeRemoved()) {\n    +        watchedCollectionStates.remove(collection);\n    +        lazyCollectionStates.put(collection, new LazyCollectionRef(collection));\n    +        reconstructState.set(true);\n    +        return null;\n    +      }\n    +      return v;\n    +    });\n    +    if (reconstructState.get()) {\n    +      synchronized (getUpdateLock()) {    +        constructState();    +      }    +    } \n    +  }\n    +\n    +  /**\n    +   * Register a CollectionStateWatcher to be called when the state of a collection changes\n    +   *\n    +   * A given CollectionStateWatcher will be only called once.  If you want to have a persistent watcher,\n    +   * it should register itself again in its \n{@link CollectionStateWatcher#onStateChanged(Set, DocCollection)}\n    +   * method.\n    +   */\n    +  public void registerCollectionStateWatcher(String collection, CollectionStateWatcher stateWatcher) {\n    +    AtomicBoolean watchSet = new AtomicBoolean(false);\n    +    collectionWatches.compute(collection, (k, v) -> \nUnknown macro: {    +      if (v == null) {\n    +        v = new CollectionWatch();\n    +        watchSet.set(true);\n    +      }    +      v.stateWatchers.add(stateWatcher);    +      return v;    +    } \n);\n    +    if (watchSet.get()) \nUnknown macro: {    +      new StateWatcher(collection).refreshAndWatch();           synchronized (getUpdateLock()) {\n             constructState();\n           }         } \n       }\n\n\n\n    +  /**\n    +   * Block until a CollectionStatePredicate returns true, or the wait times out\n    +   *\n    +   * Note that the predicate may be called again even after it has returned true, so\n    +   * implementors should avoid changing state within the predicate call itself.\n    \u2014 End diff \u2013\n\n    Yeah, I think this can be done in a follow-up issue, if need be? ",
            "id": "comment-15267144"
        },
        {
            "date": "2016-05-02T18:13:13+0000",
            "author": "ASF GitHub Bot",
            "content": "Github user romseygeek commented on the pull request:\n\n    https://github.com/apache/lucene-solr/pull/32#issuecomment-216315281\n\n    OK, latest push moves all notifications out of synchronized blocks. ",
            "id": "comment-15267156"
        },
        {
            "date": "2016-05-02T19:17:30+0000",
            "author": "ASF GitHub Bot",
            "content": "Github user dragonsinth commented on the pull request:\n\n    https://github.com/apache/lucene-solr/pull/32#issuecomment-216333963\n\n    @romseygeek nice job on the changes so far, and sorry to have so much feedback and so many asks.  This is a pretty complicated change so I feel like it merits the attention to detail.\n\n    I feel like we're at a fork in the road with this patch at the moment though, and we need to get more people involved to proceed.  Let me explain.\n\n    Even having fixed the \"calling watchers while holding locks issue\", the one thing that makes me most nervous about the current state is that we're still potentially executing user-provided predicates on threads that belong to a variety of other people-- e.g. the caller of forceUpdateCollection() or even the Zk event callback thread.  We could make a tactical fix to the implementation of waitForState() by turning that method into a loop and running the predicate on the actual thread that called waitForState(), such that the onStateChanged() handler doesn't dip into client code.\n\n    But honestly, I feel like having privatized CollectionStateWatcher and the ability to register / unregister is a missed opportunity.  I can think of uses for the feature, like in some cases Overseer operations could watch a collection for the duration of an operation to prevent having to re-query ZK.  To make that solid, we'd need to either introduce an Executor in ZkStateReader for publishing events, or else require the watch registration to provide an executor, the way Guava's ListenableFuture does.\n\n    Thoughts?  I'd also like to hear from others. ",
            "id": "comment-15267309"
        },
        {
            "date": "2016-05-02T20:06:34+0000",
            "author": "ASF GitHub Bot",
            "content": "Github user romseygeek commented on the pull request:\n\n    https://github.com/apache/lucene-solr/pull/32#issuecomment-216347644\n\n    Feedback is good \n\n    I'll pull CSW back out and make it public again.  I think keeping it separate from the Predicate is still a useful distinction though.  I'll try adding in an executor as well. ",
            "id": "comment-15267396"
        },
        {
            "date": "2016-05-02T20:21:47+0000",
            "author": "ASF GitHub Bot",
            "content": "Github user dragonsinth commented on the pull request:\n\n    https://github.com/apache/lucene-solr/pull/32#issuecomment-216351404\n\n    BTW, here's an implementation of waitForState() that does the work on the calling thread.  This passes your tests:\n\n    ```\n      public void waitForState(final String collection, long wait, TimeUnit unit, CollectionStatePredicate predicate)\n          throws InterruptedException, TimeoutException {\n        long stop = System.nanoTime() + unit.toNanos(wait);\n\n        if (predicate.matches(this.liveNodes, clusterState.getCollectionOrNull(collection))) \n{\n          return;\n        }\n\n        LinkedBlockingQueue<Pair<Set<String>, DocCollection>> queue = new LinkedBlockingQueue<>();\n        CollectionStateWatcher watcher = new CollectionStateWatcher() {\n          @Override\n          public void onStateChanged(Set<String> liveNodes, DocCollection collectionState) \n{\n            queue.add(new Pair<>(liveNodes, collectionState));\n            registerCollectionStateWatcher(collection, this);\n          }\n        };\n\n        registerCollectionStateWatcher(collection, watcher);\n        try {\n          while (true) {\n            Pair<Set<String>, DocCollection> pair = queue.poll(stop - System.nanoTime(), TimeUnit.NANOSECONDS);\n            if (pair == null) \n{\n              throw new TimeoutException();\n            }\n            if (predicate.matches(pair.getKey(), pair.getValue())) \n{\n              return;\n            }\n          }\n        } finally \n{\n          removeCollectionStateWatcher(collection, watcher);\n        }\n      }\n    ```\n\n    One thing I noticed in writing this is that it's uncertain whether you'll miss any states or not.  I kind of like the idea that you could have your watcher return true or false to decide whether to keep watching, as it would ensure we could get all updates without missing any. ",
            "id": "comment-15267426"
        },
        {
            "date": "2016-05-04T16:34:44+0000",
            "author": "ASF GitHub Bot",
            "content": "Github user romseygeek commented on the pull request:\n\n    https://github.com/apache/lucene-solr/pull/32#issuecomment-216922168\n\n    > One thing I noticed in writing this is that it's uncertain whether you'll miss any states or not\n\n    Unless I'm misunderstanding you, this is just how ZK works, though.  A watcher firing just means that there has been at least one change to the watched node in the space of the last tick.  So we wouldn't be able to guarantee that the CollectionStateWatcher is notified of every change.\n\n    If we're making CSW public again, I don't think the queueing implementation you have there will work?  An executor seems to be the most straightforward way of doing things here.  Although, thinking more about that, we already have a separate executor for watchers, don't we?  So this may just be overthinking things. ",
            "id": "comment-15270950"
        },
        {
            "date": "2016-05-04T16:59:33+0000",
            "author": "ASF GitHub Bot",
            "content": "Github user dragonsinth commented on the pull request:\n\n    https://github.com/apache/lucene-solr/pull/32#issuecomment-216931783\n\n    Correct, the queuing implementation where the waiting thread loops only helps waitForState().  Maybe we should just go with that for now and consider making CSW public as a follow up?  If we do make it public, I think we'd still want a separate executor, you don't want to end up blocking ZKSR's internal operations. ",
            "id": "comment-15270983"
        },
        {
            "date": "2016-05-04T17:33:49+0000",
            "author": "ASF GitHub Bot",
            "content": "Github user romseygeek commented on the pull request:\n\n    https://github.com/apache/lucene-solr/pull/32#issuecomment-216941787\n\n    Last push exposes CollectionStateWatcher directly again, and moves notification calls into an Executor. ",
            "id": "comment-15271040"
        },
        {
            "date": "2016-05-05T21:55:04+0000",
            "author": "ASF GitHub Bot",
            "content": "Github user markrmiller commented on the pull request:\n\n    https://github.com/apache/lucene-solr/pull/32#issuecomment-217291207\n\n    > Although, thinking more about that, we already have a separate executor for watchers, don't we?\n\n    Yes, every watch firing event should run from a dedicated executor rather than using ZK's event thread. I have not dug in enough here to know it covers what you guys are talking about, but holding up a Watcher thread should no longer interfere with ZK clients internal event thread. ",
            "id": "comment-15273176"
        },
        {
            "date": "2016-05-09T20:22:46+0000",
            "author": "ASF GitHub Bot",
            "content": "Github user romseygeek commented on the pull request:\n\n    https://github.com/apache/lucene-solr/pull/32#issuecomment-217978029\n\n    On further reflection, I've pulled the separate executor back out again.  I think the SolrZkClient's separate executor will work well enough, and for the most part client code is going to be run inside a CloudSolrClient talking to the cluster, not a Solr node's internal state reader.  I've also removed the CSC.registerCollectionWatcher() method, as that's really only for internal use, leaving the waitForState() method as a convenience.\n\n    I'd like to commit this in the next couple of days.  I think it will make a big difference to a bunch of test improvements I want to make separately. ",
            "id": "comment-15276961"
        },
        {
            "date": "2016-05-09T20:30:12+0000",
            "author": "Alan Woodward",
            "content": "Pretty sure you can create pull requests from branches within the same repository, so there's no need to have your own clone if you don't want one. ",
            "id": "comment-15276973"
        },
        {
            "date": "2016-05-09T20:47:43+0000",
            "author": "ASF GitHub Bot",
            "content": "Github user dragonsinth commented on the pull request:\n\n    https://github.com/apache/lucene-solr/pull/32#issuecomment-217984743\n\n    I did like the idea of a dedicated executor for collection events, just to ensure clean separation.  But I'll take a look in its current form. ",
            "id": "comment-15277005"
        },
        {
            "date": "2016-05-10T10:44:48+0000",
            "author": "ASF GitHub Bot",
            "content": "Github user romseygeek commented on the pull request:\n\n    https://github.com/apache/lucene-solr/pull/32#issuecomment-218122269\n\n    New plan!  We now have a separate notification thread, and change notifications are placed into a LinkedBlockingQueue that the thread waits on.\n\n    A caveat: the queue is currently unbounded, which is a Bad Thing.  I'm not sure of the best way forward here - make it bounded, and just drop notifications if the queue is full?  Make a note on the collection predicate javadocs that all predicates run in a single thread, and users need to be careful not to run slow code in them? ",
            "id": "comment-15277927"
        },
        {
            "date": "2016-05-10T17:12:27+0000",
            "author": "ASF GitHub Bot",
            "content": "Github user dragonsinth commented on the pull request:\n\n    https://github.com/apache/lucene-solr/pull/32#issuecomment-218226081\n\n    Hmm, isn't an executor a fancier way of doing a Queue + Thread(s)?  ",
            "id": "comment-15278477"
        },
        {
            "date": "2016-05-10T18:40:52+0000",
            "author": "ASF GitHub Bot",
            "content": "Github user romseygeek commented on the pull request:\n\n    https://github.com/apache/lucene-solr/pull/32#issuecomment-218251017\n\n    That's... a good point, actually. ",
            "id": "comment-15278661"
        },
        {
            "date": "2016-05-10T23:12:40+0000",
            "author": "ASF GitHub Bot",
            "content": "Github user dragonsinth commented on a diff in the pull request:\n\n    https://github.com/apache/lucene-solr/pull/32#discussion_r62769742\n\n    \u2014 Diff: solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader.java \u2014\n    @@ -485,6 +506,20 @@ private void refreshLegacyClusterState(Watcher watcher)\n               // Nothing to do, someone else updated same or newer.\n               return;\n             }\n    +        Set<String> liveNodes = this.liveNodes; // volatile read\n    +        for (Map.Entry<String, CollectionWatch> watchEntry : this.collectionWatches.entrySet()) {\n    +          String coll = watchEntry.getKey();\n    +          CollectionWatch collWatch = watchEntry.getValue();\n    +          ClusterState.CollectionRef ref = this.legacyCollectionStates.get(coll);\n    +          if (ref == null)\n    +            continue;\n    +          // watched collection, so this will always be local\n    \u2014 End diff \u2013\n\n    nit `legacy collections are always in-memory` ",
            "id": "comment-15279184"
        },
        {
            "date": "2016-05-10T23:16:03+0000",
            "author": "ASF GitHub Bot",
            "content": "Github user dragonsinth commented on a diff in the pull request:\n\n    https://github.com/apache/lucene-solr/pull/32#discussion_r62770082\n\n    \u2014 Diff: solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader.java \u2014\n    @@ -485,6 +506,20 @@ private void refreshLegacyClusterState(Watcher watcher)\n               // Nothing to do, someone else updated same or newer.\n               return;\n             }\n    +        Set<String> liveNodes = this.liveNodes; // volatile read\n    +        for (Map.Entry<String, CollectionWatch> watchEntry : this.collectionWatches.entrySet()) {\n    +          String coll = watchEntry.getKey();\n    +          CollectionWatch collWatch = watchEntry.getValue();\n    +          ClusterState.CollectionRef ref = this.legacyCollectionStates.get(coll);\n    +          if (ref == null)\n    +            continue;\n    \u2014 End diff \u2013\n\n    Q: what happens if you try to set a watcher on a collection that doesn't exist yet?  Mostly curious. ",
            "id": "comment-15279195"
        },
        {
            "date": "2016-05-10T23:18:02+0000",
            "author": "ASF GitHub Bot",
            "content": "Github user dragonsinth commented on a diff in the pull request:\n\n    https://github.com/apache/lucene-solr/pull/32#discussion_r62770248\n\n    \u2014 Diff: solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader.java \u2014\n    @@ -635,6 +669,8 @@ public Object getUpdateLock() {\n\n       public void close() {\n         this.closed  = true;\n    +    notifications.shutdownNow();  // interrupt\n    \u2014 End diff \u2013\n\n    @markrmiller and I went on a hunt a while ago to try to remove most thread interruptions from Solr due to certain Lucene NIO operations getting permanently wedged due to interrupts.  Is this necessary? ",
            "id": "comment-15279199"
        },
        {
            "date": "2016-05-10T23:18:25+0000",
            "author": "ASF GitHub Bot",
            "content": "Github user dragonsinth commented on a diff in the pull request:\n\n    https://github.com/apache/lucene-solr/pull/32#discussion_r62770279\n\n    \u2014 Diff: solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader.java \u2014\n    @@ -635,6 +669,8 @@ public Object getUpdateLock() {\n\n       public void close() {\n         this.closed  = true;\n    +    notifications.shutdownNow();  // interrupt\n    +    ExecutorUtil.shutdownAndAwaitTermination(notifications);\n    \u2014 End diff \u2013\n\n    I think I would just shutdown and not wait. ",
            "id": "comment-15279200"
        },
        {
            "date": "2016-05-10T23:21:18+0000",
            "author": "ASF GitHub Bot",
            "content": "Github user dragonsinth commented on a diff in the pull request:\n\n    https://github.com/apache/lucene-solr/pull/32#discussion_r62770569\n\n    \u2014 Diff: solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader.java \u2014\n    @@ -1069,32 +1100,190 @@ public static String getCollectionPath(String coll) \n{\n         return COLLECTIONS_ZKNODE+\"/\"+coll + \"/state.json\";\n       }\n\n\n\tpublic void addCollectionWatch(String coll) {\n\tif (interestingCollections.add(coll)) {\n\tLOG.info(\"addZkWatch [{}]\", coll);\n\tnew StateWatcher(coll).refreshAndWatch(false);\n    +  /**\n    +   * Notify this reader that a local Core is a member of a collection, and so that collection\n    +   * state should be watched.\n    +   *\n    +   * Not a public API.  This method should only be called from ZkController.\n    +   *\n    +   * The number of cores per-collection is tracked, and adding multiple cores from the same\n    +   * collection does not increase the number of watches.\n    +   *\n    +   * @param collection the collection that the core is a member of\n    +   *\n    +   * @see ZkStateReader#unregisterCore(String)\n    +   */\n    +  public void registerCore(String collection) {\n    +    AtomicBoolean reconstructState = new AtomicBoolean(false);\n    +    collectionWatches.compute(collection, (k, v) -> \nUnknown macro: {    +      if (v == null) {\n    +        reconstructState.set(true);\n    +        v = new CollectionWatch();\n    +      }    +      v.coreRefCount++;    +      return v;    +    } \n);\n    +    if (reconstructState.get()) \nUnknown macro: {    +      new StateWatcher(collection).refreshAndWatch();    +      synchronized (getUpdateLock()) {\n    +        constructState();\n    +      }\n    +    }\n    +  }\n    +\n    +  /**\n    +   * Notify this reader that a local core that is a member of a collection has been closed.\n    +   *\n    +   * Not a public API.  This method should only be called from ZkController.\n    +   *\n    +   * If no cores are registered for a collection, and there are no {@link CollectionStateWatcher}s\n    +   * for that collection either, the collection watch will be removed.\n    +   *\n    +   * @param collection the collection that the core belongs to\n    +   */\n    +  public void unregisterCore(String collection) {\n    +    AtomicBoolean reconstructState = new AtomicBoolean(false);\n    +    collectionWatches.compute(collection, (k, v) -> {\n    +      if (v == null)\n    +        return null;\n    +      if (v.coreRefCount > 0)\n    +        v.coreRefCount--;\n    +      if (v.canBeRemoved()) {\n    +        watchedCollectionStates.remove(collection);\n    +        lazyCollectionStates.put(collection, new LazyCollectionRef(collection));\n    +        reconstructState.set(true);\n    +        return null;\n    +      }\n    +      return v;\n    +    });\n    +    if (reconstructState.get()) {\n    +      synchronized (getUpdateLock()) {    +        constructState();    +      }    +    } \n    +  }\n    +\n    +  /**\n    +   * Register a CollectionStateWatcher to be called when the state of a collection changes\n    +   *\n    +   * A given CollectionStateWatcher will be only called once.  If you want to have a persistent watcher,\n    +   * it should register itself again in its \n{@link CollectionStateWatcher#onStateChanged(Set, DocCollection)}\n    +   * method.\n    +   */\n    +  public void registerCollectionStateWatcher(String collection, CollectionStateWatcher stateWatcher) {\n    +    AtomicBoolean watchSet = new AtomicBoolean(false);\n    +    collectionWatches.compute(collection, (k, v) -> \nUnknown macro: {    +      if (v == null) {\n    +        v = new CollectionWatch();\n    +        watchSet.set(true);\n    +      }    +      v.stateWatchers.add(stateWatcher);    +      return v;    +    } \n);\n    +    if (watchSet.get()) \nUnknown macro: {    +      new StateWatcher(collection).refreshAndWatch();           synchronized (getUpdateLock()) {\n             constructState();\n           }         } \n       }\n\n\n\n    +  /**\n    +   * Block until a CollectionStatePredicate returns true, or the wait times out\n    +   *\n    +   * Note that the predicate may be called again even after it has returned true, so\n    +   * implementors should avoid changing state within the predicate call itself.\n    +   *\n    +   * @param collection the collection to watch\n    +   * @param wait       how long to wait\n    +   * @param unit       the units of the wait parameter\n    +   * @param predicate  the predicate to call on state changes\n    +   * @throws InterruptedException on interrupt\n    +   * @throws TimeoutException on timeout\n    +   */\n    +  public void waitForState(final String collection, long wait, TimeUnit unit, CollectionStatePredicate predicate)\n    +      throws InterruptedException, TimeoutException {\n    +\n    +    final CountDownLatch latch = new CountDownLatch(1);\n    +\n    +    CollectionStateWatcher watcher = new CollectionStateWatcher() {\n    +      @Override\n    +      public void onStateChanged(Set<String> liveNodes, DocCollection collectionState) {\n    +        if (predicate.matches(liveNodes, collectionState)) \n{\n    +          latch.countDown();\n    +        }\n else \n{\n    +          registerCollectionStateWatcher(collection, this);\n    +        }\n    +      }\n    +    };\n    +    registerCollectionStateWatcher(collection, watcher);\n    +\n    +    try \n{\n    +      // check the current state\n    +      DocCollection dc = clusterState.getCollectionOrNull(collection);\n    +      if (predicate.matches(liveNodes, dc))\n    +        return;\n    +\n    +      // wait for the watcher predicate to return true, or time out\n    +      if (!latch.await(wait, unit))\n    +        throw new TimeoutException();\n    +\n    +    }\n    +    finally {\n    \u2014 End diff \u2013\n\n    nit: you have a few formatting issues here and elsewhere ",
            "id": "comment-15279206"
        },
        {
            "date": "2016-05-10T23:22:10+0000",
            "author": "ASF GitHub Bot",
            "content": "Github user dragonsinth commented on a diff in the pull request:\n\n    https://github.com/apache/lucene-solr/pull/32#discussion_r62770640\n\n    \u2014 Diff: solr/solrj/src/java/org/apache/solr/common/util/ExecutorUtil.java \u2014\n    @@ -154,6 +147,20 @@ public static ExecutorService newMDCAwareSingleThreadExecutor(ThreadFactory thre\n       }\n\n       /**\n    +   * Create a single thread executor using a named thread factory\n    +   */\n    +  public static ExecutorService newMDCAwareSingleThreadExecutor(String name) \n{\n    +    return newMDCAwareSingleThreadExecutor(new SolrjNamedThreadFactory(name));\n    +  }\n    \u2014 End diff \u2013\n\n    not used ",
            "id": "comment-15279209"
        },
        {
            "date": "2016-05-10T23:26:47+0000",
            "author": "ASF GitHub Bot",
            "content": "Github user dragonsinth commented on a diff in the pull request:\n\n    https://github.com/apache/lucene-solr/pull/32#discussion_r62771056\n\n    \u2014 Diff: solr/solrj/src/test/org/apache/solr/common/cloud/TestCollectionStateWatchers.java \u2014\n    @@ -0,0 +1,235 @@\n    +package org.apache.solr.common.cloud;\n    +\n    +/*\n    + * Licensed to the Apache Software Foundation (ASF) under one or more\n    + * contributor license agreements.  See the NOTICE file distributed with\n    + * this work for additional information regarding copyright ownership.\n    + * The ASF licenses this file to You under the Apache License, Version 2.0\n    + * (the \"License\"); you may not use this file except in compliance with\n    + * the License.  You may obtain a copy of the License at\n    + *\n    + *     http://www.apache.org/licenses/LICENSE-2.0\n    + *\n    + * Unless required by applicable law or agreed to in writing, software\n    + * distributed under the License is distributed on an \"AS IS\" BASIS,\n    + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    + * See the License for the specific language governing permissions and\n    + * limitations under the License.\n    + */\n    +\n    +import java.util.HashMap;\n    +import java.util.Set;\n    +import java.util.concurrent.CountDownLatch;\n    +import java.util.concurrent.ExecutorService;\n    +import java.util.concurrent.Future;\n    +import java.util.concurrent.TimeUnit;\n    +import java.util.concurrent.TimeoutException;\n    +import java.util.concurrent.atomic.AtomicInteger;\n    +\n    +import org.apache.solr.client.solrj.embedded.JettySolrRunner;\n    +import org.apache.solr.client.solrj.impl.CloudSolrClient;\n    +import org.apache.solr.client.solrj.request.CollectionAdminRequest;\n    +import org.apache.solr.cloud.SolrCloudTestCase;\n    +import org.apache.solr.common.util.ExecutorUtil;\n    +import org.apache.solr.common.util.SolrjNamedThreadFactory;\n    +import org.junit.AfterClass;\n    +import org.junit.Before;\n    +import org.junit.BeforeClass;\n    +import org.junit.Test;\n    +\n    +import static org.hamcrest.core.Is.is;\n    +\n    +public class TestCollectionStateWatchers extends SolrCloudTestCase {\n    +\n    +  private static final int CLUSTER_SIZE = 4;\n    +\n    +  private static final ExecutorService executor = ExecutorUtil.newMDCAwareCachedThreadPool(\n    +      new SolrjNamedThreadFactory(\"backgroundWatchers\")\n    +  );\n    +\n    +  private static final int MAX_WAIT_TIMEOUT = 30;\n    +\n    +  @BeforeClass\n    +  public static void startCluster() throws Exception \n{\n    +    configureCluster(CLUSTER_SIZE)\n    +        .addConfig(\"config\", getFile(\"solrj/solr/collection1/conf\").toPath())\n    +        .configure();\n    +  }\n    +\n    +  @AfterClass\n    +  public static void shutdownBackgroundExecutors() \n{\n    +    executor.shutdown();\n    +  }\n    +\n    +  @Before\n    +  public void prepareCluster() throws Exception {\n    +    int missingServers = CLUSTER_SIZE - cluster.getJettySolrRunners().size();\n    +    for (int i = 0; i < missingServers; i++) \n{\n    +      cluster.startJettySolrRunner();\n    +    }\n    +    cluster.waitForAllNodes(30);\n    +  }\n    +\n    +  private static Future<Boolean> waitInBackground(String collection, long timeout, TimeUnit unit,\n    +                                                  CollectionStatePredicate predicate) {\n    +    return executor.submit(() -> {\n    +      try \n{\n    +        cluster.getSolrClient().waitForState(collection, timeout, unit, predicate);\n    +      }\n catch (InterruptedException | TimeoutException e) \n{\n    +        return Boolean.FALSE;\n    +      }\n    +      return Boolean.TRUE;\n    +    });\n    +  }\n    +\n    +\n    +  @Test\n    +  public void testSimpleCollectionWatch() throws Exception {\n    +\n    +    CloudSolrClient client = cluster.getSolrClient();\n    +    cluster.createCollection(\"testcollection\", CLUSTER_SIZE, 1, \"config\", new HashMap<>());\n    +\n    +    client.waitForState(\"testcollection\", MAX_WAIT_TIMEOUT, TimeUnit.SECONDS, DocCollection::isFullyActive);\n    +\n    +    // shutdown a node and check that we get notified about the change\n    +    final AtomicInteger nodeCount = new AtomicInteger(0);\n    +    final CountDownLatch latch = new CountDownLatch(1);\n    +    client.registerCollectionStateWatcher(\"testcollection\", (liveNodes, collectionState) -> {\n    +      // we can't just count liveNodes here, because that's updated by a separate watcher,\n    +      // and it may be the case that we're triggered by a node setting itself to DOWN before\n    +      // the liveNodes watcher is called\n    +      for (Slice slice : collectionState) {\n    +        for (Replica replica : slice) \n{\n    +          if (replica.isActive(liveNodes))\n    +            nodeCount.incrementAndGet();\n    +        }\n    +      }\n    +      latch.countDown();\n    +    });\n    +\n    +    cluster.stopJettySolrRunner(random().nextInt(cluster.getJettySolrRunners().size()));\n    +    assertTrue(\"CollectionStateWatcher was never notified of cluster change\", latch.await(MAX_WAIT_TIMEOUT, TimeUnit.SECONDS));\n    +\n    +    assertThat(nodeCount.intValue(), is(3));\n    +\n    +  }\n    +\n    +  @Test\n    +  public void testWaitForStateChecksCurrentState() throws Exception {\n    +\n    +    CloudSolrClient client = cluster.getSolrClient();\n    +    cluster.createCollection(\"waitforstate\", 1, 1, \"config\", new HashMap<>());\n    +\n    +    client.waitForState(\"waitforstate\", MAX_WAIT_TIMEOUT, TimeUnit.SECONDS, DocCollection::isFullyActive);\n    +\n    +    // several goes, to check that we're not getting delayed state changes\n    +    for (int i = 0; i < 10; i++) {\n    +      try \n{\n    +        client.waitForState(\"waitforstate\", 1, TimeUnit.SECONDS, DocCollection::isFullyActive);\n    +      }\n    +      catch (TimeoutException e) \n{\n    +        fail(\"waitForState should return immediately if the predicate is already satisfied\");\n    +      }\n    +    }\n    +\n    +  }\n    +\n    +  @Test\n    +  public void testCanWatchForNonexistantCollection() throws Exception {\n    \u2014 End diff \u2013\n\n    technical can wait for non-existent collection.  Would like to know what happens if you try to watch for a non-existent one, does it get fired immediately, or only when the collection is created? ",
            "id": "comment-15279215"
        },
        {
            "date": "2016-05-10T23:27:50+0000",
            "author": "ASF GitHub Bot",
            "content": "Github user dragonsinth commented on a diff in the pull request:\n\n    https://github.com/apache/lucene-solr/pull/32#discussion_r62771165\n\n    \u2014 Diff: solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader.java \u2014\n    @@ -1069,32 +1100,190 @@ public static String getCollectionPath(String coll) \n{\n         return COLLECTIONS_ZKNODE+\"/\"+coll + \"/state.json\";\n       }\n\n\n\tpublic void addCollectionWatch(String coll) {\n\tif (interestingCollections.add(coll)) {\n\tLOG.info(\"addZkWatch [{}]\", coll);\n\tnew StateWatcher(coll).refreshAndWatch(false);\n    +  /**\n    +   * Notify this reader that a local Core is a member of a collection, and so that collection\n    +   * state should be watched.\n    +   *\n    +   * Not a public API.  This method should only be called from ZkController.\n    +   *\n    +   * The number of cores per-collection is tracked, and adding multiple cores from the same\n    +   * collection does not increase the number of watches.\n    +   *\n    +   * @param collection the collection that the core is a member of\n    +   *\n    +   * @see ZkStateReader#unregisterCore(String)\n    +   */\n    +  public void registerCore(String collection) {\n    +    AtomicBoolean reconstructState = new AtomicBoolean(false);\n    +    collectionWatches.compute(collection, (k, v) -> \nUnknown macro: {    +      if (v == null) {\n    +        reconstructState.set(true);\n    +        v = new CollectionWatch();\n    +      }    +      v.coreRefCount++;    +      return v;    +    } \n);\n    +    if (reconstructState.get()) \nUnknown macro: {    +      new StateWatcher(collection).refreshAndWatch();    +      synchronized (getUpdateLock()) {\n    +        constructState();\n    +      }\n    +    }\n    +  }\n    +\n    +  /**\n    +   * Notify this reader that a local core that is a member of a collection has been closed.\n    +   *\n    +   * Not a public API.  This method should only be called from ZkController.\n    +   *\n    +   * If no cores are registered for a collection, and there are no {@link CollectionStateWatcher}s\n    +   * for that collection either, the collection watch will be removed.\n    +   *\n    +   * @param collection the collection that the core belongs to\n    +   */\n    +  public void unregisterCore(String collection) {\n    +    AtomicBoolean reconstructState = new AtomicBoolean(false);\n    +    collectionWatches.compute(collection, (k, v) -> {\n    +      if (v == null)\n    +        return null;\n    +      if (v.coreRefCount > 0)\n    +        v.coreRefCount--;\n    +      if (v.canBeRemoved()) {\n    +        watchedCollectionStates.remove(collection);\n    +        lazyCollectionStates.put(collection, new LazyCollectionRef(collection));\n    +        reconstructState.set(true);\n    +        return null;\n    +      }\n    +      return v;\n    +    });\n    +    if (reconstructState.get()) {\n    +      synchronized (getUpdateLock()) {    +        constructState();    +      }    +    } \n    +  }\n    +\n    +  /**\n    +   * Register a CollectionStateWatcher to be called when the state of a collection changes\n    +   *\n    +   * A given CollectionStateWatcher will be only called once.  If you want to have a persistent watcher,\n    +   * it should register itself again in its \n{@link CollectionStateWatcher#onStateChanged(Set, DocCollection)}\n    +   * method.\n    +   */\n    +  public void registerCollectionStateWatcher(String collection, CollectionStateWatcher stateWatcher) {\n    +    AtomicBoolean watchSet = new AtomicBoolean(false);\n    +    collectionWatches.compute(collection, (k, v) -> \nUnknown macro: {    +      if (v == null) {\n    +        v = new CollectionWatch();\n    +        watchSet.set(true);\n    +      }    +      v.stateWatchers.add(stateWatcher);    +      return v;    +    } \n);\n    +    if (watchSet.get()) {\n    +      new StateWatcher(collection).refreshAndWatch();\n\t\n\t\t\n\t\t\n\t\t\tEnd diff \u2013\n\t\t\n\t\t\n\t\n\t\n\n\n\n    I feel like this needs to check whether or not the collection exists / is a legacy collection.  If it's a legacy collection, you don't want to try to create a StateWatcher. ",
            "id": "comment-15279218"
        },
        {
            "date": "2016-05-10T23:27:59+0000",
            "author": "ASF GitHub Bot",
            "content": "Github user dragonsinth commented on a diff in the pull request:\n\n    https://github.com/apache/lucene-solr/pull/32#discussion_r62771180\n\n    \u2014 Diff: solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader.java \u2014\n    @@ -1069,32 +1100,190 @@ public static String getCollectionPath(String coll) \n{\n         return COLLECTIONS_ZKNODE+\"/\"+coll + \"/state.json\";\n       }\n\n\n\tpublic void addCollectionWatch(String coll) {\n\tif (interestingCollections.add(coll)) {\n\tLOG.info(\"addZkWatch [{}]\", coll);\n\tnew StateWatcher(coll).refreshAndWatch(false);\n    +  /**\n    +   * Notify this reader that a local Core is a member of a collection, and so that collection\n    +   * state should be watched.\n    +   *\n    +   * Not a public API.  This method should only be called from ZkController.\n    +   *\n    +   * The number of cores per-collection is tracked, and adding multiple cores from the same\n    +   * collection does not increase the number of watches.\n    +   *\n    +   * @param collection the collection that the core is a member of\n    +   *\n    +   * @see ZkStateReader#unregisterCore(String)\n    +   */\n    +  public void registerCore(String collection) {\n    +    AtomicBoolean reconstructState = new AtomicBoolean(false);\n    +    collectionWatches.compute(collection, (k, v) -> \nUnknown macro: {    +      if (v == null) {\n    +        reconstructState.set(true);\n    +        v = new CollectionWatch();\n    +      }    +      v.coreRefCount++;    +      return v;    +    } \n);\n    +    if (reconstructState.get()) {\n    +      new StateWatcher(collection).refreshAndWatch();\n\t\n\t\t\n\t\t\n\t\t\tEnd diff \u2013\n\t\t\n\t\t\n\t\n\t\n\n\n\n    (same) I feel like this needs to check whether or not the collection exists / is a legacy collection.  If it's a legacy collection, you don't want to try to create a StateWatcher. ",
            "id": "comment-15279219"
        },
        {
            "date": "2016-05-10T23:29:10+0000",
            "author": "ASF GitHub Bot",
            "content": "Github user dragonsinth commented on the pull request:\n\n    https://github.com/apache/lucene-solr/pull/32#issuecomment-218321437\n\n    Almost LGTM.  There's a few nits, but the only real issue is potentially setting up a StateWatcher on legacy.\n\n    Nice work, I think we're almost done!! ",
            "id": "comment-15279223"
        },
        {
            "date": "2016-05-11T08:39:08+0000",
            "author": "ASF GitHub Bot",
            "content": "Github user romseygeek commented on a diff in the pull request:\n\n    https://github.com/apache/lucene-solr/pull/32#discussion_r62810535\n\n    \u2014 Diff: solr/solrj/src/test/org/apache/solr/common/cloud/TestCollectionStateWatchers.java \u2014\n    @@ -0,0 +1,235 @@\n    +package org.apache.solr.common.cloud;\n    +\n    +/*\n    + * Licensed to the Apache Software Foundation (ASF) under one or more\n    + * contributor license agreements.  See the NOTICE file distributed with\n    + * this work for additional information regarding copyright ownership.\n    + * The ASF licenses this file to You under the Apache License, Version 2.0\n    + * (the \"License\"); you may not use this file except in compliance with\n    + * the License.  You may obtain a copy of the License at\n    + *\n    + *     http://www.apache.org/licenses/LICENSE-2.0\n    + *\n    + * Unless required by applicable law or agreed to in writing, software\n    + * distributed under the License is distributed on an \"AS IS\" BASIS,\n    + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    + * See the License for the specific language governing permissions and\n    + * limitations under the License.\n    + */\n    +\n    +import java.util.HashMap;\n    +import java.util.Set;\n    +import java.util.concurrent.CountDownLatch;\n    +import java.util.concurrent.ExecutorService;\n    +import java.util.concurrent.Future;\n    +import java.util.concurrent.TimeUnit;\n    +import java.util.concurrent.TimeoutException;\n    +import java.util.concurrent.atomic.AtomicInteger;\n    +\n    +import org.apache.solr.client.solrj.embedded.JettySolrRunner;\n    +import org.apache.solr.client.solrj.impl.CloudSolrClient;\n    +import org.apache.solr.client.solrj.request.CollectionAdminRequest;\n    +import org.apache.solr.cloud.SolrCloudTestCase;\n    +import org.apache.solr.common.util.ExecutorUtil;\n    +import org.apache.solr.common.util.SolrjNamedThreadFactory;\n    +import org.junit.AfterClass;\n    +import org.junit.Before;\n    +import org.junit.BeforeClass;\n    +import org.junit.Test;\n    +\n    +import static org.hamcrest.core.Is.is;\n    +\n    +public class TestCollectionStateWatchers extends SolrCloudTestCase {\n    +\n    +  private static final int CLUSTER_SIZE = 4;\n    +\n    +  private static final ExecutorService executor = ExecutorUtil.newMDCAwareCachedThreadPool(\n    +      new SolrjNamedThreadFactory(\"backgroundWatchers\")\n    +  );\n    +\n    +  private static final int MAX_WAIT_TIMEOUT = 30;\n    +\n    +  @BeforeClass\n    +  public static void startCluster() throws Exception \n{\n    +    configureCluster(CLUSTER_SIZE)\n    +        .addConfig(\"config\", getFile(\"solrj/solr/collection1/conf\").toPath())\n    +        .configure();\n    +  }\n    +\n    +  @AfterClass\n    +  public static void shutdownBackgroundExecutors() \n{\n    +    executor.shutdown();\n    +  }\n    +\n    +  @Before\n    +  public void prepareCluster() throws Exception {\n    +    int missingServers = CLUSTER_SIZE - cluster.getJettySolrRunners().size();\n    +    for (int i = 0; i < missingServers; i++) \n{\n    +      cluster.startJettySolrRunner();\n    +    }\n    +    cluster.waitForAllNodes(30);\n    +  }\n    +\n    +  private static Future<Boolean> waitInBackground(String collection, long timeout, TimeUnit unit,\n    +                                                  CollectionStatePredicate predicate) {\n    +    return executor.submit(() -> {\n    +      try \n{\n    +        cluster.getSolrClient().waitForState(collection, timeout, unit, predicate);\n    +      }\n catch (InterruptedException | TimeoutException e) \n{\n    +        return Boolean.FALSE;\n    +      }\n    +      return Boolean.TRUE;\n    +    });\n    +  }\n    +\n    +\n    +  @Test\n    +  public void testSimpleCollectionWatch() throws Exception {\n    +\n    +    CloudSolrClient client = cluster.getSolrClient();\n    +    cluster.createCollection(\"testcollection\", CLUSTER_SIZE, 1, \"config\", new HashMap<>());\n    +\n    +    client.waitForState(\"testcollection\", MAX_WAIT_TIMEOUT, TimeUnit.SECONDS, DocCollection::isFullyActive);\n    +\n    +    // shutdown a node and check that we get notified about the change\n    +    final AtomicInteger nodeCount = new AtomicInteger(0);\n    +    final CountDownLatch latch = new CountDownLatch(1);\n    +    client.registerCollectionStateWatcher(\"testcollection\", (liveNodes, collectionState) -> {\n    +      // we can't just count liveNodes here, because that's updated by a separate watcher,\n    +      // and it may be the case that we're triggered by a node setting itself to DOWN before\n    +      // the liveNodes watcher is called\n    +      for (Slice slice : collectionState) {\n    +        for (Replica replica : slice) \n{\n    +          if (replica.isActive(liveNodes))\n    +            nodeCount.incrementAndGet();\n    +        }\n    +      }\n    +      latch.countDown();\n    +    });\n    +\n    +    cluster.stopJettySolrRunner(random().nextInt(cluster.getJettySolrRunners().size()));\n    +    assertTrue(\"CollectionStateWatcher was never notified of cluster change\", latch.await(MAX_WAIT_TIMEOUT, TimeUnit.SECONDS));\n    +\n    +    assertThat(nodeCount.intValue(), is(3));\n    +\n    +  }\n    +\n    +  @Test\n    +  public void testWaitForStateChecksCurrentState() throws Exception {\n    +\n    +    CloudSolrClient client = cluster.getSolrClient();\n    +    cluster.createCollection(\"waitforstate\", 1, 1, \"config\", new HashMap<>());\n    +\n    +    client.waitForState(\"waitforstate\", MAX_WAIT_TIMEOUT, TimeUnit.SECONDS, DocCollection::isFullyActive);\n    +\n    +    // several goes, to check that we're not getting delayed state changes\n    +    for (int i = 0; i < 10; i++) {\n    +      try \n{\n    +        client.waitForState(\"waitforstate\", 1, TimeUnit.SECONDS, DocCollection::isFullyActive);\n    +      }\n    +      catch (TimeoutException e) \n{\n    +        fail(\"waitForState should return immediately if the predicate is already satisfied\");\n    +      }\n    +    }\n    +\n    +  }\n    +\n    +  @Test\n    +  public void testCanWatchForNonexistantCollection() throws Exception {\n    \u2014 End diff \u2013\n\n    If there's already a watch set, then it won't be fired.  If there's no watch set, then it will be fired by StateWatcher#refreshAndWatch(). ",
            "id": "comment-15279790"
        },
        {
            "date": "2016-05-11T08:40:11+0000",
            "author": "ASF GitHub Bot",
            "content": "Github user romseygeek commented on a diff in the pull request:\n\n    https://github.com/apache/lucene-solr/pull/32#discussion_r62810671\n\n    \u2014 Diff: solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader.java \u2014\n    @@ -635,6 +669,8 @@ public Object getUpdateLock() {\n\n       public void close() {\n         this.closed  = true;\n    +    notifications.shutdownNow();  // interrupt\n    \u2014 End diff \u2013\n\n    Ah, no, that's left over from the queue impl, will remove it. ",
            "id": "comment-15279793"
        },
        {
            "date": "2016-05-11T18:28:08+0000",
            "author": "ASF GitHub Bot",
            "content": "Github user dragonsinth commented on a diff in the pull request:\n\n    https://github.com/apache/lucene-solr/pull/32#discussion_r62900820\n\n    \u2014 Diff: solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader.java \u2014\n    @@ -1069,32 +1100,190 @@ public static String getCollectionPath(String coll) \n{\n         return COLLECTIONS_ZKNODE+\"/\"+coll + \"/state.json\";\n       }\n\n\n\tpublic void addCollectionWatch(String coll) {\n\tif (interestingCollections.add(coll)) {\n\tLOG.info(\"addZkWatch [{}]\", coll);\n\tnew StateWatcher(coll).refreshAndWatch(false);\n    +  /**\n    +   * Notify this reader that a local Core is a member of a collection, and so that collection\n    +   * state should be watched.\n    +   *\n    +   * Not a public API.  This method should only be called from ZkController.\n    +   *\n    +   * The number of cores per-collection is tracked, and adding multiple cores from the same\n    +   * collection does not increase the number of watches.\n    +   *\n    +   * @param collection the collection that the core is a member of\n    +   *\n    +   * @see ZkStateReader#unregisterCore(String)\n    +   */\n    +  public void registerCore(String collection) {\n    +    AtomicBoolean reconstructState = new AtomicBoolean(false);\n    +    collectionWatches.compute(collection, (k, v) -> \nUnknown macro: {    +      if (v == null) {\n    +        reconstructState.set(true);\n    +        v = new CollectionWatch();\n    +      }    +      v.coreRefCount++;    +      return v;    +    } \n);\n    +    if (reconstructState.get()) {\n    +      new StateWatcher(collection).refreshAndWatch();\n\t\n\t\t\n\t\t\n\t\t\tEnd diff \u2013\n\t\t\n\t\t\n\t\n\t\n\n\n\n    Ignore this, I'm dumb.  You want a state watcher either way (the old code did this). ",
            "id": "comment-15280580"
        },
        {
            "date": "2016-05-11T18:28:17+0000",
            "author": "ASF GitHub Bot",
            "content": "Github user dragonsinth commented on a diff in the pull request:\n\n    https://github.com/apache/lucene-solr/pull/32#discussion_r62900842\n\n    \u2014 Diff: solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader.java \u2014\n    @@ -1069,32 +1100,190 @@ public static String getCollectionPath(String coll) \n{\n         return COLLECTIONS_ZKNODE+\"/\"+coll + \"/state.json\";\n       }\n\n\n\tpublic void addCollectionWatch(String coll) {\n\tif (interestingCollections.add(coll)) {\n\tLOG.info(\"addZkWatch [{}]\", coll);\n\tnew StateWatcher(coll).refreshAndWatch(false);\n    +  /**\n    +   * Notify this reader that a local Core is a member of a collection, and so that collection\n    +   * state should be watched.\n    +   *\n    +   * Not a public API.  This method should only be called from ZkController.\n    +   *\n    +   * The number of cores per-collection is tracked, and adding multiple cores from the same\n    +   * collection does not increase the number of watches.\n    +   *\n    +   * @param collection the collection that the core is a member of\n    +   *\n    +   * @see ZkStateReader#unregisterCore(String)\n    +   */\n    +  public void registerCore(String collection) {\n    +    AtomicBoolean reconstructState = new AtomicBoolean(false);\n    +    collectionWatches.compute(collection, (k, v) -> \nUnknown macro: {    +      if (v == null) {\n    +        reconstructState.set(true);\n    +        v = new CollectionWatch();\n    +      }    +      v.coreRefCount++;    +      return v;    +    } \n);\n    +    if (reconstructState.get()) \nUnknown macro: {    +      new StateWatcher(collection).refreshAndWatch();    +      synchronized (getUpdateLock()) {\n    +        constructState();\n    +      }\n    +    }\n    +  }\n    +\n    +  /**\n    +   * Notify this reader that a local core that is a member of a collection has been closed.\n    +   *\n    +   * Not a public API.  This method should only be called from ZkController.\n    +   *\n    +   * If no cores are registered for a collection, and there are no {@link CollectionStateWatcher}s\n    +   * for that collection either, the collection watch will be removed.\n    +   *\n    +   * @param collection the collection that the core belongs to\n    +   */\n    +  public void unregisterCore(String collection) {\n    +    AtomicBoolean reconstructState = new AtomicBoolean(false);\n    +    collectionWatches.compute(collection, (k, v) -> {\n    +      if (v == null)\n    +        return null;\n    +      if (v.coreRefCount > 0)\n    +        v.coreRefCount--;\n    +      if (v.canBeRemoved()) {\n    +        watchedCollectionStates.remove(collection);\n    +        lazyCollectionStates.put(collection, new LazyCollectionRef(collection));\n    +        reconstructState.set(true);\n    +        return null;\n    +      }\n    +      return v;\n    +    });\n    +    if (reconstructState.get()) {\n    +      synchronized (getUpdateLock()) {    +        constructState();    +      }    +    } \n    +  }\n    +\n    +  /**\n    +   * Register a CollectionStateWatcher to be called when the state of a collection changes\n    +   *\n    +   * A given CollectionStateWatcher will be only called once.  If you want to have a persistent watcher,\n    +   * it should register itself again in its \n{@link CollectionStateWatcher#onStateChanged(Set, DocCollection)}\n    +   * method.\n    +   */\n    +  public void registerCollectionStateWatcher(String collection, CollectionStateWatcher stateWatcher) {\n    +    AtomicBoolean watchSet = new AtomicBoolean(false);\n    +    collectionWatches.compute(collection, (k, v) -> \nUnknown macro: {    +      if (v == null) {\n    +        v = new CollectionWatch();\n    +        watchSet.set(true);\n    +      }    +      v.stateWatchers.add(stateWatcher);    +      return v;    +    } \n);\n    +    if (watchSet.get()) {\n    +      new StateWatcher(collection).refreshAndWatch();\n\t\n\t\t\n\t\t\n\t\t\tEnd diff \u2013\n\t\t\n\t\t\n\t\n\t\n\n\n\n    ditto, ignore this ",
            "id": "comment-15280582"
        },
        {
            "date": "2016-05-13T17:00:25+0000",
            "author": "Alan Woodward",
            "content": "Final patch.  I think this is ready! ",
            "id": "comment-15282875"
        },
        {
            "date": "2016-05-13T19:55:47+0000",
            "author": "Scott Blum",
            "content": "I already LGTM'd the github PR, I don't think I need to look at the patch file? ",
            "id": "comment-15283077"
        },
        {
            "date": "2016-05-13T20:34:40+0000",
            "author": "ASF subversion and git services",
            "content": "Commit b6d742141250a8395c96d364714a31f4a3a63a96 in lucene-solr's branch refs/heads/master from Alan Woodward\n[ https://git-wip-us.apache.org/repos/asf?p=lucene-solr.git;h=b6d7421 ]\n\nSOLR-8323: Add CollectionStateWatcher API ",
            "id": "comment-15283113"
        },
        {
            "date": "2016-05-13T20:43:54+0000",
            "author": "ASF subversion and git services",
            "content": "Commit 06d2f6368df9b6d29d852f18bab38d96255d83c7 in lucene-solr's branch refs/heads/branch_6x from Alan Woodward\n[ https://git-wip-us.apache.org/repos/asf?p=lucene-solr.git;h=06d2f63 ]\n\nSOLR-8323: Add CollectionStateWatcher API ",
            "id": "comment-15283127"
        },
        {
            "date": "2016-05-13T20:45:09+0000",
            "author": "Alan Woodward",
            "content": "Thanks for all the reviewing Scott!  Now on to SOLR-9056  ",
            "id": "comment-15283129"
        },
        {
            "date": "2016-05-14T11:53:04+0000",
            "author": "ASF subversion and git services",
            "content": "Commit 963c6522b6e10bfeaad340457d1e96351d0aecc1 in lucene-solr's branch refs/heads/master from Alan Woodward\n[ https://git-wip-us.apache.org/repos/asf?p=lucene-solr.git;h=963c652 ]\n\nSOLR-8323: DocCollection.isFullyActive needs to know how many replicas to expect ",
            "id": "comment-15283530"
        },
        {
            "date": "2016-05-14T12:01:21+0000",
            "author": "ASF subversion and git services",
            "content": "Commit 06ebd4fd7e9045b28a6a243c56f753b4f56c8561 in lucene-solr's branch refs/heads/branch_6x from Alan Woodward\n[ https://git-wip-us.apache.org/repos/asf?p=lucene-solr.git;h=06ebd4f ]\n\nSOLR-8323: DocCollection.isFullyActive needs to know how many replicas to expect ",
            "id": "comment-15283534"
        },
        {
            "date": "2016-05-14T18:09:26+0000",
            "author": "ASF subversion and git services",
            "content": "Commit c0d23a741e9f2c787ab322e29c67108e5fd5c692 in lucene-solr's branch refs/heads/master from Alan Woodward\n[ https://git-wip-us.apache.org/repos/asf?p=lucene-solr.git;h=c0d23a7 ]\n\nSOLR-8323: Handle removal of legacy collections ",
            "id": "comment-15283635"
        },
        {
            "date": "2016-05-14T18:10:11+0000",
            "author": "ASF subversion and git services",
            "content": "Commit b5c369a773689955aa9bbd1b0bce3b7d1d96cb1b in lucene-solr's branch refs/heads/branch_6x from Alan Woodward\n[ https://git-wip-us.apache.org/repos/asf?p=lucene-solr.git;h=b5c369a ]\n\nSOLR-8323: Handle removal of legacy collections ",
            "id": "comment-15283636"
        },
        {
            "date": "2016-05-15T10:24:44+0000",
            "author": "Alan Woodward",
            "content": "Still seeing test failures here, for example: http://jenkins.thetaphi.de/job/Lucene-Solr-6.x-Windows/181/consoleFull\n\nIt looks as though the collection watcher is being fired even though the state hasn't actually changed.  Will add some more debugging to try and work out why. ",
            "id": "comment-15283821"
        },
        {
            "date": "2016-05-15T17:04:54+0000",
            "author": "Alan Woodward",
            "content": "OK, I think I see what's happening.  \n\nThe test waits for a collection to be up, and then registers a watch to check for subsequent changes.  Once a wait has returned, then the watch is removed, but the collection isn't actually removed from the 'interesting' list until the next state update.\n\nWe have a race between state watchers being cleared after firing and the subsequent removal of a collection from the 'interesting' list, and the new watcher being added.  On a fast machine, the new watcher is added before the old one is cleared, and so the state is preserved between the calls; this means that the new watcher isn't actually fired, because we check if the state has changed before running notifications.  On a slower machine, the watcher is added afterwards, so there's no previous state to compare against, so the watcher is fired immediately - resulting in a test failure, because the test is expecting the state to have changed.\n\nWe can fix the test by calling registerCore() first, which puts the collection permanently on the watched list, but I think there's a bigger question here about how useful statewatchers are, as opposed to state predicate checks.  All the uses I've come up with so far have just been waitForState() calls.  Scott Blum what do you think? ",
            "id": "comment-15283882"
        },
        {
            "date": "2016-05-23T20:24:33+0000",
            "author": "Scott Blum",
            "content": "Alan Woodward sorry I'm just now having a moment to look at this.  Is this still flakey on master?  Do you have a good spot to drop in a Thread.sleep() to trigger this reliably?  If not I'll play around. ",
            "id": "comment-15297017"
        },
        {
            "date": "2016-05-23T20:34:54+0000",
            "author": "Alan Woodward",
            "content": "SOLR-9113 fixed the test failures. ",
            "id": "comment-15297033"
        },
        {
            "date": "2016-05-23T20:43:38+0000",
            "author": "Scott Blum",
            "content": "Nice, I was just figuring that out.  ",
            "id": "comment-15297052"
        }
    ]
}