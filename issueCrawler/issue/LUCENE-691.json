{
    "id": "LUCENE-691",
    "title": "Bob Carpenter's FuzzyTermEnum refactoring",
    "details": {
        "labels": "",
        "priority": "Minor",
        "components": [
            "core/search"
        ],
        "type": "Improvement",
        "fix_versions": [],
        "affect_versions": "None",
        "resolution": "Duplicate",
        "status": "Resolved"
    },
    "description": "I'll just paste Bob's complete email here.\n\nI refactored the org.apache.lucene.search.FuzzyTermEnum\nedit distance implementation.  It now only uses a single\npair of arrays, and those never get resized.  That required\nturning the order of text/target around in the loops.  You'll\nsee that with the pair of arrays method, they get re-used\nhand-over-hand, and are assigned to local variables in the\ntight loops.\n\nI removed the calculation of min distance and replaced\nit with a boolean \u2013 the min wasn't needed, only the test vs.\nthe max.  I also flipped some variables around so there's\none less addition in the very inner loop and the arrays are\nnow looping in the ordinary way (starting at 0 with a < comparison).\nI also commented out the redundant definition of the public close()\n[which just called super.close() and had none of its own doc.]\nI also just compute the max distance each time rather than\nfiddling with an array \u2013 it's just a little arithmetic done once\nper term, but that could be put back.\n\nI also rewrote min(int,int,int) to get rid of intermediate\nassignments.  Is there a lib for this kind of thing?\n\nAn intermediate refactoring that does the hand-over-hand\nwith the existing array and resizing strategy is in\nFuzzyTermEnum.intermed.java.\n\nI ran the unit tests as follows on both versions (my hat's off to the\nbuild.xml author(s) \u2013 this all just worked out of the box and was\nreally easy to follow the first through):\n\nC:\\java\\lucene-2.0.0>ant -Djunit.includes=\"\" -Dtestcase=TestFuzzyQuery test\nBuildfile: build.xml\njavacc-uptodate-check:\njavacc-notice:\ninit:\ncommon.compile-core:\n    [javac] Compiling 1 source file to\nC:\\java\\lucene-2.0.0\\build\\classes\\java\ncompile-core:\ncompile-demo:\ncommon.compile-test:\ncompile-test:\ntest:\n    [junit] Testsuite: org.apache.lucene.search.TestFuzzyQuery\n    [junit] Tests run: 2, Failures: 0, Errors: 0, Time elapsed: 0.453 sec\nBUILD SUCCESSFUL\nTotal time: 2 seconds\n\nDoes anyone have regression/performance test harnesses?\nThe unit tests were pretty minimal (which is a good thing!).\nIt'd be nice to test the min impl (ternary vs. if/then)\nand the assumption about not allocating an\narray of max distances.  All told, the refactored version\nshould be a modest speed improvement, mainly from\nunfolding the arrays so they're local one-dimensional refs.\n\nI don't know what the protocol is for one-off contributions.\nI'm happy with the Apache license, so that shouldn't\nbe a problem.  I also don't know whether you use tabs\nor spaces \u2013 I untabified the final version and used your\ntwo-space format in emacs.\n\n\n\tBob Carpenter\npackage org.apache.lucene.search;\n\n\n\n/**\n\n\tCopyright 2004 The Apache Software Foundation\n*\n\tLicensed under the Apache License, Version 2.0 (the \"License\");\n\tyou may not use this file except in compliance with the License.\n\tYou may obtain a copy of the License at\n*\n\thttp://www.apache.org/licenses/LICENSE-2.0\n*\n\tUnless required by applicable law or agreed to in writing, software\n\tdistributed under the License is distributed on an \"AS IS\" BASIS,\n\tWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\tSee the License for the specific language governing permissions and\n\tlimitations under the License.\n*/\n\n\n\nimport org.apache.lucene.index.IndexReader;\nimport org.apache.lucene.index.Term;\n\nimport java.io.IOException;\n\n/** Subclass of FilteredTermEnum for enumerating all terms that are similiar\n\n\tto the specified filter term.\n*\n\t<p>Term enumerations are always ordered by Term.compareTo().  Each term in\n\tthe enumeration is greater than all that precede it.\n*/\npublic final class FuzzyTermEnum extends FilteredTermEnum {\n\n\n\n  /* This should be somewhere around the average long word.\n\n\tIf it is longer, we waste time and space. If it is shorter, we waste a\n\tlittle bit of time growing the array as we encounter longer words.\n   */\n  private static final int TYPICAL_LONGEST_WORD_IN_INDEX = 19;\n\n\n\n  /* Allows us save time required to create a new array\n\n\teverytime similarity is called.  These are slices that\n\twill be reused during dynamic programming hand-over-hand\n\tstyle.\n   */\n  private final int[] d0;\n  private final int[] d1;    \n\n\n\n  private float similarity;\n  private boolean endEnum = false;\n\n  private Term searchTerm = null;\n  private final String field;\n  private final String text;\n  private final String prefix;\n\n  private final float minimumSimilarity;\n  private final float scale_factor;\n\n  /**\n\n\tCreates a FuzzyTermEnum with an empty prefix and a minSimilarity of 0.5f.\n\t<p>\n\tAfter calling the constructor the enumeration is already pointing to the first\n\tvalid term if such a term exists.\n   *\n\t@param reader\n\t@param term\n\t@throws IOException\n\t@see #FuzzyTermEnum(IndexReader, Term, float, int)\n   */\n  public FuzzyTermEnum(IndexReader reader, Term term) throws IOException \n{\n    this(reader, term, FuzzyQuery.defaultMinSimilarity, FuzzyQuery.defaultPrefixLength);\n  }\n    \n  /**\n   * Creates a FuzzyTermEnum with an empty prefix.\n   * <p>\n   * After calling the constructor the enumeration is already pointing to the first\n   * valid term if such a term exists.\n   *\n   * @param reader\n   * @param term\n   * @param minSimilarity\n   * @throws IOException\n   * @see #FuzzyTermEnum(IndexReader, Term, float, int)\n   */\n  public FuzzyTermEnum(IndexReader reader, Term term, float minSimilarity) throws IOException {\n    this(reader, term, minSimilarity, FuzzyQuery.defaultPrefixLength);\n  }\n    \n  /**\n   * Constructor for enumeration of all terms from specified <code>reader</code> which share a prefix of\n   * length <code>prefixLength</code> with <code>term</code> and which have a fuzzy similarity >\n   * <code>minSimilarity</code>.\n   * <p>\n   * After calling the constructor the enumeration is already pointing to the first\n   * valid term if such a term exists.\n   *\n   * @param reader Delivers terms.\n   * @param term Pattern term.\n   * @param minSimilarity Minimum required similarity for terms from the reader. Default value is 0.5f.\n   * @param prefixLength Length of required common prefix. Default value is 0.\n   * @throws IOException\n   */\n  public FuzzyTermEnum(IndexReader reader, Term term, final float minSimilarity, final int prefixLength) throws IOException {\n    super();\n    \n    if (minSimilarity >= 1.0f)\n      throw new IllegalArgumentException(\"minimumSimilarity cannot be greater than or equal to 1\");\n    else if (minSimilarity < 0.0f)\n      throw new IllegalArgumentException(\"minimumSimilarity cannot be less than 0\");\n    if(prefixLength < 0)\n      throw new IllegalArgumentException(\"prefixLength cannot be less than 0\");\n\n    this.minimumSimilarity = minSimilarity;\n    this.scale_factor = 1.0f / (1.0f - minimumSimilarity);\n    this.searchTerm = term;\n    this.field = searchTerm.field();\n\n    //The prefix could be longer than the word.\n    //It's kind of silly though.  It means we must match the entire word.\n    final int fullSearchTermLength = searchTerm.text().length();\n    final int realPrefixLength = prefixLength > fullSearchTermLength ? fullSearchTermLength : prefixLength;\n\n    this.text = searchTerm.text().substring(realPrefixLength);\n    this.prefix = searchTerm.text().substring(0, realPrefixLength);\n\n    this.d0 = new int[this.text.length()+1];\n    this.d1 = new int[this.d0.length];\n\n    setEnum(reader.terms(new Term(searchTerm.field(), prefix)));\n  }\n\n  /**\n   * The termCompare method in FuzzyTermEnum uses Levenshtein distance to\n   * calculate the distance between the given term and the comparing term.\n   */\n  protected final boolean termCompare(Term term) {\n    if (field == term.field() && term.text().startsWith(prefix)) {\n        final String target = term.text().substring(prefix.length());\n        this.similarity = similarity(target);\n        return (similarity > minimumSimilarity);\n    }\n    endEnum = true;\n    return false;\n  }\n  \n  public final float difference() {\n    return (float)((similarity - minimumSimilarity) * scale_factor);\n  }\n  \n  public final boolean endEnum() {\n    return endEnum;\n  }\n  \n  /******************************\n   * Compute Levenshtein distance\n   ******************************/\n  \n  /**\n   * Finds and returns the smallest of three integers\n   */\n  private static final int min(int a, int b, int c) {\n      // removed assignments to use double ternary\n      return (a < b)\n          ? ((a < c) ? a : c)\n          : ((b < c) ? b: c);\n\n      // alt form is:\n      // if (a < b) { if (a < c) return a; else return c; }\n      // if (b < c) return b; else return c;\n  }\n\n  /**\n   * <p>Similarity returns a number that is 1.0f or less (including negative numbers)\n   * based on how similar the Term is compared to a target term.  It returns\n   * exactly 0.0f when\n   * <pre>\n   *    editDistance < maximumEditDistance</pre>\n   * Otherwise it returns:\n   * <pre>\n   *    1 - (editDistance / length)</pre>\n   * where length is the length of the shortest term (text or target) including a\n   * prefix that are identical and editDistance is the Levenshtein distance for\n   * the two words.</p>\n   *\n   * <p>Embedded within this algorithm is a fail-fast Levenshtein distance\n   * algorithm.  The fail-fast algorithm differs from the standard Levenshtein\n   * distance algorithm in that it is aborted if it is discovered that the\n   * mimimum distance between the words is greater than some threshold.\n   *\n   * <p>To calculate the maximum distance threshold we use the following formula:\n   * <pre>\n   *     (1 - minimumSimilarity) * length</pre>\n   * where length is the shortest term including any prefix that is not part of the\n   * similarity comparision.  This formula was derived by solving for what maximum value\n   * of distance returns false for the following statements:\n   * <pre>\n   *   similarity = 1 - ((float)distance / (float) (prefixLength + Math.min(textlen, targetlen)));\n   *   return (similarity > minimumSimilarity);</pre>\n   * where distance is the Levenshtein distance for the two words.\n   * </p>\n   * <p>Levenshtein distance (also known as edit distance) is a measure of similiarity\n   * between two strings where the distance is measured as the number of character\n   * deletions, insertions or substitutions required to transform one string to\n   * the other string.\n   * @param target the target word or phrase\n   * @return the similarity,  0.0 or less indicates that it matches less than the required\n   * threshold and 1.0 indicates that the text and target are identical\n   */\n  private synchronized final float similarity(final String target) {\n    final int m = target.length();\n    final int n = text.length();\n    if (n == 0)  {\n      //we don't have anything to compare.  That means if we just add\n      //the letters for m we get the new word\n      return prefix.length() == 0 ? 0.0f : 1.0f - ((float) m / prefix.length());\n    }\n    if (m == 0) {\n      return prefix.length() == 0 ? 0.0f : 1.0f - ((float) n / prefix.length());\n    }\n\n    final int maxDistance = calculateMaxDistance(m);\n\n    if (maxDistance < Math.abs(m-n)) {\n      //just adding the characters of m to n or vice-versa results in\n      //too many edits\n      //for example \"pre\" length is 3 and \"prefixes\" length is 8.  We can see that\n      //given this optimal circumstance, the edit distance cannot be less than 5.\n      //which is 8-3 or more precisesly Math.abs(3-8).\n      //if our maximum edit distance is 4, then we can discard this word\n      //without looking at it.\n      return 0.0f;\n    }\n\n    int[] dLast = d0;  // set locals for efficiency\n    int[] dCurrent = d1;\n    for (int j = 0; j <= n; j++) dCurrent[j] = j;\n\n    for (int i = 0; i < m; ) {\n      final char s_i = target.charAt;\n      int[] dTemp = dLast;\n      dLast = dCurrent;    // previously: d[i-i]\n      dCurrent = dTemp;    // previously: d[i]\n      boolean prune = (dCurrent[0] = ++i) > maxDistance; // true if d[i][0] is too large\n      for (int j = 0; j < n; j++) {\n        dCurrent[j+1] = (s_i == text.charAt(j))\n            ? min(dLast[j+1]+1, dCurrent[j]+1, dLast[j])\n            : min(dLast[j+1], dCurrent[j], dLast[j])+1;\n        if (prune && dCurrent[j+1] <= maxDistance)\n            prune = false;\n      }\n\n      // (prune==false) iff (dCurrent[j] < maxDistance) for some j\n      if (prune) {\n          return 0.0f;\n      }\n    }\n    \n    // this will return less than 0.0 when the edit distance is\n    // greater than the number of characters in the shorter word.\n    // but this was the formula that was previously used in FuzzyTermEnum,\n    // so it has not been changed (even though minimumSimilarity must be\n    // greater than 0.0)\n    return 1.0F - dCurrent[n]/(float)(prefix.length() + Math.min(n,m));\n  }\n\n  private int calculateMaxDistance(int m) {\n    return (int) ((1-minimumSimilarity) * (Math.min(text.length(), m) + prefix.length()));\n  }\n\n    /* This is redundant\n  public void close() throws IOException {\n    super.close();  //call super.close() and let the garbage collector do its work.\n  }\n    */\n  \n\n}\npackage org.apache.lucene.search;\n\n/**\n* Copyright 2004 The Apache Software Foundation\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*     http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\nimport org.apache.lucene.index.IndexReader;\nimport org.apache.lucene.index.Term;\n\nimport java.io.IOException;\n\n/** Subclass of FilteredTermEnum for enumerating all terms that are similiar\n* to the specified filter term.\n*\n* <p>Term enumerations are always ordered by Term.compareTo().  Each term in\n* the enumeration is greater than all that precede it.\n*/\npublic final class FuzzyTermEnum extends FilteredTermEnum {\n\n  /* This should be somewhere around the average long word.\n   * If it is longer, we waste time and space. If it is shorter, we waste a\n   * little bit of time growing the array as we encounter longer words.\n   */\n  private static final int TYPICAL_LONGEST_WORD_IN_INDEX = 19;\n\n  /* Allows us save time required to create a new array\n   * everytime similarity is called.  These are slices that\n   * will be reused during dynamic programming hand-over-hand\n   * style.  They get resized, if necessary, by growDistanceArrays(int).\n   */\n  private int[] d0;\n  private int[] d1;    \n\n  private float similarity;\n  private boolean endEnum = false;\n\n  private Term searchTerm = null;\n  private final String field;\n  private final String text;\n  private final String prefix;\n\n  private final float minimumSimilarity;\n  private final float scale_factor;\n\n  /**\n   * Creates a FuzzyTermEnum with an empty prefix and a minSimilarity of 0.5f.\n   * <p>\n   * After calling the constructor the enumeration is already pointing to the first\n   * valid term if such a term exists.\n   *\n   * @param reader\n   * @param term\n   * @throws IOException\n   * @see #FuzzyTermEnum(IndexReader, Term, float, int)\n   */\n  public FuzzyTermEnum(IndexReader reader, Term term) throws IOException {    this(reader, term, FuzzyQuery.defaultMinSimilarity, FuzzyQuery.defaultPrefixLength);  }\n\n\n\n  /**\n\n\tCreates a FuzzyTermEnum with an empty prefix.\n\t<p>\n\tAfter calling the constructor the enumeration is already pointing to the first\n\tvalid term if such a term exists.\n   *\n\t@param reader\n\t@param term\n\t@param minSimilarity\n\t@throws IOException\n\t@see #FuzzyTermEnum(IndexReader, Term, float, int)\n   */\n  public FuzzyTermEnum(IndexReader reader, Term term, float minSimilarity) throws IOException \n{\n    this(reader, term, minSimilarity, FuzzyQuery.defaultPrefixLength);\n  }\n\n\n\n  /**\n\n\tConstructor for enumeration of all terms from specified <code>reader</code> which share a prefix of\n\tlength <code>prefixLength</code> with <code>term</code> and which have a fuzzy similarity >\n\t<code>minSimilarity</code>.\n\t<p>\n\tAfter calling the constructor the enumeration is already pointing to the first\n\tvalid term if such a term exists.\n   *\n\t@param reader Delivers terms.\n\t@param term Pattern term.\n\t@param minSimilarity Minimum required similarity for terms from the reader. Default value is 0.5f.\n\t@param prefixLength Length of required common prefix. Default value is 0.\n\t@throws IOException\n   */\n  public FuzzyTermEnum(IndexReader reader, Term term, final float minSimilarity, final int prefixLength) throws IOException \n{\n    super();\n    \n    if (minSimilarity >= 1.0f)\n      throw new IllegalArgumentException(\"minimumSimilarity cannot be greater than or equal to 1\");\n    else if (minSimilarity < 0.0f)\n      throw new IllegalArgumentException(\"minimumSimilarity cannot be less than 0\");\n    if(prefixLength < 0)\n      throw new IllegalArgumentException(\"prefixLength cannot be less than 0\");\n\n    this.minimumSimilarity = minSimilarity;\n    this.scale_factor = 1.0f / (1.0f - minimumSimilarity);\n    this.searchTerm = term;\n    this.field = searchTerm.field();\n\n    //The prefix could be longer than the word.\n    //It's kind of silly though.  It means we must match the entire word.\n    final int fullSearchTermLength = searchTerm.text().length();\n    final int realPrefixLength = prefixLength > fullSearchTermLength ? fullSearchTermLength : prefixLength;\n\n    this.text = searchTerm.text().substring(realPrefixLength);\n    this.prefix = searchTerm.text().substring(0, realPrefixLength);\n\n    growDistanceArrays(TYPICAL_LONGEST_WORD_IN_INDEX);\n\n    setEnum(reader.terms(new Term(searchTerm.field(), prefix)));\n  }\n\n\n\n  /**\n\n\tThe termCompare method in FuzzyTermEnum uses Levenshtein distance to\n\tcalculate the distance between the given term and the comparing term.\n   */\n  protected final boolean termCompare(Term term) \nUnknown macro: {    if (field == term.field() && term.text().startsWith(prefix)) {\n        final String target = term.text().substring(prefix.length());\n        this.similarity = similarity(target);\n        return (similarity > minimumSimilarity);\n    }    endEnum = true;    return false;  } \n\n\n\n  public final float difference() \n{\n    return (float)((similarity - minimumSimilarity) * scale_factor);\n  }\n\n  public final boolean endEnum() \n{\n    return endEnum;\n  }\n\n  /******************************\n\n\tCompute Levenshtein distance\n   ******************************/\n\n\n\n  /**\n\n\tFinds and returns the smallest of three integers\n   */\n  private static final int min(int a, int b, int c) {\n      // removed assignments to use double ternary\n      return (a < b)\n      ? ((a < c) ? a : c)\n      : ((b < c) ? b: c);\n\n\n\n      // alt form is:\n      // if (a < b) \n{ if (a < c) return a; else return c; }\n      // if (b < c) return b; else return c;\n  }\n\n  /**\n\n\t<p>Similarity returns a number that is 1.0f or less (including negative numbers)\n\tbased on how similar the Term is compared to a target term.  It returns\n\texactly 0.0f when\n\t<pre>\n\teditDistance < maximumEditDistance</pre>\n\tOtherwise it returns:\n\t<pre>\n\t1 - (editDistance / length)</pre>\n\twhere length is the length of the shortest term (text or target) including a\n\tprefix that are identical and editDistance is the Levenshtein distance for\n\tthe two words.</p>\n   *\n\t<p>Embedded within this algorithm is a fail-fast Levenshtein distance\n\talgorithm.  The fail-fast algorithm differs from the standard Levenshtein\n\tdistance algorithm in that it is aborted if it is discovered that the\n\tmimimum distance between the words is greater than some threshold.\n   *\n\t<p>To calculate the maximum distance threshold we use the following formula:\n\t<pre>\n\t(1 - minimumSimilarity) * length</pre>\n\twhere length is the shortest term including any prefix that is not part of the\n\tsimilarity comparision.  This formula was derived by solving for what maximum value\n\tof distance returns false for the following statements:\n\t<pre>\n\tsimilarity = 1 - ((float)distance / (float) (prefixLength + Math.min(textlen, targetlen)));\n\treturn (similarity > minimumSimilarity);</pre>\n\twhere distance is the Levenshtein distance for the two words.\n\t</p>\n\t<p>Levenshtein distance (also known as edit distance) is a measure of similiarity\n\tbetween two strings where the distance is measured as the number of character\n\tdeletions, insertions or substitutions required to transform one string to\n\tthe other string.\n\t@param target the target word or phrase\n\t@return the similarity,  0.0 or less indicates that it matches less than the required\n\tthreshold and 1.0 indicates that the text and target are identical\n   */\n  private synchronized final float similarity(final String target) {\n    final int m = target.length();\n    final int n = text.length();\n    if (n == 0)  \n{\n      //we don't have anything to compare.  That means if we just add\n      //the letters for m we get the new word\n      return prefix.length() == 0 ? 0.0f : 1.0f - ((float) m / prefix.length());\n    }\n    if (m == 0) \n{\n      return prefix.length() == 0 ? 0.0f : 1.0f - ((float) n / prefix.length());\n    }\n\n\n\n    final int maxDistance = calculateMaxDistance(m);\n\n    if (maxDistance < Math.abs(m-n)) \n{\n      //just adding the characters of m to n or vice-versa results in\n      //too many edits\n      //for example \"pre\" length is 3 and \"prefixes\" length is 8.  We can see that\n      //given this optimal circumstance, the edit distance cannot be less than 5.\n      //which is 8-3 or more precisesly Math.abs(3-8).\n      //if our maximum edit distance is 4, then we can discard this word\n      //without looking at it.\n      return 0.0f;\n    }\n\n    //let's make sure we have enough room in our array to do the distance calculations.\n    if (d0.length <= m) \n{\n    growDistanceArrays(m);\n    }\n\n    int[] dLast = d0;  // set local vars for efficiency ~ the old d[i-1]\n    int[] dCurrent = d1;  //                            ~ the old d[i]\n    for (int j = 0; j <= m; j++) dCurrent[j] = j;\n\n    for (int i = 0; i < n; ) {\n    final char s_i = text.charAt;\n    int[] dTemp = dLast;\n    dLast = dCurrent;    // previously: d[i-i]\n    dCurrent = dTemp;    // previously: d[i]\n    boolean prune = (dCurrent[0] = ++i) > maxDistance; // true if d[i][0] is too large\n    for (int j = 0; j < m; j++) \n{\n        dCurrent[j+1] = (s_i == target.charAt(j))\n        ? min(dLast[j+1]+1, dCurrent[j]+1, dLast[j])\n        : min(dLast[j+1], dCurrent[j], dLast[j])+1;\n        if (prune && dCurrent[j+1] <= maxDistance)\n        prune = false;\n    }\n\n    // (prune==false) iff (dCurrent[j] < maxDistance) for some j\n    if (prune) \n{\n        return 0.0f;\n    }\n    }\n\n    // this will return less than 0.0 when the edit distance is\n    // greater than the number of characters in the shorter word.\n    // but this was the formula that was previously used in FuzzyTermEnum,\n    // so it has not been changed (even though minimumSimilarity must be\n    // greater than 0.0)\n    return 1.0F - dCurrent[m]/(float)(prefix.length() + Math.min(n,m));\n  }\n\n\n  /**\n\n\tGrow the second dimension of the array slices, so that we can\n\tcalculate the Levenshtein difference.\n   */\n  private void growDistanceArrays(int m) \n{\n      d0 = new int[m+1];\n      d1 = new int[m+1];\n  }\n\n\n\n  private int calculateMaxDistance(int m) \n{\n    return (int) ((1-minimumSimilarity) * (Math.min(text.length(), m) + prefix.length()));\n  }\n\n    /* This is redundant\n  public void close() throws IOException \n{\n    super.close();  //call super.close() and let the garbage collector do its work.\n  }\n    */\n\n\n}",
    "attachments": {},
    "issue_links": {},
    "comments": [
        {
            "date": "2008-05-28T05:00:43+0000",
            "content": "The patch for Bob's change suggestions is in LUCENE-1183, so this issue is redundant. ",
            "author": "Otis Gospodnetic",
            "id": "comment-12600368"
        }
    ]
}