{
    "id": "SOLR-9269",
    "title": "Ability to create/delete/list snapshots for a solr core",
    "details": {
        "components": [
            "SolrCloud"
        ],
        "type": "Sub-task",
        "labels": "",
        "fix_versions": [
            "6.2"
        ],
        "affect_versions": "None",
        "status": "Closed",
        "resolution": "Fixed",
        "priority": "Major"
    },
    "description": "Support snapshot create/delete/list functionality @ the Solr core level. Please refer to parent JIRA for more details.",
    "attachments": {
        "SOLR-9269.patch": "https://issues.apache.org/jira/secure/attachment/12815665/SOLR-9269.patch"
    },
    "issue_links": {},
    "comments": [
        {
            "date": "2016-07-01T01:55:35+0000",
            "author": "Hrishikesh Gadre",
            "content": "David Smiley Please find the patch attached. It addresses all the review comments posted on github except one.\n\nhttps://github.com/hgadre/lucene-solr/commit/1ab2b5022a2ed970e0bad733a4bdb284bb7a0830#commitcomment-18007499\n\nAny thoughts here?\n\n ",
            "id": "comment-15358219"
        },
        {
            "date": "2016-07-09T15:51:20+0000",
            "author": "David Smiley",
            "content": "BTW I had added another comment or two last week.  Can you please submit this as a pull request so that it's attached to this issue?  Although the issue # is different now... ",
            "id": "comment-15369153"
        },
        {
            "date": "2016-07-14T01:09:20+0000",
            "author": "Hrishikesh Gadre",
            "content": "David Smiley sorry for late reply. Let me address your latest comment and submit a pull request in a day or two. ",
            "id": "comment-15376119"
        },
        {
            "date": "2016-07-20T23:17:46+0000",
            "author": "Hrishikesh Gadre",
            "content": "David Smiley I have created a pull request. It addresses all the review comments. All the tests as well as precommit is passing for me.\n\nThses are your latest comments \n\nRef: https://github.com/hgadre/lucene-solr/commit/1ab2b5022a2ed970e0bad733a4bdb284bb7a0830#commitcomment-18106713\nRef: https://github.com/hgadre/lucene-solr/commit/1ab2b5022a2ed970e0bad733a4bdb284bb7a0830#commitcomment-18106676\n\nI haven't dealt with this class much before; lots of complicated code here. The code you added seems to be only for a full copy replication, and it appears that is to a new index dir, hence the existing logic to remove an \"old\" index dir. In this circumstance why delete only the non-snapshot index files; shouldn't we basically remove everything and clear all snapshots? Or, and this may be complicated, try and retain the snapshots by copying the snapshotted files from old to new?\n\nThis is the only spot that calls deleteSnapshotIndexFiles, and I'm not completely clear as to its comments above. How would the indexDirPath not be the core index dir? Or in other words, why does the snapshot commit metadata have the index dir String when it might be implied as the same as for the Solr core?\n\nThere are some operations (e.g. restore or full replication) where Solr changes the current index directory. When the old index directory before the operation has snapshots stored, we have two options,\n(a) Copy snapshot files to the new directory.\n(b) Keep the old directory (and the relevant index files) around until the snapshot exist. When the snapshot is deleted, cleanup the index files. Note that this cleanup is performed only when the directory containing snapshot files != the current index directory. When directory containing snapshot files == the current index directory, we delegate file management to IndexDeletionPolicy implementation.\n\nOption (a) is not workable since\n\n\tThere can be a file naming conflict between files corresponding to index commit referred by the snapshot and the index commit copied from external source (e.g. from external backup or some other Solr server).\n\tCopying files would require more disk I/O which is not really necessary from Solr perspective (since the snapshot files are just a corpus intended for backup/restore use-case).\n\n\n\nHence I implemented option (b) in this patch.\n\nBTW if the path does need to continue to be a part of the snapshot metadata, then that draws suspicion to the isSnapshotted(long) method  signature since it ought to also have the path? Or maybe snapshot metadata management needs to be fundamentally managed per index dir path?\n\nYes good catch! I fixed this problem. I also addressed the case of Lucene segment sharing between multiple index commits as well as multiple snapshots referring to the same index commit by implementing a reference counting mechanism. I have added unit tests to verify this behavior as well. ",
            "id": "comment-15386789"
        },
        {
            "date": "2016-07-21T14:44:47+0000",
            "author": "ASF GitHub Bot",
            "content": "Github user dsmiley commented on a diff in the pull request:\n\n    https://github.com/apache/lucene-solr/pull/52#discussion_r71719038\n\n    \u2014 Diff: solr/core/src/java/org/apache/solr/core/snapshots/SolrSnapshotMetaDataManager.java \u2014\n    @@ -0,0 +1,419 @@\n    +/*\n    + * Licensed to the Apache Software Foundation (ASF) under one or more\n    + * contributor license agreements.  See the NOTICE file distributed with\n    + * this work for additional information regarding copyright ownership.\n    + * The ASF licenses this file to You under the Apache License, Version 2.0\n    + * (the \"License\"); you may not use this file except in compliance with\n    + * the License.  You may obtain a copy of the License at\n    + *\n    + *     http://www.apache.org/licenses/LICENSE-2.0\n    + *\n    + * Unless required by applicable law or agreed to in writing, software\n    + * distributed under the License is distributed on an \"AS IS\" BASIS,\n    + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    + * See the License for the specific language governing permissions and\n    + * limitations under the License.\n    + */\n    +package org.apache.solr.core.snapshots;\n    +\n    +import java.io.IOException;\n    +import java.lang.invoke.MethodHandles;\n    +import java.util.ArrayList;\n    +import java.util.Collection;\n    +import java.util.Collections;\n    +import java.util.HashMap;\n    +import java.util.HashSet;\n    +import java.util.List;\n    +import java.util.Locale;\n    +import java.util.Map;\n    +import java.util.Map.Entry;\n    +import java.util.Optional;\n    +import java.util.stream.Collectors;\n    +\n    +import org.apache.lucene.codecs.CodecUtil;\n    +import org.apache.lucene.index.DirectoryReader;\n    +import org.apache.lucene.index.IndexCommit;\n    +import org.apache.lucene.index.IndexDeletionPolicy;\n    +import org.apache.lucene.index.IndexWriterConfig.OpenMode;\n    +import org.apache.lucene.store.Directory;\n    +import org.apache.lucene.store.IOContext;\n    +import org.apache.lucene.store.IndexInput;\n    +import org.apache.lucene.store.IndexOutput;\n    +import org.apache.lucene.util.IOUtils;\n    +import org.apache.solr.common.SolrException;\n    +import org.apache.solr.common.SolrException.ErrorCode;\n    +import org.apache.solr.core.DirectoryFactory;\n    +import org.apache.solr.core.IndexDeletionPolicyWrapper;\n    +import org.apache.solr.core.SolrCore;\n    +import org.apache.solr.core.DirectoryFactory.DirContext;\n    +import org.slf4j.Logger;\n    +import org.slf4j.LoggerFactory;\n    +\n    +import com.google.common.base.Preconditions;\n    +\n    +/**\n    + * This class is responsible to manage the persistent snapshots meta-data for the Solr indexes. The\n    + * persistent snapshots are implemented by relying on Lucene \n{@linkplain IndexDeletionPolicy}\n    + * abstraction to configure a specific \n{@linkplain IndexCommit} to be retained. The\n    + * {@linkplain IndexDeletionPolicyWrapper} in Solr uses this class to create/delete the Solr index\n    + * snapshots.\n    + */\n    +public class SolrSnapshotMetaDataManager {\n    +  private static final Logger log = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n    +  public static final String SNAPSHOT_METADATA_DIR = \"snapshot_metadata\";\n    +\n    +  /**\n    +   * A class defining the meta-data for a specific snapshot.\n    +   */\n    +  public static class SnapshotMetaData {\n    +    private String name;\n    +    private String indexDirPath;\n    +    private long generationNumber;\n    +\n    +    public SnapshotMetaData(String name, String indexDirPath, long generationNumber) {\n    +      super();\n    +      this.name = name;\n    +      this.indexDirPath = indexDirPath;\n    +      this.generationNumber = generationNumber;\n    +    }\n    +\n    +    public String getName() {\n    +      return name;\n    +    }\n    +\n    +    public String getIndexDirPath() {\n    +      return indexDirPath;\n    +    }\n    +\n    +    public long getGenerationNumber() {\n    +      return generationNumber;\n    +    }\n    +\n    +    @Override\n    +    public String toString() {\n    +      StringBuilder builder = new StringBuilder();\n    +      builder.append(\"SnapshotMetaData[name=\");\n    +      builder.append(name);\n    +      builder.append(\", indexDirPath=\");\n    +      builder.append(indexDirPath);\n    +      builder.append(\", generation=\");\n    +      builder.append(generationNumber);\n    +      builder.append(\"]\");\n    +      return builder.toString();\n    +    }\n    +  }\n    +\n    +  /** Prefix used for the save file. */\n    +  public static final String SNAPSHOTS_PREFIX = \"snapshots_\";\n    +  private static final int VERSION_START = 0;\n    +  private static final int VERSION_CURRENT = VERSION_START;\n    +  private static final String CODEC_NAME = \"solr-snapshots\";\n    +\n    +  // The index writer which maintains the snapshots metadata\n    +  private long nextWriteGen;\n    +\n    +  private final Directory dir;\n    +\n    +  /** Used to map snapshot name to snapshot meta-data. */\n    +  protected final Map<String,SnapshotMetaData> nameToDetailsMapping = new HashMap<>();\n    +  /** Used to figure out the current index data directory path */\n    +  private final SolrCore solrCore;\n    +\n    +  /**\n    +   * A constructor.\n    +   *\n    +   * @param dir The directory where the snapshot meta-data should be stored. Enables updating\n    +   *            the existing meta-data.\n    +   * @throws IOException in case of errors.\n    +   */\n    +  public SolrSnapshotMetaDataManager(SolrCore solrCore, Directory dir) throws IOException {\n    +    this(solrCore, dir, OpenMode.CREATE_OR_APPEND);\n    +  }\n    +\n    +  /**\n    +   * A constructor.\n    +   *\n    +   * @param dir The directory where the snapshot meta-data is stored.\n    +   * @param mode CREATE If previous meta-data should be erased.\n    +   *             APPEND If previous meta-data should be read and updated.\n    +   *             CREATE_OR_APPEND Creates a new meta-data structure if one does not exist\n    +   *                              Updates the existing structure if one exists.\n    +   * @throws IOException in case of errors.\n    +   */\n    +  public SolrSnapshotMetaDataManager(SolrCore solrCore, Directory dir, OpenMode mode) throws IOException {\n    +    this.solrCore = solrCore;\n    +    this.dir = dir;\n    +\n    +    if (mode == OpenMode.CREATE) {\n    +      deleteSnapshotMetadataFiles();\n    +    }\n    +\n    +    loadFromSnapshotMetadataFile();\n    +\n    +    if (mode == OpenMode.APPEND && nextWriteGen == 0) {\n    +      throw new IllegalStateException(\"no snapshots stored in this directory\");\n    +    }\n    +  }\n    +\n    +  /**\n    +   * @return The snapshot meta-data directory\n    +   */\n    +  public Directory getSnapshotsDir() {\n    +    return dir;\n    +  }\n    +\n    +  /**\n    +   * This method creates a new snapshot meta-data entry.\n    +   *\n    +   * @param name The name of the snapshot.\n    +   * @param indexDirPath The directory path where the index files are stored.\n    +   * @param gen The generation number for the {@linkplain IndexCommit}\n being snapshotted.\n    +   * @throws IOException in case of I/O errors.\n    +   */\n    +  public synchronized void snapshot(String name, String indexDirPath, long gen) throws IOException {\n    +    Preconditions.checkNotNull(name);\n    +\n    +    log.info(\"Creating the snapshot named {} for core {} associated with index commit with generation {} in directory {}\"\n    +        , name, solrCore.getName(), gen, indexDirPath);\n    +\n    +    if(nameToDetailsMapping.containsKey(name)) \n{\n    +      throw new SolrException(ErrorCode.BAD_REQUEST, \"A snapshot with name \" + name + \" already exists\");\n    +    }\n    +\n    +    SnapshotMetaData d = new SnapshotMetaData(name, indexDirPath, gen);\n    +    nameToDetailsMapping.put(name, d);\n    +\n    +    boolean success = false;\n    +    try \n{\n    +      persist();\n    +      success = true;\n    +    }\n finally {\n    +      if (!success) {\n    +        try \n{\n    +          release(name);\n    +        }\n catch (Exception e) \n{\n    +          // Suppress so we keep throwing original exception\n    +        }\n    +      }\n    +    }\n    +  }\n    +\n    +  /**\n    +   * This method deletes a previously created snapshot (if any).\n    +   *\n    +   * @param name The name of the snapshot to be deleted.\n    +   * @return The snapshot meta-data if the snapshot with the snapshot name exists.\n    +   * @throws IOException in case of I/O error\n    +   */\n    +  public synchronized Optional<SnapshotMetaData> release(String name) throws IOException {\n    +    log.info(\"Deleting the snapshot named {} for core {}\", name, solrCore.getName());\n    +    SnapshotMetaData result = nameToDetailsMapping.remove(Preconditions.checkNotNull(name));\n    +    if(result != null) {\n    +      boolean success = false;\n    +      try \n{\n    +        persist();\n    +        success = true;\n    +      }\n finally {\n    +        if (!success) \n{\n    +          nameToDetailsMapping.put(name, result);\n    +        }\n    +      }\n    +    }\n    +    return Optional.ofNullable(result);\n    +  }\n    +\n    +  /**\n    +   * This method returns if snapshot is created for the specified generation number in\n    +   * the current index directory.\n    +   *\n    +   * @param genNumber The generation number for the \n{@linkplain IndexCommit} to be checked.\n    +   * @return true if the snapshot is created.\n    +   *         false otherwise.\n    +   */\n    +  public synchronized boolean isSnapshotted(long genNumber) {\n    +    return isSnapshotted(solrCore.getIndexDir(), genNumber);\n    +  }\n    +\n    +  /**\n    +   * This method returns if snapshot is created for the specified generation number in\n    +   * the specified index directory.\n    +   *\n    +   * @param genNumber The generation number for the {@linkplain IndexCommit}\n to be checked.\n    +   * @return true if the snapshot is created.\n    +   *         false otherwise.\n    +   */\n    +  public synchronized boolean isSnapshotted(String indexDirPath, long genNumber) {\n    +    return nameToDetailsMapping.values().stream()\n    +        .filter(entry -> entry.getIndexDirPath().equals(indexDirPath) && entry.getGenerationNumber() == genNumber)\n    \u2014 End diff \u2013\n\n    .anyMatch() is simpler ",
            "id": "comment-15387804"
        },
        {
            "date": "2016-07-21T14:55:51+0000",
            "author": "ASF GitHub Bot",
            "content": "Github user dsmiley commented on a diff in the pull request:\n\n    https://github.com/apache/lucene-solr/pull/52#discussion_r71721509\n\n    \u2014 Diff: solr/core/src/java/org/apache/solr/core/snapshots/SolrSnapshotMetaDataManager.java \u2014\n    @@ -0,0 +1,419 @@\n    +/*\n    + * Licensed to the Apache Software Foundation (ASF) under one or more\n    + * contributor license agreements.  See the NOTICE file distributed with\n    + * this work for additional information regarding copyright ownership.\n    + * The ASF licenses this file to You under the Apache License, Version 2.0\n    + * (the \"License\"); you may not use this file except in compliance with\n    + * the License.  You may obtain a copy of the License at\n    + *\n    + *     http://www.apache.org/licenses/LICENSE-2.0\n    + *\n    + * Unless required by applicable law or agreed to in writing, software\n    + * distributed under the License is distributed on an \"AS IS\" BASIS,\n    + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    + * See the License for the specific language governing permissions and\n    + * limitations under the License.\n    + */\n    +package org.apache.solr.core.snapshots;\n    +\n    +import java.io.IOException;\n    +import java.lang.invoke.MethodHandles;\n    +import java.util.ArrayList;\n    +import java.util.Collection;\n    +import java.util.Collections;\n    +import java.util.HashMap;\n    +import java.util.HashSet;\n    +import java.util.List;\n    +import java.util.Locale;\n    +import java.util.Map;\n    +import java.util.Map.Entry;\n    +import java.util.Optional;\n    +import java.util.stream.Collectors;\n    +\n    +import org.apache.lucene.codecs.CodecUtil;\n    +import org.apache.lucene.index.DirectoryReader;\n    +import org.apache.lucene.index.IndexCommit;\n    +import org.apache.lucene.index.IndexDeletionPolicy;\n    +import org.apache.lucene.index.IndexWriterConfig.OpenMode;\n    +import org.apache.lucene.store.Directory;\n    +import org.apache.lucene.store.IOContext;\n    +import org.apache.lucene.store.IndexInput;\n    +import org.apache.lucene.store.IndexOutput;\n    +import org.apache.lucene.util.IOUtils;\n    +import org.apache.solr.common.SolrException;\n    +import org.apache.solr.common.SolrException.ErrorCode;\n    +import org.apache.solr.core.DirectoryFactory;\n    +import org.apache.solr.core.IndexDeletionPolicyWrapper;\n    +import org.apache.solr.core.SolrCore;\n    +import org.apache.solr.core.DirectoryFactory.DirContext;\n    +import org.slf4j.Logger;\n    +import org.slf4j.LoggerFactory;\n    +\n    +import com.google.common.base.Preconditions;\n    +\n    +/**\n    + * This class is responsible to manage the persistent snapshots meta-data for the Solr indexes. The\n    + * persistent snapshots are implemented by relying on Lucene \n{@linkplain IndexDeletionPolicy}\n    + * abstraction to configure a specific \n{@linkplain IndexCommit} to be retained. The\n    + * {@linkplain IndexDeletionPolicyWrapper} in Solr uses this class to create/delete the Solr index\n    + * snapshots.\n    + */\n    +public class SolrSnapshotMetaDataManager {\n    +  private static final Logger log = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n    +  public static final String SNAPSHOT_METADATA_DIR = \"snapshot_metadata\";\n    +\n    +  /**\n    +   * A class defining the meta-data for a specific snapshot.\n    +   */\n    +  public static class SnapshotMetaData {\n    +    private String name;\n    +    private String indexDirPath;\n    +    private long generationNumber;\n    +\n    +    public SnapshotMetaData(String name, String indexDirPath, long generationNumber) {\n    +      super();\n    +      this.name = name;\n    +      this.indexDirPath = indexDirPath;\n    +      this.generationNumber = generationNumber;\n    +    }\n    +\n    +    public String getName() {\n    +      return name;\n    +    }\n    +\n    +    public String getIndexDirPath() {\n    +      return indexDirPath;\n    +    }\n    +\n    +    public long getGenerationNumber() {\n    +      return generationNumber;\n    +    }\n    +\n    +    @Override\n    +    public String toString() {\n    +      StringBuilder builder = new StringBuilder();\n    +      builder.append(\"SnapshotMetaData[name=\");\n    +      builder.append(name);\n    +      builder.append(\", indexDirPath=\");\n    +      builder.append(indexDirPath);\n    +      builder.append(\", generation=\");\n    +      builder.append(generationNumber);\n    +      builder.append(\"]\");\n    +      return builder.toString();\n    +    }\n    +  }\n    +\n    +  /** Prefix used for the save file. */\n    +  public static final String SNAPSHOTS_PREFIX = \"snapshots_\";\n    +  private static final int VERSION_START = 0;\n    +  private static final int VERSION_CURRENT = VERSION_START;\n    +  private static final String CODEC_NAME = \"solr-snapshots\";\n    +\n    +  // The index writer which maintains the snapshots metadata\n    +  private long nextWriteGen;\n    +\n    +  private final Directory dir;\n    +\n    +  /** Used to map snapshot name to snapshot meta-data. */\n    +  protected final Map<String,SnapshotMetaData> nameToDetailsMapping = new HashMap<>();\n    +  /** Used to figure out the current index data directory path */\n    +  private final SolrCore solrCore;\n    +\n    +  /**\n    +   * A constructor.\n    +   *\n    +   * @param dir The directory where the snapshot meta-data should be stored. Enables updating\n    +   *            the existing meta-data.\n    +   * @throws IOException in case of errors.\n    +   */\n    +  public SolrSnapshotMetaDataManager(SolrCore solrCore, Directory dir) throws IOException {\n    +    this(solrCore, dir, OpenMode.CREATE_OR_APPEND);\n    +  }\n    +\n    +  /**\n    +   * A constructor.\n    +   *\n    +   * @param dir The directory where the snapshot meta-data is stored.\n    +   * @param mode CREATE If previous meta-data should be erased.\n    +   *             APPEND If previous meta-data should be read and updated.\n    +   *             CREATE_OR_APPEND Creates a new meta-data structure if one does not exist\n    +   *                              Updates the existing structure if one exists.\n    +   * @throws IOException in case of errors.\n    +   */\n    +  public SolrSnapshotMetaDataManager(SolrCore solrCore, Directory dir, OpenMode mode) throws IOException {\n    +    this.solrCore = solrCore;\n    +    this.dir = dir;\n    +\n    +    if (mode == OpenMode.CREATE) {\n    +      deleteSnapshotMetadataFiles();\n    +    }\n    +\n    +    loadFromSnapshotMetadataFile();\n    +\n    +    if (mode == OpenMode.APPEND && nextWriteGen == 0) {\n    +      throw new IllegalStateException(\"no snapshots stored in this directory\");\n    +    }\n    +  }\n    +\n    +  /**\n    +   * @return The snapshot meta-data directory\n    +   */\n    +  public Directory getSnapshotsDir() {\n    +    return dir;\n    +  }\n    +\n    +  /**\n    +   * This method creates a new snapshot meta-data entry.\n    +   *\n    +   * @param name The name of the snapshot.\n    +   * @param indexDirPath The directory path where the index files are stored.\n    +   * @param gen The generation number for the {@linkplain IndexCommit}\n being snapshotted.\n    +   * @throws IOException in case of I/O errors.\n    +   */\n    +  public synchronized void snapshot(String name, String indexDirPath, long gen) throws IOException {\n    +    Preconditions.checkNotNull(name);\n    +\n    +    log.info(\"Creating the snapshot named {} for core {} associated with index commit with generation {} in directory {}\"\n    +        , name, solrCore.getName(), gen, indexDirPath);\n    +\n    +    if(nameToDetailsMapping.containsKey(name)) \n{\n    +      throw new SolrException(ErrorCode.BAD_REQUEST, \"A snapshot with name \" + name + \" already exists\");\n    +    }\n    +\n    +    SnapshotMetaData d = new SnapshotMetaData(name, indexDirPath, gen);\n    +    nameToDetailsMapping.put(name, d);\n    +\n    +    boolean success = false;\n    +    try \n{\n    +      persist();\n    +      success = true;\n    +    }\n finally {\n    +      if (!success) {\n    +        try \n{\n    +          release(name);\n    +        }\n catch (Exception e) \n{\n    +          // Suppress so we keep throwing original exception\n    +        }\n    +      }\n    +    }\n    +  }\n    +\n    +  /**\n    +   * This method deletes a previously created snapshot (if any).\n    +   *\n    +   * @param name The name of the snapshot to be deleted.\n    +   * @return The snapshot meta-data if the snapshot with the snapshot name exists.\n    +   * @throws IOException in case of I/O error\n    +   */\n    +  public synchronized Optional<SnapshotMetaData> release(String name) throws IOException {\n    +    log.info(\"Deleting the snapshot named {} for core {}\", name, solrCore.getName());\n    +    SnapshotMetaData result = nameToDetailsMapping.remove(Preconditions.checkNotNull(name));\n    +    if(result != null) {\n    +      boolean success = false;\n    +      try \n{\n    +        persist();\n    +        success = true;\n    +      }\n finally {\n    +        if (!success) \n{\n    +          nameToDetailsMapping.put(name, result);\n    +        }\n    +      }\n    +    }\n    +    return Optional.ofNullable(result);\n    +  }\n    +\n    +  /**\n    +   * This method returns if snapshot is created for the specified generation number in\n    +   * the current index directory.\n    +   *\n    +   * @param genNumber The generation number for the \n{@linkplain IndexCommit} to be checked.\n    +   * @return true if the snapshot is created.\n    +   *         false otherwise.\n    +   */\n    +  public synchronized boolean isSnapshotted(long genNumber) {\n    +    return isSnapshotted(solrCore.getIndexDir(), genNumber);\n    +  }\n    +\n    +  /**\n    +   * This method returns if snapshot is created for the specified generation number in\n    +   * the specified index directory.\n    +   *\n    +   * @param genNumber The generation number for the {@linkplain IndexCommit}\n to be checked.\n    +   * @return true if the snapshot is created.\n    +   *         false otherwise.\n    +   */\n    +  public synchronized boolean isSnapshotted(String indexDirPath, long genNumber) \n{\n    +    return nameToDetailsMapping.values().stream()\n    +        .filter(entry -> entry.getIndexDirPath().equals(indexDirPath) && entry.getGenerationNumber() == genNumber)\n    +        .findFirst()\n    +        .isPresent();\n    +  }\n    +\n    +  /**\n    +   * This method returns the snapshot meta-data for the specified name (if it exists).\n    +   *\n    +   * @param name The name of the snapshot\n    +   * @return The snapshot meta-data if exists.\n    +   */\n    +  public synchronized Optional<SnapshotMetaData> getSnapshotMetaData(String name) \n{\n    +    return Optional.ofNullable(nameToDetailsMapping.get(name));\n    +  }\n    +\n    +  /**\n    +   * @return A list of snapshots created so far.\n    +   */\n    +  public synchronized Collection<String> listSnapshots() \n{\n    +    return new HashSet<>(nameToDetailsMapping.keySet());\n    +  }\n    +\n    +  /**\n    +   * This method returns a list of snapshots created in a specified index directory.\n    +   *\n    +   * @param indexDirPath The index directory path.\n    +   * @return a list snapshots stored in the specified directory.\n    +   */\n    +  public synchronized Collection<SnapshotMetaData> listSnapshotsInIndexDir(String indexDirPath) {\n    +    return nameToDetailsMapping.entrySet().stream()\n    \u2014 End diff \u2013\n\n    in seems you don't need the entrySet (both key and value), you only need the values() ",
            "id": "comment-15387832"
        },
        {
            "date": "2016-07-21T14:56:23+0000",
            "author": "ASF GitHub Bot",
            "content": "Github user dsmiley commented on a diff in the pull request:\n\n    https://github.com/apache/lucene-solr/pull/52#discussion_r71721619\n\n    \u2014 Diff: solr/core/src/java/org/apache/solr/core/snapshots/SolrSnapshotMetaDataManager.java \u2014\n    @@ -0,0 +1,419 @@\n    +/*\n    + * Licensed to the Apache Software Foundation (ASF) under one or more\n    + * contributor license agreements.  See the NOTICE file distributed with\n    + * this work for additional information regarding copyright ownership.\n    + * The ASF licenses this file to You under the Apache License, Version 2.0\n    + * (the \"License\"); you may not use this file except in compliance with\n    + * the License.  You may obtain a copy of the License at\n    + *\n    + *     http://www.apache.org/licenses/LICENSE-2.0\n    + *\n    + * Unless required by applicable law or agreed to in writing, software\n    + * distributed under the License is distributed on an \"AS IS\" BASIS,\n    + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    + * See the License for the specific language governing permissions and\n    + * limitations under the License.\n    + */\n    +package org.apache.solr.core.snapshots;\n    +\n    +import java.io.IOException;\n    +import java.lang.invoke.MethodHandles;\n    +import java.util.ArrayList;\n    +import java.util.Collection;\n    +import java.util.Collections;\n    +import java.util.HashMap;\n    +import java.util.HashSet;\n    +import java.util.List;\n    +import java.util.Locale;\n    +import java.util.Map;\n    +import java.util.Map.Entry;\n    +import java.util.Optional;\n    +import java.util.stream.Collectors;\n    +\n    +import org.apache.lucene.codecs.CodecUtil;\n    +import org.apache.lucene.index.DirectoryReader;\n    +import org.apache.lucene.index.IndexCommit;\n    +import org.apache.lucene.index.IndexDeletionPolicy;\n    +import org.apache.lucene.index.IndexWriterConfig.OpenMode;\n    +import org.apache.lucene.store.Directory;\n    +import org.apache.lucene.store.IOContext;\n    +import org.apache.lucene.store.IndexInput;\n    +import org.apache.lucene.store.IndexOutput;\n    +import org.apache.lucene.util.IOUtils;\n    +import org.apache.solr.common.SolrException;\n    +import org.apache.solr.common.SolrException.ErrorCode;\n    +import org.apache.solr.core.DirectoryFactory;\n    +import org.apache.solr.core.IndexDeletionPolicyWrapper;\n    +import org.apache.solr.core.SolrCore;\n    +import org.apache.solr.core.DirectoryFactory.DirContext;\n    +import org.slf4j.Logger;\n    +import org.slf4j.LoggerFactory;\n    +\n    +import com.google.common.base.Preconditions;\n    +\n    +/**\n    + * This class is responsible to manage the persistent snapshots meta-data for the Solr indexes. The\n    + * persistent snapshots are implemented by relying on Lucene \n{@linkplain IndexDeletionPolicy}\n    + * abstraction to configure a specific \n{@linkplain IndexCommit} to be retained. The\n    + * {@linkplain IndexDeletionPolicyWrapper} in Solr uses this class to create/delete the Solr index\n    + * snapshots.\n    + */\n    +public class SolrSnapshotMetaDataManager {\n    +  private static final Logger log = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n    +  public static final String SNAPSHOT_METADATA_DIR = \"snapshot_metadata\";\n    +\n    +  /**\n    +   * A class defining the meta-data for a specific snapshot.\n    +   */\n    +  public static class SnapshotMetaData {\n    +    private String name;\n    +    private String indexDirPath;\n    +    private long generationNumber;\n    +\n    +    public SnapshotMetaData(String name, String indexDirPath, long generationNumber) {\n    +      super();\n    +      this.name = name;\n    +      this.indexDirPath = indexDirPath;\n    +      this.generationNumber = generationNumber;\n    +    }\n    +\n    +    public String getName() {\n    +      return name;\n    +    }\n    +\n    +    public String getIndexDirPath() {\n    +      return indexDirPath;\n    +    }\n    +\n    +    public long getGenerationNumber() {\n    +      return generationNumber;\n    +    }\n    +\n    +    @Override\n    +    public String toString() {\n    +      StringBuilder builder = new StringBuilder();\n    +      builder.append(\"SnapshotMetaData[name=\");\n    +      builder.append(name);\n    +      builder.append(\", indexDirPath=\");\n    +      builder.append(indexDirPath);\n    +      builder.append(\", generation=\");\n    +      builder.append(generationNumber);\n    +      builder.append(\"]\");\n    +      return builder.toString();\n    +    }\n    +  }\n    +\n    +  /** Prefix used for the save file. */\n    +  public static final String SNAPSHOTS_PREFIX = \"snapshots_\";\n    +  private static final int VERSION_START = 0;\n    +  private static final int VERSION_CURRENT = VERSION_START;\n    +  private static final String CODEC_NAME = \"solr-snapshots\";\n    +\n    +  // The index writer which maintains the snapshots metadata\n    +  private long nextWriteGen;\n    +\n    +  private final Directory dir;\n    +\n    +  /** Used to map snapshot name to snapshot meta-data. */\n    +  protected final Map<String,SnapshotMetaData> nameToDetailsMapping = new HashMap<>();\n    +  /** Used to figure out the current index data directory path */\n    +  private final SolrCore solrCore;\n    +\n    +  /**\n    +   * A constructor.\n    +   *\n    +   * @param dir The directory where the snapshot meta-data should be stored. Enables updating\n    +   *            the existing meta-data.\n    +   * @throws IOException in case of errors.\n    +   */\n    +  public SolrSnapshotMetaDataManager(SolrCore solrCore, Directory dir) throws IOException {\n    +    this(solrCore, dir, OpenMode.CREATE_OR_APPEND);\n    +  }\n    +\n    +  /**\n    +   * A constructor.\n    +   *\n    +   * @param dir The directory where the snapshot meta-data is stored.\n    +   * @param mode CREATE If previous meta-data should be erased.\n    +   *             APPEND If previous meta-data should be read and updated.\n    +   *             CREATE_OR_APPEND Creates a new meta-data structure if one does not exist\n    +   *                              Updates the existing structure if one exists.\n    +   * @throws IOException in case of errors.\n    +   */\n    +  public SolrSnapshotMetaDataManager(SolrCore solrCore, Directory dir, OpenMode mode) throws IOException {\n    +    this.solrCore = solrCore;\n    +    this.dir = dir;\n    +\n    +    if (mode == OpenMode.CREATE) {\n    +      deleteSnapshotMetadataFiles();\n    +    }\n    +\n    +    loadFromSnapshotMetadataFile();\n    +\n    +    if (mode == OpenMode.APPEND && nextWriteGen == 0) {\n    +      throw new IllegalStateException(\"no snapshots stored in this directory\");\n    +    }\n    +  }\n    +\n    +  /**\n    +   * @return The snapshot meta-data directory\n    +   */\n    +  public Directory getSnapshotsDir() {\n    +    return dir;\n    +  }\n    +\n    +  /**\n    +   * This method creates a new snapshot meta-data entry.\n    +   *\n    +   * @param name The name of the snapshot.\n    +   * @param indexDirPath The directory path where the index files are stored.\n    +   * @param gen The generation number for the {@linkplain IndexCommit}\n being snapshotted.\n    +   * @throws IOException in case of I/O errors.\n    +   */\n    +  public synchronized void snapshot(String name, String indexDirPath, long gen) throws IOException {\n    +    Preconditions.checkNotNull(name);\n    +\n    +    log.info(\"Creating the snapshot named {} for core {} associated with index commit with generation {} in directory {}\"\n    +        , name, solrCore.getName(), gen, indexDirPath);\n    +\n    +    if(nameToDetailsMapping.containsKey(name)) \n{\n    +      throw new SolrException(ErrorCode.BAD_REQUEST, \"A snapshot with name \" + name + \" already exists\");\n    +    }\n    +\n    +    SnapshotMetaData d = new SnapshotMetaData(name, indexDirPath, gen);\n    +    nameToDetailsMapping.put(name, d);\n    +\n    +    boolean success = false;\n    +    try \n{\n    +      persist();\n    +      success = true;\n    +    }\n finally {\n    +      if (!success) {\n    +        try \n{\n    +          release(name);\n    +        }\n catch (Exception e) \n{\n    +          // Suppress so we keep throwing original exception\n    +        }\n    +      }\n    +    }\n    +  }\n    +\n    +  /**\n    +   * This method deletes a previously created snapshot (if any).\n    +   *\n    +   * @param name The name of the snapshot to be deleted.\n    +   * @return The snapshot meta-data if the snapshot with the snapshot name exists.\n    +   * @throws IOException in case of I/O error\n    +   */\n    +  public synchronized Optional<SnapshotMetaData> release(String name) throws IOException {\n    +    log.info(\"Deleting the snapshot named {} for core {}\", name, solrCore.getName());\n    +    SnapshotMetaData result = nameToDetailsMapping.remove(Preconditions.checkNotNull(name));\n    +    if(result != null) {\n    +      boolean success = false;\n    +      try \n{\n    +        persist();\n    +        success = true;\n    +      }\n finally {\n    +        if (!success) \n{\n    +          nameToDetailsMapping.put(name, result);\n    +        }\n    +      }\n    +    }\n    +    return Optional.ofNullable(result);\n    +  }\n    +\n    +  /**\n    +   * This method returns if snapshot is created for the specified generation number in\n    +   * the current index directory.\n    +   *\n    +   * @param genNumber The generation number for the \n{@linkplain IndexCommit} to be checked.\n    +   * @return true if the snapshot is created.\n    +   *         false otherwise.\n    +   */\n    +  public synchronized boolean isSnapshotted(long genNumber) {\n    +    return isSnapshotted(solrCore.getIndexDir(), genNumber);\n    +  }\n    +\n    +  /**\n    +   * This method returns if snapshot is created for the specified generation number in\n    +   * the specified index directory.\n    +   *\n    +   * @param genNumber The generation number for the {@linkplain IndexCommit}\n to be checked.\n    +   * @return true if the snapshot is created.\n    +   *         false otherwise.\n    +   */\n    +  public synchronized boolean isSnapshotted(String indexDirPath, long genNumber) \n{\n    +    return nameToDetailsMapping.values().stream()\n    +        .filter(entry -> entry.getIndexDirPath().equals(indexDirPath) && entry.getGenerationNumber() == genNumber)\n    +        .findFirst()\n    +        .isPresent();\n    +  }\n    +\n    +  /**\n    +   * This method returns the snapshot meta-data for the specified name (if it exists).\n    +   *\n    +   * @param name The name of the snapshot\n    +   * @return The snapshot meta-data if exists.\n    +   */\n    +  public synchronized Optional<SnapshotMetaData> getSnapshotMetaData(String name) \n{\n    +    return Optional.ofNullable(nameToDetailsMapping.get(name));\n    +  }\n    +\n    +  /**\n    +   * @return A list of snapshots created so far.\n    +   */\n    +  public synchronized Collection<String> listSnapshots() \n{\n    +    return new HashSet<>(nameToDetailsMapping.keySet());\n    +  }\n    +\n    +  /**\n    +   * This method returns a list of snapshots created in a specified index directory.\n    +   *\n    +   * @param indexDirPath The index directory path.\n    +   * @return a list snapshots stored in the specified directory.\n    +   */\n    +  public synchronized Collection<SnapshotMetaData> listSnapshotsInIndexDir(String indexDirPath) \n{\n    +    return nameToDetailsMapping.entrySet().stream()\n    +        .filter(entry -> indexDirPath.equals(entry.getValue().getIndexDirPath()))\n    +        .map(entry -> entry.getValue())\n    +        .collect(Collectors.toList());\n    +  }\n    +\n    +  /**\n    +   * This method returns the \n{@linkplain IndexCommit} associated with the specified\n    +   * <code>commitName</code>. A snapshot with specified <code>commitName</code> must\n    +   * be created before invoking this method.\n    +   *\n    +   * @param commitName The name of persisted commit\n    +   * @return the {@linkplain IndexCommit}\n    +   * @throws IOException in case of I/O error.\n    +   */\n    +  public Optional<IndexCommit> getIndexCommitByName(String commitName) throws IOException {\n    +    Optional<IndexCommit> result = Optional.empty();\n    +    Optional<SnapshotMetaData> metaData = getSnapshotMetaData(commitName);\n    +    if (metaData.isPresent()) {\n    +      String indexDirPath = metaData.get().getIndexDirPath();\n    +      long gen = metaData.get().getGenerationNumber();\n    +\n    +      Directory d = solrCore.getDirectoryFactory().get(indexDirPath, DirContext.DEFAULT, DirectoryFactory.LOCK_TYPE_NONE);\n    +      try {\n    +        result = DirectoryReader.listCommits(d)\n    +                                .stream()\n    +                                .filter(ic -> ic.getGeneration() == gen)\n    +                                .findAny();\n    +\n    +        if (!result.isPresent()) {\n    +          log.warn(\"Unable to find commit with generation {} in the directory {}\", gen, indexDirPath);\n    +        }\n    +\n    +      } finally \n{\n    +        solrCore.getDirectoryFactory().release(d);\n    +      }\n    +    } else {\n    +      log.warn(\"Commit with name {} is not persisted for core {}\", commitName, solrCore.getName());\n    +    }\n    +\n    +    return result;\n    +  }\n    +\n    +  synchronized private void persist() throws IOException {\n    \u2014 End diff \u2013\n\n    Nitpick: private first ",
            "id": "comment-15387833"
        },
        {
            "date": "2016-07-21T15:04:50+0000",
            "author": "ASF GitHub Bot",
            "content": "Github user dsmiley commented on a diff in the pull request:\n\n    https://github.com/apache/lucene-solr/pull/52#discussion_r71723294\n\n    \u2014 Diff: solr/core/src/java/org/apache/solr/handler/ReplicationHandler.java \u2014\n    @@ -512,11 +513,24 @@ private void doSnapShoot(SolrParams params, SolrQueryResponse rsp,\n             numberToKeep = Integer.MAX_VALUE;\n           }\n\n\n\tIndexDeletionPolicyWrapper delPolicy = core.getDeletionPolicy();\n\tIndexCommit indexCommit = delPolicy.getLatestCommit();\n    +      IndexCommit indexCommit = null;\n    +      String commitName = params.get(CoreAdminParams.COMMIT_NAME);\n    +      if (commitName != null) {\n    +        SolrSnapshotMetaDataManager snapshotMgr = core.getSnapshotMetaDataManager();\n    +        Optional<IndexCommit> commit = snapshotMgr.getIndexCommitByName(commitName);\n    +        if(commit.isPresent()) \n{\n    +          indexCommit = commit.get();\n    +        }\n else {\n    +          throw new SolrException(ErrorCode.SERVER_ERROR, \"Unable to find an index commit with name \" + commitName +\n\t\n\t\t\n\t\t\n\t\t\tEnd diff \u2013\n\t\t\n\t\t\n\t\n\t\n\n\n\n    I think this should be a BAD_REQUEST ",
            "id": "comment-15387856"
        },
        {
            "date": "2016-07-21T15:13:16+0000",
            "author": "ASF GitHub Bot",
            "content": "Github user dsmiley commented on a diff in the pull request:\n\n    https://github.com/apache/lucene-solr/pull/52#discussion_r71725010\n\n    \u2014 Diff: solr/core/src/java/org/apache/solr/handler/admin/CoreAdminOperation.java \u2014\n    @@ -919,7 +928,93 @@ public void call(CallInfo callInfo) throws Exception {\n             }\n           }\n         }\n    +  },\n    +  CREATESNAPSHOT_OP(CREATESNAPSHOT) {\n    +    @Override\n    +    public void call(CallInfo callInfo) throws Exception {\n    +      CoreContainer cc = callInfo.handler.getCoreContainer();\n    +      final SolrParams params = callInfo.req.getParams();\n    +\n    +      String commitName = params.required().get(CoreAdminParams.COMMIT_NAME);\n    +      String cname = params.required().get(CoreAdminParams.CORE);\n    +      try (SolrCore core = cc.getCore(cname)) {\n    +        if (core == null) \n{\n    +          throw new SolrException(ErrorCode.SERVER_ERROR, \"Unable to locate core \" + cname);\n    +        }\n    +        if (core.getDeletionPolicy().getLatestCommit() == null) {\n    \u2014 End diff \u2013\n\n    Firstly, this check can go below after we get it on line 949; why get it twice.  Secondly... I wonder if it's null in an initial empty-index case?  If it is, this error message is wrong/confusing... and perhaps we can support that or no? ",
            "id": "comment-15387872"
        },
        {
            "date": "2016-07-21T15:17:25+0000",
            "author": "ASF GitHub Bot",
            "content": "Github user dsmiley commented on a diff in the pull request:\n\n    https://github.com/apache/lucene-solr/pull/52#discussion_r71725843\n\n    \u2014 Diff: solr/core/src/java/org/apache/solr/handler/admin/CoreAdminOperation.java \u2014\n    @@ -919,7 +928,93 @@ public void call(CallInfo callInfo) throws Exception {\n             }\n           }\n         }\n    +  },\n    +  CREATESNAPSHOT_OP(CREATESNAPSHOT) {\n    +    @Override\n    +    public void call(CallInfo callInfo) throws Exception {\n    +      CoreContainer cc = callInfo.handler.getCoreContainer();\n    +      final SolrParams params = callInfo.req.getParams();\n    +\n    +      String commitName = params.required().get(CoreAdminParams.COMMIT_NAME);\n    +      String cname = params.required().get(CoreAdminParams.CORE);\n    +      try (SolrCore core = cc.getCore(cname)) {\n    +        if (core == null) \n{\n    +          throw new SolrException(ErrorCode.SERVER_ERROR, \"Unable to locate core \" + cname);\n    +        }\n    +        if (core.getDeletionPolicy().getLatestCommit() == null) {\n    +          throw new SolrException(ErrorCode.SERVER_ERROR, \"Could not find latest commit. Please ensure to execute a hard commit\");\n    +        }\n    +\n    +        String indexDirPath = core.getIndexDir();\n    +        IndexCommit ic = core.getDeletionPolicy().getLatestCommit();\n    +        SolrSnapshotMetaDataManager mgr = core.getSnapshotMetaDataManager();\n    +        mgr.snapshot(commitName, indexDirPath, ic.getGeneration());\n    +      }\n    +    }\n    +  },\n    +  DELETESNAPSHOT_OP(DELETESNAPSHOT) {\n    +    @Override\n    +    public void call(CallInfo callInfo) throws Exception {\n    +      CoreContainer cc = callInfo.handler.getCoreContainer();\n    +      final SolrParams params = callInfo.req.getParams();\n    +\n    +      String commitName = params.required().get(CoreAdminParams.COMMIT_NAME);\n    +      String cname = params.required().get(CoreAdminParams.CORE);\n    +      try (SolrCore core = cc.getCore(cname)) {\n    +        if (core == null) {    +          throw new SolrException(ErrorCode.SERVER_ERROR, \"Unable to locate core \" + cname);    +        }\n    +\n    +        SolrSnapshotMetaDataManager mgr = core.getSnapshotMetaDataManager();\n    +        Optional<SnapshotMetaData> metadata = mgr.release(commitName);\n    +        if (metadata.isPresent()) {\n    \u2014 End diff \u2013\n\n    Perhaps add an error if we can't find the commit name?  REQUEST_ERROR.  And FYI some other exceptions we throw should also be REQUEST_ERROR if it's based on a param. ",
            "id": "comment-15387878"
        },
        {
            "date": "2016-07-21T15:17:43+0000",
            "author": "ASF GitHub Bot",
            "content": "Github user dsmiley commented on a diff in the pull request:\n\n    https://github.com/apache/lucene-solr/pull/52#discussion_r71725905\n\n    \u2014 Diff: solr/core/src/java/org/apache/solr/handler/admin/CoreAdminOperation.java \u2014\n    @@ -919,7 +928,93 @@ public void call(CallInfo callInfo) throws Exception {\n             }\n           }\n         }\n    +  },\n    +  CREATESNAPSHOT_OP(CREATESNAPSHOT) {\n    +    @Override\n    +    public void call(CallInfo callInfo) throws Exception {\n    +      CoreContainer cc = callInfo.handler.getCoreContainer();\n    +      final SolrParams params = callInfo.req.getParams();\n    +\n    +      String commitName = params.required().get(CoreAdminParams.COMMIT_NAME);\n    +      String cname = params.required().get(CoreAdminParams.CORE);\n    +      try (SolrCore core = cc.getCore(cname)) {\n    +        if (core == null) \n{\n    +          throw new SolrException(ErrorCode.SERVER_ERROR, \"Unable to locate core \" + cname);\n    +        }\n    +        if (core.getDeletionPolicy().getLatestCommit() == null) {\n    +          throw new SolrException(ErrorCode.SERVER_ERROR, \"Could not find latest commit. Please ensure to execute a hard commit\");\n    +        }\n    +\n    +        String indexDirPath = core.getIndexDir();\n    +        IndexCommit ic = core.getDeletionPolicy().getLatestCommit();\n    +        SolrSnapshotMetaDataManager mgr = core.getSnapshotMetaDataManager();\n    +        mgr.snapshot(commitName, indexDirPath, ic.getGeneration());\n    +      }\n    +    }\n    +  },\n    +  DELETESNAPSHOT_OP(DELETESNAPSHOT) {\n    +    @Override\n    +    public void call(CallInfo callInfo) throws Exception {\n    +      CoreContainer cc = callInfo.handler.getCoreContainer();\n    +      final SolrParams params = callInfo.req.getParams();\n    +\n    +      String commitName = params.required().get(CoreAdminParams.COMMIT_NAME);\n    +      String cname = params.required().get(CoreAdminParams.CORE);\n    +      try (SolrCore core = cc.getCore(cname)) {\n    +        if (core == null) {    +          throw new SolrException(ErrorCode.SERVER_ERROR, \"Unable to locate core \" + cname);    +        }\n    +\n    +        SolrSnapshotMetaDataManager mgr = core.getSnapshotMetaDataManager();\n    +        Optional<SnapshotMetaData> metadata = mgr.release(commitName);\n    +        if (metadata.isPresent()) {\n    +          long gen = metadata.get().getGenerationNumber();\n    +          String indexDirPath = metadata.get().getIndexDirPath();\n    +\n    +          // If the directory storing the snapshot is not the same as the current core\n    \u2014 End diff \u2013\n\n    This explanation helps; thanks ",
            "id": "comment-15387879"
        },
        {
            "date": "2016-07-21T15:24:41+0000",
            "author": "ASF GitHub Bot",
            "content": "Github user dsmiley commented on a diff in the pull request:\n\n    https://github.com/apache/lucene-solr/pull/52#discussion_r71727257\n\n    \u2014 Diff: solr/core/src/java/org/apache/solr/core/snapshots/SolrSnapshotMetaDataManager.java \u2014\n    @@ -0,0 +1,419 @@\n    +/*\n    + * Licensed to the Apache Software Foundation (ASF) under one or more\n    + * contributor license agreements.  See the NOTICE file distributed with\n    + * this work for additional information regarding copyright ownership.\n    + * The ASF licenses this file to You under the Apache License, Version 2.0\n    + * (the \"License\"); you may not use this file except in compliance with\n    + * the License.  You may obtain a copy of the License at\n    + *\n    + *     http://www.apache.org/licenses/LICENSE-2.0\n    + *\n    + * Unless required by applicable law or agreed to in writing, software\n    + * distributed under the License is distributed on an \"AS IS\" BASIS,\n    + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    + * See the License for the specific language governing permissions and\n    + * limitations under the License.\n    + */\n    +package org.apache.solr.core.snapshots;\n    +\n    +import java.io.IOException;\n    +import java.lang.invoke.MethodHandles;\n    +import java.util.ArrayList;\n    +import java.util.Collection;\n    +import java.util.Collections;\n    +import java.util.HashMap;\n    +import java.util.HashSet;\n    +import java.util.List;\n    +import java.util.Locale;\n    +import java.util.Map;\n    +import java.util.Map.Entry;\n    +import java.util.Optional;\n    +import java.util.stream.Collectors;\n    +\n    +import org.apache.lucene.codecs.CodecUtil;\n    +import org.apache.lucene.index.DirectoryReader;\n    +import org.apache.lucene.index.IndexCommit;\n    +import org.apache.lucene.index.IndexDeletionPolicy;\n    +import org.apache.lucene.index.IndexWriterConfig.OpenMode;\n    +import org.apache.lucene.store.Directory;\n    +import org.apache.lucene.store.IOContext;\n    +import org.apache.lucene.store.IndexInput;\n    +import org.apache.lucene.store.IndexOutput;\n    +import org.apache.lucene.util.IOUtils;\n    +import org.apache.solr.common.SolrException;\n    +import org.apache.solr.common.SolrException.ErrorCode;\n    +import org.apache.solr.core.DirectoryFactory;\n    +import org.apache.solr.core.IndexDeletionPolicyWrapper;\n    +import org.apache.solr.core.SolrCore;\n    +import org.apache.solr.core.DirectoryFactory.DirContext;\n    +import org.slf4j.Logger;\n    +import org.slf4j.LoggerFactory;\n    +\n    +import com.google.common.base.Preconditions;\n    +\n    +/**\n    + * This class is responsible to manage the persistent snapshots meta-data for the Solr indexes. The\n    + * persistent snapshots are implemented by relying on Lucene \n{@linkplain IndexDeletionPolicy}\n    + * abstraction to configure a specific \n{@linkplain IndexCommit}\n to be retained. The\n    + * \n{@linkplain IndexDeletionPolicyWrapper}\n in Solr uses this class to create/delete the Solr index\n    + * snapshots.\n    + */\n    +public class SolrSnapshotMetaDataManager {\n    +  private static final Logger log = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n    +  public static final String SNAPSHOT_METADATA_DIR = \"snapshot_metadata\";\n    +\n    +  /**\n    +   * A class defining the meta-data for a specific snapshot.\n    +   */\n    +  public static class SnapshotMetaData {\n    +    private String name;\n    +    private String indexDirPath;\n    +    private long generationNumber;\n    +\n    +    public SnapshotMetaData(String name, String indexDirPath, long generationNumber) \n{\n    +      super();\n    +      this.name = name;\n    +      this.indexDirPath = indexDirPath;\n    +      this.generationNumber = generationNumber;\n    +    }\n    +\n    +    public String getName() \n{\n    +      return name;\n    +    }\n    +\n    +    public String getIndexDirPath() \n{\n    +      return indexDirPath;\n    +    }\n    +\n    +    public long getGenerationNumber() \n{\n    +      return generationNumber;\n    +    }\n    +\n    +    @Override\n    +    public String toString() \n{\n    +      StringBuilder builder = new StringBuilder();\n    +      builder.append(\"SnapshotMetaData[name=\");\n    +      builder.append(name);\n    +      builder.append(\", indexDirPath=\");\n    +      builder.append(indexDirPath);\n    +      builder.append(\", generation=\");\n    +      builder.append(generationNumber);\n    +      builder.append(\"]\");\n    +      return builder.toString();\n    +    }\n    +  }\n    +\n    +  /** Prefix used for the save file. */\n    +  public static final String SNAPSHOTS_PREFIX = \"snapshots_\";\n    +  private static final int VERSION_START = 0;\n    +  private static final int VERSION_CURRENT = VERSION_START;\n    +  private static final String CODEC_NAME = \"solr-snapshots\";\n    +\n    +  // The index writer which maintains the snapshots metadata\n    +  private long nextWriteGen;\n    +\n    +  private final Directory dir;\n    +\n    +  /** Used to map snapshot name to snapshot meta-data. */\n    +  protected final Map<String,SnapshotMetaData> nameToDetailsMapping = new HashMap<>();\n    \u2014 End diff \u2013\n\n    For more consistency/predictability (e.g. when listing snapshots), I suggest using a LinkedHashMap ",
            "id": "comment-15387894"
        },
        {
            "date": "2016-07-21T15:27:23+0000",
            "author": "ASF GitHub Bot",
            "content": "Github user dsmiley commented on a diff in the pull request:\n\n    https://github.com/apache/lucene-solr/pull/52#discussion_r71727810\n\n    \u2014 Diff: solr/core/src/java/org/apache/solr/core/snapshots/SolrSnapshotMetaDataManager.java \u2014\n    @@ -0,0 +1,419 @@\n    +/*\n    + * Licensed to the Apache Software Foundation (ASF) under one or more\n    + * contributor license agreements.  See the NOTICE file distributed with\n    + * this work for additional information regarding copyright ownership.\n    + * The ASF licenses this file to You under the Apache License, Version 2.0\n    + * (the \"License\"); you may not use this file except in compliance with\n    + * the License.  You may obtain a copy of the License at\n    + *\n    + *     http://www.apache.org/licenses/LICENSE-2.0\n    + *\n    + * Unless required by applicable law or agreed to in writing, software\n    + * distributed under the License is distributed on an \"AS IS\" BASIS,\n    + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    + * See the License for the specific language governing permissions and\n    + * limitations under the License.\n    + */\n    +package org.apache.solr.core.snapshots;\n    +\n    +import java.io.IOException;\n    +import java.lang.invoke.MethodHandles;\n    +import java.util.ArrayList;\n    +import java.util.Collection;\n    +import java.util.Collections;\n    +import java.util.HashMap;\n    +import java.util.HashSet;\n    +import java.util.List;\n    +import java.util.Locale;\n    +import java.util.Map;\n    +import java.util.Map.Entry;\n    +import java.util.Optional;\n    +import java.util.stream.Collectors;\n    +\n    +import org.apache.lucene.codecs.CodecUtil;\n    +import org.apache.lucene.index.DirectoryReader;\n    +import org.apache.lucene.index.IndexCommit;\n    +import org.apache.lucene.index.IndexDeletionPolicy;\n    +import org.apache.lucene.index.IndexWriterConfig.OpenMode;\n    +import org.apache.lucene.store.Directory;\n    +import org.apache.lucene.store.IOContext;\n    +import org.apache.lucene.store.IndexInput;\n    +import org.apache.lucene.store.IndexOutput;\n    +import org.apache.lucene.util.IOUtils;\n    +import org.apache.solr.common.SolrException;\n    +import org.apache.solr.common.SolrException.ErrorCode;\n    +import org.apache.solr.core.DirectoryFactory;\n    +import org.apache.solr.core.IndexDeletionPolicyWrapper;\n    +import org.apache.solr.core.SolrCore;\n    +import org.apache.solr.core.DirectoryFactory.DirContext;\n    +import org.slf4j.Logger;\n    +import org.slf4j.LoggerFactory;\n    +\n    +import com.google.common.base.Preconditions;\n    +\n    +/**\n    + * This class is responsible to manage the persistent snapshots meta-data for the Solr indexes. The\n    + * persistent snapshots are implemented by relying on Lucene \n{@linkplain IndexDeletionPolicy}\n    + * abstraction to configure a specific \n{@linkplain IndexCommit} to be retained. The\n    + * {@linkplain IndexDeletionPolicyWrapper} in Solr uses this class to create/delete the Solr index\n    + * snapshots.\n    + */\n    +public class SolrSnapshotMetaDataManager {\n    +  private static final Logger log = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n    +  public static final String SNAPSHOT_METADATA_DIR = \"snapshot_metadata\";\n    +\n    +  /**\n    +   * A class defining the meta-data for a specific snapshot.\n    +   */\n    +  public static class SnapshotMetaData {\n    +    private String name;\n    +    private String indexDirPath;\n    +    private long generationNumber;\n    +\n    +    public SnapshotMetaData(String name, String indexDirPath, long generationNumber) {\n    +      super();\n    +      this.name = name;\n    +      this.indexDirPath = indexDirPath;\n    +      this.generationNumber = generationNumber;\n    +    }\n    +\n    +    public String getName() {\n    +      return name;\n    +    }\n    +\n    +    public String getIndexDirPath() {\n    +      return indexDirPath;\n    +    }\n    +\n    +    public long getGenerationNumber() {\n    +      return generationNumber;\n    +    }\n    +\n    +    @Override\n    +    public String toString() {\n    +      StringBuilder builder = new StringBuilder();\n    +      builder.append(\"SnapshotMetaData[name=\");\n    +      builder.append(name);\n    +      builder.append(\", indexDirPath=\");\n    +      builder.append(indexDirPath);\n    +      builder.append(\", generation=\");\n    +      builder.append(generationNumber);\n    +      builder.append(\"]\");\n    +      return builder.toString();\n    +    }\n    +  }\n    +\n    +  /** Prefix used for the save file. */\n    +  public static final String SNAPSHOTS_PREFIX = \"snapshots_\";\n    +  private static final int VERSION_START = 0;\n    +  private static final int VERSION_CURRENT = VERSION_START;\n    +  private static final String CODEC_NAME = \"solr-snapshots\";\n    +\n    +  // The index writer which maintains the snapshots metadata\n    +  private long nextWriteGen;\n    +\n    +  private final Directory dir;\n    +\n    +  /** Used to map snapshot name to snapshot meta-data. */\n    +  protected final Map<String,SnapshotMetaData> nameToDetailsMapping = new HashMap<>();\n    +  /** Used to figure out the current index data directory path */\n    +  private final SolrCore solrCore;\n    +\n    +  /**\n    +   * A constructor.\n    +   *\n    +   * @param dir The directory where the snapshot meta-data should be stored. Enables updating\n    +   *            the existing meta-data.\n    +   * @throws IOException in case of errors.\n    +   */\n    +  public SolrSnapshotMetaDataManager(SolrCore solrCore, Directory dir) throws IOException {\n    +    this(solrCore, dir, OpenMode.CREATE_OR_APPEND);\n    +  }\n    +\n    +  /**\n    +   * A constructor.\n    +   *\n    +   * @param dir The directory where the snapshot meta-data is stored.\n    +   * @param mode CREATE If previous meta-data should be erased.\n    +   *             APPEND If previous meta-data should be read and updated.\n    +   *             CREATE_OR_APPEND Creates a new meta-data structure if one does not exist\n    +   *                              Updates the existing structure if one exists.\n    +   * @throws IOException in case of errors.\n    +   */\n    +  public SolrSnapshotMetaDataManager(SolrCore solrCore, Directory dir, OpenMode mode) throws IOException {\n    +    this.solrCore = solrCore;\n    +    this.dir = dir;\n    +\n    +    if (mode == OpenMode.CREATE) {\n    +      deleteSnapshotMetadataFiles();\n    +    }\n    +\n    +    loadFromSnapshotMetadataFile();\n    +\n    +    if (mode == OpenMode.APPEND && nextWriteGen == 0) {\n    +      throw new IllegalStateException(\"no snapshots stored in this directory\");\n    +    }\n    +  }\n    +\n    +  /**\n    +   * @return The snapshot meta-data directory\n    +   */\n    +  public Directory getSnapshotsDir() {\n    +    return dir;\n    +  }\n    +\n    +  /**\n    +   * This method creates a new snapshot meta-data entry.\n    +   *\n    +   * @param name The name of the snapshot.\n    +   * @param indexDirPath The directory path where the index files are stored.\n    +   * @param gen The generation number for the {@linkplain IndexCommit}\n being snapshotted.\n    +   * @throws IOException in case of I/O errors.\n    +   */\n    +  public synchronized void snapshot(String name, String indexDirPath, long gen) throws IOException {\n    +    Preconditions.checkNotNull(name);\n    +\n    +    log.info(\"Creating the snapshot named {} for core {} associated with index commit with generation {} in directory {}\"\n    +        , name, solrCore.getName(), gen, indexDirPath);\n    +\n    +    if(nameToDetailsMapping.containsKey(name)) \n{\n    +      throw new SolrException(ErrorCode.BAD_REQUEST, \"A snapshot with name \" + name + \" already exists\");\n    +    }\n    +\n    +    SnapshotMetaData d = new SnapshotMetaData(name, indexDirPath, gen);\n    +    nameToDetailsMapping.put(name, d);\n    +\n    +    boolean success = false;\n    +    try \n{\n    +      persist();\n    +      success = true;\n    +    }\n finally {\n    +      if (!success) {\n    +        try \n{\n    +          release(name);\n    +        }\n catch (Exception e) \n{\n    +          // Suppress so we keep throwing original exception\n    +        }\n    +      }\n    +    }\n    +  }\n    +\n    +  /**\n    +   * This method deletes a previously created snapshot (if any).\n    +   *\n    +   * @param name The name of the snapshot to be deleted.\n    +   * @return The snapshot meta-data if the snapshot with the snapshot name exists.\n    +   * @throws IOException in case of I/O error\n    +   */\n    +  public synchronized Optional<SnapshotMetaData> release(String name) throws IOException {\n    +    log.info(\"Deleting the snapshot named {} for core {}\", name, solrCore.getName());\n    +    SnapshotMetaData result = nameToDetailsMapping.remove(Preconditions.checkNotNull(name));\n    +    if(result != null) {\n    +      boolean success = false;\n    +      try \n{\n    +        persist();\n    +        success = true;\n    +      }\n finally {\n    +        if (!success) \n{\n    +          nameToDetailsMapping.put(name, result);\n    +        }\n    +      }\n    +    }\n    +    return Optional.ofNullable(result);\n    +  }\n    +\n    +  /**\n    +   * This method returns if snapshot is created for the specified generation number in\n    +   * the current index directory.\n    +   *\n    +   * @param genNumber The generation number for the \n{@linkplain IndexCommit} to be checked.\n    +   * @return true if the snapshot is created.\n    +   *         false otherwise.\n    +   */\n    +  public synchronized boolean isSnapshotted(long genNumber) {\n    +    return isSnapshotted(solrCore.getIndexDir(), genNumber);\n    +  }\n    +\n    +  /**\n    +   * This method returns if snapshot is created for the specified generation number in\n    +   * the specified index directory.\n    +   *\n    +   * @param genNumber The generation number for the {@linkplain IndexCommit}\n to be checked.\n    +   * @return true if the snapshot is created.\n    +   *         false otherwise.\n    +   */\n    +  public synchronized boolean isSnapshotted(String indexDirPath, long genNumber) \n{\n    +    return nameToDetailsMapping.values().stream()\n    +        .filter(entry -> entry.getIndexDirPath().equals(indexDirPath) && entry.getGenerationNumber() == genNumber)\n    +        .findFirst()\n    +        .isPresent();\n    +  }\n    +\n    +  /**\n    +   * This method returns the snapshot meta-data for the specified name (if it exists).\n    +   *\n    +   * @param name The name of the snapshot\n    +   * @return The snapshot meta-data if exists.\n    +   */\n    +  public synchronized Optional<SnapshotMetaData> getSnapshotMetaData(String name) \n{\n    +    return Optional.ofNullable(nameToDetailsMapping.get(name));\n    +  }\n    +\n    +  /**\n    +   * @return A list of snapshots created so far.\n    +   */\n    +  public synchronized Collection<String> listSnapshots() {\n    +    return new HashSet<>(nameToDetailsMapping.keySet());\n    \u2014 End diff \u2013\n\n    ArrayList for consistent ordering.  Add comment that we need to copy for thread-safety. ",
            "id": "comment-15387899"
        },
        {
            "date": "2016-07-21T15:39:48+0000",
            "author": "ASF GitHub Bot",
            "content": "Github user dsmiley commented on a diff in the pull request:\n\n    https://github.com/apache/lucene-solr/pull/52#discussion_r71730215\n\n    \u2014 Diff: solr/core/src/java/org/apache/solr/core/SolrCore.java \u2014\n    @@ -414,7 +416,19 @@ private IndexDeletionPolicyWrapper initDeletionPolicy(IndexDeletionPolicyWrapper\n         } else \n{\n           delPolicy = new SolrDeletionPolicy();\n         }\n\n\treturn new IndexDeletionPolicyWrapper(delPolicy);\n    +\n    +    return new IndexDeletionPolicyWrapper(delPolicy, snapshotMgr);\n    +  }\n    +\n    +  private SolrSnapshotMetaDataManager initSnapshotMetaDataManager() {\n\t\n\t\t\n\t\t\n\t\t\tEnd diff \u2013\n\t\t\n\t\t\n\t\n\t\n\n\n\n    What do you think about possibly creating a Directory lazily on first use of a snapshot?  I'm a tad concerned we're weighing Solr down a bit more for everyone when only a small number of installations in the future will use this.  What's your feeling @markrmiller ? ",
            "id": "comment-15387917"
        },
        {
            "date": "2016-07-21T15:40:50+0000",
            "author": "ASF GitHub Bot",
            "content": "Github user dsmiley commented on a diff in the pull request:\n\n    https://github.com/apache/lucene-solr/pull/52#discussion_r71730404\n\n    \u2014 Diff: solr/core/src/java/org/apache/solr/core/snapshots/SolrSnapshotMetaDataManager.java \u2014\n    @@ -0,0 +1,419 @@\n    +/*\n    + * Licensed to the Apache Software Foundation (ASF) under one or more\n    + * contributor license agreements.  See the NOTICE file distributed with\n    + * this work for additional information regarding copyright ownership.\n    + * The ASF licenses this file to You under the Apache License, Version 2.0\n    + * (the \"License\"); you may not use this file except in compliance with\n    + * the License.  You may obtain a copy of the License at\n    + *\n    + *     http://www.apache.org/licenses/LICENSE-2.0\n    + *\n    + * Unless required by applicable law or agreed to in writing, software\n    + * distributed under the License is distributed on an \"AS IS\" BASIS,\n    + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    + * See the License for the specific language governing permissions and\n    + * limitations under the License.\n    + */\n    +package org.apache.solr.core.snapshots;\n    +\n    +import java.io.IOException;\n    +import java.lang.invoke.MethodHandles;\n    +import java.util.ArrayList;\n    +import java.util.Collection;\n    +import java.util.Collections;\n    +import java.util.HashMap;\n    +import java.util.HashSet;\n    +import java.util.List;\n    +import java.util.Locale;\n    +import java.util.Map;\n    +import java.util.Map.Entry;\n    +import java.util.Optional;\n    +import java.util.stream.Collectors;\n    +\n    +import org.apache.lucene.codecs.CodecUtil;\n    +import org.apache.lucene.index.DirectoryReader;\n    +import org.apache.lucene.index.IndexCommit;\n    +import org.apache.lucene.index.IndexDeletionPolicy;\n    +import org.apache.lucene.index.IndexWriterConfig.OpenMode;\n    +import org.apache.lucene.store.Directory;\n    +import org.apache.lucene.store.IOContext;\n    +import org.apache.lucene.store.IndexInput;\n    +import org.apache.lucene.store.IndexOutput;\n    +import org.apache.lucene.util.IOUtils;\n    +import org.apache.solr.common.SolrException;\n    +import org.apache.solr.common.SolrException.ErrorCode;\n    +import org.apache.solr.core.DirectoryFactory;\n    +import org.apache.solr.core.IndexDeletionPolicyWrapper;\n    +import org.apache.solr.core.SolrCore;\n    +import org.apache.solr.core.DirectoryFactory.DirContext;\n    +import org.slf4j.Logger;\n    +import org.slf4j.LoggerFactory;\n    +\n    +import com.google.common.base.Preconditions;\n    +\n    +/**\n    + * This class is responsible to manage the persistent snapshots meta-data for the Solr indexes. The\n    + * persistent snapshots are implemented by relying on Lucene \n{@linkplain IndexDeletionPolicy}\n    + * abstraction to configure a specific \n{@linkplain IndexCommit} to be retained. The\n    + * {@linkplain IndexDeletionPolicyWrapper} in Solr uses this class to create/delete the Solr index\n    + * snapshots.\n    + */\n    +public class SolrSnapshotMetaDataManager {\n    +  private static final Logger log = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n    +  public static final String SNAPSHOT_METADATA_DIR = \"snapshot_metadata\";\n    +\n    +  /**\n    +   * A class defining the meta-data for a specific snapshot.\n    +   */\n    +  public static class SnapshotMetaData {\n    +    private String name;\n    +    private String indexDirPath;\n    +    private long generationNumber;\n    +\n    +    public SnapshotMetaData(String name, String indexDirPath, long generationNumber) {\n    +      super();\n    +      this.name = name;\n    +      this.indexDirPath = indexDirPath;\n    +      this.generationNumber = generationNumber;\n    +    }\n    +\n    +    public String getName() {\n    +      return name;\n    +    }\n    +\n    +    public String getIndexDirPath() {\n    +      return indexDirPath;\n    +    }\n    +\n    +    public long getGenerationNumber() {\n    +      return generationNumber;\n    +    }\n    +\n    +    @Override\n    +    public String toString() {\n    +      StringBuilder builder = new StringBuilder();\n    +      builder.append(\"SnapshotMetaData[name=\");\n    +      builder.append(name);\n    +      builder.append(\", indexDirPath=\");\n    +      builder.append(indexDirPath);\n    +      builder.append(\", generation=\");\n    +      builder.append(generationNumber);\n    +      builder.append(\"]\");\n    +      return builder.toString();\n    +    }\n    +  }\n    +\n    +  /** Prefix used for the save file. */\n    +  public static final String SNAPSHOTS_PREFIX = \"snapshots_\";\n    +  private static final int VERSION_START = 0;\n    +  private static final int VERSION_CURRENT = VERSION_START;\n    +  private static final String CODEC_NAME = \"solr-snapshots\";\n    +\n    +  // The index writer which maintains the snapshots metadata\n    +  private long nextWriteGen;\n    +\n    +  private final Directory dir;\n    +\n    +  /** Used to map snapshot name to snapshot meta-data. */\n    +  protected final Map<String,SnapshotMetaData> nameToDetailsMapping = new HashMap<>();\n    +  /** Used to figure out the current index data directory path */\n    +  private final SolrCore solrCore;\n    +\n    +  /**\n    +   * A constructor.\n    +   *\n    +   * @param dir The directory where the snapshot meta-data should be stored. Enables updating\n    +   *            the existing meta-data.\n    +   * @throws IOException in case of errors.\n    +   */\n    +  public SolrSnapshotMetaDataManager(SolrCore solrCore, Directory dir) throws IOException {\n    +    this(solrCore, dir, OpenMode.CREATE_OR_APPEND);\n    +  }\n    +\n    +  /**\n    +   * A constructor.\n    +   *\n    +   * @param dir The directory where the snapshot meta-data is stored.\n    +   * @param mode CREATE If previous meta-data should be erased.\n    +   *             APPEND If previous meta-data should be read and updated.\n    +   *             CREATE_OR_APPEND Creates a new meta-data structure if one does not exist\n    +   *                              Updates the existing structure if one exists.\n    +   * @throws IOException in case of errors.\n    +   */\n    +  public SolrSnapshotMetaDataManager(SolrCore solrCore, Directory dir, OpenMode mode) throws IOException {\n    +    this.solrCore = solrCore;\n    +    this.dir = dir;\n    +\n    +    if (mode == OpenMode.CREATE) {\n    +      deleteSnapshotMetadataFiles();\n    +    }\n    +\n    +    loadFromSnapshotMetadataFile();\n    +\n    +    if (mode == OpenMode.APPEND && nextWriteGen == 0) {\n    +      throw new IllegalStateException(\"no snapshots stored in this directory\");\n    +    }\n    +  }\n    +\n    +  /**\n    +   * @return The snapshot meta-data directory\n    +   */\n    +  public Directory getSnapshotsDir() {\n    +    return dir;\n    +  }\n    +\n    +  /**\n    +   * This method creates a new snapshot meta-data entry.\n    +   *\n    +   * @param name The name of the snapshot.\n    +   * @param indexDirPath The directory path where the index files are stored.\n    +   * @param gen The generation number for the {@linkplain IndexCommit}\n being snapshotted.\n    +   * @throws IOException in case of I/O errors.\n    +   */\n    +  public synchronized void snapshot(String name, String indexDirPath, long gen) throws IOException {\n    +    Preconditions.checkNotNull(name);\n    +\n    +    log.info(\"Creating the snapshot named {} for core {} associated with index commit with generation {} in directory {}\"\n    +        , name, solrCore.getName(), gen, indexDirPath);\n    +\n    +    if(nameToDetailsMapping.containsKey(name)) \n{\n    +      throw new SolrException(ErrorCode.BAD_REQUEST, \"A snapshot with name \" + name + \" already exists\");\n    +    }\n    +\n    +    SnapshotMetaData d = new SnapshotMetaData(name, indexDirPath, gen);\n    +    nameToDetailsMapping.put(name, d);\n    +\n    +    boolean success = false;\n    +    try \n{\n    +      persist();\n    +      success = true;\n    +    }\n finally {\n    +      if (!success) {\n    +        try \n{\n    +          release(name);\n    +        }\n catch (Exception e) \n{\n    +          // Suppress so we keep throwing original exception\n    +        }\n    +      }\n    +    }\n    +  }\n    +\n    +  /**\n    +   * This method deletes a previously created snapshot (if any).\n    +   *\n    +   * @param name The name of the snapshot to be deleted.\n    +   * @return The snapshot meta-data if the snapshot with the snapshot name exists.\n    +   * @throws IOException in case of I/O error\n    +   */\n    +  public synchronized Optional<SnapshotMetaData> release(String name) throws IOException {\n    +    log.info(\"Deleting the snapshot named {} for core {}\", name, solrCore.getName());\n    +    SnapshotMetaData result = nameToDetailsMapping.remove(Preconditions.checkNotNull(name));\n    +    if(result != null) {\n    +      boolean success = false;\n    +      try \n{\n    +        persist();\n    +        success = true;\n    +      }\n finally {\n    +        if (!success) \n{\n    +          nameToDetailsMapping.put(name, result);\n    +        }\n    +      }\n    +    }\n    +    return Optional.ofNullable(result);\n    +  }\n    +\n    +  /**\n    +   * This method returns if snapshot is created for the specified generation number in\n    +   * the current index directory.\n    +   *\n    +   * @param genNumber The generation number for the \n{@linkplain IndexCommit} to be checked.\n    +   * @return true if the snapshot is created.\n    +   *         false otherwise.\n    +   */\n    +  public synchronized boolean isSnapshotted(long genNumber) {\n    +    return isSnapshotted(solrCore.getIndexDir(), genNumber);\n    +  }\n    +\n    +  /**\n    +   * This method returns if snapshot is created for the specified generation number in\n    +   * the specified index directory.\n    +   *\n    +   * @param genNumber The generation number for the {@linkplain IndexCommit}\n to be checked.\n    +   * @return true if the snapshot is created.\n    +   *         false otherwise.\n    +   */\n    +  public synchronized boolean isSnapshotted(String indexDirPath, long genNumber) {\n    +    return nameToDetailsMapping.values().stream()\n    \u2014 End diff \u2013\n\n    Since this may be called often  I suggest a quick nameToDetailsMapping.isEmpty() check first to return fast. ",
            "id": "comment-15387920"
        },
        {
            "date": "2016-07-21T16:04:45+0000",
            "author": "ASF GitHub Bot",
            "content": "Github user dsmiley commented on a diff in the pull request:\n\n    https://github.com/apache/lucene-solr/pull/52#discussion_r71735109\n\n    \u2014 Diff: solr/core/src/java/org/apache/solr/core/snapshots/SolrSnapshotManager.java \u2014\n    @@ -0,0 +1,132 @@\n    +/*\n    + * Licensed to the Apache Software Foundation (ASF) under one or more\n    + * contributor license agreements.  See the NOTICE file distributed with\n    + * this work for additional information regarding copyright ownership.\n    + * The ASF licenses this file to You under the Apache License, Version 2.0\n    + * (the \"License\"); you may not use this file except in compliance with\n    + * the License.  You may obtain a copy of the License at\n    + *\n    + *     http://www.apache.org/licenses/LICENSE-2.0\n    + *\n    + * Unless required by applicable law or agreed to in writing, software\n    + * distributed under the License is distributed on an \"AS IS\" BASIS,\n    + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    + * See the License for the specific language governing permissions and\n    + * limitations under the License.\n    + */\n    +package org.apache.solr.core.snapshots;\n    +\n    +import java.io.IOException;\n    +import java.lang.invoke.MethodHandles;\n    +import java.util.Collection;\n    +import java.util.HashMap;\n    +import java.util.List;\n    +import java.util.Map;\n    +import java.util.Set;\n    +import java.util.function.Function;\n    +import java.util.stream.Collectors;\n    +\n    +import org.apache.lucene.index.DirectoryReader;\n    +import org.apache.lucene.index.IndexCommit;\n    +import org.apache.lucene.store.Directory;\n    +import org.apache.solr.core.snapshots.SolrSnapshotMetaDataManager.SnapshotMetaData;\n    +import org.slf4j.Logger;\n    +import org.slf4j.LoggerFactory;\n    +\n    +/**\n    + * This class provides functionality required to handle the data files corresponding to Solr snapshots.\n    + */\n    +public class SolrSnapshotManager {\n    +  private static final Logger log = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n    +\n    +  /**\n    +   * This method deletes index files of the \n{@linkplain IndexCommit} for the specified generation number.\n    +   *\n    +   * @param dir The index directory storing the snapshot.\n    +   * @param gen The generation number for the {@linkplain IndexCommit}\n    +   * @throws IOException in case of I/O errors.\n    +   */\n    +  public static synchronized void deleteIndexFiles ( Directory dir, Collection<SnapshotMetaData> snapshots, long gen ) throws IOException {\n    +    List<IndexCommit> commits = DirectoryReader.listCommits(dir);\n    +    Map<String, Integer> refCounts = buildRefCounts(snapshots,commits);\n    +    for (IndexCommit ic : commits) {\n    +      if (ic.getGeneration() == gen) \n{\n    +        deleteIndexFiles(dir,refCounts, ic);\n    +        break;\n    +      }\n    +    }\n    +  }\n    +\n    +  /**\n    +   * This method deletes all files not corresponding to a configured snapshot in the specified index directory.\n    +   *\n    +   * @param dir The index directory to search for.\n    +   * @throws IOException in case of I/O errors.\n    +   */\n    +  public static synchronized void deleteNonSnapshotIndexFiles (Directory dir, Collection<SnapshotMetaData> snapshots) throws IOException {\n    +    List<IndexCommit> commits = DirectoryReader.listCommits(dir);\n    +    Map<String, Integer> refCounts = buildRefCounts(snapshots, commits);\n    +    Set<Long> snapshotGenNumbers = snapshots.stream()\n    +                                            .map(SnapshotMetaData::getGenerationNumber)\n    +                                            .collect(Collectors.toSet());\n    +    for (IndexCommit ic : commits) {\n    +      if (!snapshotGenNumbers.contains(ic.getGeneration())) \n{\n    +        deleteIndexFiles(dir,refCounts, ic);\n    +      }\n    +    }\n    +  }\n    +\n    +  /**\n    +   * This method computes reference count for the index files by taking into consideration\n    +   * (a) configured snapshots and (b) files sharing between two or more \n{@linkplain IndexCommit} instances.\n    +   *\n    +   * @param snapshots A collection of user configured snapshots\n    +   * @param commits A list of {@linkplain IndexCommit}\n instances\n    +   * @return A map containing reference count for each index file referred in one of the \n{@linkplain IndexCommit}\n instances.\n    +   * @throws IOException in case of I/O error.\n    +   */\n    +  public static Map<String, Integer> buildRefCounts (Collection<SnapshotMetaData> snapshots, List<IndexCommit> commits) throws IOException {\n    \u2014 End diff \u2013\n\n    It seems that the callers of this method don't actually need to know the ref counts.  The callers want to know which file names referred to.  I think returning exactly that, and naming it as such, would be much more helpful.\n    (could be package-private, BTW) ",
            "id": "comment-15387953"
        },
        {
            "date": "2016-07-21T16:14:37+0000",
            "author": "ASF GitHub Bot",
            "content": "Github user dsmiley commented on a diff in the pull request:\n\n    https://github.com/apache/lucene-solr/pull/52#discussion_r71736862\n\n    \u2014 Diff: solr/core/src/java/org/apache/solr/core/snapshots/SolrSnapshotManager.java \u2014\n    @@ -0,0 +1,132 @@\n    +/*\n    + * Licensed to the Apache Software Foundation (ASF) under one or more\n    + * contributor license agreements.  See the NOTICE file distributed with\n    + * this work for additional information regarding copyright ownership.\n    + * The ASF licenses this file to You under the Apache License, Version 2.0\n    + * (the \"License\"); you may not use this file except in compliance with\n    + * the License.  You may obtain a copy of the License at\n    + *\n    + *     http://www.apache.org/licenses/LICENSE-2.0\n    + *\n    + * Unless required by applicable law or agreed to in writing, software\n    + * distributed under the License is distributed on an \"AS IS\" BASIS,\n    + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    + * See the License for the specific language governing permissions and\n    + * limitations under the License.\n    + */\n    +package org.apache.solr.core.snapshots;\n    +\n    +import java.io.IOException;\n    +import java.lang.invoke.MethodHandles;\n    +import java.util.Collection;\n    +import java.util.HashMap;\n    +import java.util.List;\n    +import java.util.Map;\n    +import java.util.Set;\n    +import java.util.function.Function;\n    +import java.util.stream.Collectors;\n    +\n    +import org.apache.lucene.index.DirectoryReader;\n    +import org.apache.lucene.index.IndexCommit;\n    +import org.apache.lucene.store.Directory;\n    +import org.apache.solr.core.snapshots.SolrSnapshotMetaDataManager.SnapshotMetaData;\n    +import org.slf4j.Logger;\n    +import org.slf4j.LoggerFactory;\n    +\n    +/**\n    + * This class provides functionality required to handle the data files corresponding to Solr snapshots.\n    + */\n    +public class SolrSnapshotManager {\n    +  private static final Logger log = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n    +\n    +  /**\n    +   * This method deletes index files of the \n{@linkplain IndexCommit} for the specified generation number.\n    +   *\n    +   * @param dir The index directory storing the snapshot.\n    +   * @param gen The generation number for the {@linkplain IndexCommit}\n    +   * @throws IOException in case of I/O errors.\n    +   */\n    +  public static synchronized void deleteIndexFiles ( Directory dir, Collection<SnapshotMetaData> snapshots, long gen ) throws IOException {\n    +    List<IndexCommit> commits = DirectoryReader.listCommits(dir);\n    +    Map<String, Integer> refCounts = buildRefCounts(snapshots,commits);\n    +    for (IndexCommit ic : commits) {\n    +      if (ic.getGeneration() == gen) \n{\n    +        deleteIndexFiles(dir,refCounts, ic);\n    +        break;\n    +      }\n    +    }\n    +  }\n    +\n    +  /**\n    +   * This method deletes all files not corresponding to a configured snapshot in the specified index directory.\n    +   *\n    +   * @param dir The index directory to search for.\n    +   * @throws IOException in case of I/O errors.\n    +   */\n    +  public static synchronized void deleteNonSnapshotIndexFiles (Directory dir, Collection<SnapshotMetaData> snapshots) throws IOException {\n    +    List<IndexCommit> commits = DirectoryReader.listCommits(dir);\n    +    Map<String, Integer> refCounts = buildRefCounts(snapshots, commits);\n    +    Set<Long> snapshotGenNumbers = snapshots.stream()\n    +                                            .map(SnapshotMetaData::getGenerationNumber)\n    +                                            .collect(Collectors.toSet());\n    +    for (IndexCommit ic : commits) {\n    +      if (!snapshotGenNumbers.contains(ic.getGeneration())) \n{\n    +        deleteIndexFiles(dir,refCounts, ic);\n    +      }\n    +    }\n    +  }\n    +\n    +  /**\n    +   * This method computes reference count for the index files by taking into consideration\n    +   * (a) configured snapshots and (b) files sharing between two or more \n{@linkplain IndexCommit} instances.\n    +   *\n    +   * @param snapshots A collection of user configured snapshots\n    +   * @param commits A list of {@linkplain IndexCommit}\n instances\n    +   * @return A map containing reference count for each index file referred in one of the \n{@linkplain IndexCommit} instances.\n    +   * @throws IOException in case of I/O error.\n    +   */\n    +  public static Map<String, Integer> buildRefCounts (Collection<SnapshotMetaData> snapshots, List<IndexCommit> commits) throws IOException {\n    +    Map<String, Integer> result = new HashMap<>();\n    +    Map<Long, IndexCommit> commitsByGen = commits.stream().collect(\n    +        Collectors.toMap(IndexCommit::getGeneration, Function.identity()));\n    +\n    +    for(SnapshotMetaData md : snapshots) {\n    +      IndexCommit ic = commitsByGen.get(md.getGenerationNumber());\n    +      if (ic != null) {\n    +        Collection<String> fileNames = ic.getFileNames();\n    +        for(String fileName : fileNames) {\n    +          int refCount = result.getOrDefault(fileName, 0);\n    +          result.put(fileName, refCount+1);\n    +        }\n    +      }\n    +    }\n    +\n    +    return result;\n    +  }\n    +\n    +  /**\n    +   * This method deletes the index files associated with specified <code>indexCommit</code> provided they\n    +   * are not referred by some other {@linkplain IndexCommit}\n.\n    +   *\n    +   * @param dir The index directory containing the \n{@linkplain IndexCommit} to be deleted.\n    +   * @param refCounts A map containing reference counts for each file associated with every {@linkplain IndexCommit}\n    +   *                  in the specified directory.\n    +   * @param indexCommit The \n{@linkplain IndexCommit}\n whose files need to be deleted.\n    +   * @throws IOException in case of I/O errors.\n    +   */\n    +  private static synchronized void deleteIndexFiles ( Directory dir, Map<String, Integer> refCounts, IndexCommit indexCommit ) throws IOException {\n    \u2014 End diff \u2013\n\n    The \"static synchronized\" concerns me for the methods in this class.  This will lock this operation for the whole JVM!  Perhaps we can modify the code in this class to be tolerant of concurrent invocations.  e.g. If we fail to delete a file and the exception is a FileNotFoundException then move on.  There is similar code in Lucene. ",
            "id": "comment-15387962"
        },
        {
            "date": "2016-07-21T16:15:47+0000",
            "author": "ASF GitHub Bot",
            "content": "Github user dsmiley commented on a diff in the pull request:\n\n    https://github.com/apache/lucene-solr/pull/52#discussion_r71737044\n\n    \u2014 Diff: solr/core/src/test/org/apache/solr/handler/TestSolrCoreSnapshots.java \u2014\n    @@ -0,0 +1,446 @@\n    +/*\n    + * Licensed to the Apache Software Foundation (ASF) under one or more\n    + * contributor license agreements.  See the NOTICE file distributed with\n    + * this work for additional information regarding copyright ownership.\n    + * The ASF licenses this file to You under the Apache License, Version 2.0\n    + * (the \"License\"); you may not use this file except in compliance with\n    + * the License.  You may obtain a copy of the License at\n    + *\n    + *     http://www.apache.org/licenses/LICENSE-2.0\n    + *\n    + * Unless required by applicable law or agreed to in writing, software\n    + * distributed under the License is distributed on an \"AS IS\" BASIS,\n    + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    + * See the License for the specific language governing permissions and\n    + * limitations under the License.\n    + */\n    +package org.apache.solr.handler;\n    +\n    +import static org.apache.solr.common.cloud.ZkStateReader.BASE_URL_PROP;\n    +\n    +import java.io.IOException;\n    +import java.io.InputStream;\n    +import java.lang.invoke.MethodHandles;\n    +import java.net.URL;\n    +import java.nio.file.Files;\n    +import java.nio.file.Path;\n    +import java.nio.file.Paths;\n    +import java.util.ArrayList;\n    +import java.util.Collection;\n    +import java.util.Collections;\n    +import java.util.HashMap;\n    +import java.util.List;\n    +import java.util.Map;\n    +import java.util.Optional;\n    +import org.apache.commons.io.IOUtils;\n    +import org.apache.lucene.index.DirectoryReader;\n    +import org.apache.lucene.index.IndexCommit;\n    +import org.apache.lucene.index.IndexNotFoundException;\n    +import org.apache.lucene.store.SimpleFSDirectory;\n    +import org.apache.lucene.util.TestUtil;\n    +import org.apache.lucene.util.LuceneTestCase.Slow;\n    +import org.apache.solr.SolrTestCaseJ4;\n    +import org.apache.solr.client.solrj.SolrClient;\n    +import org.apache.solr.client.solrj.impl.CloudSolrClient;\n    +import org.apache.solr.client.solrj.request.CollectionAdminRequest;\n    +import org.apache.solr.client.solrj.request.CoreAdminRequest.CreateSnapshot;\n    +import org.apache.solr.client.solrj.request.CoreAdminRequest.DeleteSnapshot;\n    +import org.apache.solr.client.solrj.request.CoreAdminRequest.ListSnapshots;\n    +import org.apache.solr.cloud.SolrCloudTestCase;\n    +import org.apache.solr.common.SolrInputDocument;\n    +import org.apache.solr.common.cloud.DocCollection;\n    +import org.apache.solr.common.cloud.Replica;\n    +import org.apache.solr.common.cloud.Slice;\n    +import org.apache.solr.common.cloud.ZkStateReader;\n    +import org.apache.solr.common.params.CoreAdminParams.CoreAdminAction;\n    +import org.apache.solr.common.util.NamedList;\n    +import org.apache.solr.core.snapshots.SolrSnapshotManager;\n    +import org.apache.solr.core.snapshots.SolrSnapshotMetaDataManager.SnapshotMetaData;\n    +import org.junit.AfterClass;\n    +import org.junit.BeforeClass;\n    +import org.junit.Test;\n    +import org.slf4j.Logger;\n    +import org.slf4j.LoggerFactory;\n    +\n    +@SolrTestCaseJ4.SuppressSSL // Currently unknown why SSL does not work with this test\n    +@Slow\n    +public class TestSolrCoreSnapshots extends SolrCloudTestCase {\n    +  private static final Logger log = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n    +  private static long docsSeed; // see indexDocs()\n    +\n    +  @BeforeClass\n    +  public static void setupClass() throws Exception \n{\n    +    useFactory(\"solr.StandardDirectoryFactory\");\n    +    configureCluster(1)// nodes\n    +        .addConfig(\"conf1\", TEST_PATH().resolve(\"configsets\").resolve(\"cloud-minimal\").resolve(\"conf\"))\n    +        .configure();\n    +\n    +    docsSeed = random().nextLong();\n    +  }\n    +\n    +  @AfterClass\n    +  public static void teardownClass() throws Exception \n{\n    +    System.clearProperty(\"test.build.data\");\n    +    System.clearProperty(\"test.cache.data\");\n    +  }\n    +\n    +  @Test\n    +  public void testBackupRestore() throws Exception {\n    +    CloudSolrClient solrClient = cluster.getSolrClient();\n    +    String collectionName = \"SolrCoreSnapshots\";\n    +    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(collectionName, \"conf1\", 1, 1);\n    +    create.process(solrClient);\n    +\n    +    String location = createTempDir().toFile().getAbsolutePath();\n    +    int nDocs = BackupRestoreUtils.indexDocs(cluster.getSolrClient(), collectionName, docsSeed);\n    +\n    +    DocCollection collectionState = solrClient.getZkStateReader().getClusterState().getCollection(collectionName);\n    +    assertEquals(1, collectionState.getActiveSlices().size());\n    +    Slice shard = collectionState.getActiveSlices().iterator().next();\n    +    assertEquals(1, shard.getReplicas().size());\n    +    Replica replica = shard.getReplicas().iterator().next();\n    +\n    +    String replicaBaseUrl = replica.getStr(BASE_URL_PROP);\n    +    String coreName = replica.getStr(ZkStateReader.CORE_NAME_PROP);\n    +    String backupName = TestUtil.randomSimpleString(random(), 1, 5);\n    +    String commitName = TestUtil.randomSimpleString(random(), 1, 5);\n    +    String duplicateName = commitName.concat(\"_duplicate\");\n    +\n    +    try (\n    +        SolrClient adminClient = getHttpSolrClient(cluster.getJettySolrRunners().get(0).getBaseUrl().toString());\n    +        SolrClient masterClient = getHttpSolrClient(replica.getCoreUrl())) {\n    +\n    +      SnapshotMetaData metaData = createSnapshot(adminClient, coreName, commitName);\n    +      // Create another snapshot referring to the same index commit to verify the\n    +      // reference counting implementation during snapshot deletion.\n    +      SnapshotMetaData duplicateCommit = createSnapshot(adminClient, coreName, duplicateName);\n    +\n    +      assertEquals (metaData.getIndexDirPath(), duplicateCommit.getIndexDirPath());\n    +      assertEquals (metaData.getGenerationNumber(), duplicateCommit.getGenerationNumber());\n    +\n    +      // Delete all documents\n    +      masterClient.deleteByQuery(\":\");\n    +      masterClient.commit();\n    +      BackupRestoreUtils.verifyDocs(0, cluster.getSolrClient(), collectionName);\n    +\n    +      // Verify that the index directory contains at least 2 index commits - one referred by the snapshots\n    +      // and the other containing document deletions.\n    +      \n{\n    +        List<IndexCommit> commits = listCommits(metaData.getIndexDirPath());\n    +        assertTrue(2 <= commits.size());\n    +      }\n    +\n    +      // Backup the earlier created snapshot.\n    +      \n{\n    +        Map<String,String> params = new HashMap<>();\n    +        params.put(\"name\", backupName);\n    +        params.put(\"commitName\", commitName);\n    +        params.put(\"location\", location);\n    +        runCoreAdminCommand(replicaBaseUrl, coreName, CoreAdminAction.BACKUPCORE.toString(), params);\n    +      }\n    +\n    +      // Restore the backup\n    +      \n{\n    +        Map<String,String> params = new HashMap<>();\n    +        params.put(\"name\", \"snapshot.\" + backupName);\n    +        params.put(\"location\", location);\n    +        runCoreAdminCommand(replicaBaseUrl, coreName, CoreAdminAction.RESTORECORE.toString(), params);\n    +        BackupRestoreUtils.verifyDocs(nDocs, cluster.getSolrClient(), collectionName);\n    +      }\n    +\n    +      // Verify that the old index directory (before restore) contains only those index commits referred by snapshots.\n    +      \n{\n    +        List<IndexCommit> commits = listCommits(metaData.getIndexDirPath());\n    +        assertEquals(1, commits.size());\n    +        assertEquals(metaData.getGenerationNumber(), commits.get(0).getGeneration());\n    +      }\n    +\n    +      // Delete first snapshot\n    +      deleteSnapshot(adminClient, coreName, commitName);\n    +\n    +      // Verify that corresponding index files have NOT been deleted (due to reference counting).\n    +      assertFalse(listCommits(metaData.getIndexDirPath()).isEmpty());\n    +\n    +      // Delete second snapshot\n    +      deleteSnapshot(adminClient, coreName, duplicateCommit.getName());\n    +\n    +      // Verify that corresponding index files have been deleted.\n    +      assertTrue(listCommits(duplicateCommit.getIndexDirPath()).isEmpty());\n    +    }\n    +  }\n    +\n    +  @Test\n    +  public void testHandlingSharedIndexFiles() throws Exception {\n    +    CloudSolrClient solrClient = cluster.getSolrClient();\n    +    String collectionName = \"SolrCoreSnapshots_IndexFileSharing\";\n    +    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(collectionName, \"conf1\", 1, 1);\n    +    create.process(solrClient);\n    +\n    +    int nDocs = BackupRestoreUtils.indexDocs(cluster.getSolrClient(), collectionName, docsSeed);\n    +    DocCollection collectionState = solrClient.getZkStateReader().getClusterState().getCollection(collectionName);\n    +    assertEquals(1, collectionState.getActiveSlices().size());\n    +    Slice shard = collectionState.getActiveSlices().iterator().next();\n    +    assertEquals(1, shard.getReplicas().size());\n    +    Replica replica = shard.getReplicas().iterator().next();\n    +\n    +    String replicaBaseUrl = replica.getStr(BASE_URL_PROP);\n    +    String coreName = replica.getStr(ZkStateReader.CORE_NAME_PROP);\n    +    String backupName = TestUtil.randomSimpleString(random(), 1, 5);\n    +    String location = createTempDir().toFile().getAbsolutePath();\n    +\n    +    try (\n    +        SolrClient adminClient = getHttpSolrClient(cluster.getJettySolrRunners().get(0).getBaseUrl().toString());\n    +        SolrClient masterClient = getHttpSolrClient(replica.getCoreUrl())) {\n    +\n    +      int numTests = TestUtil.nextInt(random(), 2, 5);\n    +      List<SnapshotMetaData> snapshots = new ArrayList<>(numTests);\n    +\n    +      // Create multiple commits and create a snapshot per commit.\n    +      // This should result in Lucene reusing some of the segments for later index commits.\n    +      for (int attempt=0; attempt<numTests; attempt++) {\n    +        if (nDocs > 0) {\n    +          //Delete a few docs\n    +          int numDeletes = TestUtil.nextInt(random(), 1, nDocs);\n    +          for(int i=0; i<numDeletes; i++) \n{\n    +            masterClient.deleteByQuery(\"id:\" + i);\n    +          }\n    +        }\n    +\n    +        // Add a few more\n    +        int moreAdds = TestUtil.nextInt(random(), 1, 100);\n    +        for (int i = 0; i < moreAdds; i++) \n{\n    +          SolrInputDocument doc = new SolrInputDocument();\n    +          doc.addField(\"id\", i + nDocs);\n    +          doc.addField(\"name\", \"name = \" + (i + nDocs));\n    +          masterClient.add(doc);\n    +        }\n    +        masterClient.commit();\n    +\n    +        // Create a snapshot\n    +        snapshots.add(createSnapshot(adminClient, coreName, \"snapshot_\" + attempt));\n    +      }\n    +\n    +      // Backup the earlier created snapshot.\n    +      {\n    +        Map<String,String> params = new HashMap<>();\n    +        params.put(\"name\", backupName);\n    +        params.put(\"commitName\", snapshots.get(0).getName());\n    +        params.put(\"location\", location);\n    +        runCoreAdminCommand(replicaBaseUrl, coreName, CoreAdminAction.BACKUPCORE.toString(), params);\n    +      }\n    +\n    +      // Restore the backup. The purpose of the restore operation is to change the current index directory.\n    +      // This is required since we delegate the file deletion to underlying IndexDeletionPolicy in case of\n    +      // current index directory. Hence for the purpose of this test, we want to ensure that the created\n    +      // snapshots are NOT in the current index directory.\n    +      {\n    +        Map<String,String> params = new HashMap<>();\n    +        params.put(\"name\", \"snapshot.\" + backupName);\n    +        params.put(\"location\", location);\n    +        runCoreAdminCommand(replicaBaseUrl, coreName, CoreAdminAction.RESTORECORE.toString(), params);\n    +      }\n    +\n    +      {\n    +        List<IndexCommit> commits = listCommits(snapshots.get(0).getIndexDirPath());\n    +        // Check if number of index commits are > 0 to ensure index file sharing.\n    +        assertTrue(commits.size() > 0);\n    +        Map<String,Integer> refCounts = SolrSnapshotManager.buildRefCounts(snapshots, commits);\n    +\n    +        SnapshotMetaData snapshotMetaData = snapshots.get(0);\n    +        Optional<IndexCommit> ic = commits.stream()\n    +            .filter(entry -> entry.getGeneration() == snapshotMetaData.getGenerationNumber())\n    +            .findFirst();\n    +        assertTrue(ic.isPresent());\n    +        Collection<String> nonSharedFiles = new ArrayList<>();\n    +        Collection<String> sharedFiles = new ArrayList<>();\n    +        for (String fileName : ic.get().getFileNames()) {\n    +          if (refCounts.getOrDefault(fileName, 0) > 1) {\n    +            sharedFiles.add(fileName);\n    +          } else {\n    +            nonSharedFiles.add(fileName);\n    +          }\n    +        }\n    +\n    +        // Delete snapshot\n    +        deleteSnapshot(adminClient, coreName, snapshotMetaData.getName());\n    +\n    +        // Verify that the shared files are not deleted.\n    +        for (String fileName : sharedFiles) {\n    +          Path path = Paths.get(snapshotMetaData.getIndexDirPath(), fileName);\n    +          assertTrue(path + \" should exist.\", Files.exists(path));\n    +        }\n    +\n    +        // Verify that the non-shared files are deleted.\n    +        for (String fileName : nonSharedFiles) {\n    +          Path path = Paths.get(snapshotMetaData.getIndexDirPath(), fileName);\n    +          assertFalse(path + \" should not exist.\", Files.exists(path));\n    +        }\n    +        }\n    +      }\n    +  }\n    +\n    +  @Test\n    +  public void testIndexOptimization() throws Exception {\n    +    CloudSolrClient solrClient = cluster.getSolrClient();\n    +    String collectionName = \"SolrCoreSnapshots_IndexOptimization\";\n    +    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(collectionName, \"conf1\", 1, 1);\n    +    create.process(solrClient);\n    +\n    +    int nDocs = BackupRestoreUtils.indexDocs(cluster.getSolrClient(), collectionName, docsSeed);\n    +\n    +    DocCollection collectionState = solrClient.getZkStateReader().getClusterState().getCollection(collectionName);\n    +    assertEquals(1, collectionState.getActiveSlices().size());\n    +    Slice shard = collectionState.getActiveSlices().iterator().next();\n    +    assertEquals(1, shard.getReplicas().size());\n    +    Replica replica = shard.getReplicas().iterator().next();\n    +\n    +    String coreName = replica.getStr(ZkStateReader.CORE_NAME_PROP);\n    +    String commitName = TestUtil.randomSimpleString(random(), 1, 5);\n    +\n    +    try (\n    +        SolrClient adminClient = getHttpSolrClient(cluster.getJettySolrRunners().get(0).getBaseUrl().toString());\n    +        SolrClient masterClient = getHttpSolrClient(replica.getCoreUrl())) {\n    +\n    +      SnapshotMetaData metaData = createSnapshot(adminClient, coreName, commitName);\n    +\n    +      int numTests = nDocs > 0 ? TestUtil.nextInt(random(), 1, 5) : 1;\n    +      for (int attempt=0; attempt<numTests; attempt++) {\n    +        //Modify existing index before we call optimize.\n    +        if (nDocs > 0) {\n    +          //Delete a few docs\n    +          int numDeletes = TestUtil.nextInt(random(), 1, nDocs);\n    +          for(int i=0; i<numDeletes; i++) {\n    +            masterClient.deleteByQuery(\"id:\" + i);\n    +          }\n    +          //Add a few more\n    +          int moreAdds = TestUtil.nextInt(random(), 1, 100);\n    +          for (int i=0; i<moreAdds; i++) {\n    +            SolrInputDocument doc = new SolrInputDocument();\n    +            doc.addField(\"id\", i + nDocs);\n    +            doc.addField(\"name\", \"name = \" + (i + nDocs));\n    +            masterClient.add(doc);\n    +          }\n    +          masterClient.commit();\n    +        }\n    +      }\n    +\n    +      // Before invoking optimize command, verify that the index directory contains multiple commits (including the one we snapshotted earlier).\n    +      {\n    +        Collection<IndexCommit> commits = listCommits(metaData.getIndexDirPath());\n    +        // Verify that multiple index commits are stored in this directory.\n    +        assertTrue(commits.size() > 0);\n    +        // Verify that the snapshot commit is present in this directory.\n    +        assertTrue(commits.stream().filter(x -> x.getGeneration() == metaData.getGenerationNumber()).findFirst().isPresent());\n    +      }\n    +\n    +      // Optimize the index.\n    +      masterClient.optimize(true, true, 1);\n    +\n    +      // After invoking optimize command, verify that the index directory contains multiple commits (including the one we snapshotted earlier).\n    +      {\n    +        List<IndexCommit> commits = listCommits(metaData.getIndexDirPath());\n    +        // Verify that multiple index commits are stored in this directory.\n    +        assertTrue(commits.size() > 1);\n    +        // Verify that the snapshot commit is present in this directory.\n    +        assertTrue(commits.stream().filter(x -> x.getGeneration() == metaData.getGenerationNumber()).findFirst().isPresent());\n    +      }\n    +\n    +      // Delete the snapshot\n    +      deleteSnapshot(adminClient, coreName, metaData.getName());\n    +\n    +      // Add few documents. Without this the optimize command below does not take effect.\n    +      {\n    +        int moreAdds = TestUtil.nextInt(random(), 1, 100);\n    +        for (int i=0; i<moreAdds; i++) {    +          SolrInputDocument doc = new SolrInputDocument();    +          doc.addField(\"id\", i + nDocs);    +          doc.addField(\"name\", \"name = \" + (i + nDocs));    +          masterClient.add(doc);    +        }\n    +        masterClient.commit();\n    +      }\n    +\n    +      // Optimize the index.\n    +      masterClient.optimize(true, true, 1);\n    +\n    +      // Verify that the index directory contains only 1 index commit (which is not the same as the snapshotted commit).\n    +      Collection<IndexCommit> commits = listCommits(metaData.getIndexDirPath());\n    +      assertTrue(commits.size() == 1);\n    +      assertFalse(commits.stream().filter(x -> x.getGeneration() == metaData.getGenerationNumber()).findFirst().isPresent());\n    +    }\n    +  }\n    +\n    +  private SnapshotMetaData createSnapshot (SolrClient adminClient, String coreName, String commitName) throws Exception \n{\n    +    CreateSnapshot req = new CreateSnapshot(commitName);\n    +    req.setCoreName(coreName);\n    +    adminClient.request(req);\n    +\n    +    Collection<SnapshotMetaData> snapshots = listSnapshots(adminClient, coreName);\n    +    Optional<SnapshotMetaData> metaData = snapshots.stream().filter(x -> commitName.equals(x.getName())).findFirst();\n    +    assertTrue(metaData.isPresent());\n    +\n    +    return metaData.get();\n    +  }\n    +\n    +  private void deleteSnapshot(SolrClient adminClient, String coreName, String commitName) throws Exception \n{\n    +    DeleteSnapshot req = new DeleteSnapshot(commitName);\n    +    req.setCoreName(coreName);\n    +    adminClient.request(req);\n    +\n    +    Collection<SnapshotMetaData> snapshots = listSnapshots(adminClient, coreName);\n    +    assertFalse(snapshots.stream().filter(x -> commitName.equals(x.getName())).findFirst().isPresent());\n    +  }\n    +\n    +  private Collection<SnapshotMetaData> listSnapshots(SolrClient adminClient, String coreName) throws Exception {\n    +    ListSnapshots req = new ListSnapshots();\n    +    req.setCoreName(coreName);\n    +    NamedList resp = adminClient.request(req);\n    +    assertTrue( resp.get(\"snapshots\") instanceof NamedList );\n    +    NamedList apiResult = (NamedList) resp.get(\"snapshots\");\n    +\n    +    List<SnapshotMetaData> result = new ArrayList<>(apiResult.size());\n    +    for(int i = 0 ; i < apiResult.size(); i++) \n{\n    +      String commitName = apiResult.getName(i);\n    +      String indexDirPath = (String)((NamedList)apiResult.get(commitName)).get(\"indexDirPath\");\n    +      long genNumber = Long.valueOf((String)((NamedList)apiResult.get(commitName)).get(\"generation\"));\n    +      result.add(new SnapshotMetaData(commitName, indexDirPath, genNumber));\n    +    }\n    +    return result;\n    +  }\n    +\n    +  private List<IndexCommit> listCommits(String directory) throws Exception {\n    +    SimpleFSDirectory dir = new SimpleFSDirectory(Paths.get(directory));\n    +    try \n{\n    +      return DirectoryReader.listCommits(dir);\n    +    }\n catch (IndexNotFoundException ex) \n{\n    +      // This can happen when the delete snapshot functionality cleans up the index files (when the directory\n    +      // storing these files is not the *current* index directory).\n    +      return Collections.emptyList();\n    +    }\n    +  }\n    +\n    +  static void runCoreAdminCommand(String baseUrl, String coreName, String action, Map<String,String> params)\n    \u2014 End diff \u2013\n\n    It's a shame you need this method... you could add the convenience methods in CoreAdminRequest like there is for other stuff ",
            "id": "comment-15387963"
        },
        {
            "date": "2016-07-21T16:16:35+0000",
            "author": "David Smiley",
            "content": "Done adding comments for now.  I really like your tests. ",
            "id": "comment-15387966"
        },
        {
            "date": "2016-07-21T17:04:46+0000",
            "author": "ASF GitHub Bot",
            "content": "Github user hgadre commented on a diff in the pull request:\n\n    https://github.com/apache/lucene-solr/pull/52#discussion_r71745330\n\n    \u2014 Diff: solr/core/src/java/org/apache/solr/core/snapshots/SolrSnapshotMetaDataManager.java \u2014\n    @@ -0,0 +1,419 @@\n    +/*\n    + * Licensed to the Apache Software Foundation (ASF) under one or more\n    + * contributor license agreements.  See the NOTICE file distributed with\n    + * this work for additional information regarding copyright ownership.\n    + * The ASF licenses this file to You under the Apache License, Version 2.0\n    + * (the \"License\"); you may not use this file except in compliance with\n    + * the License.  You may obtain a copy of the License at\n    + *\n    + *     http://www.apache.org/licenses/LICENSE-2.0\n    + *\n    + * Unless required by applicable law or agreed to in writing, software\n    + * distributed under the License is distributed on an \"AS IS\" BASIS,\n    + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    + * See the License for the specific language governing permissions and\n    + * limitations under the License.\n    + */\n    +package org.apache.solr.core.snapshots;\n    +\n    +import java.io.IOException;\n    +import java.lang.invoke.MethodHandles;\n    +import java.util.ArrayList;\n    +import java.util.Collection;\n    +import java.util.Collections;\n    +import java.util.HashMap;\n    +import java.util.HashSet;\n    +import java.util.List;\n    +import java.util.Locale;\n    +import java.util.Map;\n    +import java.util.Map.Entry;\n    +import java.util.Optional;\n    +import java.util.stream.Collectors;\n    +\n    +import org.apache.lucene.codecs.CodecUtil;\n    +import org.apache.lucene.index.DirectoryReader;\n    +import org.apache.lucene.index.IndexCommit;\n    +import org.apache.lucene.index.IndexDeletionPolicy;\n    +import org.apache.lucene.index.IndexWriterConfig.OpenMode;\n    +import org.apache.lucene.store.Directory;\n    +import org.apache.lucene.store.IOContext;\n    +import org.apache.lucene.store.IndexInput;\n    +import org.apache.lucene.store.IndexOutput;\n    +import org.apache.lucene.util.IOUtils;\n    +import org.apache.solr.common.SolrException;\n    +import org.apache.solr.common.SolrException.ErrorCode;\n    +import org.apache.solr.core.DirectoryFactory;\n    +import org.apache.solr.core.IndexDeletionPolicyWrapper;\n    +import org.apache.solr.core.SolrCore;\n    +import org.apache.solr.core.DirectoryFactory.DirContext;\n    +import org.slf4j.Logger;\n    +import org.slf4j.LoggerFactory;\n    +\n    +import com.google.common.base.Preconditions;\n    +\n    +/**\n    + * This class is responsible to manage the persistent snapshots meta-data for the Solr indexes. The\n    + * persistent snapshots are implemented by relying on Lucene \n{@linkplain IndexDeletionPolicy}\n    + * abstraction to configure a specific \n{@linkplain IndexCommit} to be retained. The\n    + * {@linkplain IndexDeletionPolicyWrapper} in Solr uses this class to create/delete the Solr index\n    + * snapshots.\n    + */\n    +public class SolrSnapshotMetaDataManager {\n    +  private static final Logger log = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n    +  public static final String SNAPSHOT_METADATA_DIR = \"snapshot_metadata\";\n    +\n    +  /**\n    +   * A class defining the meta-data for a specific snapshot.\n    +   */\n    +  public static class SnapshotMetaData {\n    +    private String name;\n    +    private String indexDirPath;\n    +    private long generationNumber;\n    +\n    +    public SnapshotMetaData(String name, String indexDirPath, long generationNumber) {\n    +      super();\n    +      this.name = name;\n    +      this.indexDirPath = indexDirPath;\n    +      this.generationNumber = generationNumber;\n    +    }\n    +\n    +    public String getName() {\n    +      return name;\n    +    }\n    +\n    +    public String getIndexDirPath() {\n    +      return indexDirPath;\n    +    }\n    +\n    +    public long getGenerationNumber() {\n    +      return generationNumber;\n    +    }\n    +\n    +    @Override\n    +    public String toString() {\n    +      StringBuilder builder = new StringBuilder();\n    +      builder.append(\"SnapshotMetaData[name=\");\n    +      builder.append(name);\n    +      builder.append(\", indexDirPath=\");\n    +      builder.append(indexDirPath);\n    +      builder.append(\", generation=\");\n    +      builder.append(generationNumber);\n    +      builder.append(\"]\");\n    +      return builder.toString();\n    +    }\n    +  }\n    +\n    +  /** Prefix used for the save file. */\n    +  public static final String SNAPSHOTS_PREFIX = \"snapshots_\";\n    +  private static final int VERSION_START = 0;\n    +  private static final int VERSION_CURRENT = VERSION_START;\n    +  private static final String CODEC_NAME = \"solr-snapshots\";\n    +\n    +  // The index writer which maintains the snapshots metadata\n    +  private long nextWriteGen;\n    +\n    +  private final Directory dir;\n    +\n    +  /** Used to map snapshot name to snapshot meta-data. */\n    +  protected final Map<String,SnapshotMetaData> nameToDetailsMapping = new HashMap<>();\n    +  /** Used to figure out the current index data directory path */\n    +  private final SolrCore solrCore;\n    +\n    +  /**\n    +   * A constructor.\n    +   *\n    +   * @param dir The directory where the snapshot meta-data should be stored. Enables updating\n    +   *            the existing meta-data.\n    +   * @throws IOException in case of errors.\n    +   */\n    +  public SolrSnapshotMetaDataManager(SolrCore solrCore, Directory dir) throws IOException {\n    +    this(solrCore, dir, OpenMode.CREATE_OR_APPEND);\n    +  }\n    +\n    +  /**\n    +   * A constructor.\n    +   *\n    +   * @param dir The directory where the snapshot meta-data is stored.\n    +   * @param mode CREATE If previous meta-data should be erased.\n    +   *             APPEND If previous meta-data should be read and updated.\n    +   *             CREATE_OR_APPEND Creates a new meta-data structure if one does not exist\n    +   *                              Updates the existing structure if one exists.\n    +   * @throws IOException in case of errors.\n    +   */\n    +  public SolrSnapshotMetaDataManager(SolrCore solrCore, Directory dir, OpenMode mode) throws IOException {\n    +    this.solrCore = solrCore;\n    +    this.dir = dir;\n    +\n    +    if (mode == OpenMode.CREATE) {\n    +      deleteSnapshotMetadataFiles();\n    +    }\n    +\n    +    loadFromSnapshotMetadataFile();\n    +\n    +    if (mode == OpenMode.APPEND && nextWriteGen == 0) {\n    +      throw new IllegalStateException(\"no snapshots stored in this directory\");\n    +    }\n    +  }\n    +\n    +  /**\n    +   * @return The snapshot meta-data directory\n    +   */\n    +  public Directory getSnapshotsDir() {\n    +    return dir;\n    +  }\n    +\n    +  /**\n    +   * This method creates a new snapshot meta-data entry.\n    +   *\n    +   * @param name The name of the snapshot.\n    +   * @param indexDirPath The directory path where the index files are stored.\n    +   * @param gen The generation number for the {@linkplain IndexCommit}\n being snapshotted.\n    +   * @throws IOException in case of I/O errors.\n    +   */\n    +  public synchronized void snapshot(String name, String indexDirPath, long gen) throws IOException {\n    +    Preconditions.checkNotNull(name);\n    +\n    +    log.info(\"Creating the snapshot named {} for core {} associated with index commit with generation {} in directory {}\"\n    +        , name, solrCore.getName(), gen, indexDirPath);\n    +\n    +    if(nameToDetailsMapping.containsKey(name)) \n{\n    +      throw new SolrException(ErrorCode.BAD_REQUEST, \"A snapshot with name \" + name + \" already exists\");\n    +    }\n    +\n    +    SnapshotMetaData d = new SnapshotMetaData(name, indexDirPath, gen);\n    +    nameToDetailsMapping.put(name, d);\n    +\n    +    boolean success = false;\n    +    try \n{\n    +      persist();\n    +      success = true;\n    +    }\n finally {\n    +      if (!success) {\n    +        try \n{\n    +          release(name);\n    +        }\n catch (Exception e) \n{\n    +          // Suppress so we keep throwing original exception\n    +        }\n    +      }\n    +    }\n    +  }\n    +\n    +  /**\n    +   * This method deletes a previously created snapshot (if any).\n    +   *\n    +   * @param name The name of the snapshot to be deleted.\n    +   * @return The snapshot meta-data if the snapshot with the snapshot name exists.\n    +   * @throws IOException in case of I/O error\n    +   */\n    +  public synchronized Optional<SnapshotMetaData> release(String name) throws IOException {\n    +    log.info(\"Deleting the snapshot named {} for core {}\", name, solrCore.getName());\n    +    SnapshotMetaData result = nameToDetailsMapping.remove(Preconditions.checkNotNull(name));\n    +    if(result != null) {\n    +      boolean success = false;\n    +      try \n{\n    +        persist();\n    +        success = true;\n    +      }\n finally {\n    +        if (!success) \n{\n    +          nameToDetailsMapping.put(name, result);\n    +        }\n    +      }\n    +    }\n    +    return Optional.ofNullable(result);\n    +  }\n    +\n    +  /**\n    +   * This method returns if snapshot is created for the specified generation number in\n    +   * the current index directory.\n    +   *\n    +   * @param genNumber The generation number for the \n{@linkplain IndexCommit} to be checked.\n    +   * @return true if the snapshot is created.\n    +   *         false otherwise.\n    +   */\n    +  public synchronized boolean isSnapshotted(long genNumber) {\n    +    return isSnapshotted(solrCore.getIndexDir(), genNumber);\n    +  }\n    +\n    +  /**\n    +   * This method returns if snapshot is created for the specified generation number in\n    +   * the specified index directory.\n    +   *\n    +   * @param genNumber The generation number for the {@linkplain IndexCommit}\n to be checked.\n    +   * @return true if the snapshot is created.\n    +   *         false otherwise.\n    +   */\n    +  public synchronized boolean isSnapshotted(String indexDirPath, long genNumber) {\n    +    return nameToDetailsMapping.values().stream()\n    +        .filter(entry -> entry.getIndexDirPath().equals(indexDirPath) && entry.getGenerationNumber() == genNumber)\n    \u2014 End diff \u2013\n\n    Done. ",
            "id": "comment-15388044"
        },
        {
            "date": "2016-07-21T17:05:52+0000",
            "author": "ASF GitHub Bot",
            "content": "Github user hgadre commented on a diff in the pull request:\n\n    https://github.com/apache/lucene-solr/pull/52#discussion_r71745546\n\n    \u2014 Diff: solr/core/src/java/org/apache/solr/core/snapshots/SolrSnapshotMetaDataManager.java \u2014\n    @@ -0,0 +1,419 @@\n    +/*\n    + * Licensed to the Apache Software Foundation (ASF) under one or more\n    + * contributor license agreements.  See the NOTICE file distributed with\n    + * this work for additional information regarding copyright ownership.\n    + * The ASF licenses this file to You under the Apache License, Version 2.0\n    + * (the \"License\"); you may not use this file except in compliance with\n    + * the License.  You may obtain a copy of the License at\n    + *\n    + *     http://www.apache.org/licenses/LICENSE-2.0\n    + *\n    + * Unless required by applicable law or agreed to in writing, software\n    + * distributed under the License is distributed on an \"AS IS\" BASIS,\n    + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    + * See the License for the specific language governing permissions and\n    + * limitations under the License.\n    + */\n    +package org.apache.solr.core.snapshots;\n    +\n    +import java.io.IOException;\n    +import java.lang.invoke.MethodHandles;\n    +import java.util.ArrayList;\n    +import java.util.Collection;\n    +import java.util.Collections;\n    +import java.util.HashMap;\n    +import java.util.HashSet;\n    +import java.util.List;\n    +import java.util.Locale;\n    +import java.util.Map;\n    +import java.util.Map.Entry;\n    +import java.util.Optional;\n    +import java.util.stream.Collectors;\n    +\n    +import org.apache.lucene.codecs.CodecUtil;\n    +import org.apache.lucene.index.DirectoryReader;\n    +import org.apache.lucene.index.IndexCommit;\n    +import org.apache.lucene.index.IndexDeletionPolicy;\n    +import org.apache.lucene.index.IndexWriterConfig.OpenMode;\n    +import org.apache.lucene.store.Directory;\n    +import org.apache.lucene.store.IOContext;\n    +import org.apache.lucene.store.IndexInput;\n    +import org.apache.lucene.store.IndexOutput;\n    +import org.apache.lucene.util.IOUtils;\n    +import org.apache.solr.common.SolrException;\n    +import org.apache.solr.common.SolrException.ErrorCode;\n    +import org.apache.solr.core.DirectoryFactory;\n    +import org.apache.solr.core.IndexDeletionPolicyWrapper;\n    +import org.apache.solr.core.SolrCore;\n    +import org.apache.solr.core.DirectoryFactory.DirContext;\n    +import org.slf4j.Logger;\n    +import org.slf4j.LoggerFactory;\n    +\n    +import com.google.common.base.Preconditions;\n    +\n    +/**\n    + * This class is responsible to manage the persistent snapshots meta-data for the Solr indexes. The\n    + * persistent snapshots are implemented by relying on Lucene \n{@linkplain IndexDeletionPolicy}\n    + * abstraction to configure a specific \n{@linkplain IndexCommit} to be retained. The\n    + * {@linkplain IndexDeletionPolicyWrapper} in Solr uses this class to create/delete the Solr index\n    + * snapshots.\n    + */\n    +public class SolrSnapshotMetaDataManager {\n    +  private static final Logger log = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n    +  public static final String SNAPSHOT_METADATA_DIR = \"snapshot_metadata\";\n    +\n    +  /**\n    +   * A class defining the meta-data for a specific snapshot.\n    +   */\n    +  public static class SnapshotMetaData {\n    +    private String name;\n    +    private String indexDirPath;\n    +    private long generationNumber;\n    +\n    +    public SnapshotMetaData(String name, String indexDirPath, long generationNumber) {\n    +      super();\n    +      this.name = name;\n    +      this.indexDirPath = indexDirPath;\n    +      this.generationNumber = generationNumber;\n    +    }\n    +\n    +    public String getName() {\n    +      return name;\n    +    }\n    +\n    +    public String getIndexDirPath() {\n    +      return indexDirPath;\n    +    }\n    +\n    +    public long getGenerationNumber() {\n    +      return generationNumber;\n    +    }\n    +\n    +    @Override\n    +    public String toString() {\n    +      StringBuilder builder = new StringBuilder();\n    +      builder.append(\"SnapshotMetaData[name=\");\n    +      builder.append(name);\n    +      builder.append(\", indexDirPath=\");\n    +      builder.append(indexDirPath);\n    +      builder.append(\", generation=\");\n    +      builder.append(generationNumber);\n    +      builder.append(\"]\");\n    +      return builder.toString();\n    +    }\n    +  }\n    +\n    +  /** Prefix used for the save file. */\n    +  public static final String SNAPSHOTS_PREFIX = \"snapshots_\";\n    +  private static final int VERSION_START = 0;\n    +  private static final int VERSION_CURRENT = VERSION_START;\n    +  private static final String CODEC_NAME = \"solr-snapshots\";\n    +\n    +  // The index writer which maintains the snapshots metadata\n    +  private long nextWriteGen;\n    +\n    +  private final Directory dir;\n    +\n    +  /** Used to map snapshot name to snapshot meta-data. */\n    +  protected final Map<String,SnapshotMetaData> nameToDetailsMapping = new HashMap<>();\n    +  /** Used to figure out the current index data directory path */\n    +  private final SolrCore solrCore;\n    +\n    +  /**\n    +   * A constructor.\n    +   *\n    +   * @param dir The directory where the snapshot meta-data should be stored. Enables updating\n    +   *            the existing meta-data.\n    +   * @throws IOException in case of errors.\n    +   */\n    +  public SolrSnapshotMetaDataManager(SolrCore solrCore, Directory dir) throws IOException {\n    +    this(solrCore, dir, OpenMode.CREATE_OR_APPEND);\n    +  }\n    +\n    +  /**\n    +   * A constructor.\n    +   *\n    +   * @param dir The directory where the snapshot meta-data is stored.\n    +   * @param mode CREATE If previous meta-data should be erased.\n    +   *             APPEND If previous meta-data should be read and updated.\n    +   *             CREATE_OR_APPEND Creates a new meta-data structure if one does not exist\n    +   *                              Updates the existing structure if one exists.\n    +   * @throws IOException in case of errors.\n    +   */\n    +  public SolrSnapshotMetaDataManager(SolrCore solrCore, Directory dir, OpenMode mode) throws IOException {\n    +    this.solrCore = solrCore;\n    +    this.dir = dir;\n    +\n    +    if (mode == OpenMode.CREATE) {\n    +      deleteSnapshotMetadataFiles();\n    +    }\n    +\n    +    loadFromSnapshotMetadataFile();\n    +\n    +    if (mode == OpenMode.APPEND && nextWriteGen == 0) {\n    +      throw new IllegalStateException(\"no snapshots stored in this directory\");\n    +    }\n    +  }\n    +\n    +  /**\n    +   * @return The snapshot meta-data directory\n    +   */\n    +  public Directory getSnapshotsDir() {\n    +    return dir;\n    +  }\n    +\n    +  /**\n    +   * This method creates a new snapshot meta-data entry.\n    +   *\n    +   * @param name The name of the snapshot.\n    +   * @param indexDirPath The directory path where the index files are stored.\n    +   * @param gen The generation number for the {@linkplain IndexCommit}\n being snapshotted.\n    +   * @throws IOException in case of I/O errors.\n    +   */\n    +  public synchronized void snapshot(String name, String indexDirPath, long gen) throws IOException {\n    +    Preconditions.checkNotNull(name);\n    +\n    +    log.info(\"Creating the snapshot named {} for core {} associated with index commit with generation {} in directory {}\"\n    +        , name, solrCore.getName(), gen, indexDirPath);\n    +\n    +    if(nameToDetailsMapping.containsKey(name)) \n{\n    +      throw new SolrException(ErrorCode.BAD_REQUEST, \"A snapshot with name \" + name + \" already exists\");\n    +    }\n    +\n    +    SnapshotMetaData d = new SnapshotMetaData(name, indexDirPath, gen);\n    +    nameToDetailsMapping.put(name, d);\n    +\n    +    boolean success = false;\n    +    try \n{\n    +      persist();\n    +      success = true;\n    +    }\n finally {\n    +      if (!success) {\n    +        try \n{\n    +          release(name);\n    +        }\n catch (Exception e) \n{\n    +          // Suppress so we keep throwing original exception\n    +        }\n    +      }\n    +    }\n    +  }\n    +\n    +  /**\n    +   * This method deletes a previously created snapshot (if any).\n    +   *\n    +   * @param name The name of the snapshot to be deleted.\n    +   * @return The snapshot meta-data if the snapshot with the snapshot name exists.\n    +   * @throws IOException in case of I/O error\n    +   */\n    +  public synchronized Optional<SnapshotMetaData> release(String name) throws IOException {\n    +    log.info(\"Deleting the snapshot named {} for core {}\", name, solrCore.getName());\n    +    SnapshotMetaData result = nameToDetailsMapping.remove(Preconditions.checkNotNull(name));\n    +    if(result != null) {\n    +      boolean success = false;\n    +      try \n{\n    +        persist();\n    +        success = true;\n    +      }\n finally {\n    +        if (!success) \n{\n    +          nameToDetailsMapping.put(name, result);\n    +        }\n    +      }\n    +    }\n    +    return Optional.ofNullable(result);\n    +  }\n    +\n    +  /**\n    +   * This method returns if snapshot is created for the specified generation number in\n    +   * the current index directory.\n    +   *\n    +   * @param genNumber The generation number for the \n{@linkplain IndexCommit} to be checked.\n    +   * @return true if the snapshot is created.\n    +   *         false otherwise.\n    +   */\n    +  public synchronized boolean isSnapshotted(long genNumber) {\n    +    return isSnapshotted(solrCore.getIndexDir(), genNumber);\n    +  }\n    +\n    +  /**\n    +   * This method returns if snapshot is created for the specified generation number in\n    +   * the specified index directory.\n    +   *\n    +   * @param genNumber The generation number for the {@linkplain IndexCommit}\n to be checked.\n    +   * @return true if the snapshot is created.\n    +   *         false otherwise.\n    +   */\n    +  public synchronized boolean isSnapshotted(String indexDirPath, long genNumber) \n{\n    +    return nameToDetailsMapping.values().stream()\n    +        .filter(entry -> entry.getIndexDirPath().equals(indexDirPath) && entry.getGenerationNumber() == genNumber)\n    +        .findFirst()\n    +        .isPresent();\n    +  }\n    +\n    +  /**\n    +   * This method returns the snapshot meta-data for the specified name (if it exists).\n    +   *\n    +   * @param name The name of the snapshot\n    +   * @return The snapshot meta-data if exists.\n    +   */\n    +  public synchronized Optional<SnapshotMetaData> getSnapshotMetaData(String name) \n{\n    +    return Optional.ofNullable(nameToDetailsMapping.get(name));\n    +  }\n    +\n    +  /**\n    +   * @return A list of snapshots created so far.\n    +   */\n    +  public synchronized Collection<String> listSnapshots() \n{\n    +    return new HashSet<>(nameToDetailsMapping.keySet());\n    +  }\n    +\n    +  /**\n    +   * This method returns a list of snapshots created in a specified index directory.\n    +   *\n    +   * @param indexDirPath The index directory path.\n    +   * @return a list snapshots stored in the specified directory.\n    +   */\n    +  public synchronized Collection<SnapshotMetaData> listSnapshotsInIndexDir(String indexDirPath) {\n    +    return nameToDetailsMapping.entrySet().stream()\n    \u2014 End diff \u2013\n\n    Done. ",
            "id": "comment-15388048"
        },
        {
            "date": "2016-07-21T17:06:20+0000",
            "author": "ASF GitHub Bot",
            "content": "Github user hgadre commented on a diff in the pull request:\n\n    https://github.com/apache/lucene-solr/pull/52#discussion_r71745628\n\n    \u2014 Diff: solr/core/src/java/org/apache/solr/core/snapshots/SolrSnapshotMetaDataManager.java \u2014\n    @@ -0,0 +1,419 @@\n    +/*\n    + * Licensed to the Apache Software Foundation (ASF) under one or more\n    + * contributor license agreements.  See the NOTICE file distributed with\n    + * this work for additional information regarding copyright ownership.\n    + * The ASF licenses this file to You under the Apache License, Version 2.0\n    + * (the \"License\"); you may not use this file except in compliance with\n    + * the License.  You may obtain a copy of the License at\n    + *\n    + *     http://www.apache.org/licenses/LICENSE-2.0\n    + *\n    + * Unless required by applicable law or agreed to in writing, software\n    + * distributed under the License is distributed on an \"AS IS\" BASIS,\n    + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    + * See the License for the specific language governing permissions and\n    + * limitations under the License.\n    + */\n    +package org.apache.solr.core.snapshots;\n    +\n    +import java.io.IOException;\n    +import java.lang.invoke.MethodHandles;\n    +import java.util.ArrayList;\n    +import java.util.Collection;\n    +import java.util.Collections;\n    +import java.util.HashMap;\n    +import java.util.HashSet;\n    +import java.util.List;\n    +import java.util.Locale;\n    +import java.util.Map;\n    +import java.util.Map.Entry;\n    +import java.util.Optional;\n    +import java.util.stream.Collectors;\n    +\n    +import org.apache.lucene.codecs.CodecUtil;\n    +import org.apache.lucene.index.DirectoryReader;\n    +import org.apache.lucene.index.IndexCommit;\n    +import org.apache.lucene.index.IndexDeletionPolicy;\n    +import org.apache.lucene.index.IndexWriterConfig.OpenMode;\n    +import org.apache.lucene.store.Directory;\n    +import org.apache.lucene.store.IOContext;\n    +import org.apache.lucene.store.IndexInput;\n    +import org.apache.lucene.store.IndexOutput;\n    +import org.apache.lucene.util.IOUtils;\n    +import org.apache.solr.common.SolrException;\n    +import org.apache.solr.common.SolrException.ErrorCode;\n    +import org.apache.solr.core.DirectoryFactory;\n    +import org.apache.solr.core.IndexDeletionPolicyWrapper;\n    +import org.apache.solr.core.SolrCore;\n    +import org.apache.solr.core.DirectoryFactory.DirContext;\n    +import org.slf4j.Logger;\n    +import org.slf4j.LoggerFactory;\n    +\n    +import com.google.common.base.Preconditions;\n    +\n    +/**\n    + * This class is responsible to manage the persistent snapshots meta-data for the Solr indexes. The\n    + * persistent snapshots are implemented by relying on Lucene \n{@linkplain IndexDeletionPolicy}\n    + * abstraction to configure a specific \n{@linkplain IndexCommit} to be retained. The\n    + * {@linkplain IndexDeletionPolicyWrapper} in Solr uses this class to create/delete the Solr index\n    + * snapshots.\n    + */\n    +public class SolrSnapshotMetaDataManager {\n    +  private static final Logger log = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n    +  public static final String SNAPSHOT_METADATA_DIR = \"snapshot_metadata\";\n    +\n    +  /**\n    +   * A class defining the meta-data for a specific snapshot.\n    +   */\n    +  public static class SnapshotMetaData {\n    +    private String name;\n    +    private String indexDirPath;\n    +    private long generationNumber;\n    +\n    +    public SnapshotMetaData(String name, String indexDirPath, long generationNumber) {\n    +      super();\n    +      this.name = name;\n    +      this.indexDirPath = indexDirPath;\n    +      this.generationNumber = generationNumber;\n    +    }\n    +\n    +    public String getName() {\n    +      return name;\n    +    }\n    +\n    +    public String getIndexDirPath() {\n    +      return indexDirPath;\n    +    }\n    +\n    +    public long getGenerationNumber() {\n    +      return generationNumber;\n    +    }\n    +\n    +    @Override\n    +    public String toString() {\n    +      StringBuilder builder = new StringBuilder();\n    +      builder.append(\"SnapshotMetaData[name=\");\n    +      builder.append(name);\n    +      builder.append(\", indexDirPath=\");\n    +      builder.append(indexDirPath);\n    +      builder.append(\", generation=\");\n    +      builder.append(generationNumber);\n    +      builder.append(\"]\");\n    +      return builder.toString();\n    +    }\n    +  }\n    +\n    +  /** Prefix used for the save file. */\n    +  public static final String SNAPSHOTS_PREFIX = \"snapshots_\";\n    +  private static final int VERSION_START = 0;\n    +  private static final int VERSION_CURRENT = VERSION_START;\n    +  private static final String CODEC_NAME = \"solr-snapshots\";\n    +\n    +  // The index writer which maintains the snapshots metadata\n    +  private long nextWriteGen;\n    +\n    +  private final Directory dir;\n    +\n    +  /** Used to map snapshot name to snapshot meta-data. */\n    +  protected final Map<String,SnapshotMetaData> nameToDetailsMapping = new HashMap<>();\n    +  /** Used to figure out the current index data directory path */\n    +  private final SolrCore solrCore;\n    +\n    +  /**\n    +   * A constructor.\n    +   *\n    +   * @param dir The directory where the snapshot meta-data should be stored. Enables updating\n    +   *            the existing meta-data.\n    +   * @throws IOException in case of errors.\n    +   */\n    +  public SolrSnapshotMetaDataManager(SolrCore solrCore, Directory dir) throws IOException {\n    +    this(solrCore, dir, OpenMode.CREATE_OR_APPEND);\n    +  }\n    +\n    +  /**\n    +   * A constructor.\n    +   *\n    +   * @param dir The directory where the snapshot meta-data is stored.\n    +   * @param mode CREATE If previous meta-data should be erased.\n    +   *             APPEND If previous meta-data should be read and updated.\n    +   *             CREATE_OR_APPEND Creates a new meta-data structure if one does not exist\n    +   *                              Updates the existing structure if one exists.\n    +   * @throws IOException in case of errors.\n    +   */\n    +  public SolrSnapshotMetaDataManager(SolrCore solrCore, Directory dir, OpenMode mode) throws IOException {\n    +    this.solrCore = solrCore;\n    +    this.dir = dir;\n    +\n    +    if (mode == OpenMode.CREATE) {\n    +      deleteSnapshotMetadataFiles();\n    +    }\n    +\n    +    loadFromSnapshotMetadataFile();\n    +\n    +    if (mode == OpenMode.APPEND && nextWriteGen == 0) {\n    +      throw new IllegalStateException(\"no snapshots stored in this directory\");\n    +    }\n    +  }\n    +\n    +  /**\n    +   * @return The snapshot meta-data directory\n    +   */\n    +  public Directory getSnapshotsDir() {\n    +    return dir;\n    +  }\n    +\n    +  /**\n    +   * This method creates a new snapshot meta-data entry.\n    +   *\n    +   * @param name The name of the snapshot.\n    +   * @param indexDirPath The directory path where the index files are stored.\n    +   * @param gen The generation number for the {@linkplain IndexCommit}\n being snapshotted.\n    +   * @throws IOException in case of I/O errors.\n    +   */\n    +  public synchronized void snapshot(String name, String indexDirPath, long gen) throws IOException {\n    +    Preconditions.checkNotNull(name);\n    +\n    +    log.info(\"Creating the snapshot named {} for core {} associated with index commit with generation {} in directory {}\"\n    +        , name, solrCore.getName(), gen, indexDirPath);\n    +\n    +    if(nameToDetailsMapping.containsKey(name)) \n{\n    +      throw new SolrException(ErrorCode.BAD_REQUEST, \"A snapshot with name \" + name + \" already exists\");\n    +    }\n    +\n    +    SnapshotMetaData d = new SnapshotMetaData(name, indexDirPath, gen);\n    +    nameToDetailsMapping.put(name, d);\n    +\n    +    boolean success = false;\n    +    try \n{\n    +      persist();\n    +      success = true;\n    +    }\n finally {\n    +      if (!success) {\n    +        try \n{\n    +          release(name);\n    +        }\n catch (Exception e) \n{\n    +          // Suppress so we keep throwing original exception\n    +        }\n    +      }\n    +    }\n    +  }\n    +\n    +  /**\n    +   * This method deletes a previously created snapshot (if any).\n    +   *\n    +   * @param name The name of the snapshot to be deleted.\n    +   * @return The snapshot meta-data if the snapshot with the snapshot name exists.\n    +   * @throws IOException in case of I/O error\n    +   */\n    +  public synchronized Optional<SnapshotMetaData> release(String name) throws IOException {\n    +    log.info(\"Deleting the snapshot named {} for core {}\", name, solrCore.getName());\n    +    SnapshotMetaData result = nameToDetailsMapping.remove(Preconditions.checkNotNull(name));\n    +    if(result != null) {\n    +      boolean success = false;\n    +      try \n{\n    +        persist();\n    +        success = true;\n    +      }\n finally {\n    +        if (!success) \n{\n    +          nameToDetailsMapping.put(name, result);\n    +        }\n    +      }\n    +    }\n    +    return Optional.ofNullable(result);\n    +  }\n    +\n    +  /**\n    +   * This method returns if snapshot is created for the specified generation number in\n    +   * the current index directory.\n    +   *\n    +   * @param genNumber The generation number for the \n{@linkplain IndexCommit} to be checked.\n    +   * @return true if the snapshot is created.\n    +   *         false otherwise.\n    +   */\n    +  public synchronized boolean isSnapshotted(long genNumber) {\n    +    return isSnapshotted(solrCore.getIndexDir(), genNumber);\n    +  }\n    +\n    +  /**\n    +   * This method returns if snapshot is created for the specified generation number in\n    +   * the specified index directory.\n    +   *\n    +   * @param genNumber The generation number for the {@linkplain IndexCommit}\n to be checked.\n    +   * @return true if the snapshot is created.\n    +   *         false otherwise.\n    +   */\n    +  public synchronized boolean isSnapshotted(String indexDirPath, long genNumber) \n{\n    +    return nameToDetailsMapping.values().stream()\n    +        .filter(entry -> entry.getIndexDirPath().equals(indexDirPath) && entry.getGenerationNumber() == genNumber)\n    +        .findFirst()\n    +        .isPresent();\n    +  }\n    +\n    +  /**\n    +   * This method returns the snapshot meta-data for the specified name (if it exists).\n    +   *\n    +   * @param name The name of the snapshot\n    +   * @return The snapshot meta-data if exists.\n    +   */\n    +  public synchronized Optional<SnapshotMetaData> getSnapshotMetaData(String name) \n{\n    +    return Optional.ofNullable(nameToDetailsMapping.get(name));\n    +  }\n    +\n    +  /**\n    +   * @return A list of snapshots created so far.\n    +   */\n    +  public synchronized Collection<String> listSnapshots() \n{\n    +    return new HashSet<>(nameToDetailsMapping.keySet());\n    +  }\n    +\n    +  /**\n    +   * This method returns a list of snapshots created in a specified index directory.\n    +   *\n    +   * @param indexDirPath The index directory path.\n    +   * @return a list snapshots stored in the specified directory.\n    +   */\n    +  public synchronized Collection<SnapshotMetaData> listSnapshotsInIndexDir(String indexDirPath) \n{\n    +    return nameToDetailsMapping.entrySet().stream()\n    +        .filter(entry -> indexDirPath.equals(entry.getValue().getIndexDirPath()))\n    +        .map(entry -> entry.getValue())\n    +        .collect(Collectors.toList());\n    +  }\n    +\n    +  /**\n    +   * This method returns the \n{@linkplain IndexCommit} associated with the specified\n    +   * <code>commitName</code>. A snapshot with specified <code>commitName</code> must\n    +   * be created before invoking this method.\n    +   *\n    +   * @param commitName The name of persisted commit\n    +   * @return the {@linkplain IndexCommit}\n    +   * @throws IOException in case of I/O error.\n    +   */\n    +  public Optional<IndexCommit> getIndexCommitByName(String commitName) throws IOException {\n    +    Optional<IndexCommit> result = Optional.empty();\n    +    Optional<SnapshotMetaData> metaData = getSnapshotMetaData(commitName);\n    +    if (metaData.isPresent()) {\n    +      String indexDirPath = metaData.get().getIndexDirPath();\n    +      long gen = metaData.get().getGenerationNumber();\n    +\n    +      Directory d = solrCore.getDirectoryFactory().get(indexDirPath, DirContext.DEFAULT, DirectoryFactory.LOCK_TYPE_NONE);\n    +      try {\n    +        result = DirectoryReader.listCommits(d)\n    +                                .stream()\n    +                                .filter(ic -> ic.getGeneration() == gen)\n    +                                .findAny();\n    +\n    +        if (!result.isPresent()) {\n    +          log.warn(\"Unable to find commit with generation {} in the directory {}\", gen, indexDirPath);\n    +        }\n    +\n    +      } finally \n{\n    +        solrCore.getDirectoryFactory().release(d);\n    +      }\n    +    } else {\n    +      log.warn(\"Commit with name {} is not persisted for core {}\", commitName, solrCore.getName());\n    +    }\n    +\n    +    return result;\n    +  }\n    +\n    +  synchronized private void persist() throws IOException {\n    \u2014 End diff \u2013\n\n    Done. ",
            "id": "comment-15388050"
        },
        {
            "date": "2016-07-21T17:09:26+0000",
            "author": "ASF GitHub Bot",
            "content": "Github user hgadre commented on a diff in the pull request:\n\n    https://github.com/apache/lucene-solr/pull/52#discussion_r71746146\n\n    \u2014 Diff: solr/core/src/java/org/apache/solr/handler/ReplicationHandler.java \u2014\n    @@ -512,11 +513,24 @@ private void doSnapShoot(SolrParams params, SolrQueryResponse rsp,\n             numberToKeep = Integer.MAX_VALUE;\n           }\n\n\n\tIndexDeletionPolicyWrapper delPolicy = core.getDeletionPolicy();\n\tIndexCommit indexCommit = delPolicy.getLatestCommit();\n    +      IndexCommit indexCommit = null;\n    +      String commitName = params.get(CoreAdminParams.COMMIT_NAME);\n    +      if (commitName != null) {\n    +        SolrSnapshotMetaDataManager snapshotMgr = core.getSnapshotMetaDataManager();\n    +        Optional<IndexCommit> commit = snapshotMgr.getIndexCommitByName(commitName);\n    +        if(commit.isPresent()) \n{\n    +          indexCommit = commit.get();\n    +        }\n else {\n    +          throw new SolrException(ErrorCode.SERVER_ERROR, \"Unable to find an index commit with name \" + commitName +\n\t\n\t\t\n\t\t\n\t\t\tEnd diff \u2013\n\t\t\n\t\t\n\t\n\t\n\n\n\n    Done. ",
            "id": "comment-15388057"
        },
        {
            "date": "2016-07-21T17:18:33+0000",
            "author": "ASF GitHub Bot",
            "content": "Github user hgadre commented on a diff in the pull request:\n\n    https://github.com/apache/lucene-solr/pull/52#discussion_r71747583\n\n    \u2014 Diff: solr/core/src/java/org/apache/solr/handler/admin/CoreAdminOperation.java \u2014\n    @@ -919,7 +928,93 @@ public void call(CallInfo callInfo) throws Exception {\n             }\n           }\n         }\n    +  },\n    +  CREATESNAPSHOT_OP(CREATESNAPSHOT) {\n    +    @Override\n    +    public void call(CallInfo callInfo) throws Exception {\n    +      CoreContainer cc = callInfo.handler.getCoreContainer();\n    +      final SolrParams params = callInfo.req.getParams();\n    +\n    +      String commitName = params.required().get(CoreAdminParams.COMMIT_NAME);\n    +      String cname = params.required().get(CoreAdminParams.CORE);\n    +      try (SolrCore core = cc.getCore(cname)) {\n    +        if (core == null) \n{\n    +          throw new SolrException(ErrorCode.SERVER_ERROR, \"Unable to locate core \" + cname);\n    +        }\n    +        if (core.getDeletionPolicy().getLatestCommit() == null) {\n    \u2014 End diff \u2013\n\n    I see that ReplicationHandler is implemented differently. If the latestCommit is null, it uses the commit opened by the index searcher. Now I am using the same logic here, assuming the index searcher will always return non-null index commit.  ",
            "id": "comment-15388066"
        },
        {
            "date": "2016-07-21T17:22:04+0000",
            "author": "ASF GitHub Bot",
            "content": "Github user hgadre commented on a diff in the pull request:\n\n    https://github.com/apache/lucene-solr/pull/52#discussion_r71748142\n\n    \u2014 Diff: solr/core/src/java/org/apache/solr/handler/admin/CoreAdminOperation.java \u2014\n    @@ -919,7 +928,93 @@ public void call(CallInfo callInfo) throws Exception {\n             }\n           }\n         }\n    +  },\n    +  CREATESNAPSHOT_OP(CREATESNAPSHOT) {\n    +    @Override\n    +    public void call(CallInfo callInfo) throws Exception {\n    +      CoreContainer cc = callInfo.handler.getCoreContainer();\n    +      final SolrParams params = callInfo.req.getParams();\n    +\n    +      String commitName = params.required().get(CoreAdminParams.COMMIT_NAME);\n    +      String cname = params.required().get(CoreAdminParams.CORE);\n    +      try (SolrCore core = cc.getCore(cname)) {\n    +        if (core == null) \n{\n    +          throw new SolrException(ErrorCode.SERVER_ERROR, \"Unable to locate core \" + cname);\n    +        }\n    +        if (core.getDeletionPolicy().getLatestCommit() == null) {\n    +          throw new SolrException(ErrorCode.SERVER_ERROR, \"Could not find latest commit. Please ensure to execute a hard commit\");\n    +        }\n    +\n    +        String indexDirPath = core.getIndexDir();\n    +        IndexCommit ic = core.getDeletionPolicy().getLatestCommit();\n    +        SolrSnapshotMetaDataManager mgr = core.getSnapshotMetaDataManager();\n    +        mgr.snapshot(commitName, indexDirPath, ic.getGeneration());\n    +      }\n    +    }\n    +  },\n    +  DELETESNAPSHOT_OP(DELETESNAPSHOT) {\n    +    @Override\n    +    public void call(CallInfo callInfo) throws Exception {\n    +      CoreContainer cc = callInfo.handler.getCoreContainer();\n    +      final SolrParams params = callInfo.req.getParams();\n    +\n    +      String commitName = params.required().get(CoreAdminParams.COMMIT_NAME);\n    +      String cname = params.required().get(CoreAdminParams.CORE);\n    +      try (SolrCore core = cc.getCore(cname)) {\n    +        if (core == null) {    +          throw new SolrException(ErrorCode.SERVER_ERROR, \"Unable to locate core \" + cname);    +        }\n    +\n    +        SolrSnapshotMetaDataManager mgr = core.getSnapshotMetaDataManager();\n    +        Optional<SnapshotMetaData> metadata = mgr.release(commitName);\n    +        if (metadata.isPresent()) {\n    \u2014 End diff \u2013\n\n    OK I am using BAD_REQUEST for parameter related errors. I don't think we should throw error if the commit is not found since this is in-line with the user expectation (which is Solr should not have a snapshot with the specified name). ",
            "id": "comment-15388071"
        },
        {
            "date": "2016-07-21T17:23:38+0000",
            "author": "ASF GitHub Bot",
            "content": "Github user hgadre commented on a diff in the pull request:\n\n    https://github.com/apache/lucene-solr/pull/52#discussion_r71748418\n\n    \u2014 Diff: solr/core/src/java/org/apache/solr/core/snapshots/SolrSnapshotMetaDataManager.java \u2014\n    @@ -0,0 +1,419 @@\n    +/*\n    + * Licensed to the Apache Software Foundation (ASF) under one or more\n    + * contributor license agreements.  See the NOTICE file distributed with\n    + * this work for additional information regarding copyright ownership.\n    + * The ASF licenses this file to You under the Apache License, Version 2.0\n    + * (the \"License\"); you may not use this file except in compliance with\n    + * the License.  You may obtain a copy of the License at\n    + *\n    + *     http://www.apache.org/licenses/LICENSE-2.0\n    + *\n    + * Unless required by applicable law or agreed to in writing, software\n    + * distributed under the License is distributed on an \"AS IS\" BASIS,\n    + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    + * See the License for the specific language governing permissions and\n    + * limitations under the License.\n    + */\n    +package org.apache.solr.core.snapshots;\n    +\n    +import java.io.IOException;\n    +import java.lang.invoke.MethodHandles;\n    +import java.util.ArrayList;\n    +import java.util.Collection;\n    +import java.util.Collections;\n    +import java.util.HashMap;\n    +import java.util.HashSet;\n    +import java.util.List;\n    +import java.util.Locale;\n    +import java.util.Map;\n    +import java.util.Map.Entry;\n    +import java.util.Optional;\n    +import java.util.stream.Collectors;\n    +\n    +import org.apache.lucene.codecs.CodecUtil;\n    +import org.apache.lucene.index.DirectoryReader;\n    +import org.apache.lucene.index.IndexCommit;\n    +import org.apache.lucene.index.IndexDeletionPolicy;\n    +import org.apache.lucene.index.IndexWriterConfig.OpenMode;\n    +import org.apache.lucene.store.Directory;\n    +import org.apache.lucene.store.IOContext;\n    +import org.apache.lucene.store.IndexInput;\n    +import org.apache.lucene.store.IndexOutput;\n    +import org.apache.lucene.util.IOUtils;\n    +import org.apache.solr.common.SolrException;\n    +import org.apache.solr.common.SolrException.ErrorCode;\n    +import org.apache.solr.core.DirectoryFactory;\n    +import org.apache.solr.core.IndexDeletionPolicyWrapper;\n    +import org.apache.solr.core.SolrCore;\n    +import org.apache.solr.core.DirectoryFactory.DirContext;\n    +import org.slf4j.Logger;\n    +import org.slf4j.LoggerFactory;\n    +\n    +import com.google.common.base.Preconditions;\n    +\n    +/**\n    + * This class is responsible to manage the persistent snapshots meta-data for the Solr indexes. The\n    + * persistent snapshots are implemented by relying on Lucene \n{@linkplain IndexDeletionPolicy}\n    + * abstraction to configure a specific \n{@linkplain IndexCommit}\n to be retained. The\n    + * \n{@linkplain IndexDeletionPolicyWrapper}\n in Solr uses this class to create/delete the Solr index\n    + * snapshots.\n    + */\n    +public class SolrSnapshotMetaDataManager {\n    +  private static final Logger log = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n    +  public static final String SNAPSHOT_METADATA_DIR = \"snapshot_metadata\";\n    +\n    +  /**\n    +   * A class defining the meta-data for a specific snapshot.\n    +   */\n    +  public static class SnapshotMetaData {\n    +    private String name;\n    +    private String indexDirPath;\n    +    private long generationNumber;\n    +\n    +    public SnapshotMetaData(String name, String indexDirPath, long generationNumber) \n{\n    +      super();\n    +      this.name = name;\n    +      this.indexDirPath = indexDirPath;\n    +      this.generationNumber = generationNumber;\n    +    }\n    +\n    +    public String getName() \n{\n    +      return name;\n    +    }\n    +\n    +    public String getIndexDirPath() \n{\n    +      return indexDirPath;\n    +    }\n    +\n    +    public long getGenerationNumber() \n{\n    +      return generationNumber;\n    +    }\n    +\n    +    @Override\n    +    public String toString() \n{\n    +      StringBuilder builder = new StringBuilder();\n    +      builder.append(\"SnapshotMetaData[name=\");\n    +      builder.append(name);\n    +      builder.append(\", indexDirPath=\");\n    +      builder.append(indexDirPath);\n    +      builder.append(\", generation=\");\n    +      builder.append(generationNumber);\n    +      builder.append(\"]\");\n    +      return builder.toString();\n    +    }\n    +  }\n    +\n    +  /** Prefix used for the save file. */\n    +  public static final String SNAPSHOTS_PREFIX = \"snapshots_\";\n    +  private static final int VERSION_START = 0;\n    +  private static final int VERSION_CURRENT = VERSION_START;\n    +  private static final String CODEC_NAME = \"solr-snapshots\";\n    +\n    +  // The index writer which maintains the snapshots metadata\n    +  private long nextWriteGen;\n    +\n    +  private final Directory dir;\n    +\n    +  /** Used to map snapshot name to snapshot meta-data. */\n    +  protected final Map<String,SnapshotMetaData> nameToDetailsMapping = new HashMap<>();\n    \u2014 End diff \u2013\n\n    Done. ",
            "id": "comment-15388073"
        },
        {
            "date": "2016-07-21T17:32:53+0000",
            "author": "ASF GitHub Bot",
            "content": "Github user hgadre commented on a diff in the pull request:\n\n    https://github.com/apache/lucene-solr/pull/52#discussion_r71750235\n\n    \u2014 Diff: solr/core/src/java/org/apache/solr/core/snapshots/SolrSnapshotMetaDataManager.java \u2014\n    @@ -0,0 +1,419 @@\n    +/*\n    + * Licensed to the Apache Software Foundation (ASF) under one or more\n    + * contributor license agreements.  See the NOTICE file distributed with\n    + * this work for additional information regarding copyright ownership.\n    + * The ASF licenses this file to You under the Apache License, Version 2.0\n    + * (the \"License\"); you may not use this file except in compliance with\n    + * the License.  You may obtain a copy of the License at\n    + *\n    + *     http://www.apache.org/licenses/LICENSE-2.0\n    + *\n    + * Unless required by applicable law or agreed to in writing, software\n    + * distributed under the License is distributed on an \"AS IS\" BASIS,\n    + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    + * See the License for the specific language governing permissions and\n    + * limitations under the License.\n    + */\n    +package org.apache.solr.core.snapshots;\n    +\n    +import java.io.IOException;\n    +import java.lang.invoke.MethodHandles;\n    +import java.util.ArrayList;\n    +import java.util.Collection;\n    +import java.util.Collections;\n    +import java.util.HashMap;\n    +import java.util.HashSet;\n    +import java.util.List;\n    +import java.util.Locale;\n    +import java.util.Map;\n    +import java.util.Map.Entry;\n    +import java.util.Optional;\n    +import java.util.stream.Collectors;\n    +\n    +import org.apache.lucene.codecs.CodecUtil;\n    +import org.apache.lucene.index.DirectoryReader;\n    +import org.apache.lucene.index.IndexCommit;\n    +import org.apache.lucene.index.IndexDeletionPolicy;\n    +import org.apache.lucene.index.IndexWriterConfig.OpenMode;\n    +import org.apache.lucene.store.Directory;\n    +import org.apache.lucene.store.IOContext;\n    +import org.apache.lucene.store.IndexInput;\n    +import org.apache.lucene.store.IndexOutput;\n    +import org.apache.lucene.util.IOUtils;\n    +import org.apache.solr.common.SolrException;\n    +import org.apache.solr.common.SolrException.ErrorCode;\n    +import org.apache.solr.core.DirectoryFactory;\n    +import org.apache.solr.core.IndexDeletionPolicyWrapper;\n    +import org.apache.solr.core.SolrCore;\n    +import org.apache.solr.core.DirectoryFactory.DirContext;\n    +import org.slf4j.Logger;\n    +import org.slf4j.LoggerFactory;\n    +\n    +import com.google.common.base.Preconditions;\n    +\n    +/**\n    + * This class is responsible to manage the persistent snapshots meta-data for the Solr indexes. The\n    + * persistent snapshots are implemented by relying on Lucene \n{@linkplain IndexDeletionPolicy}\n    + * abstraction to configure a specific \n{@linkplain IndexCommit} to be retained. The\n    + * {@linkplain IndexDeletionPolicyWrapper} in Solr uses this class to create/delete the Solr index\n    + * snapshots.\n    + */\n    +public class SolrSnapshotMetaDataManager {\n    +  private static final Logger log = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n    +  public static final String SNAPSHOT_METADATA_DIR = \"snapshot_metadata\";\n    +\n    +  /**\n    +   * A class defining the meta-data for a specific snapshot.\n    +   */\n    +  public static class SnapshotMetaData {\n    +    private String name;\n    +    private String indexDirPath;\n    +    private long generationNumber;\n    +\n    +    public SnapshotMetaData(String name, String indexDirPath, long generationNumber) {\n    +      super();\n    +      this.name = name;\n    +      this.indexDirPath = indexDirPath;\n    +      this.generationNumber = generationNumber;\n    +    }\n    +\n    +    public String getName() {\n    +      return name;\n    +    }\n    +\n    +    public String getIndexDirPath() {\n    +      return indexDirPath;\n    +    }\n    +\n    +    public long getGenerationNumber() {\n    +      return generationNumber;\n    +    }\n    +\n    +    @Override\n    +    public String toString() {\n    +      StringBuilder builder = new StringBuilder();\n    +      builder.append(\"SnapshotMetaData[name=\");\n    +      builder.append(name);\n    +      builder.append(\", indexDirPath=\");\n    +      builder.append(indexDirPath);\n    +      builder.append(\", generation=\");\n    +      builder.append(generationNumber);\n    +      builder.append(\"]\");\n    +      return builder.toString();\n    +    }\n    +  }\n    +\n    +  /** Prefix used for the save file. */\n    +  public static final String SNAPSHOTS_PREFIX = \"snapshots_\";\n    +  private static final int VERSION_START = 0;\n    +  private static final int VERSION_CURRENT = VERSION_START;\n    +  private static final String CODEC_NAME = \"solr-snapshots\";\n    +\n    +  // The index writer which maintains the snapshots metadata\n    +  private long nextWriteGen;\n    +\n    +  private final Directory dir;\n    +\n    +  /** Used to map snapshot name to snapshot meta-data. */\n    +  protected final Map<String,SnapshotMetaData> nameToDetailsMapping = new HashMap<>();\n    +  /** Used to figure out the current index data directory path */\n    +  private final SolrCore solrCore;\n    +\n    +  /**\n    +   * A constructor.\n    +   *\n    +   * @param dir The directory where the snapshot meta-data should be stored. Enables updating\n    +   *            the existing meta-data.\n    +   * @throws IOException in case of errors.\n    +   */\n    +  public SolrSnapshotMetaDataManager(SolrCore solrCore, Directory dir) throws IOException {\n    +    this(solrCore, dir, OpenMode.CREATE_OR_APPEND);\n    +  }\n    +\n    +  /**\n    +   * A constructor.\n    +   *\n    +   * @param dir The directory where the snapshot meta-data is stored.\n    +   * @param mode CREATE If previous meta-data should be erased.\n    +   *             APPEND If previous meta-data should be read and updated.\n    +   *             CREATE_OR_APPEND Creates a new meta-data structure if one does not exist\n    +   *                              Updates the existing structure if one exists.\n    +   * @throws IOException in case of errors.\n    +   */\n    +  public SolrSnapshotMetaDataManager(SolrCore solrCore, Directory dir, OpenMode mode) throws IOException {\n    +    this.solrCore = solrCore;\n    +    this.dir = dir;\n    +\n    +    if (mode == OpenMode.CREATE) {\n    +      deleteSnapshotMetadataFiles();\n    +    }\n    +\n    +    loadFromSnapshotMetadataFile();\n    +\n    +    if (mode == OpenMode.APPEND && nextWriteGen == 0) {\n    +      throw new IllegalStateException(\"no snapshots stored in this directory\");\n    +    }\n    +  }\n    +\n    +  /**\n    +   * @return The snapshot meta-data directory\n    +   */\n    +  public Directory getSnapshotsDir() {\n    +    return dir;\n    +  }\n    +\n    +  /**\n    +   * This method creates a new snapshot meta-data entry.\n    +   *\n    +   * @param name The name of the snapshot.\n    +   * @param indexDirPath The directory path where the index files are stored.\n    +   * @param gen The generation number for the {@linkplain IndexCommit}\n being snapshotted.\n    +   * @throws IOException in case of I/O errors.\n    +   */\n    +  public synchronized void snapshot(String name, String indexDirPath, long gen) throws IOException {\n    +    Preconditions.checkNotNull(name);\n    +\n    +    log.info(\"Creating the snapshot named {} for core {} associated with index commit with generation {} in directory {}\"\n    +        , name, solrCore.getName(), gen, indexDirPath);\n    +\n    +    if(nameToDetailsMapping.containsKey(name)) \n{\n    +      throw new SolrException(ErrorCode.BAD_REQUEST, \"A snapshot with name \" + name + \" already exists\");\n    +    }\n    +\n    +    SnapshotMetaData d = new SnapshotMetaData(name, indexDirPath, gen);\n    +    nameToDetailsMapping.put(name, d);\n    +\n    +    boolean success = false;\n    +    try \n{\n    +      persist();\n    +      success = true;\n    +    }\n finally {\n    +      if (!success) {\n    +        try \n{\n    +          release(name);\n    +        }\n catch (Exception e) \n{\n    +          // Suppress so we keep throwing original exception\n    +        }\n    +      }\n    +    }\n    +  }\n    +\n    +  /**\n    +   * This method deletes a previously created snapshot (if any).\n    +   *\n    +   * @param name The name of the snapshot to be deleted.\n    +   * @return The snapshot meta-data if the snapshot with the snapshot name exists.\n    +   * @throws IOException in case of I/O error\n    +   */\n    +  public synchronized Optional<SnapshotMetaData> release(String name) throws IOException {\n    +    log.info(\"Deleting the snapshot named {} for core {}\", name, solrCore.getName());\n    +    SnapshotMetaData result = nameToDetailsMapping.remove(Preconditions.checkNotNull(name));\n    +    if(result != null) {\n    +      boolean success = false;\n    +      try \n{\n    +        persist();\n    +        success = true;\n    +      }\n finally {\n    +        if (!success) \n{\n    +          nameToDetailsMapping.put(name, result);\n    +        }\n    +      }\n    +    }\n    +    return Optional.ofNullable(result);\n    +  }\n    +\n    +  /**\n    +   * This method returns if snapshot is created for the specified generation number in\n    +   * the current index directory.\n    +   *\n    +   * @param genNumber The generation number for the \n{@linkplain IndexCommit} to be checked.\n    +   * @return true if the snapshot is created.\n    +   *         false otherwise.\n    +   */\n    +  public synchronized boolean isSnapshotted(long genNumber) {\n    +    return isSnapshotted(solrCore.getIndexDir(), genNumber);\n    +  }\n    +\n    +  /**\n    +   * This method returns if snapshot is created for the specified generation number in\n    +   * the specified index directory.\n    +   *\n    +   * @param genNumber The generation number for the {@linkplain IndexCommit}\n to be checked.\n    +   * @return true if the snapshot is created.\n    +   *         false otherwise.\n    +   */\n    +  public synchronized boolean isSnapshotted(String indexDirPath, long genNumber) {\n    +    return nameToDetailsMapping.values().stream()\n    \u2014 End diff \u2013\n\n    Done. ",
            "id": "comment-15388084"
        },
        {
            "date": "2016-07-21T17:33:04+0000",
            "author": "ASF GitHub Bot",
            "content": "Github user hgadre commented on a diff in the pull request:\n\n    https://github.com/apache/lucene-solr/pull/52#discussion_r71750261\n\n    \u2014 Diff: solr/core/src/java/org/apache/solr/core/snapshots/SolrSnapshotMetaDataManager.java \u2014\n    @@ -0,0 +1,419 @@\n    +/*\n    + * Licensed to the Apache Software Foundation (ASF) under one or more\n    + * contributor license agreements.  See the NOTICE file distributed with\n    + * this work for additional information regarding copyright ownership.\n    + * The ASF licenses this file to You under the Apache License, Version 2.0\n    + * (the \"License\"); you may not use this file except in compliance with\n    + * the License.  You may obtain a copy of the License at\n    + *\n    + *     http://www.apache.org/licenses/LICENSE-2.0\n    + *\n    + * Unless required by applicable law or agreed to in writing, software\n    + * distributed under the License is distributed on an \"AS IS\" BASIS,\n    + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    + * See the License for the specific language governing permissions and\n    + * limitations under the License.\n    + */\n    +package org.apache.solr.core.snapshots;\n    +\n    +import java.io.IOException;\n    +import java.lang.invoke.MethodHandles;\n    +import java.util.ArrayList;\n    +import java.util.Collection;\n    +import java.util.Collections;\n    +import java.util.HashMap;\n    +import java.util.HashSet;\n    +import java.util.List;\n    +import java.util.Locale;\n    +import java.util.Map;\n    +import java.util.Map.Entry;\n    +import java.util.Optional;\n    +import java.util.stream.Collectors;\n    +\n    +import org.apache.lucene.codecs.CodecUtil;\n    +import org.apache.lucene.index.DirectoryReader;\n    +import org.apache.lucene.index.IndexCommit;\n    +import org.apache.lucene.index.IndexDeletionPolicy;\n    +import org.apache.lucene.index.IndexWriterConfig.OpenMode;\n    +import org.apache.lucene.store.Directory;\n    +import org.apache.lucene.store.IOContext;\n    +import org.apache.lucene.store.IndexInput;\n    +import org.apache.lucene.store.IndexOutput;\n    +import org.apache.lucene.util.IOUtils;\n    +import org.apache.solr.common.SolrException;\n    +import org.apache.solr.common.SolrException.ErrorCode;\n    +import org.apache.solr.core.DirectoryFactory;\n    +import org.apache.solr.core.IndexDeletionPolicyWrapper;\n    +import org.apache.solr.core.SolrCore;\n    +import org.apache.solr.core.DirectoryFactory.DirContext;\n    +import org.slf4j.Logger;\n    +import org.slf4j.LoggerFactory;\n    +\n    +import com.google.common.base.Preconditions;\n    +\n    +/**\n    + * This class is responsible to manage the persistent snapshots meta-data for the Solr indexes. The\n    + * persistent snapshots are implemented by relying on Lucene \n{@linkplain IndexDeletionPolicy}\n    + * abstraction to configure a specific \n{@linkplain IndexCommit} to be retained. The\n    + * {@linkplain IndexDeletionPolicyWrapper} in Solr uses this class to create/delete the Solr index\n    + * snapshots.\n    + */\n    +public class SolrSnapshotMetaDataManager {\n    +  private static final Logger log = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n    +  public static final String SNAPSHOT_METADATA_DIR = \"snapshot_metadata\";\n    +\n    +  /**\n    +   * A class defining the meta-data for a specific snapshot.\n    +   */\n    +  public static class SnapshotMetaData {\n    +    private String name;\n    +    private String indexDirPath;\n    +    private long generationNumber;\n    +\n    +    public SnapshotMetaData(String name, String indexDirPath, long generationNumber) {\n    +      super();\n    +      this.name = name;\n    +      this.indexDirPath = indexDirPath;\n    +      this.generationNumber = generationNumber;\n    +    }\n    +\n    +    public String getName() {\n    +      return name;\n    +    }\n    +\n    +    public String getIndexDirPath() {\n    +      return indexDirPath;\n    +    }\n    +\n    +    public long getGenerationNumber() {\n    +      return generationNumber;\n    +    }\n    +\n    +    @Override\n    +    public String toString() {\n    +      StringBuilder builder = new StringBuilder();\n    +      builder.append(\"SnapshotMetaData[name=\");\n    +      builder.append(name);\n    +      builder.append(\", indexDirPath=\");\n    +      builder.append(indexDirPath);\n    +      builder.append(\", generation=\");\n    +      builder.append(generationNumber);\n    +      builder.append(\"]\");\n    +      return builder.toString();\n    +    }\n    +  }\n    +\n    +  /** Prefix used for the save file. */\n    +  public static final String SNAPSHOTS_PREFIX = \"snapshots_\";\n    +  private static final int VERSION_START = 0;\n    +  private static final int VERSION_CURRENT = VERSION_START;\n    +  private static final String CODEC_NAME = \"solr-snapshots\";\n    +\n    +  // The index writer which maintains the snapshots metadata\n    +  private long nextWriteGen;\n    +\n    +  private final Directory dir;\n    +\n    +  /** Used to map snapshot name to snapshot meta-data. */\n    +  protected final Map<String,SnapshotMetaData> nameToDetailsMapping = new HashMap<>();\n    +  /** Used to figure out the current index data directory path */\n    +  private final SolrCore solrCore;\n    +\n    +  /**\n    +   * A constructor.\n    +   *\n    +   * @param dir The directory where the snapshot meta-data should be stored. Enables updating\n    +   *            the existing meta-data.\n    +   * @throws IOException in case of errors.\n    +   */\n    +  public SolrSnapshotMetaDataManager(SolrCore solrCore, Directory dir) throws IOException {\n    +    this(solrCore, dir, OpenMode.CREATE_OR_APPEND);\n    +  }\n    +\n    +  /**\n    +   * A constructor.\n    +   *\n    +   * @param dir The directory where the snapshot meta-data is stored.\n    +   * @param mode CREATE If previous meta-data should be erased.\n    +   *             APPEND If previous meta-data should be read and updated.\n    +   *             CREATE_OR_APPEND Creates a new meta-data structure if one does not exist\n    +   *                              Updates the existing structure if one exists.\n    +   * @throws IOException in case of errors.\n    +   */\n    +  public SolrSnapshotMetaDataManager(SolrCore solrCore, Directory dir, OpenMode mode) throws IOException {\n    +    this.solrCore = solrCore;\n    +    this.dir = dir;\n    +\n    +    if (mode == OpenMode.CREATE) {\n    +      deleteSnapshotMetadataFiles();\n    +    }\n    +\n    +    loadFromSnapshotMetadataFile();\n    +\n    +    if (mode == OpenMode.APPEND && nextWriteGen == 0) {\n    +      throw new IllegalStateException(\"no snapshots stored in this directory\");\n    +    }\n    +  }\n    +\n    +  /**\n    +   * @return The snapshot meta-data directory\n    +   */\n    +  public Directory getSnapshotsDir() {\n    +    return dir;\n    +  }\n    +\n    +  /**\n    +   * This method creates a new snapshot meta-data entry.\n    +   *\n    +   * @param name The name of the snapshot.\n    +   * @param indexDirPath The directory path where the index files are stored.\n    +   * @param gen The generation number for the {@linkplain IndexCommit}\n being snapshotted.\n    +   * @throws IOException in case of I/O errors.\n    +   */\n    +  public synchronized void snapshot(String name, String indexDirPath, long gen) throws IOException {\n    +    Preconditions.checkNotNull(name);\n    +\n    +    log.info(\"Creating the snapshot named {} for core {} associated with index commit with generation {} in directory {}\"\n    +        , name, solrCore.getName(), gen, indexDirPath);\n    +\n    +    if(nameToDetailsMapping.containsKey(name)) \n{\n    +      throw new SolrException(ErrorCode.BAD_REQUEST, \"A snapshot with name \" + name + \" already exists\");\n    +    }\n    +\n    +    SnapshotMetaData d = new SnapshotMetaData(name, indexDirPath, gen);\n    +    nameToDetailsMapping.put(name, d);\n    +\n    +    boolean success = false;\n    +    try \n{\n    +      persist();\n    +      success = true;\n    +    }\n finally {\n    +      if (!success) {\n    +        try \n{\n    +          release(name);\n    +        }\n catch (Exception e) \n{\n    +          // Suppress so we keep throwing original exception\n    +        }\n    +      }\n    +    }\n    +  }\n    +\n    +  /**\n    +   * This method deletes a previously created snapshot (if any).\n    +   *\n    +   * @param name The name of the snapshot to be deleted.\n    +   * @return The snapshot meta-data if the snapshot with the snapshot name exists.\n    +   * @throws IOException in case of I/O error\n    +   */\n    +  public synchronized Optional<SnapshotMetaData> release(String name) throws IOException {\n    +    log.info(\"Deleting the snapshot named {} for core {}\", name, solrCore.getName());\n    +    SnapshotMetaData result = nameToDetailsMapping.remove(Preconditions.checkNotNull(name));\n    +    if(result != null) {\n    +      boolean success = false;\n    +      try \n{\n    +        persist();\n    +        success = true;\n    +      }\n finally {\n    +        if (!success) \n{\n    +          nameToDetailsMapping.put(name, result);\n    +        }\n    +      }\n    +    }\n    +    return Optional.ofNullable(result);\n    +  }\n    +\n    +  /**\n    +   * This method returns if snapshot is created for the specified generation number in\n    +   * the current index directory.\n    +   *\n    +   * @param genNumber The generation number for the \n{@linkplain IndexCommit} to be checked.\n    +   * @return true if the snapshot is created.\n    +   *         false otherwise.\n    +   */\n    +  public synchronized boolean isSnapshotted(long genNumber) {\n    +    return isSnapshotted(solrCore.getIndexDir(), genNumber);\n    +  }\n    +\n    +  /**\n    +   * This method returns if snapshot is created for the specified generation number in\n    +   * the specified index directory.\n    +   *\n    +   * @param genNumber The generation number for the {@linkplain IndexCommit}\n to be checked.\n    +   * @return true if the snapshot is created.\n    +   *         false otherwise.\n    +   */\n    +  public synchronized boolean isSnapshotted(String indexDirPath, long genNumber) \n{\n    +    return nameToDetailsMapping.values().stream()\n    +        .filter(entry -> entry.getIndexDirPath().equals(indexDirPath) && entry.getGenerationNumber() == genNumber)\n    +        .findFirst()\n    +        .isPresent();\n    +  }\n    +\n    +  /**\n    +   * This method returns the snapshot meta-data for the specified name (if it exists).\n    +   *\n    +   * @param name The name of the snapshot\n    +   * @return The snapshot meta-data if exists.\n    +   */\n    +  public synchronized Optional<SnapshotMetaData> getSnapshotMetaData(String name) \n{\n    +    return Optional.ofNullable(nameToDetailsMapping.get(name));\n    +  }\n    +\n    +  /**\n    +   * @return A list of snapshots created so far.\n    +   */\n    +  public synchronized Collection<String> listSnapshots() {\n    +    return new HashSet<>(nameToDetailsMapping.keySet());\n    \u2014 End diff \u2013\n\n    Done. ",
            "id": "comment-15388085"
        },
        {
            "date": "2016-07-21T17:52:06+0000",
            "author": "ASF GitHub Bot",
            "content": "Github user hgadre commented on a diff in the pull request:\n\n    https://github.com/apache/lucene-solr/pull/52#discussion_r71753653\n\n    \u2014 Diff: solr/core/src/test/org/apache/solr/handler/TestSolrCoreSnapshots.java \u2014\n    @@ -0,0 +1,446 @@\n    +/*\n    + * Licensed to the Apache Software Foundation (ASF) under one or more\n    + * contributor license agreements.  See the NOTICE file distributed with\n    + * this work for additional information regarding copyright ownership.\n    + * The ASF licenses this file to You under the Apache License, Version 2.0\n    + * (the \"License\"); you may not use this file except in compliance with\n    + * the License.  You may obtain a copy of the License at\n    + *\n    + *     http://www.apache.org/licenses/LICENSE-2.0\n    + *\n    + * Unless required by applicable law or agreed to in writing, software\n    + * distributed under the License is distributed on an \"AS IS\" BASIS,\n    + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    + * See the License for the specific language governing permissions and\n    + * limitations under the License.\n    + */\n    +package org.apache.solr.handler;\n    +\n    +import static org.apache.solr.common.cloud.ZkStateReader.BASE_URL_PROP;\n    +\n    +import java.io.IOException;\n    +import java.io.InputStream;\n    +import java.lang.invoke.MethodHandles;\n    +import java.net.URL;\n    +import java.nio.file.Files;\n    +import java.nio.file.Path;\n    +import java.nio.file.Paths;\n    +import java.util.ArrayList;\n    +import java.util.Collection;\n    +import java.util.Collections;\n    +import java.util.HashMap;\n    +import java.util.List;\n    +import java.util.Map;\n    +import java.util.Optional;\n    +import org.apache.commons.io.IOUtils;\n    +import org.apache.lucene.index.DirectoryReader;\n    +import org.apache.lucene.index.IndexCommit;\n    +import org.apache.lucene.index.IndexNotFoundException;\n    +import org.apache.lucene.store.SimpleFSDirectory;\n    +import org.apache.lucene.util.TestUtil;\n    +import org.apache.lucene.util.LuceneTestCase.Slow;\n    +import org.apache.solr.SolrTestCaseJ4;\n    +import org.apache.solr.client.solrj.SolrClient;\n    +import org.apache.solr.client.solrj.impl.CloudSolrClient;\n    +import org.apache.solr.client.solrj.request.CollectionAdminRequest;\n    +import org.apache.solr.client.solrj.request.CoreAdminRequest.CreateSnapshot;\n    +import org.apache.solr.client.solrj.request.CoreAdminRequest.DeleteSnapshot;\n    +import org.apache.solr.client.solrj.request.CoreAdminRequest.ListSnapshots;\n    +import org.apache.solr.cloud.SolrCloudTestCase;\n    +import org.apache.solr.common.SolrInputDocument;\n    +import org.apache.solr.common.cloud.DocCollection;\n    +import org.apache.solr.common.cloud.Replica;\n    +import org.apache.solr.common.cloud.Slice;\n    +import org.apache.solr.common.cloud.ZkStateReader;\n    +import org.apache.solr.common.params.CoreAdminParams.CoreAdminAction;\n    +import org.apache.solr.common.util.NamedList;\n    +import org.apache.solr.core.snapshots.SolrSnapshotManager;\n    +import org.apache.solr.core.snapshots.SolrSnapshotMetaDataManager.SnapshotMetaData;\n    +import org.junit.AfterClass;\n    +import org.junit.BeforeClass;\n    +import org.junit.Test;\n    +import org.slf4j.Logger;\n    +import org.slf4j.LoggerFactory;\n    +\n    +@SolrTestCaseJ4.SuppressSSL // Currently unknown why SSL does not work with this test\n    +@Slow\n    +public class TestSolrCoreSnapshots extends SolrCloudTestCase {\n    +  private static final Logger log = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n    +  private static long docsSeed; // see indexDocs()\n    +\n    +  @BeforeClass\n    +  public static void setupClass() throws Exception \n{\n    +    useFactory(\"solr.StandardDirectoryFactory\");\n    +    configureCluster(1)// nodes\n    +        .addConfig(\"conf1\", TEST_PATH().resolve(\"configsets\").resolve(\"cloud-minimal\").resolve(\"conf\"))\n    +        .configure();\n    +\n    +    docsSeed = random().nextLong();\n    +  }\n    +\n    +  @AfterClass\n    +  public static void teardownClass() throws Exception \n{\n    +    System.clearProperty(\"test.build.data\");\n    +    System.clearProperty(\"test.cache.data\");\n    +  }\n    +\n    +  @Test\n    +  public void testBackupRestore() throws Exception {\n    +    CloudSolrClient solrClient = cluster.getSolrClient();\n    +    String collectionName = \"SolrCoreSnapshots\";\n    +    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(collectionName, \"conf1\", 1, 1);\n    +    create.process(solrClient);\n    +\n    +    String location = createTempDir().toFile().getAbsolutePath();\n    +    int nDocs = BackupRestoreUtils.indexDocs(cluster.getSolrClient(), collectionName, docsSeed);\n    +\n    +    DocCollection collectionState = solrClient.getZkStateReader().getClusterState().getCollection(collectionName);\n    +    assertEquals(1, collectionState.getActiveSlices().size());\n    +    Slice shard = collectionState.getActiveSlices().iterator().next();\n    +    assertEquals(1, shard.getReplicas().size());\n    +    Replica replica = shard.getReplicas().iterator().next();\n    +\n    +    String replicaBaseUrl = replica.getStr(BASE_URL_PROP);\n    +    String coreName = replica.getStr(ZkStateReader.CORE_NAME_PROP);\n    +    String backupName = TestUtil.randomSimpleString(random(), 1, 5);\n    +    String commitName = TestUtil.randomSimpleString(random(), 1, 5);\n    +    String duplicateName = commitName.concat(\"_duplicate\");\n    +\n    +    try (\n    +        SolrClient adminClient = getHttpSolrClient(cluster.getJettySolrRunners().get(0).getBaseUrl().toString());\n    +        SolrClient masterClient = getHttpSolrClient(replica.getCoreUrl())) {\n    +\n    +      SnapshotMetaData metaData = createSnapshot(adminClient, coreName, commitName);\n    +      // Create another snapshot referring to the same index commit to verify the\n    +      // reference counting implementation during snapshot deletion.\n    +      SnapshotMetaData duplicateCommit = createSnapshot(adminClient, coreName, duplicateName);\n    +\n    +      assertEquals (metaData.getIndexDirPath(), duplicateCommit.getIndexDirPath());\n    +      assertEquals (metaData.getGenerationNumber(), duplicateCommit.getGenerationNumber());\n    +\n    +      // Delete all documents\n    +      masterClient.deleteByQuery(\":\");\n    +      masterClient.commit();\n    +      BackupRestoreUtils.verifyDocs(0, cluster.getSolrClient(), collectionName);\n    +\n    +      // Verify that the index directory contains at least 2 index commits - one referred by the snapshots\n    +      // and the other containing document deletions.\n    +      \n{\n    +        List<IndexCommit> commits = listCommits(metaData.getIndexDirPath());\n    +        assertTrue(2 <= commits.size());\n    +      }\n    +\n    +      // Backup the earlier created snapshot.\n    +      \n{\n    +        Map<String,String> params = new HashMap<>();\n    +        params.put(\"name\", backupName);\n    +        params.put(\"commitName\", commitName);\n    +        params.put(\"location\", location);\n    +        runCoreAdminCommand(replicaBaseUrl, coreName, CoreAdminAction.BACKUPCORE.toString(), params);\n    +      }\n    +\n    +      // Restore the backup\n    +      \n{\n    +        Map<String,String> params = new HashMap<>();\n    +        params.put(\"name\", \"snapshot.\" + backupName);\n    +        params.put(\"location\", location);\n    +        runCoreAdminCommand(replicaBaseUrl, coreName, CoreAdminAction.RESTORECORE.toString(), params);\n    +        BackupRestoreUtils.verifyDocs(nDocs, cluster.getSolrClient(), collectionName);\n    +      }\n    +\n    +      // Verify that the old index directory (before restore) contains only those index commits referred by snapshots.\n    +      \n{\n    +        List<IndexCommit> commits = listCommits(metaData.getIndexDirPath());\n    +        assertEquals(1, commits.size());\n    +        assertEquals(metaData.getGenerationNumber(), commits.get(0).getGeneration());\n    +      }\n    +\n    +      // Delete first snapshot\n    +      deleteSnapshot(adminClient, coreName, commitName);\n    +\n    +      // Verify that corresponding index files have NOT been deleted (due to reference counting).\n    +      assertFalse(listCommits(metaData.getIndexDirPath()).isEmpty());\n    +\n    +      // Delete second snapshot\n    +      deleteSnapshot(adminClient, coreName, duplicateCommit.getName());\n    +\n    +      // Verify that corresponding index files have been deleted.\n    +      assertTrue(listCommits(duplicateCommit.getIndexDirPath()).isEmpty());\n    +    }\n    +  }\n    +\n    +  @Test\n    +  public void testHandlingSharedIndexFiles() throws Exception {\n    +    CloudSolrClient solrClient = cluster.getSolrClient();\n    +    String collectionName = \"SolrCoreSnapshots_IndexFileSharing\";\n    +    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(collectionName, \"conf1\", 1, 1);\n    +    create.process(solrClient);\n    +\n    +    int nDocs = BackupRestoreUtils.indexDocs(cluster.getSolrClient(), collectionName, docsSeed);\n    +    DocCollection collectionState = solrClient.getZkStateReader().getClusterState().getCollection(collectionName);\n    +    assertEquals(1, collectionState.getActiveSlices().size());\n    +    Slice shard = collectionState.getActiveSlices().iterator().next();\n    +    assertEquals(1, shard.getReplicas().size());\n    +    Replica replica = shard.getReplicas().iterator().next();\n    +\n    +    String replicaBaseUrl = replica.getStr(BASE_URL_PROP);\n    +    String coreName = replica.getStr(ZkStateReader.CORE_NAME_PROP);\n    +    String backupName = TestUtil.randomSimpleString(random(), 1, 5);\n    +    String location = createTempDir().toFile().getAbsolutePath();\n    +\n    +    try (\n    +        SolrClient adminClient = getHttpSolrClient(cluster.getJettySolrRunners().get(0).getBaseUrl().toString());\n    +        SolrClient masterClient = getHttpSolrClient(replica.getCoreUrl())) {\n    +\n    +      int numTests = TestUtil.nextInt(random(), 2, 5);\n    +      List<SnapshotMetaData> snapshots = new ArrayList<>(numTests);\n    +\n    +      // Create multiple commits and create a snapshot per commit.\n    +      // This should result in Lucene reusing some of the segments for later index commits.\n    +      for (int attempt=0; attempt<numTests; attempt++) {\n    +        if (nDocs > 0) {\n    +          //Delete a few docs\n    +          int numDeletes = TestUtil.nextInt(random(), 1, nDocs);\n    +          for(int i=0; i<numDeletes; i++) \n{\n    +            masterClient.deleteByQuery(\"id:\" + i);\n    +          }\n    +        }\n    +\n    +        // Add a few more\n    +        int moreAdds = TestUtil.nextInt(random(), 1, 100);\n    +        for (int i = 0; i < moreAdds; i++) \n{\n    +          SolrInputDocument doc = new SolrInputDocument();\n    +          doc.addField(\"id\", i + nDocs);\n    +          doc.addField(\"name\", \"name = \" + (i + nDocs));\n    +          masterClient.add(doc);\n    +        }\n    +        masterClient.commit();\n    +\n    +        // Create a snapshot\n    +        snapshots.add(createSnapshot(adminClient, coreName, \"snapshot_\" + attempt));\n    +      }\n    +\n    +      // Backup the earlier created snapshot.\n    +      {\n    +        Map<String,String> params = new HashMap<>();\n    +        params.put(\"name\", backupName);\n    +        params.put(\"commitName\", snapshots.get(0).getName());\n    +        params.put(\"location\", location);\n    +        runCoreAdminCommand(replicaBaseUrl, coreName, CoreAdminAction.BACKUPCORE.toString(), params);\n    +      }\n    +\n    +      // Restore the backup. The purpose of the restore operation is to change the current index directory.\n    +      // This is required since we delegate the file deletion to underlying IndexDeletionPolicy in case of\n    +      // current index directory. Hence for the purpose of this test, we want to ensure that the created\n    +      // snapshots are NOT in the current index directory.\n    +      {\n    +        Map<String,String> params = new HashMap<>();\n    +        params.put(\"name\", \"snapshot.\" + backupName);\n    +        params.put(\"location\", location);\n    +        runCoreAdminCommand(replicaBaseUrl, coreName, CoreAdminAction.RESTORECORE.toString(), params);\n    +      }\n    +\n    +      {\n    +        List<IndexCommit> commits = listCommits(snapshots.get(0).getIndexDirPath());\n    +        // Check if number of index commits are > 0 to ensure index file sharing.\n    +        assertTrue(commits.size() > 0);\n    +        Map<String,Integer> refCounts = SolrSnapshotManager.buildRefCounts(snapshots, commits);\n    +\n    +        SnapshotMetaData snapshotMetaData = snapshots.get(0);\n    +        Optional<IndexCommit> ic = commits.stream()\n    +            .filter(entry -> entry.getGeneration() == snapshotMetaData.getGenerationNumber())\n    +            .findFirst();\n    +        assertTrue(ic.isPresent());\n    +        Collection<String> nonSharedFiles = new ArrayList<>();\n    +        Collection<String> sharedFiles = new ArrayList<>();\n    +        for (String fileName : ic.get().getFileNames()) {\n    +          if (refCounts.getOrDefault(fileName, 0) > 1) {\n    +            sharedFiles.add(fileName);\n    +          } else {\n    +            nonSharedFiles.add(fileName);\n    +          }\n    +        }\n    +\n    +        // Delete snapshot\n    +        deleteSnapshot(adminClient, coreName, snapshotMetaData.getName());\n    +\n    +        // Verify that the shared files are not deleted.\n    +        for (String fileName : sharedFiles) {\n    +          Path path = Paths.get(snapshotMetaData.getIndexDirPath(), fileName);\n    +          assertTrue(path + \" should exist.\", Files.exists(path));\n    +        }\n    +\n    +        // Verify that the non-shared files are deleted.\n    +        for (String fileName : nonSharedFiles) {\n    +          Path path = Paths.get(snapshotMetaData.getIndexDirPath(), fileName);\n    +          assertFalse(path + \" should not exist.\", Files.exists(path));\n    +        }\n    +        }\n    +      }\n    +  }\n    +\n    +  @Test\n    +  public void testIndexOptimization() throws Exception {\n    +    CloudSolrClient solrClient = cluster.getSolrClient();\n    +    String collectionName = \"SolrCoreSnapshots_IndexOptimization\";\n    +    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(collectionName, \"conf1\", 1, 1);\n    +    create.process(solrClient);\n    +\n    +    int nDocs = BackupRestoreUtils.indexDocs(cluster.getSolrClient(), collectionName, docsSeed);\n    +\n    +    DocCollection collectionState = solrClient.getZkStateReader().getClusterState().getCollection(collectionName);\n    +    assertEquals(1, collectionState.getActiveSlices().size());\n    +    Slice shard = collectionState.getActiveSlices().iterator().next();\n    +    assertEquals(1, shard.getReplicas().size());\n    +    Replica replica = shard.getReplicas().iterator().next();\n    +\n    +    String coreName = replica.getStr(ZkStateReader.CORE_NAME_PROP);\n    +    String commitName = TestUtil.randomSimpleString(random(), 1, 5);\n    +\n    +    try (\n    +        SolrClient adminClient = getHttpSolrClient(cluster.getJettySolrRunners().get(0).getBaseUrl().toString());\n    +        SolrClient masterClient = getHttpSolrClient(replica.getCoreUrl())) {\n    +\n    +      SnapshotMetaData metaData = createSnapshot(adminClient, coreName, commitName);\n    +\n    +      int numTests = nDocs > 0 ? TestUtil.nextInt(random(), 1, 5) : 1;\n    +      for (int attempt=0; attempt<numTests; attempt++) {\n    +        //Modify existing index before we call optimize.\n    +        if (nDocs > 0) {\n    +          //Delete a few docs\n    +          int numDeletes = TestUtil.nextInt(random(), 1, nDocs);\n    +          for(int i=0; i<numDeletes; i++) {\n    +            masterClient.deleteByQuery(\"id:\" + i);\n    +          }\n    +          //Add a few more\n    +          int moreAdds = TestUtil.nextInt(random(), 1, 100);\n    +          for (int i=0; i<moreAdds; i++) {\n    +            SolrInputDocument doc = new SolrInputDocument();\n    +            doc.addField(\"id\", i + nDocs);\n    +            doc.addField(\"name\", \"name = \" + (i + nDocs));\n    +            masterClient.add(doc);\n    +          }\n    +          masterClient.commit();\n    +        }\n    +      }\n    +\n    +      // Before invoking optimize command, verify that the index directory contains multiple commits (including the one we snapshotted earlier).\n    +      {\n    +        Collection<IndexCommit> commits = listCommits(metaData.getIndexDirPath());\n    +        // Verify that multiple index commits are stored in this directory.\n    +        assertTrue(commits.size() > 0);\n    +        // Verify that the snapshot commit is present in this directory.\n    +        assertTrue(commits.stream().filter(x -> x.getGeneration() == metaData.getGenerationNumber()).findFirst().isPresent());\n    +      }\n    +\n    +      // Optimize the index.\n    +      masterClient.optimize(true, true, 1);\n    +\n    +      // After invoking optimize command, verify that the index directory contains multiple commits (including the one we snapshotted earlier).\n    +      {\n    +        List<IndexCommit> commits = listCommits(metaData.getIndexDirPath());\n    +        // Verify that multiple index commits are stored in this directory.\n    +        assertTrue(commits.size() > 1);\n    +        // Verify that the snapshot commit is present in this directory.\n    +        assertTrue(commits.stream().filter(x -> x.getGeneration() == metaData.getGenerationNumber()).findFirst().isPresent());\n    +      }\n    +\n    +      // Delete the snapshot\n    +      deleteSnapshot(adminClient, coreName, metaData.getName());\n    +\n    +      // Add few documents. Without this the optimize command below does not take effect.\n    +      {\n    +        int moreAdds = TestUtil.nextInt(random(), 1, 100);\n    +        for (int i=0; i<moreAdds; i++) {    +          SolrInputDocument doc = new SolrInputDocument();    +          doc.addField(\"id\", i + nDocs);    +          doc.addField(\"name\", \"name = \" + (i + nDocs));    +          masterClient.add(doc);    +        }\n    +        masterClient.commit();\n    +      }\n    +\n    +      // Optimize the index.\n    +      masterClient.optimize(true, true, 1);\n    +\n    +      // Verify that the index directory contains only 1 index commit (which is not the same as the snapshotted commit).\n    +      Collection<IndexCommit> commits = listCommits(metaData.getIndexDirPath());\n    +      assertTrue(commits.size() == 1);\n    +      assertFalse(commits.stream().filter(x -> x.getGeneration() == metaData.getGenerationNumber()).findFirst().isPresent());\n    +    }\n    +  }\n    +\n    +  private SnapshotMetaData createSnapshot (SolrClient adminClient, String coreName, String commitName) throws Exception \n{\n    +    CreateSnapshot req = new CreateSnapshot(commitName);\n    +    req.setCoreName(coreName);\n    +    adminClient.request(req);\n    +\n    +    Collection<SnapshotMetaData> snapshots = listSnapshots(adminClient, coreName);\n    +    Optional<SnapshotMetaData> metaData = snapshots.stream().filter(x -> commitName.equals(x.getName())).findFirst();\n    +    assertTrue(metaData.isPresent());\n    +\n    +    return metaData.get();\n    +  }\n    +\n    +  private void deleteSnapshot(SolrClient adminClient, String coreName, String commitName) throws Exception \n{\n    +    DeleteSnapshot req = new DeleteSnapshot(commitName);\n    +    req.setCoreName(coreName);\n    +    adminClient.request(req);\n    +\n    +    Collection<SnapshotMetaData> snapshots = listSnapshots(adminClient, coreName);\n    +    assertFalse(snapshots.stream().filter(x -> commitName.equals(x.getName())).findFirst().isPresent());\n    +  }\n    +\n    +  private Collection<SnapshotMetaData> listSnapshots(SolrClient adminClient, String coreName) throws Exception {\n    +    ListSnapshots req = new ListSnapshots();\n    +    req.setCoreName(coreName);\n    +    NamedList resp = adminClient.request(req);\n    +    assertTrue( resp.get(\"snapshots\") instanceof NamedList );\n    +    NamedList apiResult = (NamedList) resp.get(\"snapshots\");\n    +\n    +    List<SnapshotMetaData> result = new ArrayList<>(apiResult.size());\n    +    for(int i = 0 ; i < apiResult.size(); i++) \n{\n    +      String commitName = apiResult.getName(i);\n    +      String indexDirPath = (String)((NamedList)apiResult.get(commitName)).get(\"indexDirPath\");\n    +      long genNumber = Long.valueOf((String)((NamedList)apiResult.get(commitName)).get(\"generation\"));\n    +      result.add(new SnapshotMetaData(commitName, indexDirPath, genNumber));\n    +    }\n    +    return result;\n    +  }\n    +\n    +  private List<IndexCommit> listCommits(String directory) throws Exception {\n    +    SimpleFSDirectory dir = new SimpleFSDirectory(Paths.get(directory));\n    +    try \n{\n    +      return DirectoryReader.listCommits(dir);\n    +    }\n catch (IndexNotFoundException ex) \n{\n    +      // This can happen when the delete snapshot functionality cleans up the index files (when the directory\n    +      // storing these files is not the *current* index directory).\n    +      return Collections.emptyList();\n    +    }\n    +  }\n    +\n    +  static void runCoreAdminCommand(String baseUrl, String coreName, String action, Map<String,String> params)\n    \u2014 End diff \u2013\n\n    The problem is that we don't have CoreAdminRequest representation for backup/restore functionality (may be because they are internal APIs ?). Now I have moved this method to BackupRestoreUtil class so that all backup/restore related tests can use it. ",
            "id": "comment-15388119"
        },
        {
            "date": "2016-07-22T05:15:58+0000",
            "author": "ASF GitHub Bot",
            "content": "Github user hgadre commented on a diff in the pull request:\n\n    https://github.com/apache/lucene-solr/pull/52#discussion_r71827952\n\n    \u2014 Diff: solr/core/src/java/org/apache/solr/core/SolrCore.java \u2014\n    @@ -414,7 +416,19 @@ private IndexDeletionPolicyWrapper initDeletionPolicy(IndexDeletionPolicyWrapper\n         } else \n{\n           delPolicy = new SolrDeletionPolicy();\n         }\n\n\treturn new IndexDeletionPolicyWrapper(delPolicy);\n    +\n    +    return new IndexDeletionPolicyWrapper(delPolicy, snapshotMgr);\n    +  }\n    +\n    +  private SolrSnapshotMetaDataManager initSnapshotMetaDataManager() {\n\t\n\t\t\n\t\t\n\t\t\tEnd diff \u2013\n\t\t\n\t\t\n\t\n\t\n\n\n\n    I don't think directory creation should have any significant performance impact. Also lazy creation just adds a bit of complexity in the code which I wanted to avoid. But I am open to this idea if you insist. ",
            "id": "comment-15388925"
        },
        {
            "date": "2016-07-22T05:18:17+0000",
            "author": "ASF GitHub Bot",
            "content": "Github user hgadre commented on a diff in the pull request:\n\n    https://github.com/apache/lucene-solr/pull/52#discussion_r71828065\n\n    \u2014 Diff: solr/core/src/java/org/apache/solr/core/snapshots/SolrSnapshotManager.java \u2014\n    @@ -0,0 +1,132 @@\n    +/*\n    + * Licensed to the Apache Software Foundation (ASF) under one or more\n    + * contributor license agreements.  See the NOTICE file distributed with\n    + * this work for additional information regarding copyright ownership.\n    + * The ASF licenses this file to You under the Apache License, Version 2.0\n    + * (the \"License\"); you may not use this file except in compliance with\n    + * the License.  You may obtain a copy of the License at\n    + *\n    + *     http://www.apache.org/licenses/LICENSE-2.0\n    + *\n    + * Unless required by applicable law or agreed to in writing, software\n    + * distributed under the License is distributed on an \"AS IS\" BASIS,\n    + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    + * See the License for the specific language governing permissions and\n    + * limitations under the License.\n    + */\n    +package org.apache.solr.core.snapshots;\n    +\n    +import java.io.IOException;\n    +import java.lang.invoke.MethodHandles;\n    +import java.util.Collection;\n    +import java.util.HashMap;\n    +import java.util.List;\n    +import java.util.Map;\n    +import java.util.Set;\n    +import java.util.function.Function;\n    +import java.util.stream.Collectors;\n    +\n    +import org.apache.lucene.index.DirectoryReader;\n    +import org.apache.lucene.index.IndexCommit;\n    +import org.apache.lucene.store.Directory;\n    +import org.apache.solr.core.snapshots.SolrSnapshotMetaDataManager.SnapshotMetaData;\n    +import org.slf4j.Logger;\n    +import org.slf4j.LoggerFactory;\n    +\n    +/**\n    + * This class provides functionality required to handle the data files corresponding to Solr snapshots.\n    + */\n    +public class SolrSnapshotManager {\n    +  private static final Logger log = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n    +\n    +  /**\n    +   * This method deletes index files of the \n{@linkplain IndexCommit} for the specified generation number.\n    +   *\n    +   * @param dir The index directory storing the snapshot.\n    +   * @param gen The generation number for the {@linkplain IndexCommit}\n    +   * @throws IOException in case of I/O errors.\n    +   */\n    +  public static synchronized void deleteIndexFiles ( Directory dir, Collection<SnapshotMetaData> snapshots, long gen ) throws IOException {\n    +    List<IndexCommit> commits = DirectoryReader.listCommits(dir);\n    +    Map<String, Integer> refCounts = buildRefCounts(snapshots,commits);\n    +    for (IndexCommit ic : commits) {\n    +      if (ic.getGeneration() == gen) \n{\n    +        deleteIndexFiles(dir,refCounts, ic);\n    +        break;\n    +      }\n    +    }\n    +  }\n    +\n    +  /**\n    +   * This method deletes all files not corresponding to a configured snapshot in the specified index directory.\n    +   *\n    +   * @param dir The index directory to search for.\n    +   * @throws IOException in case of I/O errors.\n    +   */\n    +  public static synchronized void deleteNonSnapshotIndexFiles (Directory dir, Collection<SnapshotMetaData> snapshots) throws IOException {\n    +    List<IndexCommit> commits = DirectoryReader.listCommits(dir);\n    +    Map<String, Integer> refCounts = buildRefCounts(snapshots, commits);\n    +    Set<Long> snapshotGenNumbers = snapshots.stream()\n    +                                            .map(SnapshotMetaData::getGenerationNumber)\n    +                                            .collect(Collectors.toSet());\n    +    for (IndexCommit ic : commits) {\n    +      if (!snapshotGenNumbers.contains(ic.getGeneration())) \n{\n    +        deleteIndexFiles(dir,refCounts, ic);\n    +      }\n    +    }\n    +  }\n    +\n    +  /**\n    +   * This method computes reference count for the index files by taking into consideration\n    +   * (a) configured snapshots and (b) files sharing between two or more \n{@linkplain IndexCommit} instances.\n    +   *\n    +   * @param snapshots A collection of user configured snapshots\n    +   * @param commits A list of {@linkplain IndexCommit}\n instances\n    +   * @return A map containing reference count for each index file referred in one of the \n{@linkplain IndexCommit} instances.\n    +   * @throws IOException in case of I/O error.\n    +   */\n    +  public static Map<String, Integer> buildRefCounts (Collection<SnapshotMetaData> snapshots, List<IndexCommit> commits) throws IOException {\n    +    Map<String, Integer> result = new HashMap<>();\n    +    Map<Long, IndexCommit> commitsByGen = commits.stream().collect(\n    +        Collectors.toMap(IndexCommit::getGeneration, Function.identity()));\n    +\n    +    for(SnapshotMetaData md : snapshots) {\n    +      IndexCommit ic = commitsByGen.get(md.getGenerationNumber());\n    +      if (ic != null) {\n    +        Collection<String> fileNames = ic.getFileNames();\n    +        for(String fileName : fileNames) {\n    +          int refCount = result.getOrDefault(fileName, 0);\n    +          result.put(fileName, refCount+1);\n    +        }\n    +      }\n    +    }\n    +\n    +    return result;\n    +  }\n    +\n    +  /**\n    +   * This method deletes the index files associated with specified <code>indexCommit</code> provided they\n    +   * are not referred by some other {@linkplain IndexCommit}\n.\n    +   *\n    +   * @param dir The index directory containing the \n{@linkplain IndexCommit} to be deleted.\n    +   * @param refCounts A map containing reference counts for each file associated with every {@linkplain IndexCommit}\n    +   *                  in the specified directory.\n    +   * @param indexCommit The \n{@linkplain IndexCommit}\n whose files need to be deleted.\n    +   * @throws IOException in case of I/O errors.\n    +   */\n    +  private static synchronized void deleteIndexFiles ( Directory dir, Map<String, Integer> refCounts, IndexCommit indexCommit ) throws IOException {\n    \u2014 End diff \u2013\n\n    Good catch! I was mainly concerned about concurrent deletion of files e.g. due to simultaneous invocation of restore functionality. But after reviewing ReplicationHandler code and more thinking, I don't think we need to worry about it. Hence removed the synchronization. ",
            "id": "comment-15388936"
        },
        {
            "date": "2016-07-22T05:21:05+0000",
            "author": "ASF GitHub Bot",
            "content": "Github user hgadre commented on a diff in the pull request:\n\n    https://github.com/apache/lucene-solr/pull/52#discussion_r71828221\n\n    \u2014 Diff: solr/core/src/java/org/apache/solr/core/snapshots/SolrSnapshotManager.java \u2014\n    @@ -0,0 +1,132 @@\n    +/*\n    + * Licensed to the Apache Software Foundation (ASF) under one or more\n    + * contributor license agreements.  See the NOTICE file distributed with\n    + * this work for additional information regarding copyright ownership.\n    + * The ASF licenses this file to You under the Apache License, Version 2.0\n    + * (the \"License\"); you may not use this file except in compliance with\n    + * the License.  You may obtain a copy of the License at\n    + *\n    + *     http://www.apache.org/licenses/LICENSE-2.0\n    + *\n    + * Unless required by applicable law or agreed to in writing, software\n    + * distributed under the License is distributed on an \"AS IS\" BASIS,\n    + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    + * See the License for the specific language governing permissions and\n    + * limitations under the License.\n    + */\n    +package org.apache.solr.core.snapshots;\n    +\n    +import java.io.IOException;\n    +import java.lang.invoke.MethodHandles;\n    +import java.util.Collection;\n    +import java.util.HashMap;\n    +import java.util.List;\n    +import java.util.Map;\n    +import java.util.Set;\n    +import java.util.function.Function;\n    +import java.util.stream.Collectors;\n    +\n    +import org.apache.lucene.index.DirectoryReader;\n    +import org.apache.lucene.index.IndexCommit;\n    +import org.apache.lucene.store.Directory;\n    +import org.apache.solr.core.snapshots.SolrSnapshotMetaDataManager.SnapshotMetaData;\n    +import org.slf4j.Logger;\n    +import org.slf4j.LoggerFactory;\n    +\n    +/**\n    + * This class provides functionality required to handle the data files corresponding to Solr snapshots.\n    + */\n    +public class SolrSnapshotManager {\n    +  private static final Logger log = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n    +\n    +  /**\n    +   * This method deletes index files of the \n{@linkplain IndexCommit} for the specified generation number.\n    +   *\n    +   * @param dir The index directory storing the snapshot.\n    +   * @param gen The generation number for the {@linkplain IndexCommit}\n    +   * @throws IOException in case of I/O errors.\n    +   */\n    +  public static synchronized void deleteIndexFiles ( Directory dir, Collection<SnapshotMetaData> snapshots, long gen ) throws IOException {\n    +    List<IndexCommit> commits = DirectoryReader.listCommits(dir);\n    +    Map<String, Integer> refCounts = buildRefCounts(snapshots,commits);\n    +    for (IndexCommit ic : commits) {\n    +      if (ic.getGeneration() == gen) \n{\n    +        deleteIndexFiles(dir,refCounts, ic);\n    +        break;\n    +      }\n    +    }\n    +  }\n    +\n    +  /**\n    +   * This method deletes all files not corresponding to a configured snapshot in the specified index directory.\n    +   *\n    +   * @param dir The index directory to search for.\n    +   * @throws IOException in case of I/O errors.\n    +   */\n    +  public static synchronized void deleteNonSnapshotIndexFiles (Directory dir, Collection<SnapshotMetaData> snapshots) throws IOException {\n    +    List<IndexCommit> commits = DirectoryReader.listCommits(dir);\n    +    Map<String, Integer> refCounts = buildRefCounts(snapshots, commits);\n    +    Set<Long> snapshotGenNumbers = snapshots.stream()\n    +                                            .map(SnapshotMetaData::getGenerationNumber)\n    +                                            .collect(Collectors.toSet());\n    +    for (IndexCommit ic : commits) {\n    +      if (!snapshotGenNumbers.contains(ic.getGeneration())) \n{\n    +        deleteIndexFiles(dir,refCounts, ic);\n    +      }\n    +    }\n    +  }\n    +\n    +  /**\n    +   * This method computes reference count for the index files by taking into consideration\n    +   * (a) configured snapshots and (b) files sharing between two or more \n{@linkplain IndexCommit} instances.\n    +   *\n    +   * @param snapshots A collection of user configured snapshots\n    +   * @param commits A list of {@linkplain IndexCommit}\n instances\n    +   * @return A map containing reference count for each index file referred in one of the \n{@linkplain IndexCommit}\n instances.\n    +   * @throws IOException in case of I/O error.\n    +   */\n    +  public static Map<String, Integer> buildRefCounts (Collection<SnapshotMetaData> snapshots, List<IndexCommit> commits) throws IOException {\n    \u2014 End diff \u2013\n\n    Actually we need to know the actual reference count for the unit test. But now I changed this method to be package protected. Hence we should be OK with this. ",
            "id": "comment-15388937"
        },
        {
            "date": "2016-07-26T05:44:10+0000",
            "author": "ASF GitHub Bot",
            "content": "Github user dsmiley commented on the issue:\n\n    https://github.com/apache/lucene-solr/pull/52\n\n    The last SolrSnapshotManager.deleteIndexFiles is still synchronized; I think you forgot this one? ",
            "id": "comment-15393268"
        },
        {
            "date": "2016-07-26T05:45:33+0000",
            "author": "David Smiley",
            "content": "Aside from my last comment RE one more synchronized to remove, I think I'm keen on getting this committed.  This is of course very new with tricky interactions with the rest of the code base so should be considered \"experimental\". ",
            "id": "comment-15393271"
        },
        {
            "date": "2016-07-26T13:03:47+0000",
            "author": "David Smiley",
            "content": "Please run \"ant precommit\".  I did and the first problem I see is that the \"snapshots\" package has no javadocs. ",
            "id": "comment-15393754"
        },
        {
            "date": "2016-07-26T18:48:57+0000",
            "author": "Hrishikesh Gadre",
            "content": "David Smiley Thanks for the review! I have removed the unnecessary synchronization and pushed the latest changes to github. I also fixed Javadocs related error and ensured that unit tests and precommit are passing. Please take a look.  ",
            "id": "comment-15394319"
        },
        {
            "date": "2016-07-28T17:08:10+0000",
            "author": "David Smiley",
            "content": "Attaching the patch file from your pull request.  I'm running tests now, then precommit.  If goes well I'll commit it and add CHANGES.txt. ",
            "id": "comment-15397833"
        },
        {
            "date": "2016-07-28T18:23:23+0000",
            "author": "ASF subversion and git services",
            "content": "Commit b7aa0b56bebcc22e63f0602a4ef15a728a799fc6 in lucene-solr's branch refs/heads/master from David Smiley\n[ https://git-wip-us.apache.org/repos/asf?p=lucene-solr.git;h=b7aa0b5 ]\n\nSOLR-9269: Snapshots (Solr core level) ",
            "id": "comment-15397959"
        },
        {
            "date": "2016-07-28T19:02:02+0000",
            "author": "ASF subversion and git services",
            "content": "Commit 0f26f11f6c52e2a621142460792ed79827618d28 in lucene-solr's branch refs/heads/branch_6x from David Smiley\n[ https://git-wip-us.apache.org/repos/asf?p=lucene-solr.git;h=0f26f11 ]\n\nSOLR-9269: Snapshots (Solr core level)\n(cherry picked from commit b7aa0b5) ",
            "id": "comment-15398029"
        },
        {
            "date": "2016-07-28T19:03:47+0000",
            "author": "David Smiley",
            "content": "Thanks so much for this great feature Hrishikesh Gadre! ",
            "id": "comment-15398033"
        },
        {
            "date": "2016-07-28T19:08:37+0000",
            "author": "ASF GitHub Bot",
            "content": "Github user dsmiley commented on the issue:\n\n    https://github.com/apache/lucene-solr/pull/52\n\n    I forgot to use the magic words in my commit to auto-close this, so you can close this. ",
            "id": "comment-15398041"
        },
        {
            "date": "2016-07-28T21:02:06+0000",
            "author": "ASF GitHub Bot",
            "content": "Github user hgadre closed the pull request at:\n\n    https://github.com/apache/lucene-solr/pull/52 ",
            "id": "comment-15398202"
        },
        {
            "date": "2016-07-29T14:04:18+0000",
            "author": "David Smiley",
            "content": "New test failure:  http://jenkins.thetaphi.de/job/Lucene-Solr-6.x-Windows/349/  TestReplicationHandler   Can you please investigate? ",
            "id": "comment-15399375"
        },
        {
            "date": "2016-08-02T21:12:19+0000",
            "author": "Hrishikesh Gadre",
            "content": "David Smiley sorry for late reply. Let me take a look. ",
            "id": "comment-15404804"
        },
        {
            "date": "2016-08-11T00:18:45+0000",
            "author": "ASF GitHub Bot",
            "content": "GitHub user hgadre opened a pull request:\n\n    https://github.com/apache/lucene-solr/pull/68\n\n    SOLR-9269 Refactor the snapshot cleanup mechanism to rely on Lucene\n\n    The current snapshot cleanup mechanism is based on reference counting\n    the index files shared between multiple segments. Since this mechanism\n    completely skips the Lucene APIs, it is not portable (e.g. it doesn't\n    work on 4.10.x version).\n\n    This patch provides an alternate implementation which relies exclusively\n    on Lucene IndexWriter (+ IndexDeletionPolicy) for cleanup.\n\nYou can merge this pull request into a Git repository by running:\n\n    $ git pull https://github.com/hgadre/lucene-solr SOLR-9269_update\n\nAlternatively you can review and apply these changes as the patch at:\n\n    https://github.com/apache/lucene-solr/pull/68.patch\n\nTo close this pull request, make a commit to your master/trunk branch\nwith (at least) the following in the commit message:\n\n    This closes #68\n\n\ncommit d329f03830b88d4214790b7c85e19c55e947e918\nAuthor: Hrishikesh Gadre <hgadre@cloudera.com>\nDate:   2016-08-10T23:59:31Z\n\n    SOLR-9269 Refactor the snapshot cleanup mechanism to rely on Lucene\n\n    The current snapshot cleanup mechanism is based on reference counting\n    the index files shared between multiple segments. Since this mechanism\n    completely skips the Lucene APIs, it is not portable (e.g. it doesn't\n    work on 4.10.x version).\n\n    This patch provides an alternate implementation which relies exclusively\n    on Lucene IndexWriter (+ IndexDeletionPolicy) for cleanup.\n\n ",
            "id": "comment-15416264"
        },
        {
            "date": "2016-08-26T13:58:36+0000",
            "author": "Michael McCandless",
            "content": "Bulk close resolved issues after 6.2.0 release. ",
            "id": "comment-15438945"
        },
        {
            "date": "2016-09-08T06:01:53+0000",
            "author": "ASF GitHub Bot",
            "content": "Github user hgadre commented on the issue:\n\n    https://github.com/apache/lucene-solr/pull/68\n\n    @dsmiley can you please take a look? ",
            "id": "comment-15472897"
        },
        {
            "date": "2016-10-06T16:04:19+0000",
            "author": "Yonik Seeley",
            "content": "Since this was released in 6.2 (and the issue closed), we should probably have a new JIRA for follow-on work. ",
            "id": "comment-15552339"
        },
        {
            "date": "2016-10-16T23:57:16+0000",
            "author": "ASF GitHub Bot",
            "content": "Github user hgadre commented on the issue:\n\n    https://github.com/apache/lucene-solr/pull/68\n\n    Created another PR as part of SOLR-9642. Hence closing this... ",
            "id": "comment-15580763"
        },
        {
            "date": "2016-10-16T23:57:16+0000",
            "author": "ASF GitHub Bot",
            "content": "Github user hgadre closed the pull request at:\n\n    https://github.com/apache/lucene-solr/pull/68 ",
            "id": "comment-15580764"
        }
    ]
}