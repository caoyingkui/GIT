{
    "id": "SOLR-104",
    "title": "Update Plugins",
    "details": {
        "affect_versions": "1.2",
        "status": "Closed",
        "fix_versions": [
            "1.2"
        ],
        "components": [
            "update"
        ],
        "type": "Improvement",
        "priority": "Major",
        "labels": "",
        "resolution": "Fixed"
    },
    "description": "The plugin framework should work for 'update' actions in addition to 'search' actions.\n\nFor more discussion on this, see:\nhttp://www.nabble.com/Re%3A-Handling-disparate-data-sources-in-Solr-tf2918621.html#a8305828",
    "attachments": {
        "DispatchFilter.patch": "https://issues.apache.org/jira/secure/attachment/12349111/DispatchFilter.patch",
        "HandlerRefactoring.DRAFT.zip": "https://issues.apache.org/jira/secure/attachment/12348911/HandlerRefactoring.DRAFT.zip",
        "commons-io-1.2.jar": "https://issues.apache.org/jira/secure/attachment/12349321/commons-io-1.2.jar",
        "HandlerRefactoring-DRAFT-SRC.zip": "https://issues.apache.org/jira/secure/attachment/12348913/HandlerRefactoring-DRAFT-SRC.zip",
        "commons-fileupload-20070107.jar": "https://issues.apache.org/jira/secure/attachment/12349320/commons-fileupload-20070107.jar",
        "HandlerRefactoring.DRAFT.patch": "https://issues.apache.org/jira/secure/attachment/12348910/HandlerRefactoring.DRAFT.patch"
    },
    "issue_links": {},
    "comments": [
        {
            "author": "Ryan McKinley",
            "id": "comment-12464557",
            "date": "2007-01-14T03:12:23+0000",
            "content": "I tried my hand at refactoring solr to have a more flexible plugin framework.  \n\nTo apply this patch, you will need to:\n1) apply: HandlerRefactoring.DRAFT.patch\n2) download HandlerRefactoring.DRAFT.zip and extract the contents to:\n    \\solr\\src\\java\\org\\apache\\solr\\handler\n\n(svn patches don' t let you add new directories!)\n\nAll tests pass, and http://localhost:8983/solr/select/ & http://localhost:8983/solr/update point to the same servlets as before and should behave exactly as they did before.\n\n\n\tI changed the RequestHandlers framework to map \"action\" > \"name\" > handler, rather then just \"name\" > handler\n\n\n\n\n\tI added a filter (SolrRequestFilter.java) that gets applied to every request and checks if the path is a registered \"action\".  If it is, it will be handled by the RequestHander otherwise it is passed down the filter chain.\n\n\n\n\n\tI refactored 'SolrParams' to handles the general case, not only query params.  I moved the specific params to o.a.s.handler.search.QueryParams.  I deleted a few deprecated parameter options: it just got too messy to refactor depricated things.\n\n\n\n\n\tI moved the 'query' handlers into org.apache.solr.handler.search.*  In general, handlers are in a package with the name of their action.\n\n\n\nTODO:\n\n\tThe generic SolrRequest must somehow encapsulate the posted stream\n\tAdd cookies, remote host, remote user to the SolrRequest?  (standard requests won't use them, but custom handlers may have a good use for them)\n\tand much much more!\n\n\n\n\n\t- - - - - - -\n\n\n\nUsage: \nhttp://localhost:8983/solr/${action}/${handler}?args\n\nIf no handler is specified, it will use the default handler for that action.\n\n\nCurrent: (still works)\nhttp://localhost:8983/solr/select/?q=solr  (current style)\n\nNew: (should be exact same output)\nhttp://localhost:8983/solr/search/?q=solr\nhttp://localhost:8983/solr/search/standard/?q=solr\nhttp://localhost:8983/solr/search/dismax/?q=solr\n\nhttp://localhost:8983/solr/update2/commit\nhttp://localhost:8983/solr/update2/optimize\n\nnote: I am using 'search' and 'update2' so that the old URL still works and points to what people are used to.\n\nDocument adding stubs:\nhttp://localhost:8983/solr/add/xml/\nhttp://localhost:8983/solr/add/csv/\nhttp://localhost:8983/solr/add/sql/\n\n\nLet me know what you think!\n "
        },
        {
            "author": "Ryan McKinley",
            "id": "comment-12464559",
            "date": "2007-01-14T04:03:39+0000",
            "content": "I just uploaded: HandlerRefactoring-DRAFT-SRC.zip.  It is not a patch, but it will be easier to integrate with /trunk.\n\n1) Extract the zip files\n2) Copy them into your solr directory.  Overwrite all files (svn will give you diff)\n3) delete the following files:  (they have been renamed or moved)\n\nsrc/java/org/apache/solr/request/DisMaxRequestHandler.java\nsrc/java/org/apache/solr/request/LocalSolrQueryRequest.java\nsrc/java/org/apache/solr/request/SolrQueryRequest.java\nsrc/java/org/apache/solr/request/SolrQueryRequestBase.java\nsrc/java/org/apache/solr/request/SolrRequestHandler.java\nsrc/java/org/apache/solr/request/StandardRequestHandler.java\nsrc/java/org/apache/solr/util/CommonParams.java\nsrc/java/org/apache/solr/util/DisMaxParams.java\n "
        },
        {
            "author": "Ryan McKinley",
            "id": "comment-12464640",
            "date": "2007-01-14T23:26:31+0000",
            "content": "I just upload a new version of HandlerRefactoring-DRAFT-SRC.zip\n\nIn addition to the 8 files above, also delete:\nsrc/java/org/apache/solr/request/SolrQueryResponse.java\nsrc/webapp/src/org/apache/solr/servlet/SolrServlet.java\nsrc/webapp/src/org/apache/solr/servlet/SolrUpdateServlet.java\n\nThere is also a clean copy on:\n  http://svn.lapnap.net/solr/handler-draft/solr/\nThis should be easier to install - or look at (without having to install)\n\nThis version converts everything to use the new framework rather then keeping /select and /update on the old one.  It also includes a draft proposal on how to deal with deal with GET vs POST body vs multipart content.\n\nIt passes all the tests and seems to work exactly as before (with a few exceptions)\n\n\t/update content is returned with a ResponseWriter\n\t[my-BUG] I am unable to get some posted content to read its stream properly.  I had to modify:\nhttp://svn.lapnap.net/solr/handler-draft/solr/example/exampledocs/post.sh\n\n\n\nto call:\n curl $URL --data-binary '<commit/>' -H 'Content-type:text/xml;' \nrather then just:\n curl $URL --data-binary '<commit/>'\n\n(any ideas?)\n\n\n\t- - - - - - -\n\n\n\nI define three basic types of request handlers in: http://svn.lapnap.net/solr/handler-draft/solr/src/java/org/apache/solr/handler/\n1) standard.  This gets everything from parameters (get or post) \n2) posted.  This gets a reader from the posted body:\nhttp://svn.lapnap.net/solr/handler-draft/solr/src/java/org/apache/solr/handler/PostedRequestHandler.java\n3) multipart.  This gets an iterator over each file item using commons-upload streaming API\nhttp://jakarta.apache.org/commons/fileupload/streaming.html\nhttp://svn.lapnap.net/solr/handler-draft/solr/src/java/org/apache/solr/handler/MultipartRequestHandler.java\n\nI think this takes care of every case...  is anything missing?\n\nThe http://svn.lapnap.net/solr/handler-draft/solr/src/webapp/src/org/apache/solr/servlet/SolrRequestFilter.java RequestFilter manages setting the reader or iterator for the proper handlers.\n\nWhen you run the example, i added the page http://localhost:8983/solr/up.html that should help you see a little of it in action.  \n\nI added an example for each type:\nhttp://svn.lapnap.net/solr/handler-draft/solr/src/java/org/apache/solr/handler/add/\n\n\n\t- -\n\n\n\nThis added:\ncommons-io-1.2.jar\nmysql-connector-java-5.0.4.jar\ncommons-fileupload-20070107.jar\n\nto the library.  If we want to get rid of commons-io, I am only using IOUtils.java\n\n\n\n\n\n\n\n\n\n\n\n "
        },
        {
            "author": "J.J. Larrea",
            "id": "comment-12464653",
            "date": "2007-01-15T04:47:46+0000",
            "content": "I think this is a fantastic effort, so please take my comments and suggestions for improvement below in the context of my appreciation you took the time to wade deeply into the SOLR request-handling code looking for places to improve it.  If the request structure is cleaned up along these lines it will make it much simpler for people to develop and contribute alternate request handlers (both update and query varieties) and further SOLRs standing as an open-source community-driven project.\n\n1. I really like your idea of using the URL suffix to specify the handler.  But it looks like you have required this to be a fixed 2-level hierarchy, with URLs of the form\n\n    http://<host>:<port>/<solr-root>/<action>/<handler>\n\nwhich are looked up in a handler table keyed by <action> and then <handler>. For example search/standard looks for a <requestHandler action=\"search\" name=\"standard\"...>, loads the indicated handler class, and associates it with the config.\n\nBut this hierarchy seems a little overdetermined and the implementation overcomplex.  It could be argued that one would want <handler>/<action>, for the <handler> alone to resolve to a handler class, and the handler class to be responsible for deciding how to act on the <action> part... but any hierarchical arrangement that makes perfect sense to one person can seem wrong to another. And in your implementation I see no actual action taken by the <action> argument other than selection of a per-<action> default <handler>, and that seems more complexity than it's worth; there are easier ways.\n\nI would suggest the simpler approach of simply taking the entire path after <solr-root> to be a handler configuration name,  without conforming it to any fixed hierarchy, e.g. a developer could set up\n\n\t<requestHandler name=\"search/products/bysku\" class=\"...\">...</>\n\t<requestHandler name=\"search/products/byname\" class=\"...\">...</>\n\t<requestHandler name=\"search/companies\" class=\"...\">...</>\n\t<requestHandler name=\"index/csv\" class=\"...\">...</>\n\nIn that way establishing a command/subcommand hierarchy is entirely up to the user's solrconfig.xml setup, and there is no imposed logic as to whether the different behavior between the 3 search examples is achieved through different config of the same handler class, different handler classes, or both.\n\nAs for default actions, there is no need for special code, they can entirely be defined in solrconfig.  For example, if a developer sets up a /search/xxx space as above, the response to a client request /search without further qualification is entirely up to what is defined in solrconfig.xml:\n\n\tIf there is no request handler defined under name=\"search\" SOLR would return a standard \"No handler found\" message\n\tIf it has a query request handler under that name (e.g. with name=\"search\" class=\"solr.StandardRequestHandler\") it would get to handle less-qualified requests with developer-defined defaults.\n\tIt could be defined to explicitly invoke your UnavailableRequestHandler \u2013 a great idea which should be extended so the error code and error message could be custom-configured with handler config params.\n\n\n\nThus I think this free-form hierarchy would achieve greater simplicity and greater flexibility at the same time.\n\n2. What would make this even more powerful would be the ability to \"subclass\" (meaning refine and/or extend) request handler configs: If the requestHandler element allowed an attribute extends=\"<another-requesthandler-name>\" and chained the SolrParams, then one could do something like:\n\n  <requestHandler name=\"search/products/all\" class=\"solr.DisMaxRequestHandler\" >\n    <lst name=\"defaults\">\n     <float name=\"tie\">0.01</float>\n     <str name=\"qf\">\n        text^0.5 features^1.0 name^1.2 sku^1.5 id^10.0 manu^1.1 cat^1.4\n     </str>\n     ... much more, per the \"dismax\" example in the sample solrconfig.xml ...\n  </requestHandler>\n\n  ... and replacing the \"partitioned\" example ...\n  <requestHandler name=\"search/products/instock\" extends=\"search/products/all\" >\n    <lst name=\"appends\">\n      <str name=\"fq\">inStock:true</str>\n    </lst>\n  </requestHandler>\n\nOne could even allow the extending requestHandler to set a different handler class, in the case where the difference in behavior requires a different handler implementation but can share all or part of the params.\n\n3. Structuring the code and action under /add is conceptually limiting because update-style request plugins such as SQL-based or CSV-based (and certainly XML-based) should still be able to add, replace, and delete, either based on internal logic or external command.\n\nYour code suggests further refactoring improvements along those lines.  For example, in your SQLUpdateHandler example you call:\n\n    AddUpdateCommand cmd = UpdateUtils.getAddUpdateCommandFromParams( params );\n\nand then for each assembled Document\n\n    cmd.doc = docmap.toDocument( schema );\n    UpdateUtils.addDoc( cmd );\n\t[which does SolrCore.getSolrCore().getUpdateHandler().addDoc( cmd );]\n    addedDocumentCount++;\n\nLets say:\n\n  A. We standardized on action=... as a way to define an action in a param\n\n  B. A new method UpdateUtils.getUpdateCommandFromParams( params ) would use the action= param to decide which xxxUpdateCommand class to instantiate \u2013 though this might be better placed as a static class method getCommandFromParams defined in UpdateCommand itself.\n\n(Perhaps once it decodes the action param it could call another UpdateCommand static method getCommandFromString( name ), which would centralize the instantiation logic, and provide a pathway for it it to evolve into a name->class soft mapping should extensibility to other commands ever be desired.)\n\n  C. Responsibility for initializing each update command from params would be the responsibility of the xxxUpdateCommand itself, e.g. base class UpdateCommand would define an abstract initializeFromParams( params ) which each subclass would implement.\n\n  D. Responsibility for executing each update command would also lay with the xxxUpdateCommand via an abstract execute() method, which for AddUpdateCommand would be:\n\n    SolrCore.getSolrCore().getUpdateHandler().addDoc( this );\n\n(It could be argued that some of the various UpdateHandler functionality should migrate to the xxxUpdateCommands themselves, but that's another discussion)\n\n  E. The DeleteUpdateCommand could allow the target record to be defined by setting a Document, and using the schema keyfield definition to extract the ID.  The logic could be encapsulated in DeleteUpdateCommand.execute() itself, extracting the keyfield value from the Document and setting it in its own id field before calling getUpdateHandler().delete( cmd ). Or if setters were defined for the internal fields, setDocument(doc) could call setId(id) and not need to keep a reference to the document.  In either case the existing UpdateHandlers don't even need to know about this new modality.\n\nThen SQLUpdateHandler or CSVUpdateHandler or whatever (which should really be called xxxRequestHandler since UpdateHandler is quite another beast) would be agnostic as to whether they are doing adds or deletes of the selected rows; they could just ask for an UpdateCommand implementation, and in a loop set the constructed Document, and call updateCommand.execute().  While it would be most efficient if for deletes the query or data file only specified a single keyfield column, there is no harm in creating Documents with many more fields and simply ignoring all but the keyfield.\n\nEither way one could set up an explicit deletion-only CSV handler:\n\n    <!-- Could be csv/delete, delete/csv, product/delete, or whatever -->\n    <requestHandler name=\"csv/delete\" class=\"solr.CSVUpdateHandler\">\n        <lst name=\"invariants\">\n            <str name=\"action\">delete</str>\n\t</lst>\n    </requestHandler>\n\nor more flexibly allow the parameter to be passed in a URL query param:\n\n    /<solr-root>/update/product?action=delete&...\n\n4. Similarly with this structure your CommitHandler and OptimizeHandler classes can be replaced with a simple CommandHandler which is defined in solrconfig; it could even handle deletion by ID or query:\n\n    <requestHandler name=\"commit-and-flush\" class=\"solr.CommandHandler\">\n        <lst name=\"invariants\">\n            <str name=\"action\">commit</str>\n            <str name=\"waitFlush\">true</str> \n\t</lst>\n        <lst name=\"defaults\">\n            <str name=\"waitSearcher\">false</str>\n\t</lst>\n    </requestHandler>\n\n5. Of course a RequestHandler could be non-command-agnostic as well, for example the XML update parsing code now in SolrCore.update() could be recast as a RequestHandler which reads the <add>, <delete>, <commit>, <optimize> tags and decides itself which type of UpdateCommand(s) to instantiate (using UpdateCommand.getCommandFromString as described above).\n\nBut it could be made more agnostic and simpler still, for example by parsing the action and parameters from XML into a SolrParams and calling getCommandFromParams as described above.  That would forge a path for other non-XML command-stream-based  update handlers by leaving only XML parsing logic in the XML update RequestHandler \u2013 all the rest of the logic would be in UpdateCommand, the UpdateCommand implementations, and UpdateHandler.\n\nAnyway, those are some ideas, for what they're worth. "
        },
        {
            "author": "J.J. Larrea",
            "id": "comment-12464654",
            "date": "2007-01-15T05:01:31+0000",
            "content": "6. I may be going a little crazy with this soft-configuration concept, but thinking about how to support the legacy\n\n    /select?qt=faceted...\n\nformat leads me to think there could be a trivial (3-line handleRequestBody) NamedRequestHandler which uses one parameter to provide the name of another parameter which names another requestHandler definition which it would then invoke.  With that,\n\n\t<requestHandler name=\"select\" class=\"solr. NamedRequestHandler\">\n\t    <lst name=\"invariants\">\n\t\t<str name=\"handlerNameParameter\">qt</str>\n\t    </lst>\n\t    <lst name=\"defaults\">\n\t\t<str name=\"qt\">standard</str>\n\t    </lst>\n\t</requestHandler>\n\nwould allow /select?qt=dismax... to be soft-implemented; a developer who had no use for the non-URL-path selectors could strip it out, another developer who wanted to use a different parameter to set the handler could define it that way. "
        },
        {
            "author": "Yonik Seeley",
            "id": "comment-12464655",
            "date": "2007-01-15T05:07:24+0000",
            "content": "I haven't had a chance to look at all this stuff yet, but we should take care to not try and implement too much.\nIn some cases the right \"plugin\" mechanism might be the servlet spec and web.xml (made me think of it when I saw the \"cookies\" comment  "
        },
        {
            "author": "Ryan McKinley",
            "id": "comment-12464667",
            "date": "2007-01-15T07:05:27+0000",
            "content": "I agree with points J.J's points 1-6.  thanks\n\nIf one were to look at only one thing, the stuff i to look at woud be how Handlers get their parameters and content streams. \n\nfrom my previous post:\n\nI define three basic types of request handlers in: http://svn.lapnap.net/solr/handler-draft/solr/src/java/org/apache/solr/handler/\n1) standard. This gets everything from parameters (get or post)\n2) posted. This gets a reader from the posted body:\nhttp://svn.lapnap.net/solr/handler-draft/solr/src/java/org/apache/solr/handler/PostedRequestHandler.java\n3) multipart. This gets an iterator over each file item using commons-upload streaming API\nhttp://jakarta.apache.org/commons/fileupload/streaming.html\nhttp://svn.lapnap.net/solr/handler-draft/solr/src/java/org/apache/solr/handler/MultipartRequestHandler.java\n\nand: http://svn.lapnap.net/solr/handler-draft/solr/src/webapp/src/org/apache/solr/servlet/SolrRequestFilter.java  fills them up.  \n\nIt currently uses instanceof... any other ideas?  \n\n\n\n\n\n "
        },
        {
            "author": "Ryan McKinley",
            "id": "comment-12465538",
            "date": "2007-01-17T20:13:26+0000",
            "content": "I attached 'DispatchFilter.patch'  This extracts some stuff from my previous (monstrous) refactoring that will be useful.  I did not refactor anything, but I did:\n\n\n\tAdded SolrRequestParser interface\n\tAdded ContentStream interface\n\tExtracted common handler code into RequestHandlerBase.\n\tAdded 'getRequestParser() to Handler interface.  The RequestHandlerBase would return a Parser from the 'invariant' 'rp'\n\tmodified StandardRequest/DisMaxRequest to use the HandlerBase\n\tAdded Iterable<ContentStream> getContentStreams() to SolrQueryRequest\n\tAdded UpdateHandlerRequest that acts as /update  The only difference is the returned format\n\tReplaced SolrServelt and UpdateServlet with SolrRequestFilter.  This now dispatches all requests\n\n\n\nWith the example solrconfig.xml, you can run queries like:\n http://localhost:8983/solr/select/?q=solr\n http://localhost:8983/solr/standard?q=solr\n http://localhost:8983/solr/dismax?q=solr\n http://localhost:8983/solr/dismax?q=solr\n http://localhost:8983/solr/instock?q=solr\n http://localhost:8983/solr/update \n\n\nTODO: \n\n\tactually build the RequestParser registry.  currently everything returns StandardRequestParser\n\thandle multipart requests in StandardRequestParser\n\tmove update( reader, writer ) out of SolrCore into UpdateRequestHandler\n\n\n\n\n\n\t- - - - -\nSVN NOTE: \n\n\n\nwhen i tested this patch, I got strange results for the files it added.  Specifically, new files are repeated twice.\n\nsrc\\java\\org\\apache\\solr\\handler\\UpdateRequestHandler.java\n package org.apache.solr.handler;\n public class UpdateRequestHandler()\n {\n   ...\n }\n\n package org.apache.solr.handler;\n public class UpdateRequestHandler()\n {   ... }\n\nDelete the second copy of the class it it will compile ok.\n\n\n\t- - - - -\n\n\n\nIs it possible to delete previous file attachments?  I don't think  HandlerRefactoring.DRAFT.* is useful for anyone to see anymore.\n\nryan\n\n\n\n "
        },
        {
            "author": "Ryan McKinley",
            "id": "comment-12465563",
            "date": "2007-01-17T21:18:05+0000",
            "content": "removed getRequestParser() from Handler interface.\n\nusing ':' in the URL to specify the request parser.\n\n http://localhost:8983/solr/standard:requestparser?q=video\n\nNOTE:  it still uses a defalt request parser. "
        },
        {
            "author": "Ryan McKinley",
            "id": "comment-12466273",
            "date": "2007-01-20T19:44:24+0000",
            "content": "I just updated DispatchFilter.path to implement most of our discussion on solr-dev\n\nThe implemented URL structure is:\nhttp://${host}:${port}/${context}/${path/defined/in/solrconfig.xml}:${optional/path/for/handler}?${params}\n\n(If there needs to be a constant between ${context}  and  ${path} I am ok with it, but i don't think its necessary.)\n\nIf you get this running, check:\nhttp://localhost:8983/solr/test.html\n\nThis is a test page that shows the various methods to get streamed content into the handler\n\n\twith param stream.URL - puts the content of remote url into stream\n\twith stream.BODY - puts the content of the parameter into a stream\n\tmultipart upload.  put the fields into SolrParams and the Files into streams\n\tPOST with no query string.  - uses the fields to fill SolrParams\n\tPOST with query string.  - uses the post body as the ContentStream, fills SolrParams from the query string\n\n\n\nI think this covers all the normal cases.  If you can think of others, let me know.  I believe things that would iterate over a huge collection of streams should be implemented as a RequestHandler, not as the RequestBuilder\n\n\n\t- - - - - - - - - -\n\n\n\nThings to note:\n\n1) /select and /update are handled with their same old servlets.  They have just been refactored to LegacyUpdateServlet etc.  I think the example solrconfig.xml should map /update to the new framework, not the old one.  This would get people who start using solr to use the new framework, but still work for people who don't map /update in their solrconfig.xml.  This would also require we change the included 'post.sh' to use: URL=http://localhost:8983/solr/update?stream  (so the content is read as a stream)\n\n2) Even when /update is mapped to the legacy servlet, you can map subfolders to the new one.  I included /update/commit in this patch\n\n3) Configuration?  Where should we configure enable/disable streams?  max file upload size?  upload temp directory?  I REALLY think its a bad idea to enable stream.URL by default.  Although the model is that solr sits in a private network, we know that is not always the case.  It may also be good to configure a required user role to be able to stream.  for example, stream.URL requires isUserInRole( 'admin' );\n\n4) Sending context to handlers.  Some handlers will want/need additional information about the request (headers,user,remote host,path, etc).  In this patch, I add 'path' to all requests.  There should be a way for the handler to say what information it needs\n\n\nryan "
        },
        {
            "author": "Ryan McKinley",
            "id": "comment-12466277",
            "date": "2007-01-20T20:34:32+0000",
            "content": "\nI just thought of something that will make Hoss' blod curl!  I KNOW it\nis a bad idea for things within solr-core, but it would be the\ncleanest/cheapest way to expose the unknown things a potential\nRequestHandler would want from the HttpServletRequest without changing\nthe existing API.  It goes like this:\n\n  SolrRequest solrReq = (build the solr request)\n  solrReq.getContent().put( \"HttpServletRequest\", req );\n\nIt would never be used by anything in core.\n\nThe alternative I see is to give each handler some mechanism to tell\nthe RequestBuilder what attributes it needs set, then have the\nRequestBuilder put those attributes in the context or solr params.  In\nmy opinion, that is a lot of overhead to do stuff that clearly falls\noutside of what solr-core should be doing.\n\nryan "
        },
        {
            "author": "Ryan McKinley",
            "id": "comment-12466356",
            "date": "2007-01-21T21:40:37+0000",
            "content": "this can replace the special servlet for SOLR-85 "
        },
        {
            "author": "Ryan McKinley",
            "id": "comment-12466357",
            "date": "2007-01-21T21:41:19+0000",
            "content": "can be implemented with RequestHandler with ContentStreams "
        },
        {
            "author": "Ryan McKinley",
            "id": "comment-12466358",
            "date": "2007-01-21T21:42:09+0000",
            "content": "could be implemented with ContentStreams "
        },
        {
            "author": "Ryan McKinley",
            "id": "comment-12466359",
            "date": "2007-01-21T21:47:47+0000",
            "content": "this extracts the common things into RequestHandlerBase "
        },
        {
            "author": "Yonik Seeley",
            "id": "comment-12466912",
            "date": "2007-01-24T05:58:11+0000",
            "content": "Finally got a chance to review this... it's really great stuff Ryan!\n\nRandom questions:\n\n\tWhat's the funny chars at the start of web.xml?\n\tWhy is there a 2MB upload limit, and why does it only apply to multi-part uploads?  I think I'm missing some background in this area...\n\n\n\nI'm not going to try and pick out little bugs or suggest little changes to a patch of this scope and size...\nI think we should have more frequent Solr releases, and that the Solr trunk  can have APIs change from one day to the next w/o having to maintaining back-compatibility.\n\nSo since we agree on the direction, I think this patch should be committed and we should work from there.\nI'd like to hear from hoss though, since he was following along more than I was, esp at the start of that marathon thread. "
        },
        {
            "author": "Yonik Seeley",
            "id": "comment-12466913",
            "date": "2007-01-24T06:01:21+0000",
            "content": "Oh, and where possible, it would be nice to have some unit tests.\nServlet related stuff is probably too hard, but things like stream.body should be easy. "
        },
        {
            "author": "Ryan McKinley",
            "id": "comment-12466914",
            "date": "2007-01-24T06:02:54+0000",
            "content": "If there are funny chars at the start of web.xml, it was an SVN error.\n\nthe 2MB limit is set in solrconfig.xml\n\n  <requestParsers enableRemoteStreaming=\"true\" multipartUploadLimitInKB=\"2048\" />\n\nmaybe 2MB is too small as the default, but i figured it shoudl be configurable.\n "
        },
        {
            "author": "Ryan McKinley",
            "id": "comment-12466928",
            "date": "2007-01-24T07:30:28+0000",
            "content": "This is minor changes to the previous filter it \n\n1. Adds unit tests for stream.BODY and stream.URL\n2. uses different init logic for HandlerBase and DisMax (legacy stuff)\n3. Adds Size() to the content stream.  filled up if we know it otherwise not.\n4. A few comments here and there... "
        },
        {
            "author": "Hoss Man",
            "id": "comment-12467305",
            "date": "2007-01-25T09:35:22+0000",
            "content": "Woot! ... i think we're really close to comiting this. \n\nI made a hodgepodge list of comments as i read through everything, and then tried to organize them.  I agree with yonik that we should feel free to commit new functionality without being afraid of needing to change the api of that functionality befor the next release, but i'm not 100% comfortable with how backwards compatible this patch is for the existing /select and /update URLs ... this may just be an issue of me being paranoid (and tired) but there's at least one code path difference.\n\nAnyway, here are my notes...\n\n\n\n\n\nComments regarding backwards compatibility of the patch...\n\n\n\tSolrCore.update(Reader,Writer) was a public method that's been\n   removed ... this is probably fine, just pointing it out for the \n   record.\n\tSolrUpdateServlet used HttpServletRequest.getReader, the new\n   UpdateRequestHandler uses an InputStreamReader arround\n   HttpServletRequest.getInputStream() ... this seems bad for legacy\n   update support from a char encoding standpoint.\n\tWhile i think it's important to refactor the XML Update\n   parsing out of SolrCore - I'm still not clear what is gained by \n   eliminating SolrServlet and SolrUpdate.  The big advantage of\n   the new dispatcher being a Filter is that it can pass requests on\n   that it doesn't want to deal with, so why not leave the existing\n   servlets arround with only the minimum neccessary changes...\n\tmove SolrCore's init to Dispatcher\n\tuse 3 arg core.execute in SolrServlet\n\thave SolrUpdateServlet call UpdateRequestHandler.update(Reader)\n      and generate the legacy response XML\n   ...in order to reduce the possibility of an introducing bugs\n   (particularly since the existing Servlets are the one area where we\n   don't have any unit tests)\n\n\n\nComments regarding functionality that i think we may want to address\nbefore commiting (but i won't fight over if i'm the only one that cares)...\n\n\n\tUpdateRequestHandler should probably renamed XmlUpdateRequestHandler\n   (particularly since i expect Yonik to commit a\n   CsvUpdateRequestHandler real soon now) \n\tStandardRequestParser can't assume that a POST which isn't\n   multipart/* should be handled by a RawRequestParser ... if the\n   content type is \"application/x-www-form-urlencoded\" then\n   SimpleRequestParser should be used (so all params from query string\n   and body are included)\n\tWhat should the expectations of\n   ContentStream.getInputStream().close() be? Should the Dispatcher\n   iterate over any Iterable streams when writing the output and try\n   to close them, ignoring any Exceptions?\n\tI'm really not fond of having SolrParams.STREAM_TYPE. Can we please,\n   please leave it out for now and rely on on content-type detection?\n   We can add it back in if/when we make RequestParser a public\n   interface and let people register them in solrconfig.\n\tI really don't think we want to open the pandoras box of putting\n   the HttpServletRequest in the SolrQueryRequest ... i'd hate to put\n   that in and then have to support it forever.\n\n\n\nThings in the current patch that aren't strictly neccessary\nfor the current issue and can (should?) be commited seperately...\n\n\n\tare we definitely deprecating SolrQueryResponse.getException ?\n\tStandardRequestHandler and DisMaxRequestHandler have only been\n   changed to subclass the new base class.\n\tonly whitespace changes in SolrRequestHandler.java\n\tSolrServletRequest has only imports rearranged\n\n\n\nThings which definitely shouldn't block up the patch, but should go on\na short term todo list...\n\n\n\tsee backwards compatibility comment about (Xml)UpdateRequestHandler\n   using InputStreamReader without specifying a charset ... in general\n   the handler should look at the ContentStream's content type to determine\n   the encoding of the InputStream (and probably default to UTF-8)\n\tneed to work out what kind of NamedList should be returned by\n   (Xml)UpdateRequestHandler.update(Reader)\n\tsome of the new files are missing the Apache boilerplate.\n\ta use case we talked about that still isn't covered is opening local\n   files as a stream ... this should be easy to add later right along \n   side STREAM_URL.\n\twe should fill in the getURL methods for DisMax/Standard to point at wiki\n\tCommitRequestHandler should use UpdateParams.OPTIMIZE\n\tthe init semantics for (Xml)UpdateRequestHandler are odd: as a\n   RequestHandler it's garunteed that init(NamedList) will be called, but\n   instead it uses it's own private init() that's called lazily.\n\tDumpRequestHandler should dump ContentStream.getSize().\n\tdoFilter should call parsers.parse( path, req ) as soon as it has\n   the path, and then delegate to a helper method that doesn't have \n   access to the HttpServletRequest ... this reduces both the\n   complexity of the method, and the likelyhood of \n   someone inadvertently introducing an error (mangling the POST body)\n   when making future changes in the long deep method.  \n   The one thing to watch out for is forcing POST in legacy\n   update. (assuming legacy update stays in the Filter) \n\tSTREAM_URL based ContentStreams can have a meaningful getSize()\n   and getContentType() if we use openConnection instead of openStream.\n\tSTREAM_BODY based ContentStreams can get their size from the char[]\n\tit's not clear to me why the interface for SolrRequestParser is...\n     public SolrParams parseParamsAndFillStreams(\n       final HttpServletRequest, ArrayList<ContentStream>)\n   ...instead of just...\n     public SolrQueryRequest(final HttpServletRequest)\n   ...with the param parsing loops in\n   SolrRequestParsers.buildRequestFrom \n   in static utility methods (in case a RequestParser doesn't want to\n   support STREAM_URL or STREAM_BODY)\n\n\n\n\n\n "
        },
        {
            "author": "Ryan McKinley",
            "id": "comment-12467330",
            "date": "2007-01-25T11:10:49+0000",
            "content": "\nThanks for going through this!\n\nI'll comment on points i have answers or questions.  The rest will go\non the TODO list.\n\n\nOk, so we should make sure to put the charset into\nContentStream.getContentType() and open the Reader with:\n\n  String charset = getCharset( stream.getContentType() );\n  new InputStreamReader( stream.getStream(),  charset );\n\n\n\nSounds reasonable.  I took them out because (at the time) it seemed\nclearer and has less duplicated code.\n\n\n\nyes.  At some point it would also be good to make a stronger name\ndistinction between UpdateHandler (the thing that handles the nity\ngritty lucene indexing) and the UpdateRequestHandler \u2013 but lets save\nthat for another day!\n\n\n\nAs written, the StandardRequestParser:\n1) checks if multipart\n2) checks if it has parameters in the URL (?xxx=yyy)\n  if it has parameters (?xxx=yyy) then use the RawRequestParser\n  otherwise it pulls parameters from the map. (SimpleRequestParser)\n\nTo trigger raw request reading you must have a parameter on the URL.\n This was my design in response to Yonik's observation that curl puts\n\"application/x-www-form-urlencoded\" in the header even if it is not\nform-urlencoded encoded.\n\nAs written, it does not rely on clients putting accurate headers\n(except for multipart) - it relies on a URL convention.\n\n\n\nI only put it in there to make you happy!  I'll take it out and we can\ndeal with it later if necessary.\n\n\n\nI didn't think i could get that past you!  I'll take it out and save\nthe pleeding for another time.\n\n\n\nfor a local file, you can use stream.url=file:///C:/pathtofile.txt,\nfor remote ones, you use stream.url=http://...\n\nWe should have a good notice in the config warning people to have some\nsecurity running before enabling streaming.\n\n\n\nI had implemented it the normal way, BUT it broke many tests (since\nthey never call init).   The better solution is to make sure the tests\ncall init a standard way, but that got me into editing many files I\ndon't quite understand, so i opted for lazy init.\n\n\nThat sounds fine.  Since it is a tenative private interface, i was not\ntoo worried about it. "
        },
        {
            "author": "Ryan McKinley",
            "id": "comment-12467755",
            "date": "2007-01-26T08:29:57+0000",
            "content": "\nHymm, this is awkward.  I'm not quite sure what happened.  But this is what I thought I sent.  (I apologize that you already took the time to try to decipher it).  I'll include the original, for clarification\n\n\n\t- - - - - -\n\n\n\n>\n> Woot! ... i think we're really close to comiting this.\n>\n\nThanks for going through this!\n\nI'll comment on points i have answers or questions.  The rest will go\non the TODO list.\n\n>  - SolrUpdateServlet used HttpServletRequest.getReader, the new\n>    UpdateRequestHandler uses an InputStreamReader arround\n>    HttpServletRequest.getInputStream() ... this seems bad for legacy\n>    update support from a char encoding standpoint.\n\nOk, so we should make sure to put the charset into\nContentStream.getContentType() and open the Reader with:\n\n String charset = getCharset( stream.getContentType() );\n new InputStreamReader( stream.getStream(),  charset );\n\n\n>  - While i think it's important to refactor the XML Update\n>    parsing out of SolrCore - I'm still not clear what is gained by\n>    eliminating SolrServlet and SolrUpdate.  The big advantage of\n>    the new dispatcher being a Filter is that it can pass requests on\n>    that it doesn't want to deal with, so why not leave the existing\n>    servlets arround with only the minimum neccessary changes...\n\nSounds reasonable.  I took them out because (at the time) it seemed\nclearer and has less duplicated code.\n\n\n> Comments regarding functionality that i think we may want to address\n> before commiting (but i won't fight over if i'm the only one that cares)...\n>\n>  - UpdateRequestHandler should probably renamed XmlUpdateRequestHandler\n>    (particularly since i expect Yonik to commit a\n>    CsvUpdateRequestHandler real soon now)\n\nyes.  At some point it would also be good to make a stronger name\ndistinction between UpdateHandler (the thing that handles the nity\ngritty lucene indexing) and the UpdateRequestHandler \u2013 but lets save\nthat for another day!\n\n\n>  - StandardRequestParser can't assume that a POST which isn't\n>    multipart/* should be handled by a RawRequestParser ... if the\n>    content type is \"application/x-www-form-urlencoded\" then\n>    SimpleRequestParser should be used (so all params from query string\n>    and body are included)\n\nAs written, the StandardRequestParser:\n1) checks if multipart\n2) checks if it has parameters in the URL (?xxx=yyy)\n if it has parameters (?xxx=yyy) then use the RawRequestParser\n otherwise it pulls parameters from the map. (SimpleRequestParser)\n\nTo trigger raw request reading you must have a parameter on the URL.\n This was my design in response to Yonik's observation that curl puts\n\"application/x-www-form-urlencoded\" in the header even if it is not\nform-urlencoded encoded.\n\nAs written, it does not rely on clients putting accurate headers\n(except for multipart) - it relies on a URL convention.\n\n\n>  - I'm really not fond of having SolrParams.STREAM_TYPE. Can we please,\n>    please leave it out for now and rely on on content-type detection?\n>    We can add it back in if/when we make RequestParser a public\n>    interface and let people register them in solrconfig.\n\nI only put it in there to make you happy!  I'll take it out and we can\ndeal with it later if necessary.\n\n\n>  - I really don't think we want to open the pandoras box of putting\n>    the HttpServletRequest in the SolrQueryRequest ... i'd hate to put\n>    that in and then have to support it forever.\n\nI didn't think i could get that past you!  I'll take it out and save\nthe pleading for another time.\n\n\n>  - a use case we talked about that still isn't covered is opening local\n>    files as a stream ... this should be easy to add later right along\n>    side STREAM_URL.\n\nfor a local file, you can use stream.url=file:///C:/pathtofile.txt,\nfor remote ones, you use stream.url=http://...\n\nWe should have a good notice in the config warning people to have some\nsecurity running before enabling streaming.\n\n\n>  - the init semantics for (Xml)UpdateRequestHandler are odd: as a\n>    RequestHandler it's garunteed that init(NamedList) will be called, but\n>    instead it uses it's own private init() that's called lazily.\n\nI had implemented it the normal way, BUT it broke many tests (since\nthey never call init).   The better solution is to make sure the tests\ncall init a standard way, but that got me into editing many files I\ndon't quite understand, so i opted for lazy init.\n\n>  - it's not clear to me why the interface for SolrRequestParser is...\n>      public SolrParams parseParamsAndFillStreams(\n>        final HttpServletRequest, ArrayList<ContentStream>)\n>    ...instead of just...\n>      public SolrQueryRequest(final HttpServletRequest)\n>    ...with the param parsing loops in\n>    SolrRequestParsers.buildRequestFrom\n>    in static utility methods (in case a RequestParser doesn't want to\n>    support STREAM_URL or STREAM_BODY)\n>\n\nThat sounds fine.  Since it is a tentative private interface, i was not\ntoo worried about it.\n\n\n\n "
        },
        {
            "author": "Ryan McKinley",
            "id": "comment-12467787",
            "date": "2007-01-26T11:23:57+0000",
            "content": "\nOk, I just uploaded (hopefully) a final version.  It takes care of (most) everything you suggest.\n\n\n>  - SolrUpdateServlet used HttpServletRequest.getReader, the new\n>    UpdateRequestHandler uses an InputStreamReader arround\n>    HttpServletRequest.getInputStream() ... this seems bad for legacy\n>    update support from a char encoding standpoint.\n\nCan you check: XmlUpdateRequestHandler.handleRequestBody();\n\nI added a check for charset, but am not totally confident in the method.\n\n\n>  - StandardRequestParser can't assume that a POST which isn't\n>    multipart/* should be handled by a RawRequestParser ... if the\n>    content type is \"application/x-www-form-urlencoded\" then\n>    SimpleRequestParser should be used (so all params from query string\n>    and body are included)\n\ndone.  \n\n\n>  - What should the expectations of\n>    ContentStream.getInputStream().close() be? Should the Dispatcher\n>    iterate over any Iterable streams when writing the output and try\n>    to close them, ignoring any Exceptions?\n\nEach handler is responsible to make sure they are closed.  Since it is an Iterable<ContentStream> - I don't think it is OK to iterate a second time.  If we make it a Collection<> then that would be a reasonable behavior.\n\n\n> \n> Things in the current patch that aren't strictly neccessary\n> for the current issue and can (should?) be commited seperately...\n> \n>  - are we definitely deprecating SolrQueryResponse.getException ?\n\nI took it out. we can commit it separately.\n\n>  - StandardRequestHandler and DisMaxRequestHandler have only been\n>    changed to subclass the new base class.\n\nI left it in.  You can ignore changes to StandardRequestHandler and DisMax if that makes more sense.\n\n\n>  - doFilter should call parsers.parse( path, req ) as soon as it has \n>    the path, and then delegate to a helper method that doesn't have \n>    access to the HttpServletRequest ... this reduces both the\n>    complexity of the method, and the likelyhood of \n>    someone inadvertently introducing an error (mangling the POST body)\n>    when making future changes in the long deep method.  \n>    The one thing to watch out for is forcing POST in legacy\n>    update. (assuming legacy update stays in the Filter) \n\nI removed the legacy handling from SolrDispatchFilter - this simplifies it greatly, so i'm not sure if you still think this is necessary.\n\n\n>  - it's not clear to me why the interface for SolrRequestParser is...\n>      public SolrParams parseParamsAndFillStreams(\n>        final HttpServletRequest, ArrayList<ContentStream>)\n>    ...instead of just...\n>      public SolrQueryRequest(final HttpServletRequest)\n>    ...with the param parsing loops in\n>    SolrRequestParsers.buildRequestFrom \n>    in static utility methods (in case a RequestParser doesn't want to\n>    support STREAM_URL or STREAM_BODY)\n> \n\nI left it as is for now.  Since it is a private interface, we should feel free to clean it up / change it as we see fit.  But now I go to sleep!\n "
        },
        {
            "author": "Hoss Man",
            "id": "comment-12468403",
            "date": "2007-01-29T20:38:02+0000",
            "content": "Kick Ass!\n\nRyan, Everything looks great ... I've commited a minor variation on your latest patch.\n\nModifications I made to your patch before commiting...\n\n\tRemoved an empty handleRequest method from SolrDispatchFilter\n\tcleaned up some funky chars in web.xml\n\tmoved LICENSE info to top of all new files (before package declaration)\n\trefactored some duplicate code from SolrUpdateServlet and TestHarness\n   into XmlUpdateRequestHandler.doLegacyUpdate\n\tdid not commit test.html\n\tI also set svn:keywords on all of your new RequestHandlers, as well\n   as the DisMaxRequestHandler (aparently it had never been set there,\n   so the keywords weren't getting replaced properly)\n\n\n\n(The charset detection from content-type seems good enough for now ... there's some more crazy stuff that can be done diferentiating between text/xml and application/xml and inspecting the InputStream itself for specific indicator bytes \u2013  but that can be dealt with in SOLR-96).\n\nThanks for putting in all of this work, and sticking with it through my (most likely extremely paranoid) critical comments ... what you've done is really going to help catapult Solr's flexibility.\n "
        },
        {
            "author": "Ryan McKinley",
            "id": "comment-12468406",
            "date": "2007-01-29T20:53:14+0000",
            "content": "Thanks Hoss! "
        }
    ]
}