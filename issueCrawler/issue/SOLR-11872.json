{
    "id": "SOLR-11872",
    "title": "Refactor test infra to work with a managed SolrClient; ditch TestHarness",
    "details": {
        "labels": "",
        "priority": "Major",
        "components": [
            "Tests"
        ],
        "type": "Improvement",
        "fix_versions": [],
        "affect_versions": "None",
        "resolution": "Unresolved",
        "status": "Open"
    },
    "description": "This is a proposal to substantially refactor SolrTestCaseJ4 and some of its intermediate subclasses\u00a0in the hierarchy. \u00a0In essence, I envision that tests should\u00a0work with a SolrClient typed \"solrClient\" field managed by the test infrastructure. With only a few lines of code, a test should be able to pick between an instance based on EmbeddedSolrServer (lighter tests), HttpSolrClient (tests HTTP/Jetty behavior directly or indirectly), SolrCloud, and perhaps a special one for our distributed search tests. STCJ4 would refactor its methods to use the solrClient field instead of TestHarness. TestHarness would disappear as-such; bits of its existing code would migrate elsewhere, such as to manage an EmbeddedSolrServer for testing.\n\nI think we can do a transition like this in stages and furthermore minimally affecting most tests by adding some deprecated shims. Perhaps STCJ4 should become the deprecated shim so that users can still use it during 7.x and to help us with the transition internally too. More specifically, we'd add a new superclass to STCJ4 that is the future \u2013 \"SolrTestCase\".\n\nAdditionally, there are a bunch of methods on SolrTestCaseJ4 that I question the design of, especially ones that return XML strings like delI (generates a delete-by-id XML string) and adoc. Perhaps that used to be a fine idea before there was a convenient SolrClient API but we've got\u00a0one now and a test shouldn't be building XML unless it's trying to test exactly that.\n\nFor consulting work I once developed a JUnit4 TestRule managing a SolrClient that is declared in a test with an annotation of @ClassRule. I had a variation for SolrCloud and EmbeddedSolrServer that was easy for a test to choose. Since TestRule is an interface, I was able to make a special delegating SolrClient subclass that implements TestRule. This isn't essential but makes use of it easier since otherwise you'd be forced to call something like getSolrClient(). We could go the TestRule route here, which I prefer (with or without having it subclass SolrClient), or we could alternatively do TestCase subclassing to manage the lifecycle.\n\nInitially I'm just looking for agreement and refinement of the approach. After that, sub-tasks ought to be added. I won't have time to work on this for some time.",
    "attachments": {},
    "issue_links": {},
    "comments": [
        {
            "date": "2018-01-18T17:46:09+0000",
            "content": "Refactor and document... How to use the new refactored version should be covered in the Ref Guide. Presently I wind up reading other tests to find out how things work, and very often copy/paste/modify other tests to get going. It would be nice if one could refer to documentation that pointed out the options available and gave some advice on when to use what.\n\u00a0a test shouldn't be building XML unless it's trying to test exactly that.\nYes, Read/Write of any writer type should be thoroughly tested in a single place and then presumed to work elsewhere, so it shouldn't matter which is used by the test (could be randomized?).\n\nAlso\u00a0I think it should ideally be easy to flip between:\n\n\tUsing solrj API and letting it do whatever it happens to prefer (the most common case)\n\texplicitly sending V1 style requests\u00a0\n\texplicitly sending V2 style requests\n\n\n\nHow ever we do things, it has to be easy for the test writer to see/understand that they HAVE exercised both API's, and to get printouts of exactly what was sent as a post-body, headers, request line etc... For testing API command implementations it's pretty key to make sure all the bases are covered, and that the v1/v2 conversions and property substitutions are happening properly behind the scenes. Other usages possibly don't care as much... which is something to think about too.\n\nAlso, it seems that there are about 30 tests that turn off SSL to avoid random keystore errors... that also needs to be fixed, though probably a separate issue. ",
            "author": "Gus Heck",
            "id": "comment-16330842"
        },
        {
            "date": "2018-01-18T19:20:51+0000",
            "content": "Not to take away from your points about v1/v2 but I think that's a separate issue then the scope in the description, which will be a lot to deal with as it is.\n\nGood point about documentation.  I also search for existing tests to know what to do; there really isn't any other way at the moment.  It can be hard to keep documentation up to date.  One way that I think worked well in Lucene-spatial-extras is to have a particular real test case that is especially well documented.  Then link to this test-case in various places.  Perhaps this would be a sub-task of this issue. ",
            "author": "David Smiley",
            "id": "comment-16331014"
        },
        {
            "date": "2018-02-02T23:21:45+0000",
            "content": "With only a few lines of code, a test should be able to pick between an instance based on EmbeddedSolrServer (lighter tests), HttpSolrClient (tests HTTP/Jetty behavior directly or indirectly), SolrCloud,\nI'd go even farther and say Ideally it should be possible for a test to say \"using confgiset=XXX, give me a SolrClient, i don't care what type\" for tests that want to verify that the updates/queries/asserts they run behave consistently regardless of whether they are used against a single node/core, or a cloud cluster with that collection using 1 shard, or 10 shards.\n\nHaving that, and having explicit asserts of the expected behavior (regardless of shard count) would be vastly superior to a lot of our existing \"distributed\" tests that just assert the response bodies of 2 identical queries done in paralell to single/multi-node solr instance \"match\" \u2013 w/o ever verifying that those responses contain anything of substance (let alone the correct substance)\nAdditionally, there are a bunch of methods on SolrTestCaseJ4 that I question the design of, especially ones that return XML strings like delI (generates a delete-by-id XML string) and adoc. Perhaps that used to be a fine idea before there was a convenient SolrClient API but we've got one now and a test shouldn't be building XML unless it's trying to test exactly that.\nI can confirm i wrote all of those methods way, way, way back in the Solr 1.0 days when XML was the only way to talk to Solr.\u00a0 And while I generally agree with you on this point (and would love to see methods like delI, delQ, & adoc be phased out in favor of \"short hand macros\" that do similar things but return actual UpdateRequest objects for passing to a SolrClient) I would like to point out that one advantage of things like assertQ and the use of xpaths is that I find it helps me write assertions much less verbosely then when i write Cloud based tests of similar functionality \u2013 the trade off being that then you have to know xpath, and for people who\u00a0don't intimately understand the syntax, that brevity can be a hinderance to understanding/maintaining those tests.\n\nI guess my point is that as we look towards ways to re-write tests using \"real\" SolrJ supported SolrClient based APIs, and start looking at what some \"real\" converted tests would actually look like, it would be worth while to constantly keep an eye out for what kinds of helper functionality we might want to include in our tests base classes to reduce the brevity needed when drilling down into response documents to assert expected results. (But alas, i don't have any concrete suggestions on what that might look like at this point)\n\n\u00a0\n\n\n\nRefactor and document... How to use the new refactored version should be covered in the Ref Guide. ...\nWhoa... I strongly disagree with this idea: the ref guide is for end users of solr \u2013 not java developers maintaining Solr tests or attempting to subclass test framework base classes to write their own unit tests. This is exactly what javadocs are for. If something doesn't seem like a good fit for a specific classes javadoc, it should got in the package javadocs. (Or worst case scenerio in ./doc-files w/ a link from the relevant package/class/method javadocs.) ",
            "author": "Hoss Man",
            "id": "comment-16351053"
        },
        {
            "date": "2018-02-03T01:08:27+0000",
            "content": "Whoa...\u00a0I strongly disagree with this idea: the ref guide is for\u00a0end users\u00a0of solr\nPeople who write\u00a0solrj code that interacts with solr sometimes use these test classes to power their own tests (running against their schema/etc)... I think our end users are\u00a0almost always\u00a0developers of one level or another. How to quickly and easily write a unit test against an embedded solr (which class to use, what to do and not do, C/P starter example etc) is something I think a segment end users\u00a0who use solrj might\u00a0be happy to find in the ref guide, but sure better javadocs would be a great too. Personally for projects I do, I often pursue a more strictly unit test / mock object style, with fewer of these sorts of integrated tests (using embeded servers), but I know there are lots of folks who\u00a0just love embedded server tests (for a variety of servers, not just solr).\n\n\u00a0 ",
            "author": "Gus Heck",
            "id": "comment-16351152"
        },
        {
            "date": "2018-02-03T04:32:04+0000",
            "content": "bq:  I think our end users are almost always developers of one level or another. \n\nThis is not true in my experience. I interact with a lot of organizations where they're using Solr without writing a single line of Java code. And even in the organizations where there are some devs, after they get things working the project is often thrown over the wall to the operations people who want to do things like create collections, add replicas, change the schema and re-index, troubleshoot performance, troubleshoot why queries aren't returning expected results etc.. You know, keep Solr actually running day in and day out. All without necessarily knowing how to read Java, much less write unit tests.\n\nNow that said, for a dev to try to start developing Solr code, writing plugins, whatever is more difficult than it needs to be. \"Dive in to the code and figure it out\" is the advice I often have to give. \"Start with a unit test\" is another way to go. It would make a lot of sense to have a \"Developer's Guide\" aimed at, well, developers in addition to the end-user Reference Guide. That's where this kind of documentation should be done, not intermixed with the rest of the Reference Guide.\n\nOrganizationally I don't particularly care if we have two separate guides or they're two clearly separate halves of a single large. I do care that we don't conflate the two; these are two very different audiences. I'm pretty sure there's content in the Reference Guide that would be a better fit in a Developer's Guide as well. ",
            "author": "Erick Erickson",
            "id": "comment-16351243"
        },
        {
            "date": "2018-02-03T17:30:22+0000",
            "content": "Ok, that's fair, my perspective is probably skewed by things I have been involved in. I did have one client who was using PHP for indexing, but mostly my\u00a0work\u00a0has been with teams of java folks, or with me as \"the guy\".\u00a0I don't care much if it's separate or segregated, I just think it ought to exist at a level beyond javadocs, somewhere where examples are easy to read/maintain and\u00a0people don't have to dig to find it. Package level javadocs, while a good idea in theory are so rarely done well that I hardly ever look at them. 90% of the time it's just blank anyway, so often I forget they even exist. ",
            "author": "Gus Heck",
            "id": "comment-16351458"
        }
    ]
}