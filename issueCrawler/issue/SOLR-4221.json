{
    "id": "SOLR-4221",
    "title": "Custom sharding",
    "details": {
        "affect_versions": "None",
        "status": "Closed",
        "fix_versions": [
            "4.5",
            "6.0"
        ],
        "components": [],
        "type": "New Feature",
        "priority": "Major",
        "labels": "",
        "resolution": "Fixed"
    },
    "description": "Features to let users control everything about sharding/routing.",
    "attachments": {
        "SOLR-4221.patch": "https://issues.apache.org/jira/secure/attachment/12587636/SOLR-4221.patch"
    },
    "issue_links": {},
    "comments": [
        {
            "author": "Commit Tag Bot",
            "id": "comment-13536676",
            "date": "2012-12-20T01:40:10+0000",
            "content": "[trunk commit] Yonik Seeley\nhttp://svn.apache.org/viewvc?view=revision&revision=1424263\n\nSOLR-4221: pick correct router for collection props "
        },
        {
            "author": "Commit Tag Bot",
            "id": "comment-13536681",
            "date": "2012-12-20T01:48:17+0000",
            "content": "[branch_4x commit] Yonik Seeley\nhttp://svn.apache.org/viewvc?view=revision&revision=1424265\n\nSOLR-4221: pick correct router for collection props "
        },
        {
            "author": "Yonik Seeley",
            "id": "comment-13679494",
            "date": "2013-06-10T13:30:26+0000",
            "content": "Off the top of my head, some things left to do in this general area of \"custom sharding\":\n\n\tability to create a new shard via collections API (and other lifecycle operations... delete, rename?)\n\t\n\t\tprobably want to have the option of either leaving it empty, or creating new replicas\n\t\n\t\n\tanything that may make time based sharding easier\n\t\n\t\tthis probably includes shard aliasing, like we have collection aliasing now\n\t\n\t\n\twhen creating a collection, the ability to specify a router (and associated config for the router) and have that persisted, etc\n\tusing request parameters or document fields to direct what shard an update is for\n\t\n\t\tI think a lot of this is done/working (implicit router), but lacks tests\n\t\n\t\n\n\n\nFurther down the road, we also need to consider what to do about deletes, real-time get, or other operations where we would normally derive the shard from the ID... if it's not provided in another form, then we could decide to broadcast to all shards. "
        },
        {
            "author": "Noble Paul",
            "id": "comment-13679508",
            "date": "2013-06-10T13:47:55+0000",
            "content": "\n\nwhen creating a collection, the ability to specify a router (and associated config for the router) and have that persisted, etc\nI guess this can be a separate issue and can be fixed right away\n\nusing request parameters or document fields to direct what shard an update is for\n Is there a DocRouter which shards on the basis of document fields? (Other than the composite Id router) . I feel we need another one which does not change id of the document "
        },
        {
            "author": "Noble Paul",
            "id": "comment-13681012",
            "date": "2013-06-12T07:16:54+0000",
            "content": "\nAssigning 'implicit' router in the absence of 'numShards' param is confusing for the user. I would like it this way. there is a param caller 'router' whose default is \"compositeId\" . if both 'numShards' and 'router' params are absent the create action should fail stating 'numShards is a required param for default 'compositeId' router.\n\n\nProposed modifications to the collection CREATE action\n\n\tcreating a shard should be possible even if no nodes can be allocated to the shard. As and when nodes come up , it can be allocated to the shard\n\tnew required parameter 'shard' (multivalued) for 'implicit' route\n\n\n\nNew collection action , CREATE_SHARD \n\n\n\tparams . 'shard' (multivalued) optional . It creates new shards and try to allocate nodes for the same. If enough nodes are not available the shards will remain in 'construction' state\n\treplicationFactor : (optional) if absent the value will be inherited from the collection\n\n\n\nNew collection action , UPDATE_SHARD\n\n\n\treplicationFactor : provide a new value to add capacity to an existing shard\n\n\n\n\n\nThe name of the Router is a bit confusing. I fee it should be called \"explicit\" instead of \"implicit\". But let us leave it  "
        },
        {
            "author": "Yonik Seeley",
            "id": "comment-13681207",
            "date": "2013-06-12T13:19:24+0000",
            "content": "'numShards is a required param for default 'compositeId' router.\n\nWe want things to be as easy as possible to get going... it may make sense to have a default of 1 for numShards.\n\nThe name of the Router is a bit confusing. I fee it should be called \"explicit\" instead of \"implicit\". But let us leave it\n\nYeah... I guess what I was thinking at the time was when someone sent and update to a shard w/ no further routing info.  The update is assumed to belong on the receiving shard (that's the implicit part).  Of course it should work with explict shard info too.\n\nnew required parameter 'shard' (multivalued) for 'implicit' route\n\nOne should be able to create a collection w/ no shards also (although normally the next steps would be to create shards).\n "
        },
        {
            "author": "Noble Paul",
            "id": "comment-13681213",
            "date": "2013-06-12T13:32:52+0000",
            "content": "We want things to be as easy as possible to get going... it may make sense to have a default of 1 for numShards.\n\nIn case of \"implicit\" router , we do not wish to assign shard names . So the parameter is pretty useless. We can only create as many shards as user provides. If no 'shard' params are present we will have to create a collection with no shards \n\nThe update is assumed to belong on the receiving shard (that's the implicit part).\n\nyeah. makes sense. I can't imagine a name which makes sense foe both cases\n\nOne should be able to create a collection w/ no shards also (although normally the next steps would be to create shards).\n\nIs it possible to create collection w/ no shard?, or we do we need to add support for that first? "
        },
        {
            "author": "Yonik Seeley",
            "id": "comment-13681234",
            "date": "2013-06-12T13:59:47+0000",
            "content": "In case of \"implicit\" router , we do not wish to assign shard names\n\nRight - I was more talking about the default when we were already using the compositeId router.\nIt seems like that for the collections API, defaulting to router=compositeId and numShards=1 is reasonable.\n\nIs it possible to create collection w/ no shard?, or we do we need to add support for that first?\n\nI don't think the collections API currently has support for routers other than the default compositeId (just tried it... I get a NPE if I don't provide numShards).  There may be issues at a lower level too - not sure (initially, collections were created by bringing up a core - the collections API came later). "
        },
        {
            "author": "Mark Miller",
            "id": "comment-13681258",
            "date": "2013-06-12T14:18:04+0000",
            "content": "I get a NPE if I don't provide numShards)\n\nThat's a weird little bug I ran into a couple days ago - you should be getting a message about numShards being required (it is currently). "
        },
        {
            "author": "Noble Paul",
            "id": "comment-13681494",
            "date": "2013-06-12T18:42:04+0000",
            "content": "Yes, It gives an NPE if numShards is missing. It should throw a proper message why it is failing. That'll be fixed as a part of this "
        },
        {
            "author": "Noble Paul",
            "id": "comment-13682281",
            "date": "2013-06-13T14:21:30+0000",
            "content": "Very interesting. This can go into a java tricks n tips book\n\n\n  static Integer msgToStr(String val,Integer def ){\n        return  val == null ? def : Integer.parseInt(val);\n    }\n\n\n\ncompiles to\n\n\n  static Integer msgToStr(String val,Integer def ){\n        return Integer.valueOf(val == null ? def : Integer.parseInt(val));\n    }\n\n\n\nSo NPE , if both 'val' and 'def' are null\n\nShould I open another bug or just commit it as a SOLR-4221 "
        },
        {
            "author": "Mark Miller",
            "id": "comment-13682291",
            "date": "2013-06-13T14:33:41+0000",
            "content": "Nice tracking that down! It was weird as hell. I could not figure out what I was missing. I think we should fix it as it's own bug - it can go into 4.4 when this may not. "
        },
        {
            "author": "Otis Gospodnetic",
            "id": "comment-13684936",
            "date": "2013-06-17T03:11:57+0000",
            "content": "Noble Paul should SOLR-4059 be closed as dupe? "
        },
        {
            "author": "Mark Miller",
            "id": "comment-13686639",
            "date": "2013-06-18T12:22:39+0000",
            "content": "It's only a dupe by text name afaict - really it should be a part tracked as part of this issue IMO. "
        },
        {
            "author": "Noble Paul",
            "id": "comment-13689573",
            "date": "2013-06-20T19:55:39+0000",
            "content": "why do we keep the numShards in the CoreDescriptor? It says \" // setting only matters on core creation\" .Is it the right place to keep it \n\nwhen a \"state\" operation is sent to overseer, other information such as router etc is missing and it is difficult to create collection with any router other than the default "
        },
        {
            "author": "Shalin Shekhar Mangar",
            "id": "comment-13689925",
            "date": "2013-06-21T00:59:06+0000",
            "content": "why do we keep the numShards in the CoreDescriptor? It says \" // setting only matters on core creation\" .Is it the right place to keep it\n\nNo it is not the right place. Besides numShards, there's shardRange and shardState too which are used only for core creation. We need to figure out where we can keep such properties that are useful only during core creation. "
        },
        {
            "author": "Mark Miller",
            "id": "comment-13689991",
            "date": "2013-06-21T03:08:51+0000",
            "content": "I don't think it's a big deal myself - if it can be improved without adding complication, thats fine - but you can still simply view a CoreDescriptor as information to be used for core creation. I don't know that it ever promised to have 'live' information or something - the SolrCore reads the info on the CoreDescriptor to create the SolrCore.\n\nIt is not 100% satisfying, but unless the solution is pretty simple, I don't think it's worth worrying about near term. "
        },
        {
            "author": "Noble Paul",
            "id": "comment-13694670",
            "date": "2013-06-27T12:36:29+0000",
            "content": "Ideally a user would want new shards to go to new nodes so that the existing nodes are not overloaded. Now it is not possible to achieve it. If I start a node before t5he command is issued it would just join some random shard and it is taken up. If I issue the CREATESHARD command before adding nodes it will/should fail saying insufficient nodes .\n\n\nActually, it is relevant for SPLITSHARDas well. Now the new shards created will go and live in an already loaded node.\n\nThe proposed behavior is this. If I startup a node w/o specifying the collection , it would just be a part of the live nodes and no shard and collection should be assigned to it. So when a new shard has to be created , the command  can lookup and see if there are unutilized live nodes and it can be assigned there "
        },
        {
            "author": "Mark Miller",
            "id": "comment-13694736",
            "date": "2013-06-27T14:08:14+0000",
            "content": "If I startup a node w/o specifying the collection \n\nTo get that behavior we should be starting with no cores defined out of the box - you start up a node and it joins nothing because it has no cores. Then collection create commands and what not can start using that empty node. I don't think we care about starting a core that doesn't belong to a collection - we just want to get to the point where you start a solrcloud node and there is no predefined cores. "
        },
        {
            "author": "Yonik Seeley",
            "id": "comment-13694789",
            "date": "2013-06-27T15:22:11+0000",
            "content": "The proposed behavior is this. If I startup a node w/o specifying the collection , it would just be a part of the live nodes and no shard and collection should be assigned to it. \n\nThat's not so friendly though... seems like most of the time we would want to just be able to start a new node and have it utilized automatically.\n\nI think your use case (reserving some nodes for a new collection/shard/whatever you know you are going to create) may be best served by temporarily setting autoCreateReplicas=false (or whatever) via API.  If autoCreateReplicas==false, then there should be a way to bring up a node and not have cores created on it. "
        },
        {
            "author": "Noble Paul",
            "id": "comment-13694815",
            "date": "2013-06-27T15:47:15+0000",
            "content": "I miss something here. What is the work flow like? Do I add nodes first or do I create the shards/collection first? I can pass these api params only when the shard/collection is happening. Automatically assigning nodes to shards even when we have sufficient replicas is something I find strange "
        },
        {
            "author": "Yonik Seeley",
            "id": "comment-13694823",
            "date": "2013-06-27T15:57:57+0000",
            "content": "What is the work flow like? Do I add nodes first or do I create the shards/collection first?\n\nBoth?\n\nAutomatically assigning nodes to shards even when we have sufficient replicas is something I find strange\n\nYeah, that's sort of a different case... I was sort of assuming that we either didn't have sufficient replicas, or that the overseer may chose to rebalance some replicas off more heavily loaded nodes. "
        },
        {
            "author": "Noble Paul",
            "id": "comment-13694827",
            "date": "2013-06-27T16:09:12+0000",
            "content": "If I create the shard first and I don't have enough nodes to sign it to, it should probably just fai just the way create collection does. That would be the consistent behavior\n\nAuto rebalancing should be an opt in thing , right?  "
        },
        {
            "author": "Yonik Seeley",
            "id": "comment-13694844",
            "date": "2013-06-27T16:31:03+0000",
            "content": "If I create the shard first and I don't have enough nodes to sign it to, it should probably just fail\n\nSeems like it should be fine to create a shard w/ no current replicas (but it should also be fine to specify a certain minimum replication factor for the create to succeed).\n\nAs far as consistency with how collection creation works, I think we're going to need an additional parameter now that we can store the the replicationFactor in ZK and it can act as a target.  We need something like createReplicationFactor or something that specifies the minimum replication factor to achieve for the collection creation to succeed.\n\nAuto rebalancing should be an opt in thing , right?\n\nIt should certainly be optional/configurable.  What the default should be is a decision we can tackle once it's implemented. "
        },
        {
            "author": "Noble Paul",
            "id": "comment-13695252",
            "date": "2013-06-28T04:17:46+0000",
            "content": "As far as consistency with how collection creation works, I think we're going to need an additional parameter now that we can store the the replicationFactor in ZK and it can act as a target.\n\nDo we really need to have so many configuration params and complicate this? I believe we should define a standard recipe for doing something and people will just follow . Adding more options like createReplictionFactor is not elegant . \n\nIf you wish to create a new collection/shard w/o enough nodes we can just use something like forceCreate=true so that the collection and shards are created empty +  inactive . if forceCreate=false let us just fail if nodes are insufficient "
        },
        {
            "author": "Jan H\u00f8ydahl",
            "id": "comment-13695723",
            "date": "2013-06-28T19:52:08+0000",
            "content": "If you wish to create a new collection/shard w/o enough nodes we can just use something like forceCreate=true so that the collection and shards are created empty + inactive . if forceCreate=false let us just fail if nodes are insufficient\n\n+1\n\nWhen adding a new empty node, it should only get auto-assigned replicas if any of the existing collections have not filled up its numShards and replicationFactor yet. Else it should be left empty and then be utilized by future create collection requests or rebalance/split requests. "
        },
        {
            "author": "Yonik Seeley",
            "id": "comment-13695754",
            "date": "2013-06-28T20:27:31+0000",
            "content": "Do we really need to have so many configuration params and complicate this? \n\nEh, you replaced one parameter (a minimum replication factor to achieve) with another (a boolean meaning 0 or replicationFactor).\nThis seems akin to facet.includeZeros vs facet.minCount... the latter incorporates the former and is more powerful (hence fewer parameters in the long run), and the former would have never existed if the latter had been thought of first.\n\nNow, I don't like the name \"createReplictionFactor\" (maybe \"minReplicas\" or something like that would be better), but the functionality is a superset of  \"forceCreate\" and is more descriptive (after all, there are many ways to force things).  It also seems useful to say something like \"create this collection and make sure it's usable (at least one replica for every shard) but don't worry about trying to satisfy the replciationFactor just yet).  That would be minReplicas=1 "
        },
        {
            "author": "Noble Paul",
            "id": "comment-13696165",
            "date": "2013-06-29T17:43:45+0000",
            "content": "I agree with you Yonik. forceCreate is a superset and can mean a lot of things.\n\nminReplicas make sense. \n\nBut we need a clear definition of the following . Otherwise we are getting into a slippery slope \n\n\n\treplicationFactor : I'm still not very clear about this because it has a different meanoing in other nosql systems.\n\tminReplicas\n\n\n\ndoes it also mean if ever the no:of replicas fall below the 'minReplicas' , write ops would fail? Or does it only mean that it is only for creation of cluster/shard ?\n\nwe should also go ahead and define what those will mean when the 'autoManageCluster' (or whatever it is going to be called) is implemented . \n\n "
        },
        {
            "author": "Noble Paul",
            "id": "comment-13696766",
            "date": "2013-07-01T12:08:15+0000",
            "content": "If I specify replicationFactor=2 and minReplicas=1\n\nand Ithe cluster could create only 1 core , What is the state of the shard? ACTIVE|INACTIVE or something new ? \n "
        },
        {
            "author": "Yonik Seeley",
            "id": "comment-13697930",
            "date": "2013-07-02T16:15:59+0000",
            "content": "does it also mean if ever the no:of replicas fall below the 'minReplicas' , write ops would fail?\n\nI was considering it only as a create-time parameter (not persisted), and had originally thought about a parameter on updates that could specify the required replication level for safety.  But we really need to think about all the use-cases we can up front - it could make sense to have additional persisted properties around replicationFactor.\n\nOne use case is expanding your search capacity dynamically by simply starting up new nodes that automatically become replicas of existing shards.  This is the current behavior today.  We need to think about if/how to handle this use case when we start persisting replicationFactor and if the overseer will destroy nodes to bring things back to the replication factor.  One way would be to set the replicationFactor really high (to prevent this distruction), but this could lead to other negatives such as a future GUI displaying the status of the collection as degraded since the replicationFactor isn't met. Requiring the user to bump the replicationFactor up before adding new nodes isn't the friendliest thing given that this will be a very common use case.\n "
        },
        {
            "author": "Shai Erera",
            "id": "comment-13698040",
            "date": "2013-07-02T17:55:01+0000",
            "content": "Another usecase is to have multiple collections, each with different number of shards and different #replicas. I would not want to see 10 replicas for each shard just because I loaded 10 servers. Rather, I think it would be useful if I could say \"collection1, #shards=3, #replicas=2\" (total 6 indexes) and \"collection2, #shards=4, #replicas=5\" (total 20 indexes) and if I bring up a 10 nodes cluster, the indexes are somehow distributed across them. "
        },
        {
            "author": "Yonik Seeley",
            "id": "comment-13698051",
            "date": "2013-07-02T18:04:58+0000",
            "content": "Another usecase is to have multiple collections, each with different number of shards and different #replicas. \n\nRight - we need to figure out how to accomodate all these use cases. "
        },
        {
            "author": "Noble Paul",
            "id": "comment-13698142",
            "date": "2013-07-02T19:50:40+0000",
            "content": "Another usecase is to have multiple collections, each with different number of shards and different #replicas.\n\nThis is why I feel we should not automatically create cores in nodes that come up. The best thing to do is\n\nAny new node will just not participate in any collection (unless a shard has fewer nodes than replicationFactor)\n\nThere should be an explicit ASSIGN_NODE command to add/remove nodes to/from a shard.  \nIt should be possible to do an ASSIGN_NODE without specifying a nodename in which case the overseer would look for free nodes in the cluster and add to the specified shard \n\nwhen a new shard is created by CREATESHARD command or by a SPLITSHARD command these nodes could be automatically be taken up.  "
        },
        {
            "author": "Shai Erera",
            "id": "comment-13698158",
            "date": "2013-07-02T20:07:02+0000",
            "content": "Exactly. New nodes mean just more resources, I don't think they should affect the number of resources the search cluster needs, only define how many resources are available. Conceptually, we could have a cost function which takes into account the node's RAM/CPU/Disk + indexes size (GBs, #docs), maybe even based on performance history, and assign indexes to nodes following that cost function.\n\nThe way I picture it (and I don't know how to map that to Solr jargon):\n\n\tA new node comes up, broadcasts \"I'm alive\"\n\tMaybe communicates with other \"overbooked\" nodes to transfer indexes over\n\tA ClusterBalancer (Overseer?) periodically checks if the cluster can be better balanced (e.g. splitting shards, moving indexes)\n\tMaybe even we drop numShards entirely and make this a completely dynamic and automatic setting (or at least optional), but this is for future work\n\n "
        },
        {
            "author": "Noble Paul",
            "id": "comment-13702066",
            "date": "2013-07-08T15:32:44+0000",
            "content": "The working code is posted here https://github.com/shalinmangar/lucene-solr . We will start moving it to SVN after 4.4 branching "
        },
        {
            "author": "Noble Paul",
            "id": "comment-13719645",
            "date": "2013-07-25T14:12:38+0000",
            "content": "working patch with testcases .  "
        },
        {
            "author": "Noble Paul",
            "id": "comment-13724165",
            "date": "2013-07-30T17:55:19+0000",
            "content": "OverseerCollectionProcessor test errors fixed "
        },
        {
            "author": "Noble Paul",
            "id": "comment-13724931",
            "date": "2013-07-31T06:46:35+0000",
            "content": "I plan to commit this soon "
        },
        {
            "author": "Noble Paul",
            "id": "comment-13724980",
            "date": "2013-07-31T07:47:02+0000",
            "content": "tests added for CREATESHARD "
        },
        {
            "author": "Anshum Gupta",
            "id": "comment-13725021",
            "date": "2013-07-31T08:33:11+0000",
            "content": "You may want to check on the current router being used, before being able to add a shard. "
        },
        {
            "author": "Anshum Gupta",
            "id": "comment-13725165",
            "date": "2013-07-31T12:11:12+0000",
            "content": "Spoke to Noble offline and perhaps it's fine to deliberately not check it in OCP and just in the CollectionsHandler.\nThis lets Shards be created even when the router is non-implicit for cases like ShardSplitting. "
        },
        {
            "author": "ASF subversion and git services",
            "id": "comment-13725494",
            "date": "2013-07-31T17:53:03+0000",
            "content": "Commit 1508968 from Noble Paul in branch 'dev/trunk'\n[ https://svn.apache.org/r1508968 ]\n\nSOLR-4221 SOLR-4808 SOLR-5006 SOLR-5017 SOLR-4222 "
        },
        {
            "author": "ASF subversion and git services",
            "id": "comment-13725549",
            "date": "2013-07-31T18:28:04+0000",
            "content": "Commit 1508981 from Noble Paul in branch 'dev/branches/branch_4x'\n[ https://svn.apache.org/r1508981 ]\n\nSOLR-4221 SOLR-4808 SOLR-5006 SOLR-5017 SOLR-4222 "
        },
        {
            "author": "Noble Paul",
            "id": "comment-13725625",
            "date": "2013-07-31T19:29:36+0000",
            "content": "A custom collection can be created by explicitly specifying the router as 'implicit' and by giving the names of the shards explicitly as follows\n\nhttp://host:port/solr/admin/collections?action=CREATE&name=monthly&router=implicit&collection.configName=x&shards=jan13,feb13,mar13\n\nwhere 3 shards named jan13,feb13,mar13 will be created\n\nDocument routing\n\n\n\n\n\tadd a special request param called _route_=june13\u2019 . It means all docs added in the batch would belong to the same shard or,\n\tadd a special field _route_ in the document to signal the shard where it belongs to\n\tif the collection is created with \u2018routeField\u2019 value , the docRouter would look at that field to get the shard name SOLR-5017\n\tIf it is unable to identify the shard using any of the above methods , the write operation fails. If the shard is not present , then the write fails too\n\n\n\nQuery routing\nIt remain same as other routers. _route_ parameter can specify the actual shard name\n\nCreating new shards\nThere is a  a new command CREATESHARD . refer to SOLR-5006.  "
        },
        {
            "author": "ASF subversion and git services",
            "id": "comment-13725670",
            "date": "2013-07-31T20:20:43+0000",
            "content": "Commit 1509017 from shalin@apache.org in branch 'dev/branches/branch_4x'\n[ https://svn.apache.org/r1509017 ]\n\nSOLR-4221: Fix compile error on Java6 due to use of diamond operator "
        },
        {
            "author": "Hoss Man",
            "id": "comment-13764968",
            "date": "2013-09-11T23:41:30+0000",
            "content": "Is this feature complete? (all of the subtasks are marked resolved and several commits associated with this isue are in branch 4x)\n\n\nCan someone who understands all of the various changes made in these issues please update the ref guide (or post a comment suggestion what additions should be made)...\n\nhttps://cwiki.apache.org/confluence/display/solr/Collections+API\n\n "
        },
        {
            "author": "Yonik Seeley",
            "id": "comment-13769675",
            "date": "2013-09-17T16:55:18+0000",
            "content": "Hmmm, it feels like the \"routeField\" parameter should be scoped under \"router\" somehow... I think there will be additional parameters to configure a router in the future (such as number of bits to allocate to parts of the compositeId router, etc), as well as custom routers, where their configuration could include additional parameters that would best be scoped.\n\nrouter.routeField?\n\nAs far as persistence, it could be flat, but perhaps nicer to scope that as well...\n\n\"router\" : \n{\"name\" : \"implicit\", \"routField\" : \"companyName\"} "
        },
        {
            "author": "Noble Paul",
            "id": "comment-13769685",
            "date": "2013-09-17T17:08:37+0000",
            "content": "Makes sense\n\nwhen the collection is created let us accept the parameters with the 'router' prefix . eg: router.name=implicit&router.field=somefield. So any value that has a router prefix will go into the router attribute. we can use it in the future for more attributes and even custom attributes for custom routers. eg: router.class=my.ClassName&router.attr1=x&router.attr2=y\n\nwhen it is persisted, it can be\n\nrouter : \n{\"name\":\"implicit\",\"field\":\"somefield\"}\n\n "
        },
        {
            "author": "Noble Paul",
            "id": "comment-13770683",
            "date": "2013-09-18T11:47:52+0000",
            "content": "router and associated variables moved to an object "
        },
        {
            "author": "Noble Paul",
            "id": "comment-13770768",
            "date": "2013-09-18T13:31:13+0000",
            "content": "fixed some failing tests "
        },
        {
            "author": "ASF subversion and git services",
            "id": "comment-13770854",
            "date": "2013-09-18T15:10:05+0000",
            "content": "Commit 1524442 from Noble Paul in branch 'dev/trunk'\n[ https://svn.apache.org/r1524442 ]\n\nSOLR-4221 changed format router is stored "
        },
        {
            "author": "ASF subversion and git services",
            "id": "comment-13770865",
            "date": "2013-09-18T15:13:58+0000",
            "content": "Commit 1524446 from Noble Paul in branch 'dev/branches/branch_4x'\n[ https://svn.apache.org/r1524446 ]\n\nSOLR-4221 changed format router is stored "
        },
        {
            "author": "ASF subversion and git services",
            "id": "comment-13771910",
            "date": "2013-09-19T14:00:42+0000",
            "content": "Commit 1524742 from Adrien Grand in branch 'dev/branches/lucene_solr_4_5'\n[ https://svn.apache.org/r1524742 ]\n\nSOLR-4221 changed format router is stored "
        },
        {
            "author": "Yonik Seeley",
            "id": "comment-13776649",
            "date": "2013-09-24T19:18:50+0000",
            "content": "I think the last patch here broke back compat with clusterstate (Markus hit this, reported in SOLR-5261)\nI'll try to come up with a patch.  It shouldn't be too hard to fix (longest part will be testing). "
        },
        {
            "author": "Yonik Seeley",
            "id": "comment-13776707",
            "date": "2013-09-24T20:28:13+0000",
            "content": "Here's a patch that seems to work with some manual back compat testing.  I'll commit after the unit tests run. "
        },
        {
            "author": "ASF subversion and git services",
            "id": "comment-13776723",
            "date": "2013-09-24T20:39:55+0000",
            "content": "Commit 1526003 from Yonik Seeley in branch 'dev/trunk'\n[ https://svn.apache.org/r1526003 ]\n\nSOLR-4221: back compat for router spec "
        },
        {
            "author": "ASF subversion and git services",
            "id": "comment-13776740",
            "date": "2013-09-24T21:01:28+0000",
            "content": "Commit 1526007 from Yonik Seeley in branch 'dev/branches/branch_4x'\n[ https://svn.apache.org/r1526007 ]\n\nSOLR-4221: back compat for router spec "
        },
        {
            "author": "ASF subversion and git services",
            "id": "comment-13776742",
            "date": "2013-09-24T21:03:34+0000",
            "content": "Commit 1526008 from Yonik Seeley in branch 'dev/branches/lucene_solr_4_5'\n[ https://svn.apache.org/r1526008 ]\n\nSOLR-4221: back compat for router spec "
        },
        {
            "author": "Noble Paul",
            "id": "comment-13777141",
            "date": "2013-09-25T04:27:28+0000",
            "content": "Yonik Seeley I don't think we can fix this in a a backcompat manner if we reuse the name router and change the Object type.\n\nThere will be atleast one node in the cluster which will have the old binaries and will expect the router instanceof String. the new binaries will keep writing router as Map.\n\nThe backward compatible solution would be to choose another name say \"route\" and if the 'router' value is missing, the old binaries would not complain "
        },
        {
            "author": "Yonik Seeley",
            "id": "comment-13777142",
            "date": "2013-09-25T04:34:18+0000",
            "content": "I don't think we can fix this in a a backcompat manner \n\nThere are different degrees of back compat, and I've already committed something that at least works a lot better than what was there.  I tested by creating a 4.4 cluster, bringing it down, and then replacing the jar file with 4.5. "
        },
        {
            "author": "Noble Paul",
            "id": "comment-13777161",
            "date": "2013-09-25T05:06:30+0000",
            "content": "Yeah , that works\n\nBut if my usecase is,\n\nBring down each node , replace the jar and restart the node this will fail. right?\n\nIf this does not work , we will have to document it clearly "
        },
        {
            "author": "Markus Jelsma",
            "id": "comment-13777407",
            "date": "2013-09-25T12:42:49+0000",
            "content": "Ah, i come from SOLR-5261 and noticed the discussion here so i'll comment here as well. The stack trace i posted earlier is gone now and is replaced by the trace below. This only happens if a new SolrJ attempts to talk to a slightly older cluster.\n\n\njava.lang.ClassCastException: java.lang.String cannot be cast to java.util.Map\n        at org.apache.solr.common.cloud.DocRouter.getRouteField(DocRouter.java:54)\n        at org.apache.solr.common.cloud.CompositeIdRouter.sliceHash(CompositeIdRouter.java:64)\n        at org.apache.solr.common.cloud.HashBasedRouter.getTargetSlice(HashBasedRouter.java:33)\n        at org.apache.solr.client.solrj.request.UpdateRequest.getRoutes(UpdateRequest.java:190)\n        at org.apache.solr.client.solrj.impl.CloudSolrServer.directUpdate(CloudSolrServer.java:313)\n        at org.apache.solr.client.solrj.impl.CloudSolrServer.request(CloudSolrServer.java:506)\n        at org.apache.solr.client.solrj.request.AbstractUpdateRequest.process(AbstractUpdateRequest.java:117)\n\n "
        },
        {
            "author": "Noble Paul",
            "id": "comment-13777436",
            "date": "2013-09-25T13:12:35+0000",
            "content": "Thanks Markus Jelsma good catch\n\nI'll connect it to SOLR-5258 "
        },
        {
            "author": "ASF subversion and git services",
            "id": "comment-13777807",
            "date": "2013-09-25T17:52:55+0000",
            "content": "Commit 1526244 from Yonik Seeley in branch 'dev/trunk'\n[ https://svn.apache.org/r1526244 ]\n\nSOLR-4221: make new solrj client/router able to read old clusterstate "
        },
        {
            "author": "ASF subversion and git services",
            "id": "comment-13777862",
            "date": "2013-09-25T18:23:50+0000",
            "content": "Commit 1526255 from Yonik Seeley in branch 'dev/branches/lucene_solr_4_5'\n[ https://svn.apache.org/r1526255 ]\n\nSOLR-4221: make new solrj client/router able to read old clusterstate "
        },
        {
            "author": "ASF subversion and git services",
            "id": "comment-13778509",
            "date": "2013-09-26T06:21:16+0000",
            "content": "Commit 1526395 from Noble Paul in branch 'dev/branches/branch_4x'\n[ https://svn.apache.org/r1526395 ]\n\nSOLR-4221 make new solrj client/router able to read old clusterstate "
        },
        {
            "author": "Markus Jelsma",
            "id": "comment-13778609",
            "date": "2013-09-26T09:40:15+0000",
            "content": "I tested it again with a SolrJ of just now and an older cluster 18th of september. It keeps throwing the exception:\n\n\njava.lang.ClassCastException: java.lang.String cannot be cast to java.util.Map\n        at org.apache.solr.common.cloud.DocRouter.getRouteField(DocRouter.java:54)\n        at org.apache.solr.common.cloud.CompositeIdRouter.sliceHash(CompositeIdRouter.java:64)\n        at org.apache.solr.common.cloud.HashBasedRouter.getTargetSlice(HashBasedRouter.java:33)\n        at org.apache.solr.client.solrj.request.UpdateRequest.getRoutes(UpdateRequest.java:190)\n        at org.apache.solr.client.solrj.impl.CloudSolrServer.directUpdate(CloudSolrServer.java:313)\n        at org.apache.solr.client.solrj.impl.CloudSolrServer.request(CloudSolrServer.java:506)\n        at org.apache.solr.client.solrj.request.AbstractUpdateRequest.process(AbstractUpdateRequest.java:117)\n\n\n\nDue to the commit message i assumed it would work now. "
        },
        {
            "author": "Noble Paul",
            "id": "comment-13778613",
            "date": "2013-09-26T09:54:13+0000",
            "content": "Did  u test with the newest build? The line numbers aere referring to old build "
        },
        {
            "author": "Markus Jelsma",
            "id": "comment-13778617",
            "date": "2013-09-26T10:01:58+0000",
            "content": "Ah, perhaps the current 5.0-SNAPSHOT doesn't yet contain the fix. I'll try again a bit later. "
        },
        {
            "author": "Adrien Grand",
            "id": "comment-13778664",
            "date": "2013-09-26T11:07:32+0000",
            "content": "Thanks for doing these tests Markus! I'll wait for your confirmation that the issue is fixed before building new artifacts. "
        },
        {
            "author": "Markus Jelsma",
            "id": "comment-13778679",
            "date": "2013-09-26T11:37:04+0000",
            "content": "Adrien, SolrJ can now index to an older cluster successfully! Thanks Yonik, Noble!\nThis is great! "
        },
        {
            "author": "Adrien Grand",
            "id": "comment-13787150",
            "date": "2013-10-05T10:19:28+0000",
            "content": "4.5 release -> bulk close "
        },
        {
            "author": "ASF subversion and git services",
            "id": "comment-15198700",
            "date": "2016-03-17T03:56:17+0000",
            "content": "Commit ae846bfb492fd91e30daac017c6587083e278236 in lucene-solr's branch refs/heads/master from Shalin Shekhar Mangar\n[ https://git-wip-us.apache.org/repos/asf?p=lucene-solr.git;h=ae846bf ]\n\nSOLR-8860: Remove back-compat handling of router format made in SOLR-4221 in 4.5.0 "
        },
        {
            "author": "ASF subversion and git services",
            "id": "comment-15198715",
            "date": "2016-03-17T04:25:46+0000",
            "content": "Commit f5a4b0419cd3e8fa3a9c707503ab0f42adfd59f0 in lucene-solr's branch refs/heads/branch_6x from Shalin Shekhar Mangar\n[ https://git-wip-us.apache.org/repos/asf?p=lucene-solr.git;h=f5a4b04 ]\n\nSOLR-8860: Remove back-compat handling of router format made in SOLR-4221 in 4.5.0\n(cherry picked from commit ae846bf) "
        },
        {
            "author": "ASF subversion and git services",
            "id": "comment-15201166",
            "date": "2016-03-18T08:29:51+0000",
            "content": "Commit ae846bfb492fd91e30daac017c6587083e278236 in lucene-solr's branch refs/heads/apiv2 from Shalin Shekhar Mangar\n[ https://git-wip-us.apache.org/repos/asf?p=lucene-solr.git;h=ae846bf ]\n\nSOLR-8860: Remove back-compat handling of router format made in SOLR-4221 in 4.5.0 "
        }
    ]
}