{
    "id": "LUCENE-8227",
    "title": "TestGeo3DPoint.testGeo3DRelations() reproducing failures",
    "details": {
        "labels": "",
        "priority": "Blocker",
        "components": [
            "general/test",
            "modules/spatial3d"
        ],
        "type": "Bug",
        "fix_versions": [
            "6.7",
            "7.4",
            "master (8.0)"
        ],
        "affect_versions": "None",
        "resolution": "Fixed",
        "status": "Closed"
    },
    "description": "Three failures: two NPEs and one assert \"assess edge that ends in a crossing can't both up and down\":\n\n1.a. (NPE) From https://builds.apache.org/job/Lucene-Solr-NightlyTests-master/1512/:\n\n\n   [junit4]   2> NOTE: reproduce with: ant test  -Dtestcase=TestGeo3DPoint -Dtests.method=testGeo3DRelations -Dtests.seed=C1F88333EC85EAE0 -Dtests.multiplier=2 -Dtests.nightly=true -Dtests.slow=true -Dtests.linedocsfile=/home/jenkins/jenkins-slave/workspace/Lucene-Solr-NightlyTests-master/test-data/enwiki.random.lines.txt -Dtests.locale=ga -Dtests.timezone=America/Ojinaga -Dtests.asserts=true -Dtests.file.encoding=UTF-8\n   [junit4] ERROR   10.4s J1 | TestGeo3DPoint.testGeo3DRelations <<<\n   [junit4]    > Throwable #1: java.lang.NullPointerException\n   [junit4]    > \tat __randomizedtesting.SeedInfo.seed([C1F88333EC85EAE0:7187FEA763C8447C]:0)\n   [junit4]    > \tat org.apache.lucene.spatial3d.geom.GeoComplexPolygon$DualCrossingEdgeIterator.countCrossingPoint(GeoComplexPolygon.java:1382)\n   [junit4]    > \tat org.apache.lucene.spatial3d.geom.GeoComplexPolygon$DualCrossingEdgeIterator.matches(GeoComplexPolygon.java:1283)\n   [junit4]    > \tat org.apache.lucene.spatial3d.geom.GeoComplexPolygon$Node.traverse(GeoComplexPolygon.java:564)\n   [junit4]    > \tat org.apache.lucene.spatial3d.geom.GeoComplexPolygon$Node.traverse(GeoComplexPolygon.java:572)\n   [junit4]    > \tat org.apache.lucene.spatial3d.geom.GeoComplexPolygon$Node.traverse(GeoComplexPolygon.java:569)\n   [junit4]    > \tat org.apache.lucene.spatial3d.geom.GeoComplexPolygon$Tree.traverse(GeoComplexPolygon.java:660)\n   [junit4]    > \tat org.apache.lucene.spatial3d.geom.GeoComplexPolygon$Tree.traverse(GeoComplexPolygon.java:646)\n   [junit4]    > \tat org.apache.lucene.spatial3d.geom.GeoComplexPolygon.isWithin(GeoComplexPolygon.java:370)\n   [junit4]    > \tat org.apache.lucene.spatial3d.geom.GeoBaseMembershipShape.isWithin(GeoBaseMembershipShape.java:36)\n   [junit4]    > \tat org.apache.lucene.spatial3d.geom.GeoBaseShape.getBounds(GeoBaseShape.java:35)\n   [junit4]    > \tat org.apache.lucene.spatial3d.geom.GeoComplexPolygon.getBounds(GeoComplexPolygon.java:440)\n   [junit4]    > \tat org.apache.lucene.spatial3d.TestGeo3DPoint.testGeo3DRelations(TestGeo3DPoint.java:225)\n   [junit4]    > \tat java.lang.Thread.run(Thread.java:748)\n\n\n\n1.b. (NPE) From https://builds.apache.org/job/Lucene-Solr-SmokeRelease-7.x/184/:\n\n\n   [smoker]    [junit4]   2> NOTE: reproduce with: ant test  -Dtestcase=TestGeo3DPoint -Dtests.method=testGeo3DRelations -Dtests.seed=F2A368AB96A2FD75 -Dtests.multiplier=2 -Dtests.locale=fr-ML -Dtests.timezone=America/Godthab -Dtests.asserts=true -Dtests.file.encoding=UTF-8\n   [smoker]    [junit4] ERROR   0.99s J0 | TestGeo3DPoint.testGeo3DRelations <<<\n   [smoker]    [junit4]    > Throwable #1: java.lang.NullPointerException\n   [smoker]    [junit4]    > \tat __randomizedtesting.SeedInfo.seed([F2A368AB96A2FD75:42DC153F19EF53E9]:0)\n   [smoker]    [junit4]    > \tat org.apache.lucene.spatial3d.geom.GeoComplexPolygon$DualCrossingEdgeIterator.countCrossingPoint(GeoComplexPolygon.java:1382)\n   [smoker]    [junit4]    > \tat org.apache.lucene.spatial3d.geom.GeoComplexPolygon$DualCrossingEdgeIterator.matches(GeoComplexPolygon.java:1283)\n   [smoker]    [junit4]    > \tat org.apache.lucene.spatial3d.geom.GeoComplexPolygon$Node.traverse(GeoComplexPolygon.java:564)\n   [smoker]    [junit4]    > \tat org.apache.lucene.spatial3d.geom.GeoComplexPolygon$Node.traverse(GeoComplexPolygon.java:572)\n   [smoker]    [junit4]    > \tat org.apache.lucene.spatial3d.geom.GeoComplexPolygon$Node.traverse(GeoComplexPolygon.java:572)\n   [smoker]    [junit4]    > \tat org.apache.lucene.spatial3d.geom.GeoComplexPolygon$Tree.traverse(GeoComplexPolygon.java:660)\n   [smoker]    [junit4]    > \tat org.apache.lucene.spatial3d.geom.GeoComplexPolygon$Tree.traverse(GeoComplexPolygon.java:646)\n   [smoker]    [junit4]    > \tat org.apache.lucene.spatial3d.geom.GeoComplexPolygon.isWithin(GeoComplexPolygon.java:370)\n   [smoker]    [junit4]    > \tat org.apache.lucene.spatial3d.geom.GeoBaseMembershipShape.isWithin(GeoBaseMembershipShape.java:36)\n   [smoker]    [junit4]    > \tat org.apache.lucene.spatial3d.geom.GeoBaseShape.getBounds(GeoBaseShape.java:43)\n   [smoker]    [junit4]    > \tat org.apache.lucene.spatial3d.geom.GeoComplexPolygon.getBounds(GeoComplexPolygon.java:440)\n   [smoker]    [junit4]    > \tat org.apache.lucene.spatial3d.TestGeo3DPoint.testGeo3DRelations(TestGeo3DPoint.java:224)\n   [smoker]    [junit4]    > \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n   [smoker]    [junit4]    > \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n   [smoker]    [junit4]    > \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n   [smoker]    [junit4]    > \tat java.base/java.lang.reflect.Method.invoke(Method.java:564)\n   [smoker]    [junit4]    > \tat java.base/java.lang.Thread.run(Thread.java:844)\n\n\n\n2. (both up&down) From https://jenkins.thetaphi.de/job/Lucene-Solr-7.x-Linux/1598/:\n\n\n   [junit4]   2> NOTE: reproduce with: ant test  -Dtestcase=TestGeo3DPoint -Dtests.method=testGeo3DRelations -Dtests.seed=BACC479CC2D38CCA -Dtests.multiplier=3 -Dtests.slow=true -Dtests.badapples=true -Dtests.locale=lv -Dtests.timezone=SystemV/AST4ADT -Dtests.asserts=true -Dtests.file.encoding=UTF-8\n   [junit4] FAILURE 3.01s J2 | TestGeo3DPoint.testGeo3DRelations <<<\n   [junit4]    > Throwable #1: java.lang.AssertionError: assess edge that ends in a crossing can't both up and down\n   [junit4]    > \tat __randomizedtesting.SeedInfo.seed([BACC479CC2D38CCA:AB33A084D9E2256]:0)\n   [junit4]    > \tat org.apache.lucene.spatial3d.geom.GeoComplexPolygon$DualCrossingEdgeIterator.countCrossingPoint(GeoComplexPolygon.java:1438)\n   [junit4]    > \tat org.apache.lucene.spatial3d.geom.GeoComplexPolygon$DualCrossingEdgeIterator.matches(GeoComplexPolygon.java:1283)\n   [junit4]    > \tat org.apache.lucene.spatial3d.geom.GeoComplexPolygon$Node.traverse(GeoComplexPolygon.java:564)\n   [junit4]    > \tat org.apache.lucene.spatial3d.geom.GeoComplexPolygon$Tree.traverse(GeoComplexPolygon.java:660)\n   [junit4]    > \tat org.apache.lucene.spatial3d.geom.GeoComplexPolygon$Tree.traverse(GeoComplexPolygon.java:646)\n   [junit4]    > \tat org.apache.lucene.spatial3d.geom.GeoComplexPolygon.isWithin(GeoComplexPolygon.java:370)\n   [junit4]    > \tat org.apache.lucene.spatial3d.geom.GeoBaseMembershipShape.isWithin(GeoBaseMembershipShape.java:36)\n   [junit4]    > \tat org.apache.lucene.spatial3d.geom.GeoBaseShape.getBounds(GeoBaseShape.java:43)\n   [junit4]    > \tat org.apache.lucene.spatial3d.geom.GeoComplexPolygon.getBounds(GeoComplexPolygon.java:440)\n   [junit4]    > \tat org.apache.lucene.spatial3d.TestGeo3DPoint.testGeo3DRelations(TestGeo3DPoint.java:224)\n   [junit4]    > \tat java.lang.Thread.run(Thread.java:748)",
    "attachments": {},
    "issue_links": {},
    "comments": [
        {
            "date": "2018-03-27T18:53:16+0000",
            "content": "The NPEs are caused when travel planes are identical to edges.  This is relatively easy to address, but needs to be carefully coded.\n\nThe assertion failures are a bit tougher because they indicate we don't understand the geometry properly in some situations.  I'll have to look into these in more depth. ",
            "author": "Karl Wright",
            "id": "comment-16416092"
        },
        {
            "date": "2018-03-27T23:06:09+0000",
            "content": "Commit 6dcb6ae64155921ffb2841732844c9b8776968bd in lucene-solr's branch refs/heads/master from Karl Wright\n[ https://git-wip-us.apache.org/repos/asf?p=lucene-solr.git;h=6dcb6ae ]\n\nLUCENE-8227: Handle identical planes properly in GeoComplexPolygon. ",
            "author": "ASF subversion and git services",
            "id": "comment-16416432"
        },
        {
            "date": "2018-03-27T23:06:43+0000",
            "content": "Commit e656091690b7efc869da5eb2702791152070b388 in lucene-solr's branch refs/heads/branch_7x from Karl Wright\n[ https://git-wip-us.apache.org/repos/asf?p=lucene-solr.git;h=e656091 ]\n\nLUCENE-8227: Handle identical planes properly in GeoComplexPolygon. ",
            "author": "ASF subversion and git services",
            "id": "comment-16416434"
        },
        {
            "date": "2018-03-27T23:07:13+0000",
            "content": "Commit 9b05d5676d01a09635b403cd7057c7207735e3e2 in lucene-solr's branch refs/heads/branch_6x from Karl Wright\n[ https://git-wip-us.apache.org/repos/asf?p=lucene-solr.git;h=9b05d56 ]\n\nLUCENE-8227: Handle identical planes properly in GeoComplexPolygon. ",
            "author": "ASF subversion and git services",
            "id": "comment-16416435"
        },
        {
            "date": "2018-03-27T23:09:16+0000",
            "content": "Committed code that should fix the NPEs.  The assertions are also fixed.  However, we still see failures in cases 2 and 3 due to incorrect edge-crossing logic that need to be worked out, so this ticket is not yet complete. ",
            "author": "Karl Wright",
            "id": "comment-16416442"
        },
        {
            "date": "2018-03-28T05:16:15+0000",
            "content": "This is the failure case I'm going to convert to a unit test first:\n\n\n   [junit4]   1>     doc=2333 is contained by shape but is outside the returned XYZBounds\n   [junit4]   1>       unquantized=[lat=-3.1780051348770987E-74, lon=-3.032608859187692([X=-0.9951793580358298, Y=-0.1088898762907205, Z=-3.181560858610375E-74])]\n   [junit4]   1>       quantized=[X=-0.9951793580415914, Y=-0.10888987641797832, Z=-2.3309121299774915E-10]\n\n\n\n\n   [junit4]   1>   shape=GeoComplexPolygon:\n{planetmodel=PlanetModel.WGS84, \n number of shapes=1, \n address=40c76856, \n testPoint=[X=0.38044889065958476, Y=-0.47772089071622287, Z=0.7906122375677148], \n testPointInSet=true, \n shapes={ {\n  [lat=-0.63542308910253, lon=0.9853722928232957([X=0.4446759777403525, Y=0.6707549854468698, Z=-0.5934780737681111])], \n  [lat=0.0, lon=0.0([X=1.0011188539924791, Y=0.0, Z=0.0])], [lat=0.45435018176633574, lon=3.141592653589793([X=-0.8989684544372841, Y=1.1009188402610632E-16, Z=0.4390846549572752])], \n  [lat=-0.375870856827283, lon=2.9129132647718414([X=-0.9065744420970767, Y=0.21100590938346708, Z=-0.36732668582405886])], \n  [lat=-1.2205765069413237, lon=3.141592653589793([X=-0.3424714964202101, Y=4.194066218902145E-17, Z=-0.9375649457139603])]}}\n\n\n\n\n   [junit4]   1>   bounds=XYZBounds: [xmin=-0.9936143692718389 xmax=1.0011188549924792 ymin=-1.0011188549924792 ymax=0.6707549864468698 zmin=-0.9977622930221051 zmax=0.9977622930221051]\n\n\n ",
            "author": "Karl Wright",
            "id": "comment-16416832"
        },
        {
            "date": "2018-03-28T06:02:38+0000",
            "content": "Correction \u2013 it's not clear whether it's edge-crossing logic that is at fault.\nI think there's a reasonable chance that the issue could be the bounds computation.  It's a wacky polygon that includes most of the ends of the earth so I could believe we fail in some way to compute bounds properly.  Will need to analyze. ",
            "author": "Karl Wright",
            "id": "comment-16416863"
        },
        {
            "date": "2018-03-28T11:04:39+0000",
            "content": "The following test demonstrates that the problem is in computing the bounds, and doesn't have anything specific to do with GeoComplexPolygons:\n\n\n  public void testLUCENE8227() throws Exception {\n    List<GeoPoint> points = new ArrayList<>();\n    points.add(new GeoPoint(PlanetModel.WGS84, -0.63542308910253, 0.9853722928232957));\n    points.add(new GeoPoint(PlanetModel.WGS84, 0.0, 0.0));\n    points.add(new GeoPoint(PlanetModel.WGS84, 0.45435018176633574, 3.141592653589793));\n    points.add(new GeoPoint(PlanetModel.WGS84, -0.375870856827283, 2.9129132647718414));\n    points.add(new GeoPoint(PlanetModel.WGS84, -1.2205765069413237, 3.141592653589793));\n    GeoPolygonFactory.PolygonDescription pd = new GeoPolygonFactory.PolygonDescription(points);\n    \n    final GeoPoint unquantized = new GeoPoint(PlanetModel.WGS84, -3.1780051348770987E-74, -3.032608859187692);\n    final GeoPoint quantized = new GeoPoint(-0.9951793580415914, -0.10888987641797832, -2.3309121299774915E-10);\n    \n    // Construct a standard polygon first to see what that does\n    GeoPolygon standard = GeoPolygonFactory.makeGeoPolygon(PlanetModel.WGS84, pd);\n    assertTrue(standard.isWithin(quantized));\n    assertTrue(standard.isWithin(unquantized));\n    \n    // Make sure that a large polygon works the same\n    final List<GeoPolygonFactory.PolygonDescription> pdList = new ArrayList<>(1);\n    pdList.add(pd);\n    GeoPolygon large = GeoPolygonFactory.makeLargeGeoPolygon(PlanetModel.WGS84, pdList);\n    \n    // This should behave the same as the standard guy\n    assertTrue(large.isWithin(quantized));\n    assertTrue(large.isWithin(unquantized));\n    \n    // Next, compute the bounds for both of these\n    final XYZBounds standardBounds = new XYZBounds();\n    standard.getBounds(standardBounds);\n    final XYZBounds largeBounds = new XYZBounds();\n    large.getBounds(largeBounds);\n    \n    final XYZSolid standardSolid = XYZSolidFactory.makeXYZSolid(PlanetModel.WGS84, standardBounds);\n    final XYZSolid largeSolid = XYZSolidFactory.makeXYZSolid(PlanetModel.WGS84, largeBounds);\n    \n    // All four of these fail.\n    //assertTrue(standardSolid.isWithin(quantized));\n    //assertTrue(standardSolid.isWithin(unquantized));\n    \n    //assertTrue(largeSolid.isWithin(quantized));\n    //assertTrue(largeSolid.isWithin(unquantized));\n\n  }\n\n ",
            "author": "Karl Wright",
            "id": "comment-16417171"
        },
        {
            "date": "2018-03-28T11:11:41+0000",
            "content": "Bounds are the same too for standard vs. large:\n\n\n   [junit4] Suite: org.apache.lucene.spatial3d.geom.GeoPolygonTest\n   [junit4]   1> Standard bounds: XYZBounds: [xmin=-0.9936143692718389 xmax=1.0011188549924792 ymin=-1.0011188549924792 ymax=0.6707549864468698 zmin=-0.9977622930221051 zmax=0.9977622930221051]\n   [junit4]   1> Large bounds: XYZBounds: [xmin=-0.9936143692718389 xmax=1.0011188549924792 ymin=-1.0011188549924792 ymax=0.6707549864468698 zmin=-0.9977622930221051 zmax=0.9977622930221051]\n\n\n\nThe point's X, Y, Z are:\n\n\n[X=-0.9951793580358298, Y=-0.1088898762907205, Z=-3.181560858610375E-74]\n\n\n\nThe problem is that the point's X is less than xmin. ",
            "author": "Karl Wright",
            "id": "comment-16417177"
        },
        {
            "date": "2018-03-28T11:17:03+0000",
            "content": "The points that go into constructing the polygon are not what sets bounds in this case:\n\n\n[X=0.4446759777403525, Y=0.6707549854468698, Z=-0.5934780737681111]\n[X=1.0011188539924791, Y=0.0, Z=0.0]\n[X=-0.8989684544372841, Y=1.1009188402610632E-16, Z=0.4390846549572752]\n[X=-0.9065744420970767, Y=0.21100590938346708, Z=-0.36732668582405886]\n[X=-0.3424714964202101, Y=4.194066218902145E-17, Z=-0.9375649457139603]\n\n\n\nClearly the edge bounds code is not doing the right thing in this situation.  That's the next place to write a test for and/or analyze. ",
            "author": "Karl Wright",
            "id": "comment-16417182"
        },
        {
            "date": "2018-03-28T11:20:54+0000",
            "content": "Karl Wright currently you are generating in both cases the same polygon as in the standard polygon cannot be created because of a TileException.\n\nOne thing to note is that the polygon is concave (covers both poles) and probably that is the reason bounds are not properly computed.\n\n\u00a0 ",
            "author": "Ignacio Vera",
            "id": "comment-16417193"
        },
        {
            "date": "2018-03-28T12:18:00+0000",
            "content": "Adding x-bounds logging yields the following dump:\n\n\n   [junit4]   1> Computing new x bound for plane [A=0.6890973226271416, B=-0.6795484036912525; C=-0.2517118332315264; D=0.0]\n   [junit4]   1>  x-bound point1: [X=-0.7253404115923568, Y=-0.6473134187879598, Z=-0.2381665352265543]\n   [junit4]   1>  x-bound point2: [X=0.7253404115923568, Y=0.6473134187879598, Z=0.2381665352265543]\n   [junit4]   1> Computing new x bound for plane [A=0.0, B=-0.6626477256017624; C=-0.7489312329945998; D=0.0]\n   [junit4]   1>  x-bound point1: [X=-1.0011188539924791, Y=-0.0, Z=-0.0]\n   [junit4]   1>  x-bound point2: [X=1.0011188539924791, Y=0.0, Z=0.0]\n   [junit4]   1> Computing new x bound for plane [A=0.0, B=-1.0; C=2.5073042927637435E-16; D=0.0]\n   [junit4]   1>  x-bound point1: [X=-1.0011188539924791, Y=-0.0, Z=0.0]\n   [junit4]   1>  x-bound point2: [X=1.0011188539924791, Y=0.0, Z=-0.0]\n   [junit4]   1> Computing new x bound for plane [A=-0.12218735010855987, B=-0.9604628616740691; C=-0.25016263273779726; D=0.0]\n   [junit4]   1>  x-bound point1: [X=-0.9936143682718389, Y=0.11842468105083435, Z=0.030638463267361405]\n   [junit4]   1>  x-bound point2: [X=0.9936143682718389, Y=-0.11842468105083435, Z=-0.030638463267361405]\n   [junit4]   1> Computing new x bound for plane [A=-0.2623138822938212, B=-0.9602137546257182; C=0.09581739186350438; D=0.0]\n   [junit4]   1>  x-bound point1: [X=-0.9660600853870557, Y=0.26132624795300813, Z=-0.02590253971121584]\n   [junit4]   1>  x-bound point2: [X=0.9660600853870557, Y=-0.26132624795300813, Z=0.02590253971121584]\n   [junit4]   1> Computing new x bound for plane [A=0.6890973226271416, B=-0.6795484036912525; C=-0.2517118332315264; D=0.0]\n   [junit4]   1>  x-bound point1: [X=-0.7253404115923568, Y=-0.6473134187879598, Z=-0.2381665352265543]\n   [junit4]   1>  x-bound point2: [X=0.7253404115923568, Y=0.6473134187879598, Z=0.2381665352265543]\n   [junit4]   1> Computing new x bound for plane [A=0.0, B=-0.6626477256017624; C=-0.7489312329945998; D=0.0]\n   [junit4]   1>  x-bound point1: [X=-1.0011188539924791, Y=-0.0, Z=-0.0]\n   [junit4]   1>  x-bound point2: [X=1.0011188539924791, Y=0.0, Z=0.0]\n   [junit4]   1> Computing new x bound for plane [A=0.0, B=-1.0; C=2.5073042927637435E-16; D=0.0]\n   [junit4]   1>  x-bound point1: [X=-1.0011188539924791, Y=-0.0, Z=0.0]\n   [junit4]   1>  x-bound point2: [X=1.0011188539924791, Y=0.0, Z=-0.0]\n   [junit4]   1> Computing new x bound for plane [A=-0.12218735010855987, B=-0.9604628616740691; C=-0.25016263273779726; D=0.0]\n   [junit4]   1>  x-bound point1: [X=-0.9936143682718389, Y=0.11842468105083435, Z=0.030638463267361405]\n   [junit4]   1>  x-bound point2: [X=0.9936143682718389, Y=-0.11842468105083435, Z=-0.030638463267361405]\n   [junit4]   1> Computing new x bound for plane [A=-0.2623138822938212, B=-0.9602137546257182; C=0.09581739186350438; D=0.0]\n   [junit4]   1>  x-bound point1: [X=-0.9660600853870557, Y=0.26132624795300813, Z=-0.02590253971121584]\n   [junit4]   1>  x-bound point2: [X=0.9660600853870557, Y=-0.26132624795300813, Z=0.02590253971121584]\n   [junit4]   1> Computing new x bound for plane [A=0.6890973226271416, B=-0.6795484036912525; C=-0.2517118332315264; D=0.0]\n   [junit4]   1>  x-bound point1: [X=-0.7253404115923568, Y=-0.6473134187879598, Z=-0.2381665352265543]\n   [junit4]   1>  x-bound point2: [X=0.7253404115923568, Y=0.6473134187879598, Z=0.2381665352265543]\n   [junit4]   1> Computing new x bound for plane [A=0.0, B=-0.6626477256017624; C=-0.7489312329945998; D=0.0]\n   [junit4]   1>  x-bound point1: [X=-1.0011188539924791, Y=-0.0, Z=-0.0]\n   [junit4]   1>  x-bound point2: [X=1.0011188539924791, Y=0.0, Z=0.0]\n   [junit4]   1> Computing new x bound for plane [A=0.0, B=-1.0; C=2.5073042927637435E-16; D=0.0]\n   [junit4]   1>  x-bound point1: [X=-1.0011188539924791, Y=-0.0, Z=0.0]\n   [junit4]   1>  x-bound point2: [X=1.0011188539924791, Y=0.0, Z=-0.0]\n   [junit4]   1> Computing new x bound for plane [A=-0.12218735010855987, B=-0.9604628616740691; C=-0.25016263273779726; D=0.0]\n   [junit4]   1>  x-bound point1: [X=-0.9936143682718389, Y=0.11842468105083435, Z=0.030638463267361405]\n   [junit4]   1>  x-bound point2: [X=0.9936143682718389, Y=-0.11842468105083435, Z=-0.030638463267361405]\n   [junit4]   1> Computing new x bound for plane [A=-0.2623138822938212, B=-0.9602137546257182; C=0.09581739186350438; D=0.0]\n   [junit4]   1>  x-bound point1: [X=-0.9660600853870557, Y=0.26132624795300813, Z=-0.02590253971121584]\n   [junit4]   1>  x-bound point2: [X=0.9660600853870557, Y=-0.26132624795300813, Z=0.02590253971121584]\n   [junit4]   1> Computing new x bound for plane [A=0.6890973226271416, B=-0.6795484036912525; C=-0.2517118332315264; D=0.0]\n   [junit4]   1>  x-bound point1: [X=-0.7253404115923568, Y=-0.6473134187879598, Z=-0.2381665352265543]\n   [junit4]   1>  x-bound point2: [X=0.7253404115923568, Y=0.6473134187879598, Z=0.2381665352265543]\n   [junit4]   1> Computing new x bound for plane [A=0.0, B=-0.6626477256017624; C=-0.7489312329945998; D=0.0]\n   [junit4]   1>  x-bound point1: [X=-1.0011188539924791, Y=-0.0, Z=-0.0]\n   [junit4]   1>  x-bound point2: [X=1.0011188539924791, Y=0.0, Z=0.0]\n   [junit4]   1> Computing new x bound for plane [A=0.0, B=-1.0; C=2.5073042927637435E-16; D=0.0]\n   [junit4]   1>  x-bound point1: [X=-1.0011188539924791, Y=-0.0, Z=0.0]\n   [junit4]   1>  x-bound point2: [X=1.0011188539924791, Y=0.0, Z=-0.0]\n   [junit4]   1> Computing new x bound for plane [A=-0.12218735010855987, B=-0.9604628616740691; C=-0.25016263273779726; D=0.0]\n   [junit4]   1>  x-bound point1: [X=-0.9936143682718389, Y=0.11842468105083435, Z=0.030638463267361405]\n   [junit4]   1>  x-bound point2: [X=0.9936143682718389, Y=-0.11842468105083435, Z=-0.030638463267361405]\n   [junit4]   1> Computing new x bound for plane [A=-0.2623138822938212, B=-0.9602137546257182; C=0.09581739186350438; D=0.0]\n   [junit4]   1>  x-bound point1: [X=-0.9660600853870557, Y=0.26132624795300813, Z=-0.02590253971121584]\n   [junit4]   1>  x-bound point2: [X=0.9660600853870557, Y=-0.26132624795300813, Z=0.02590253971121584]\n\n\n\nThere are a number of points which would extend the bounds sufficiently, but they seemingly are discarded because they're outside of the membership of the plane intersection.  The one we accept is this one:\n\n\n[junit4]   1> Computing new x bound for plane [A=-0.12218735010855987, B=-0.9604628616740691; C=-0.25016263273779726; D=0.0]\n[junit4]   1>  x-bound point1: [X=-0.9936143682718389, Y=0.11842468105083435, Z=0.030638463267361405]\n[junit4]   1>  x-bound point2: [X=0.9936143682718389, Y=-0.11842468105083435, Z=-0.030638463267361405]\n\n\n\nBut we apparently reject this one (and shouldn't):\n\n\n[junit4]   1> Computing new x bound for plane [A=-0.2623138822938212, B=-0.9602137546257182; C=0.09581739186350438; D=0.0]\n[junit4]   1>  x-bound point1: [X=-0.9660600853870557, Y=0.26132624795300813, Z=-0.02590253971121584]\n[junit4]   1>  x-bound point2: [X=0.9660600853870557, Y=-0.26132624795300813, Z=0.02590253971121584]\n\n ",
            "author": "Karl Wright",
            "id": "comment-16417255"
        },
        {
            "date": "2018-03-28T12:29:30+0000",
            "content": "Here's the plane that is rejecting the bounds point:\n\n\n[junit4]   1>  x-bound point1: [X=-0.9660600853870557, Y=0.26132624795300813, Z=-0.02590253971121584]\n[junit4]   1>   in addPoint() for [X=-0.9660600853870557, Y=0.26132624795300813, Z=-0.02590253971121584]\n[junit4]   1>   rejected due to [A=0.3322732772082172, B=-0.18309880331194991, C=-0.9252401296307047, D=0.0, side=1.0]\n\n\n\nI'm now wondering if the problem is that the polygon is very close to being greater than 180 degrees, and the min X point is outside of the bounds for that reason, but the endpoints of the segment are not.  If that's the case, we would need to only use the adjoining edge bounds rather than all polygon bounds when computing the bounds. ",
            "author": "Karl Wright",
            "id": "comment-16417268"
        },
        {
            "date": "2018-03-28T15:26:39+0000",
            "content": "The plane that rejects the right bound goes through point 3 of the polygon:\n\n\n[junit4]   1> Rejection plane contains [lat=-0.375870856827283, lon=2.9129132647718414([X=-0.9065744420970767, Y=0.21100590938346708, Z=-0.36732668582405886])]\n\n\n\nThe question is therefore whether the described arc segment is greater than 180 degrees.  If it is, then the plane's sidedness will be incorrect, and that would lead to this exact situation.  It would also lead to a polygon that is bogus, since edges cannot span more than 180 degrees and still work.  Let me see if I can figure out whether the shape is bogus, and if so, find a way to detect that when we build it. ",
            "author": "Karl Wright",
            "id": "comment-16417546"
        },
        {
            "date": "2018-03-28T16:10:24+0000",
            "content": "Some quick sanity checking did not show anything pathological with the polygon.  But the only check I did was making sure that all poly points came back as \"within\" the polygon.  I still wonder if it is possible for any one edge to exceed 180 and yet have that check pass.  The edge endpoint planes are not the same as what is used for \"within\" checks; they're meant to be used only for a specific segment, and they use the other end of the segment to determine sidedness.  I did confirm that the bounds point I was looking at was considered \"outside\" both the standard and the large polygons, though.\n\nI need to eyeball it further and figure out which edge should be contributing the most negative X value. ",
            "author": "Karl Wright",
            "id": "comment-16417655"
        },
        {
            "date": "2018-03-28T17:30:23+0000",
            "content": "Something is odd with the rejection plane.\n\nThe code definitely uses adjoining edges to delimit polygon edges, so each delimiting plane should go through two points and the origin.  But:\n\n\n[junit4]   1> Rejection plane distance to point 0= 0.5740492391748969\n[junit4]   1> Rejection plane distance to point 1= 0.33264504249101573\n[junit4]   1> Rejection plane distance to point 2= -0.7049619375342049\n[junit4]   1> Rejection plane distance to point 3= -5.551115123125783E-17\n[junit4]   1> Rejection plane distance to point 4= 0.7536785854436437\n\n\n\nThe rejection edge goes through only one point and is nowhere near any of the others.  It does go through the origin, but unless it was specifically constructed to be perpendicular to original edge, this makes no sense.\n ",
            "author": "Karl Wright",
            "id": "comment-16417803"
        },
        {
            "date": "2018-03-28T17:47:37+0000",
            "content": "Turns out that a standard polygon cannot be tiled with these points, and a complex polygon is getting built instead:\n\n\n   [junit4]   1> Standard polygon: GeoComplexPolygon: {planetmodel=PlanetModel.WGS84, number of shapes=1, address=99c3330b, testPoint=[X=0.3804488906595847, Y=-0.47772089071622287, Z=0.7906122375677148], testPointInSet=true, shapes={ {[lat=-1.2205765069413237, lon=3.141592653589793([X=-0.3424714964202101, Y=4.194066\n218902145E-17, Z=-0.9375649457139603])], [lat=-0.63542308910253, lon=0.9853722928232957([X=0.4446759777403525, Y=0.6707549854468698, Z=-0.5934780737681111])], [lat=0.0, lon=0.0([X=1.0011188539924791, Y=0.0, Z=0.0])], [lat=0.45435018176633574, lon=3.141592653589793([X=-0.8989684544372841, Y=1.1009188402610632E-16, Z=\n0.4390846549572752])], [lat=-0.375870856827283, lon=2.9129132647718414([X=-0.9065744420970767, Y=0.21100590938346708, Z=-0.36732668582405886])]}}\n\n\n\nThat is meaningful because (a) we have no assurances that the polygon is legal, and (b) all the comparisons we were doing in the test between standard and large are not useful.  Furthermore, the edge cutoffs for complex polygons are definitely computed differently than they are for standard polygons.  But it's pretty concerning that a standard poly cannot be built at all. ",
            "author": "Karl Wright",
            "id": "comment-16417823"
        },
        {
            "date": "2018-03-28T20:57:54+0000",
            "content": "So, the following is true:\n\n(1) All polygon points are in the hemisphere y>=0\n(2) The bounds point we think is right is on the edge plane, precision 1.0e-17\n(3) The bounds point we think is right is in the hemisphere y>=0\n(4) But, the membership sided plane that rejects the bounds point we think is right accepts the antipodes point, which is in the y < 0 part of the world\n(5) All edges are properly constructed so that each endpoint is within the other endpoint's membership sided plane\n\nThe conclusion is that the sector of the edge plane that is not contributing properly towards the bounds is at least partly in the y<0 space.  But since the two endpoints are both in the y>=0 space, this makes no sense, because any arc that connects the two would have to remain in the y>=0 space as well.\n\nAdding the following code to the GeoComplexPolygon constructor demonstrates that nothing odd is happening with edge construction:\n\n\n      if (startPoint.y < 0.0 || endPoint.y < 0.0) {\n        System.out.println(\"Found start/end in y < 0 space\");\n        throw new IllegalStateException(\"blah\");\n      }\n\n\n\nNo exception is thrown, so there are no unexpected points being included somehow.  So the min x point is being excluded because it really is in the wrong sector.  The membership bounds sided planes divide the space into four sections, and only one is legal; the excluded bounds point therefore cannot be on the right part of the sector in question.  So we're looking in the wrong place; this polygon edge cannot contribute to the min/max. ",
            "author": "Karl Wright",
            "id": "comment-16418092"
        },
        {
            "date": "2018-03-28T21:37:15+0000",
            "content": "If the bounds look good, then we're left with a point that GeoComplexPolygon thinks is in set that actually isn't. ",
            "author": "Karl Wright",
            "id": "comment-16418163"
        },
        {
            "date": "2018-03-29T01:02:52+0000",
            "content": "The test point is in y < 0 territory, and is considered in-set.  So all of y < 0 must be in-set.  You can apparently get from the test point to the point we're evaluating without crossing anything.  But x == -1.001 is thought to be NOT in set; I don't understand this.  That is intuitively weird and needs to be verified.\n ",
            "author": "Karl Wright",
            "id": "comment-16418297"
        },
        {
            "date": "2018-03-29T07:00:25+0000",
            "content": "What happens is finally clear.\nOne of the travel planes in the -x pole case goes directly along an edge.  The edge's endpoint is actually within the \"envelope\", and another edge crosses out.  But this case isn't handled correctly for some reason.\n\nThe logic for complex cases like this needs to be reviewed.  Essentially there are four surfaces: inside the travel corridor, outside the travel corridor, and either end of the travel corridor.  We need to make sure the following cases are properly handled:\n\n\n\tpolygon points within the corridor\n\tedges crossing corridor ends\n\tpolygon points on the corridor boundaries\n\n\n\nWhile we have logic to identify all edges that intersect at all with a travel corridor, the logic dealing with the cases mentioned is complex and may have issues.  Needs careful thought. ",
            "author": "Karl Wright",
            "id": "comment-16418521"
        },
        {
            "date": "2018-03-29T07:27:48+0000",
            "content": "Karl Wright should we add the AwaitsFix annotation so that this test doesn't contribute to the noise until it is fixed? ",
            "author": "Adrien Grand",
            "id": "comment-16418539"
        },
        {
            "date": "2018-03-29T07:44:09+0000",
            "content": "Adrien Grand, how much noise is it generating?  The main failure source of noise generation was already corrected, I believe, in the commit already made as part of this ticket.\n\nIt's a rare case, and it only is possible at all when a standard polygon cannot be tiled for some reason, which was what changed recently.\n\nI won't have a fix for probably something like 48 hours; if we see another failure in that time frame I will be happy to change the test annotation.  Prior to that, the last known failure of this code was in January 2017, which I didn't even know about until Tuesday. ",
            "author": "Karl Wright",
            "id": "comment-16418553"
        },
        {
            "date": "2018-03-29T08:06:53+0000",
            "content": "We had this one last night on the Elastic CI, which I assumed was related to the issues discussed here: https://elasticsearch-ci.elastic.co/job/apache+lucene-solr+master/25957/console ",
            "author": "Adrien Grand",
            "id": "comment-16418577"
        },
        {
            "date": "2018-03-29T12:55:42+0000",
            "content": "Every single Geo3D test that works with random polygons can potentially fail in this way.  The spatial package has some of these too; I am not even able to list all the tests potentially affected.\n\nMeanwhile, I know what the fix is and just need the time to code it.\n\nWhat would you like me to do? ",
            "author": "Karl Wright",
            "id": "comment-16418945"
        },
        {
            "date": "2018-03-29T12:58:53+0000",
            "content": "What we usually do in such cases that we do not need more information from CI is that we add the @AwaitsFix annotation to the test. Then once the fix is merged, it can be removed. This annotation will make ant test skip this test. ",
            "author": "Adrien Grand",
            "id": "comment-16418947"
        },
        {
            "date": "2018-03-29T13:34:36+0000",
            "content": "Ok, I've abandoned my work.  This will set back the fix for some days.  I've started annotating all the random tests that involve polygons; I should have that done in an hour or so.\n\nI have never had to do this before when working on Lucene.\n\nCurrently, that code gets errors, so please advise the proper way to use the annotation.\n\n\n    [javac] Compiling 2 source files to C:\\wipgit\\lucene4\\lucene-solr\\lucene\\build\\spatial3d\\classes\\test\n    [javac] C:\\wipgit\\lucene4\\lucene-solr\\lucene\\spatial3d\\src\\test\\org\\apache\\lucene\\spatial3d\\TestGeo3DPoint.java:191: error: cannot find symbol\n    [javac]   @AwaitsFix(\"https://issues.apache.org/jira/browse/LUCENE-8227\")\n    [javac]              ^\n    [javac]   symbol:   method value()\n    [javac]   location: @interface AwaitsFix\n    [javac] C:\\wipgit\\lucene4\\lucene-solr\\lucene\\spatial3d\\src\\test\\org\\apache\\lucene\\spatial3d\\TestGeo3DPoint.java:471: error: cannot find symbol\n    [javac]   @AwaitsFix(\"https://issues.apache.org/jira/browse/LUCENE-8227\")\n    [javac]              ^\n    [javac]   symbol:   method value()\n    [javac]   location: @interface AwaitsFix\n    [javac] C:\\wipgit\\lucene4\\lucene-solr\\lucene\\spatial3d\\src\\test\\org\\apache\\lucene\\spatial3d\\TestGeo3DPoint.java:477: error: cannot find symbol\n    [javac]   @AwaitsFix(\"https://issues.apache.org/jira/browse/LUCENE-8227\")\n    [javac]              ^\n    [javac]   symbol:   method value()\n    [javac]   location: @interface AwaitsFix\n    [javac] C:\\wipgit\\lucene4\\lucene-solr\\lucene\\spatial3d\\src\\test\\org\\apache\\lucene\\spatial3d\\TestGeo3DPoint.java:483: error: cannot find symbol\n    [javac]   @AwaitsFix(\"https://issues.apache.org/jira/browse/LUCENE-8227\")\n    [javac]              ^\n    [javac]   symbol:   method value()\n    [javac]   location: @interface AwaitsFix\n    [javac] C:\\wipgit\\lucene4\\lucene-solr\\lucene\\spatial3d\\src\\test\\org\\apache\\lucene\\spatial3d\\TestGeo3DPoint.java:191: error: annotation @AwaitsFix is missing a default value for the element 'bugUrl'\n    [javac]   @AwaitsFix(\"https://issues.apache.org/jira/browse/LUCENE-8227\")\n    [javac]   ^\n    [javac] C:\\wipgit\\lucene4\\lucene-solr\\lucene\\spatial3d\\src\\test\\org\\apache\\lucene\\spatial3d\\TestGeo3DPoint.java:471: error: annotation @AwaitsFix is missing a default value for the element 'bugUrl'\n    [javac]   @AwaitsFix(\"https://issues.apache.org/jira/browse/LUCENE-8227\")\n    [javac]   ^\n    [javac] C:\\wipgit\\lucene4\\lucene-solr\\lucene\\spatial3d\\src\\test\\org\\apache\\lucene\\spatial3d\\TestGeo3DPoint.java:477: error: annotation @AwaitsFix is missing a default value for the element 'bugUrl'\n    [javac]   @AwaitsFix(\"https://issues.apache.org/jira/browse/LUCENE-8227\")\n    [javac]   ^\n    [javac] C:\\wipgit\\lucene4\\lucene-solr\\lucene\\spatial3d\\src\\test\\org\\apache\\lucene\\spatial3d\\TestGeo3DPoint.java:483: error: annotation @AwaitsFix is missing a default value for the element 'bugUrl'\n    [javac]   @AwaitsFix(\"https://issues.apache.org/jira/browse/LUCENE-8227\")\n    [javac]   ^\n    [javac] Note: C:\\wipgit\\lucene4\\lucene-solr\\lucene\\spatial3d\\src\\test\\org\\apache\\lucene\\spatial3d\\TestGeo3DPoint.java uses or overrides a deprecated API.\n    [javac] Note: Recompile with -Xlint:deprecation for details.\n    [javac] 8 errors\n\n ",
            "author": "Karl Wright",
            "id": "comment-16418992"
        },
        {
            "date": "2018-03-29T14:37:55+0000",
            "content": "Commit 5b429df56f36031c8423803d5157029c59bcbb3d in lucene-solr's branch refs/heads/master from Karl Wright\n[ https://git-wip-us.apache.org/repos/asf?p=lucene-solr.git;h=5b429df ]\n\nLUCENE-8227: Under pressure, had to @Ignore tests that caused intermittent failures.  This means no further work on Geo3D until these tests can be re-enabled. ",
            "author": "ASF subversion and git services",
            "id": "comment-16419096"
        },
        {
            "date": "2018-03-29T14:39:04+0000",
            "content": "Commit 8dbb65b0d762792d5cde2fdf5073e67c7fce6dbe in lucene-solr's branch refs/heads/branch_7x from Karl Wright\n[ https://git-wip-us.apache.org/repos/asf?p=lucene-solr.git;h=8dbb65b ]\n\nLUCENE-8227: Under pressure, had to @Ignore tests that caused intermittent failures.  This means no further work on Geo3D until these tests can be re-enabled. ",
            "author": "ASF subversion and git services",
            "id": "comment-16419098"
        },
        {
            "date": "2018-03-29T14:39:32+0000",
            "content": "Commit 5f2c7cbeb16f9c264f888e1a3118056140f8e97f in lucene-solr's branch refs/heads/branch_6x from Karl Wright\n[ https://git-wip-us.apache.org/repos/asf?p=lucene-solr.git;h=5f2c7cb ]\n\nLUCENE-8227: Under pressure, had to @Ignore tests that caused intermittent failures.  This means no further work on Geo3D until these tests can be re-enabled. ",
            "author": "ASF subversion and git services",
            "id": "comment-16419100"
        },
        {
            "date": "2018-03-29T14:45:51+0000",
            "content": "I was forced to use Ignore annotation instead, since I couldn't figure out what was wrong with AwaitsFix.\n\nAll random tests in that suite have been disabled.  There are likely other random tests that still fail elsewhere that have not been reported.  I will wait for a time (several days) before attempting to fix anything so that other tests that arise can be Ignored too.  As I said before, this will substantially delay a fix since it prevents me from actually coding it.\n\nIn the meantime, please note that Geo3D polygons are, effectively, unreliable.  Hopefully we will not be releasing code based on this code base until the repair is complete.\n\nAlso note that this problem has been around for more than a year.  The main difference has been that GeoComplexPolygons are used more extensively in the random suites now, in cases where standard polygons cannot be tiled.  That means they are instantiated for some really horrific cases, so it's not surprising these have problems in those conditions.\n ",
            "author": "Karl Wright",
            "id": "comment-16419110"
        },
        {
            "date": "2018-03-29T17:17:26+0000",
            "content": "I was forced to use Ignore annotation instead, since I couldn't figure out what was wrong with AwaitsFix.\n\nI think this is because you need to do @AwaitsFix(bugUrl=\"http://foo\") rather than @AwaitsFix(\"http://foo\"). ",
            "author": "Adrien Grand",
            "id": "comment-16419419"
        },
        {
            "date": "2018-03-30T10:44:12+0000",
            "content": "Commit bc40f6c7e219c3def81e5d3bee6d5123cc4141e6 in lucene-solr's branch refs/heads/master from Karl Wright\n[ https://git-wip-us.apache.org/repos/asf?p=lucene-solr.git;h=bc40f6c ]\n\nLUCENE-8227: Redevelop path iterator implementations to make them robust against edges on paths. ",
            "author": "ASF subversion and git services",
            "id": "comment-16420369"
        },
        {
            "date": "2018-03-30T10:44:56+0000",
            "content": "Commit acfa2d0207497afca4c3a4152baf2540d5243344 in lucene-solr's branch refs/heads/branch_7x from Karl Wright\n[ https://git-wip-us.apache.org/repos/asf?p=lucene-solr.git;h=acfa2d0 ]\n\nLUCENE-8227: Redevelop path iterator implementations to make them robust against edges on paths. ",
            "author": "ASF subversion and git services",
            "id": "comment-16420370"
        },
        {
            "date": "2018-03-30T10:45:27+0000",
            "content": "Commit 007450f8a3806102479ff309e19c4dae539a4358 in lucene-solr's branch refs/heads/branch_6x from Karl Wright\n[ https://git-wip-us.apache.org/repos/asf?p=lucene-solr.git;h=007450f ]\n\nLUCENE-8227: Redevelop path iterator implementations to make them robust against edges on paths. ",
            "author": "ASF subversion and git services",
            "id": "comment-16420371"
        },
        {
            "date": "2018-03-30T11:24:58+0000",
            "content": "Commit b78d980097d41e48acbecbe305794103df119190 in lucene-solr's branch refs/heads/master from Shalin Shekhar Mangar\n[ https://git-wip-us.apache.org/repos/asf?p=lucene-solr.git;h=b78d980 ]\n\nLUCENE-8227: Remove unused import to make precommit happy ",
            "author": "ASF subversion and git services",
            "id": "comment-16420400"
        },
        {
            "date": "2018-03-30T11:39:32+0000",
            "content": "Commit fb47c166b7976fe3e4c65150e348c5887f28319e in lucene-solr's branch refs/heads/branch_7x from Shalin Shekhar Mangar\n[ https://git-wip-us.apache.org/repos/asf?p=lucene-solr.git;h=fb47c16 ]\n\nLUCENE-8227: Remove unused import to make precommit happy\n\n(cherry picked from commit b78d980) ",
            "author": "ASF subversion and git services",
            "id": "comment-16420412"
        },
        {
            "date": "2018-03-30T11:40:56+0000",
            "content": "Commit e01ff16cffd1b12bd54d3dbb127d065b688abf97 in lucene-solr's branch refs/heads/branch_6x from Shalin Shekhar Mangar\n[ https://git-wip-us.apache.org/repos/asf?p=lucene-solr.git;h=e01ff16 ]\n\nLUCENE-8227: Remove unused import to make precommit happy\n\n(cherry picked from commit b78d980)\n\n(cherry picked from commit fb47c16) ",
            "author": "ASF subversion and git services",
            "id": "comment-16420414"
        },
        {
            "date": "2018-03-30T12:37:19+0000",
            "content": "Commit e06554ad408a60dc37eb77c0aeeff542e506f1a5 in lucene-solr's branch refs/heads/master from Karl Wright\n[ https://git-wip-us.apache.org/repos/asf?p=lucene-solr.git;h=e06554a ]\n\nLUCENE-8227: Widen plane envelopes a small amount to allow for some imprecision when intersecting inner and outer edges. ",
            "author": "ASF subversion and git services",
            "id": "comment-16420439"
        },
        {
            "date": "2018-03-30T12:38:22+0000",
            "content": "Commit f28b56210ad25bdb70e44487bc76e24027b5c145 in lucene-solr's branch refs/heads/branch_7x from Karl Wright\n[ https://git-wip-us.apache.org/repos/asf?p=lucene-solr.git;h=f28b562 ]\n\nLUCENE-8227: Widen plane envelopes a small amount to allow for some imprecision when intersecting inner and outer edges. ",
            "author": "ASF subversion and git services",
            "id": "comment-16420440"
        },
        {
            "date": "2018-03-30T12:41:29+0000",
            "content": "Commit d7bf82df51f52fdc5e662d518446ebc251e92e8c in lucene-solr's branch refs/heads/branch_6x from Karl Wright\n[ https://git-wip-us.apache.org/repos/asf?p=lucene-solr.git;h=d7bf82d ]\n\nLUCENE-8227: Widen plane envelopes a small amount to allow for some imprecision when intersecting inner and outer edges. ",
            "author": "ASF subversion and git services",
            "id": "comment-16420443"
        }
    ]
}