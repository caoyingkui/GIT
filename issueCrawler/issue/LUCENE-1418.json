{
    "id": "LUCENE-1418",
    "title": "QueryParser can throw NullPointerException during parsing of some queries in case if default field passed to constructor is null",
    "details": {
        "labels": "",
        "priority": "Minor",
        "components": [
            "core/queryparser"
        ],
        "type": "Bug",
        "fix_versions": [],
        "affect_versions": "2.4",
        "resolution": "Not A Problem",
        "status": "Closed"
    },
    "description": "In case if QueryParser was constructed using \"QueryParser(String f,  Analyzer a)\" constructor and f equals null then QueryParser can fail with NullPointerException during parsing of some queries that does contain field name but have unbalanced parenthesis.\n\nExample 1:\nQuery:  field:(expr1) expr2)\nResult:\njava.lang.NullPointerException\n\tat org.apache.lucene.index.Term.<init>(Term.java:50)\n\tat org.apache.lucene.index.Term.<init>(Term.java:36)\n\tat org.apache.lucene.queryParser.QueryParser.getFieldQuery(QueryParser.java:543)\n\tat org.apache.lucene.queryParser.QueryParser.Term(QueryParser.java:1324)\n\tat org.apache.lucene.queryParser.QueryParser.Clause(QueryParser.java:1211)\n\tat org.apache.lucene.queryParser.QueryParser.Query(QueryParser.java:1168)\n\tat org.apache.lucene.queryParser.QueryParser.TopLevelQuery(QueryParser.java:1128)\n\tat org.apache.lucene.queryParser.QueryParser.parse(QueryParser.java:170)\n\nExample2:\nQuery:  field:(expr1) \"expr2\")\nResult:\njava.lang.NullPointerException\n\tat org.apache.lucene.index.Term.<init>(Term.java:50)\n\tat org.apache.lucene.index.Term.<init>(Term.java:36)\n\tat org.apache.lucene.queryParser.QueryParser.getFieldQuery(QueryParser.java:543)\n\tat org.apache.lucene.queryParser.QueryParser.getFieldQuery(QueryParser.java:612)\n\tat org.apache.lucene.queryParser.QueryParser.Term(QueryParser.java:1459)\n\tat org.apache.lucene.queryParser.QueryParser.Clause(QueryParser.java:1211)\n\tat org.apache.lucene.queryParser.QueryParser.Query(QueryParser.java:1168)\n\tat org.apache.lucene.queryParser.QueryParser.TopLevelQuery(QueryParser.java:1128)\n\tat org.apache.lucene.queryParser.QueryParser.parse(QueryParser.java:170)\n\nWorkaround: pass in constructor empty string as a default field name - in this case QueryParser.parse method will throw ParseException (expected result because query string is wrong) instead of NullPointerException.\n\nIt is not obvious to me how to fix this so I'll describe my usecase, may be I'm doing something completely wrong.\nBasically I have a set of per-field queries entered by user and need to programmatically construct (after some preprocessing) one real Lucene query combined from these user-entered per-field subqueries.\nTo achieve this I basically do the following (simplified a bit):\n\nQueryParser parser = new QueryParser(null, analyzer); // I'll always provide a field name in a query string as it is different each time and I don't have any default\nBooleanQuery query = new BooleanQuery();\nQuery subQuery1 = parser.parse(field1 + \"\" + queryString1 + ')');\nquery.add(subQuery1, operator1); // operator = BooleanClause.Occur.MUST, BooleanClause.Occur.MUST_NOT or BooleanClause.Occur.SHOULD\nQuery subQuery2 = parser.parse(field2 + \"\" + queryString2 + ')');\nquery.add(subQuery2, operator2); \nQuery subQuery3 = parser.parse(field3 + \"\" + queryString3 + ')');\nquery.add(subQuery3, operator3); \n...\n\nIMHO either QueryParser constructor should be changed to throw NullPointerException/InvalidArgumentException in case of null field passed (and API documentation updated) or QueryParser.parse behavior should be fixed to correctly throw ParseException instead of NullPointerException. Also IMHO of a great help can be public setField/getField methods of QueryParser (that set/get field), this can help in use cases like my:\n\nQueryParser parser = new QueryParser(null, analyzer); // or add constructor with analyzer only for such cases\nBooleanQuery query = new BooleanQuery();\nparser.setField(field1);\nQuery subQuery1 = parser.parse(queryString1);\nquery.add(subQuery1, operator1);\nparser.setField(field2);\nQuery subQuery2 = parser.parse(queryString2);\nquery.add(subQuery2, operator2); \n...",
    "attachments": {},
    "issue_links": {},
    "comments": [
        {
            "date": "2008-11-13T00:10:40+0000",
            "content": "You shouldn't be passing null to the queryparser as a field right? And if you do, its not part of the query syntax, so it doesn't make sense to feed a \"\" instead of the null to force a parse exception. Just don't pass null, or if someone is really worried about it we could check for null at the top of the method and throw a null argument exception as you suggest. ",
            "author": "Mark Miller",
            "id": "comment-12647132"
        },
        {
            "date": "2008-11-13T20:10:42+0000",
            "content": "> You shouldn't be passing null to the queryparser as a field right?\nWrong. It is not documented anywhere and in practice this WORKS PERFECTLY except for one case of one particular syntax error in a query string that is not handled correctly in this case. (All?) other syntax errors correctly cause ParseException and all valid queries are parsed successfully. BTW, this is exactly what does MultiFieldQueryParser in its constructor - it calls super(null, analyzer).\n\n> its not part of the query syntax, so it doesn't make sense to feed a \"\" instead of the null\nAnd this is also wrong because Lucene query parser syntax allows for queries without explicit field specification (i.e. \"cat AND dog\" is a valid query). From the current docs it is not obvious how to properly construct a query parser that will correctly parse such queries, not clear what should be passed as a field in a QueryParser constructor because there is no any particular field, the same query parser instance is used to parse queries for different fields. If I'll pass not null and not empty string then AFAIR instead of \"+cat + dog\" I'll get as a result \"+field:cat +field:doc\" and this is not acceptable as this will cause a creation of a separate query parser instance for each field - a real overkill I'd say.\n\nReally there are two issues:\n1) it should be documented how should be created \"fieldless\" query parser: that empty string should be used as a field name, that null is unsupported and can give undefined results (alternative is to fix this problem with NullPointerException and document that both ways are supported - null and empty string);\n2) currently there is no way to use the same query parser instance for parsing queries for the different fields (except set default field to empty string and manually add \"field:\" prefix to each query before parsing).\n\nWhat I propose:\n1) document that null field gives undefined behavior (and optionally add null check in constructor  /IMHO documentation can be enough/ or document that null is officially supported);\n2) add public setField method to be able to change the field (may be also setAnalyzer can be usefull?);\n3) add default constructor QueryParser() - and document that in this case field (and analyzer) must be set later before parsing.\n\nI guess currently the same thing can be achieved using static method MultiFieldQueryParser.parse(String[] queries, String[] fields, BooleanClause.Occur[] flags, Analyzer analyzer) but having the way to make it using regular QueryParser can be also usefull (i.e. significantly less overhead - static methods in MultiFieldQueryParser are internally constructing a new parser instance per field!). QueryParser can also benefit from a static parse method similar to MultiFieldQueryParser: public static Query QueryParser.parse(String query, String field, Analyzer analyzer).\n\nI think I can come up with the patch if we all agree on something  ",
            "author": "Alexei Dets",
            "id": "comment-12647381"
        },
        {
            "date": "2008-11-13T22:50:44+0000",
            "content": "And this is also wrong because Lucene query parser syntax allows for queries without explicit field specification (i.e. \"cat AND dog\" is a valid query). From the current docs it is not obvious how to properly construct a query parser that will correctly parse such queries, not clear what should be passed as a field in a QueryParser constructor because there is no any particular field, the same query parser instance is used to parse queries for different fields. If I'll pass not null and not empty string then AFAIR instead of \"+cat + dog\" I'll get as a result \"+field:cat +field:doc\" and this is not acceptable as this will cause a creation of a separate query parser instance for each field - a real overkill I'd say.\n\nHmmm...it was my understanding that QueryParser supports \"cat AND dog\" by allowing you to enter a default field to use, not by letting NULL be any field or the \"\" field. If you want each term to match the \"\" field, I would recommend thats what you pass as the default field to use. You are doing two things here - one, you are supplying a default field to use when the query syntax doesn't contain one, and two, you are supplying the query syntax. I don't see how passing null to the method as the default field is a parse error - supplying the field and parsing the query are two distinct pieces.\n\n1) it should be documented how should be created \"fieldless\" query parser: that empty string should be used as a field name, that null is unsupported and can give undefined results (alternative is to fix this problem with NullPointerException and document that both ways are supported - null and empty string);\n\nI don't believe a 'fieldless' query parser is supported...I may be missing something though...\n\n2) currently there is no way to use the same query parser instance for parsing queries for the different fields (except set default field to empty string and manually add \"field:\" prefix to each query before parsing).\n\nI think this is by design...perhaps a patch will change peoples minds though...\n\nI think checking for null and throwing an error makes sense,  but I'm not understanding the other changes. Perhaps a patch will help move the issue forward. ",
            "author": "Mark Miller",
            "id": "comment-12647446"
        },
        {
            "date": "2011-01-25T15:36:13+0000",
            "content": "I don't think QP should support 'null' passed as the default field, and I doubt if people really pass null as the default field. True, we can add a null check to the ctor, but due to long inactivity, I think it's not a problem people hit, so closing. ",
            "author": "Shai Erera",
            "id": "comment-12986440"
        },
        {
            "date": "2011-04-30T21:42:34+0000",
            "content": "Sorry, but I disagree Mark & Shai.\n\nThe status quo (doing nothing) is the worst option. If committers decide the default field is mandatory then the constructor should check and throw an exception.\n\nBut I happen to believe that null is valid.  In my Solr schema.xml I don't specify a default field because there isn't a suitable default field.  I use dismax (DisjunctionMaxQuery) and list appropriate fields for user queries. That works fine.  In every case a raw lucene query exists, it's one that I write, not users, and I explicitly name fields appropriate for what I'm doing as applicable. The query \":\" for the dismax q.alt param fails due to an NPE.  This issue's title is appropriate so I'm not opening a new bug, but the reporter's description is completely off base from my scenario since I know to balance parenthesis in my queries  ",
            "author": "David Smiley",
            "id": "comment-13027384"
        },
        {
            "date": "2011-05-04T23:11:12+0000",
            "content": "David: i agree with you that QueryParser should be usable w/o a defaultField specified, and any query string that doesn't need the defaultField should be parsed cleanly.\n\nthe original bug reported here was actually about a case where the defaultField was needed to parse the query string (the unbounded params resulted in the QUeryParser wanting to parse \"expr2\" as a field query on the defaultField \u2013 in which case i think the NPE is appropriate, and \"Not a Problem\" makes sense.\n\nHowever: your example of *:* generating an NPE if there is no defaultField should definitely be fixed \u2013 it sounds like a more specific example of \"QueryParser throwing NPE during parsing of a query that does not need the default field when default field is not defined\", and should probably be tracked in a distinct jira ... i was going to file one, but i can't actually reproduce the problem you are describing to post a stack trace \u2013 can you please do that? ",
            "author": "Hoss Man",
            "id": "comment-13029034"
        },
        {
            "date": "2011-05-05T15:04:45+0000",
            "content": "Ok, thanks for your attention Chris. I could have sworn I cornered the bug with my debugger the other day but at the moment I can't seem to reproduce it. It very well may be user error  \u2013 a typo in AJAX-Solr which used \".\" instead of \":\"... probably it was that, in hindsight. ",
            "author": "David Smiley",
            "id": "comment-13029356"
        }
    ]
}