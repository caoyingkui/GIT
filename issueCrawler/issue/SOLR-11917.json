{
    "id": "SOLR-11917",
    "title": "A Potential Roadmap for robust multi-analyzer TextFields w/various options for configuring docValues",
    "details": {
        "labels": "",
        "priority": "Major",
        "components": [
            "Schema and Analysis"
        ],
        "type": "Wish",
        "fix_versions": [],
        "affect_versions": "None",
        "resolution": "Unresolved",
        "status": "Open"
    },
    "description": "A while back, I was tasked at my day job to brainstorm & design some \"smarter field types\" in Solr. In particular to think about:\n\n\tHow to simplify some of the \"special things\" people have to know about Solr behavior when creating their schemas\n\tHow to reduce the number of situations where users have to copy/clone one \"logical field\" into multiple \"schema felds in order to meet diff use cases\n\n\n\nThe main result of this thought excercise is a handful of usecases/goals that people seem to have - many of which are already tracked in existing jiras - along with a high level design/roadmap of potential solutions for these goals that can be implemented incrementally to leverage some common changes (and what those changes might look like).\n\nMy intention is to use this jira as a place to share these ideas for broader community discussion, and as a central linkage point for the related jiras. (details to follow in a very looooooong comment)\n\nNOTE: I am not (at this point) personally committing to following through on implementing every aspect of these ideas",
    "attachments": {},
    "issue_links": {},
    "comments": [
        {
            "date": "2018-01-26T22:17:54+0000",
            "content": "The following notes were compiled over many months and iteratively tweaked/revised \u2013 It's likeley that in some cases my comments may be overlooking/ignorant-of comments/ideas/patches related to some of these concepts that were posted added after I wrote them that i just haven't noticed since.\n\nAlso: Jira says my notes are too long for one comment, so i have to break it up into sections\n\nHigh Level Goals / *U*secases\n\nTalking to various customers about their pain points, and reading up on various jiras lead me to a handful of Text/String related *U*secases that all seemed like they have solutions that could either overlapp, or be in close proximity, when it came to implementation:\n\n\tU0: \"I want sane defaults when sorting on multivalued fields, not an error\"\n\t\n\t\tLow hanging fruit already implemented for PrimitiveFieldType subclasses in SOLR-11854\n\t\n\t\n\tU1: (SOLR-8362) Add docValues support to TextField (or some new subclasses of TextField) \u2013 Because...\n\t\n\t\tU1.1: \"I want to be able to (efficiently) sort on the original input of a TextField (using docValues)\"\n\t\tU1.2: \"I want to be able to (efficiently) facet on (docValues built from) the indexed terms of a TextField\n\t\tU1.3: \"I want to be able to (efficiently) sort/facet on docValues built from analyzed terms using a completely diff analyzer then what i use for searching\"\n\t\t\n\t\t\tExample: StandardAnalyzer for searching, but lowercased docValues for sorting.\n\t\t\n\t\t\n\t\n\t\n\tU2: Choose Query Analysis Aspects At Query Time \u2013 Because...\n\t\n\t\tU2.1: \"I want to be able to do multi-language indexing/querying easily so it only looks like one 'field' name.\" (SOLR-6492)\n\t\tU2.2: \"I want to be able to have lots of arbitrary analyzers I pick between arbitrarily at query time and maybe shoot myself in the foot but it's ok i'm an expert and i have special needs.\" (SOLR-5053)\n\t\t\n\t\t\tNOTE: the description of SOLR-5053 does also list multi-lang as a motivation, but some of the examples \u2013 like \"ignore synonyms\" \u2013 are definitely broader scope then this.\n\t\t\n\t\t\n\t\n\t\n\n\n\n\u00a0\n\n\u00a0 ",
            "author": "Hoss Man",
            "id": "comment-16341679"
        },
        {
            "date": "2018-01-26T22:18:48+0000",
            "content": "Hoss'ss High Level Thoughts on these Goals / *U*secases\n\nWhile it's certainly possible to takle some of these objectives independently of the others, either from a standpoint of of incremental feature delivery, or from a standpoint of \"end user ease of use\" there definitely seems to be some overlap here that's worth considering.\n\nIn particular:\n\n\tWhile there is certainly some non-trivial set of possible implementations that can satisfy both U2.1 and U2.2, my gut impression is that no one implementation will really fit both usecases well in an easy to use/understand way. I'm also pretty confident that the \"multi-language\" use cases would be easier to solve/build in a \"clean\" (and easy for users to understand) approach more simply / quickly then any (non-silly) solutions that would support the \"let me shoot my self in the foot if I want\" objectives.\n\tWhile I personally don't feel that the U2.2 usecase is a particularly good idea, the overall \"plumbing\" involved in supporting this type of usecase would be very helpful towards supporting U1.3\n\tLikewise: U1.1 and U1.2 should be easy be implement as new FieldTypes independent from the more complex needs of U1.3. But if U1.3 was possible, then there would likely be potential for refactoring to reduce common code and simplify the implementations.\n\n\n\n\u00a0 ",
            "author": "Hoss Man",
            "id": "comment-16341681"
        },
        {
            "date": "2018-01-26T22:20:00+0000",
            "content": "Some Concrete Thoughts On *S*olutions\n\nNOTE: While there is a one-to-one corrispondice in the naming/numbering of the *U*secases listed above and the proposed *S*olutions listed below, I have ordered the *S*olutions in the way that I think makes the most sense from an \"explaining how to achieve things\" standpoint.\n\nS1.1: A 'SortableTextField' that builds docValues using the original text input\nS1.1G: Goal\n\nA new SortableTextField subclass would be added that would functionally work the same as TextField except:\n\n\tdocValues=\"true|false\" could be configured, with the default being \"true\"\n\tThe docValues would contain (a prefix of) the original input values (just like StrField) for sorting (or faceting)\n\t\n\t\tBy default, to protect users from excessively large docValues, only the first 1024 of each field value would be used \u2013 but this could be overridden with configuration.\n\t\n\t\n\n\n\nS1.1E: Example Usage\n\nConsider the following sample configuration:\n\n<field name=\"title\" type=\"text_sortable\" docValues=\"true\"\n       indexed=\"true\" docValues=\"true\" stored=\"true\" multiValued=\"false\"/>\n<fieldType name=\"text_sortable\" class=\"solr.SortableTextField\">\n  <analyzer type=\"index\">\n   ...\n  </analyzer>\n  <analyzer type=\"query\">\n   ...\n  </analyzer>\n</fieldType>\n\n\nGiven a document with a title of \"Solr In Action\"\n\nUsers could:\n\n\tSearch for individual (indexed) terms in the \"title\" field: q=title:solr\n\tSort documents by title ( sort=title asc ) such that this document's sort value would be \"Solr In Action\"\n\n\n\nIf another document had a \"title\" value that was longer then 1024 chars, then the docValues would be built using only the first 1024 characters of the value (unless the user modified the configuration)\n\nNOTE: This would be functionally equivalent to the following existing configuration - including the on disk index segments - except that the on disk DocValues would refer directly to the \"title\" field, reducing the total number of \"field infos\" in the index (which has a small impact on segment housekeeping and merge times) and end users would not need to sort on an alternate \"title_string\" field name - the original \"title\" field name would always be used directly.\n\n<field name=\"title\" type=\"text\"\n       indexed=\"true\" docValues=\"true\" stored=\"true\" multiValued=\"false\"/>\n<field name=\"title_string\" type=\"string\"\n       indexed=\"false\" docValues=\"true\" stored=\"false\" multiValued=\"false\"/>\n<copyField source=\"title\" dest=\"title_string\" maxChars=\"1024\" />\n\n\nS1.1A: Suggested Approach (SOLR-11916)\n\nWhile experimenting with a quick POC for this idea, I actually wound up building a SortableTextField that is feature complete. See patch in SOLR-11916.\n\nNOTE: If/when S1.3A is implemented, this SortableTextField could be refactored to be syntactic sugar for TextField w/ some added defaults \u2013 see below.\n\nS1.2: A 'TermDocValuesTextField' that builds docValues using the post-analysis terms\nS1.2G: Goal\n\nA new TermDocValuesTextField subclass would be added that would functionally work the same as TextField except:\n\n\tdocValues=\"true|false\" could be configured, with the default being \"true\"\n\tInstances of fields using this type would support faceting (or sorting), using DocValues build from the terms produced by the \"index\" analyzer\n\t\n\t\tNOTE: Sorting on this type of field would only make sense in some special circumstances depending on the analyzer used (ie: KeywordTokenizer)\n\t\n\t\n\n\n\nS1.2E: Example Usage\n\nConsider the following sample configuration\n\n<field name=\"keywords\" type=\"text_facet\" docValues=\"true\"\n       indexed=\"true\" docValues=\"true\" stored=\"true\" multiValued=\"true\"/>\n<fieldType name=\"text_facet\" class=\"solr.TermDocValuesTextField\">\n  <analyzer>\n   <tokenizer class=\"solr.WhitespaceTokenizerFactory\" rule=\"unicode\"/>\n   ...\n  </analyzer>\n</fieldType>\n\n<field name=\"author\" type=\"text_lc_sort\" docValues=\"true\"\n       indexed=\"true\" docValues=\"true\" stored=\"true\" multiValued=\"false\"/>\n<fieldType name=\"text_lc_sort\" class=\"solr.TermDocValuesTextField\">\n  <analyzer>\n   <tokenizer class=\"solr.KeywordTokenizerFactory\"/>\n   <filter class=\"solr.LowerCaseFilterFactory\"/>\n  </analyzer>\n</fieldType>\n\n\nGiven a document with an author of \"Grainger, Trey\" and keywords value of of \"book lucene solr\"\n\nUsers could:\n\n\tSearch for individual (indexed) terms in the \"keywords\" field: q=keywords:book\n\tFacet on the keywords field (facet.field=keywords) such that if this were the only document in the index, the facet counts would be \"book=1, lucene=1, solr=1\"\n\tSort documents by author (sort=title asc) such that this document's sort value would be \"grainger, trey\"\n\n\n\nNOTE: This should be functionally equivalent to users faceting on a \"keywords\" TextField (or sorting on an \"author\" TextField using KeywordTokenizer) today, except that the facet/sort values would come from DocValues (written at indexing time), and not the FieldCache (built on the fly at query time and held solely in RAM).\nS1.2A: Suggested Approach\n\n\tAdd a new TermDocValuesTextField subclass of TextField\n\tif docValues=\"true\":\n\t\n\t\tAugment the configured \"index\" analyzer to record each resulting token from the stream in a Set\n\t\tWhen indexing, pre-analyze/buffer the token stream and use the recorded Set of tokens to build additional SortedSetDocValuesField instances in the underling indexed document\n\t\n\t\n\tOPTIMIZATION?: We may be able to avoid the pre-analysis/buffering of the TokenStream and instead hook into the low level indexing code with a callback to generate the SortedSetDocValuesField instances on the fly as the DocumentsWriter reads from the (original) TokenStream ... needs experimentation/refactoring once we have some tests.\n\n\n\nNOTE: If/when S1.3A is implemented, this TermDocValuesTextField could be refactored to be syntactic sugar for TextField w/ some added defaults \u2013 see below.\n\n\u00a0\n\n\u00a0 ",
            "author": "Hoss Man",
            "id": "comment-16341687"
        },
        {
            "date": "2018-01-26T22:21:31+0000",
            "content": "S2.1: Easy Multi-Language Querying (SOLR-6492)\nS2.1G: Goal\n\nSimplified indexing & querying of text in diff languages w/o the query clients being required to know about a lot of language specific variant field names. At index time we want things to be \"easy\" for clients wending documents, regardless of whether they already know the lang of each field value in advance, or if they want solr to do langauge detection.\nS2.1A: Suggested Approach\nRefresher: Summary of Solr In Action (SIA) code linked to from\nSOLR-6492\nWhat's included & how it works...\n\n\tcustom update process & custom field type\n\t\n\t\tprocessor is subclass of existing lang detect update processor\n\t\t\n\t\t\tsuper class normally adds a field with languages in doc, or renames fields to include language (ie: text => text_de)\n\t\t\n\t\t\n\t\tfield type is subclass of TextField\n\t\t\n\t\t\tgoes out of it's way to override any Analyzer config with a custom one (details below)\n\t\t\tconfigured with a list of mappings from langid to other (existing) field types\n\t\t\n\t\t\n\t\n\t\n\tIndex Time:\n\t\n\t\tupdate processor delegates to super to detect languages but instead of (in addition to?) super class's behavior of adding a language field to doc, or renaming the field with suffix, the custom processor \"decorates\" the values with the detected language(s)...\n\t\tfor any field where the field type is our custom type:\n\t\t\n\t\t\t\"decorate\" each of the field values with either:\n\t\t\t\n\t\t\t\tthe langs of the whole doc\n\t\t\t\tthe langs of the field (after re-running lang detect on all values in just that field)\n\t\t\t\tthe langs of the individual field value (after re-running lang detect on just that field value)\n\t\t\t\n\t\t\t\n\t\t\n\t\t\n\t\tother processors can then run as normal, and eventually the IndexSchema is asked to build up the IndexableFields for this doc, and it delegates to the (custom) field type for these \"decorated\" fields...\n\t\tfield type's custom analyzer looks for these lang \"decorations\" on each field value\n\t\t\n\t\t\tfor every lang found, go fetch the analyzer from the mapped field type it's configured with\n\t\t\tcreate a token stream that delegates to all the other analyzers & merges the resulting token streams\n\t\t\tall this custom delegation/merging tokenstream stuff is (optionally/wisely) wrapped in RemoveDuplicatesTokenFilter since there can be lots of dup tokens for similar languages.\n\t\t\n\t\t\n\t\n\t\n\tQuery Time:\n\t\n\t\tthe query string provided by the user can be \"decorated\" with a list of languages\n\t\tthe normal plumbing of TextField analyzes the query string, delegating to the various analyzers\n\t\t\n\t\t\tAFAICT: this means MultiTermPhraseQueries are frequently produced?\n\t\t\n\t\t\n\t\n\t\n\tNOTE: as mentioned in Trey's LR talk for 2014, a \"perk\" of this solution (over using diff fields per languages) is that mixing languages in one field value can \u2013 in theory \u2013 still produce useful phrase queries, even if the non-correct analyzers butcher the terms in other languages such that a single phrase produced by either language analyzer wouldn't match the original string\n\t\n\t\thttps://www.youtube.com/watch?v=MQ6WtBw8T_U\n\t\tBUT: it's not really clear if/how useful/important this is. Does any one have any actual usecases for this???\n\t\n\t\n\n\n\nThe Fiddly / Awkward / Problematic Bits Of All This Existing Code\n\n\tlanguage \"decoration\" is super hackish\n\t\n\t\tindex time:\n\t\t\n\t\t\tthe update processor prepends them as a string\n\t\t\tnot a lot of easy improvements currently possible given the current SolrInputDocument / UpdateProcessor / DocumentBuilder structure / code paths\n\t\t\t\n\t\t\t\tfixing this \"THE RIGHT WAY\" would probably require some pretty big changes to all this code so SolrInputField could support arbitrary metadata (instead of just \"boost\" like it does today) and passing the SolrInputFields all the way to the FieldType's createFields method\n\t\t\t\tthe hackish way to do this might be to follow in the footsteps of atomic update with \"field value may be a map containing magic keys\", but...\n\t\t\t\t\n\t\t\t\t\tthis would probably break Atomic Updates (unexpected keys in the Maps it thinks it owns)\n\t\t\t\t\tthis was already a super heinous API hack and hacks this heinous should not be reworded by being copied\n\t\t\t\t\tEven if we did this, i'm not certain the FieldType's createFields() would get the full Map w/o a bunch of other changes in the middle \u2013 if we're going to have to change existing DocumentBuilder/IndexSchema code to make this work, let's not be heinous about it.\n\t\t\t\t\n\t\t\t\t\n\t\t\t\n\t\t\t\n\t\t\n\t\t\n\t\tquery time:\n\t\t\n\t\t\tuser must prefixing the terms inside the query strings \u2013 after the field name\n\t\t\texample: q=my_multi_lang_field:\"en,es|Hello there compadre\"\n\t\t\tfixing this in a sane way should be really straight forward...\n\t\t\t\n\t\t\t\tall of the \"public Query getFoo(...)\" methods a FieldType must implement take in the QParser originating the query\n\t\t\t\twe can ask the QParser for the local/req params\n\t\t\t\tso syntax like \"q= {!field f=body langs='en,es'}Hello there compadre\" would be easy to support\n\t\t\t\n\t\t\t\n\t\t\n\t\t\n\t\n\t\n\tthe tokenstream merging slurps in the entire Reader as a String on first use, then pre-analyzes using every analyzer and builds up an in memory LinkedList<Token>\n\t\n\t\twhy is this needed? why can't we just cache one \"Token\" per Analyzer? ie...\n\t\t\n\t\t\teach call to incrementTokens calls incrementTokens on any delegate analyzer where we don't have a cached token (and says it's not done with the input)\n\t\t\tthen return (and null out) whichever cached token has the lowest position\n\t\t\n\t\t\n\t\talso: since this is super custom code and we know the way our analyzer is getting used is from our custom FieldType, why mess with a Reader -> String at all since we know for certain the Reader is a StringReader\n\t\t\n\t\t\tie: bypass the normal \"this.getAnalyzer()\" and just give the \"Analyzer\" the original String ?\n\t\t\n\t\t\n\t\n\t\n\n\nS2.1.STRAW1: Straw Man Proposal #1 \u2013 aka \"Complex For Users\"\n\nExisting SIA Code + query time local params\n\n\tkeep most of the existing SOLR-6492 code as is\n\t\n\t\tall indexing code and update processor sub class stay the same\n\t\t\n\t\t\tincluding the hackish way we have to prefix-decorate the langs on field values at index time\n\t\t\thopefully fix the analyzer to be more efficient\n\t\t\n\t\t\n\t\tat query time:\n\t\t\n\t\t\tin the FieldType: override the \"public Query getFoo(...)\" methods to look at the local/req params for a langs\n\t\t\tuse those langs when using our custom (wrapper) analyzer\n\t\t\tNOTE: This cleaner query time API still has a hitch \u2013 see S2.1.HITCH below\n\t\t\n\t\t\n\t\n\t\n\tThis approach seems more \"complex\" to explain to users then the strawman #2 (S2.1.STRAW2) below\n\t\n\t\tparticularly given the dependency on the new update processor (or users adding magic field value decoration at index time)\n\t\tand especially if/when they gain more experience with solr and want to understand more what's happening under the covers and how to tweak/customize behavior.\n\t\tsee full pro/con list below\n\t\n\t\n\n\n\nS2.1E.STRAW1: Hypothetical Example Usage of this S2.1.STRAW1 Strawman...\n\n<field name=\"title\" type=\"langaware\" />\n<field name=\"body\" type=\"langaware\" />\n\n<fieldType name=\"langaware\" class=\"solr.MultiLangAwareTextField\"\n           defaultFieldType=\"text_general\"\n           fieldMappings=\"en:text_english,\n                          es:text_latin,\n                          fr:text_french\"/>\n<fieldType name=\"text_general\" ... />\n<fieldType name=\"text_english\" ... />\n<fieldType name=\"text_french\" ... />\n<fieldType name=\"text_latin\" ... />\n\n\n\n<!-- doc sent by client using new custom update processor -->\n<doc>\n  <field name=\"title\">Solr In Action</field>\n  <field name=\"body\">Ipsum Lorem ... thousands of pages of text</field>\n<doc>\n\n<!-- doc sent by client that knows what lang these fields are\n<doc>  \n  <field name=\"title\">en|Solr In Action</field>\n  <field name=\"body\">la|Ipsum Lorem ... thousands of pages of text</field>\n<doc>\n\n\n\n\n# Uses the lang specific analysis the user asked for\n/query?q={!lang=la}body:Lorem&fq={!field f=title lang=en}Action\n\n# Falls back to the text_general analysis since no lang is known\n/query?q=body:Lorem&fq={!field f=title}Action\n\n\nS2.1.STRAW2: Straw Man Proposal #2 \u2013 aka \"Simple for Users\"\n\nOverride only the Query parsing bits of TextField (or huper duper text field)\n\n\tcontinue using diff fields per lang ague (either dynamic or explicitly) in schema\n\tcontinue using the existing clone / lang detect update processors to processors copy/rename fields (ie: title => title + title_es)\n\tlet the analyzer for types like \"text_es\" do it's regular analysis and indexing into the underlying fields like \"title_es\"\n\tlet types like \"text_multilang\" for fields like \"title\" be a new QueryLangAwareProxyTextField that extends TextField\n\t\n\t\tstill supports a direct analyzer configuration for it's \"default\" behavior (ie: something simple that is as lang agnostic as possible, aka: text_general)\n\t\tat index time, just does it's regular indexing with it's configured analyzer\n\t\tat query time:\n\t\t\n\t\t\tif the QParser's params don't indicate a lang ague, do a normal query against the specified field\n\t\t\tif the QParser does specify some languages:\n\t\t\t\n\t\t\t\tbuild up a list lang specific field names using the current field name + the languages (ie \"title\" + \"_\" + \"es\")\n\t\t\t\t\n\t\t\t\t\tfetch the FieldType's for each of those field names from the IndexSchema\n\t\t\t\t\tdelegate to the equivalent \"public Query getFoo\" for each of those FieldTypes, wrap the results in a DisjunctionMaxQuery\n\t\t\t\t\n\t\t\t\t\n\t\t\t\n\t\t\t\n\t\t\tNOTE: This use of QParser params still has the same hitch as strawman #1 (S2.1.STRAW1) \u2013 see S2.1.HITCH below\n\t\t\n\t\t\n\t\n\t\n\tThis approach seems simpler to explain to new users then strawman #1 (S2.1.STRAW1)\n\t\n\t\tparticularly given that it can be useful (in a clean way) even w/o any (new) langid update processors when users already know the language of the fields for each doc, but just want simplified querying.\n\t\tsee full pro/con list below\n\t\n\t\n\n\n\nS2.1E.STRAW2: Hypothetical Examples of this S2.1.STRAW2 Strawman #2...\n\n<field name=\"title\" type=\"langaware\" />\n<field name=\"body\" type=\"langaware\" />\n\n<fieldType name=\"langaware\" class=\"solr.QueryLangAwareProxyTextField\">\n  <!-- no special mappings needed, just simple lang agnostic default analyzers -->\n  <analyzer type=\"index\" ... />\n  <analyzer type=\"query\" ... />\n</fieldType>\n\n<dynamicField name=\"*_en\" type=\"text_english\" ... />\n<dynamicField name=\"*_fr\" type=\"text_french\" ... />\n<dynamicField name=\"*_la\" type=\"text_latin\" ... />\n\n<fieldType name=\"text_english\" ... />\n<fieldType name=\"text_french\" ... />\n<fieldType name=\"text_latin\" ... />\n\n\n\n<!-- sample doc sent by client using langid update processor -->\n<!-- title copied to title_en, body copied to body_la -->\n<doc>\n  <field name=\"title\">Solr In Action</field>\n  <field name=\"body\">Ipsum Lorem ... thousands of pages of text</field>\n<doc>\n\n<!-- sample doc sent by client that knows what lang these fields are -->\n<!-- CloneFieldUpdateProcessor or something simple like can copy these to \"title\" & \"body\" -->\n<doc>  \n  <field name=\"title_en\">Solr In Action</field>\n  <field name=\"body_en\">Ipsum Lorem ... thousands of pages of text</field>\n<doc>\n\n\n\n\n# rewrites the queries against the lang specific versions using the langs the user asked for\n/query?q={!lang=la}body:Lorem&fq={!field f=title lang=en}Action\n\n# Falls back to the default analysis (configured on 'langaware' type) since no 'lang' is specified\n/query?q=body:Lorem&fq={!field f=title}Action\n\n# user can still choose to sort on, or filter against, the existence of data in specific language fields\n/query?q=body_la:Lorem&sort=title_la asc\n\n\nS2.1.HITCH: One Hitch @ Query Time To Both Strawmen\n\nCurrently, SolrQueryParserBase/QueryBuilder sometimes uses the \"Analyzer\" (IndexSchema's per field wrapper) directly w/o delegating to ft.getFieldQuery(...).\n\nBest solution I can think of:\n\n\tSolrQueryParserBase should override createFieldQuery(Analyzer,...) in a way that it can delegate to the FieldType\n\t\n\t\tmust happen in such a way that the FieldType can make a callback to the low level QueryBuilder.createFieldQuery \u2013 otherwise we'll have to copy/paste a lot of existing code.\n\t\tNOTE: QueryBuilder.createFieldQuery currently protected.\n\t\n\t\n\tThis callback should involve a QParser (like the existing \"public Query getFoo\" methods on FieldType) to access the flags/params to capture some of the QueryBuilder state / variables passed to createFieldQuery\n\t\n\t\tin our special case, we ignore the specified Analyzer and pick one at query time\n\t\n\t\n\tGENERAL IMPROVEMENT IDEA:\n\t\n\t\tmaybe QParser should extend SolrQueryParserBase/QueryBuilder and automatically call some QueryBuilder setter methods based on common local params (like \"df\", \"f\", \"q.op\", etc...)\n\t\tsome existing QParsers (like LuceneQParser and ExtendedDismaxQParser could then be refactored to do their query parsing directly (instead of the QParser instantiating a custom subclass of SolrQueryParser)\n\t\tthis would potentially simplify a variety of existing QParser subclasses\n\t\tcould also simplify some FieldType.getFoo methods that currently call \"new FooQuery\" \u2013 they could instead delegate back to QParser.newFooQuery\n\t\tif we did this, then the callback mechanism needed for these strawmen ideas would be (mostly?) straight forward:\n\t\t\n\t\t\tQParser would override QueryBuilder.createFieldQuery(Analyzer,...) to delegate to the FieldType's getFieldQuery, passing in a nested/sub-QParser with the various method call specific options included as state/params\n\t\t\tQParser would also expose a new public method that the FieldType could call back to that would ultimately call super.createFieldQuery(Analyzer,...)\n\t\t\n\t\t\n\t\n\t\n\n\n\nHypothetical (Broken) Alternatively:\n\n\twe could consider eliminating the analyzers \"cache\" that IndexSchema uses (only helpful for non-dynamic fields) and change getQueryAnalyzer to take in a QParser can can capture some query/request state so that the FieldType can customize the Analyzer behavior\n\tthen our special field type can delegate to a completely diff FieldType\n\tThe Problem With This Alternative:\n\t\n\t\tthe field name that QueryBuilder then uses in the underlying Query objects would still be \"wrong\"\n\t\tThis would not be a problem with the callback approach discussed above, because our new FieldType could call callback to the QueryBuilder methods w/any field name + analyzer pair it wanted.\n\t\n\t\n\n\n\nS2.1.PROCON: Pros/Cons of the two Strawmen\n\n\tThe S2.1.STRAW2 approach seems simpler to understand/explain to users\n\t\n\t\tno special/magic field types they have to declare and reference from another field\n\t\t\n\t\t\tie: they declare/manage title, title_en, title_es, title_de fields \u2013 the only thing special is that querying the \"title\" field can proxy to the others as well when the query requests it\n\t\t\tthis means this approach is also automatically compatible with people who want to explicitly index multiple fields for each language:\n\t\t\t\n\t\t\t\tie: they already have/know an \"english title\" and a \"translated spanish title\" in the source docs, and don't need any index side (langdetect/copyfield) help \u2013 our new field type just helps make the query side simple/easy to use.\n\t\t\t\n\t\t\t\n\t\t\n\t\t\n\t\talso plays nicely if we decide to do the SortableTextField described above (S1.1) and want to extend it here:\n\t\t\n\t\t\tthe user still has distinct fields for \"title\", \"title_es\", etc... and can choose to sort on any of them\n\t\t\t\n\t\t\t\teven in the trivial case, where they only have one original field value per doc (which lang detect also copied to title_XX), they probably always want to sort on the general \"title\" field \u2013 \"keep simple stuff simple\"\n\t\t\t\n\t\t\t\n\t\t\n\t\t\n\t\tcan be implemented completely independently/orthogonally from all the ideas discussed here\n\t\tthe downsides of S2.1.STRAW2 are:\n\t\t\n\t\t\tdoesn't give us the \"mixed languages in a single field value\" phrase query benefit (which seemed out of scope? do we have usecases like this we care about?)\n\t\t\tdoesn't \"save space\" like single field approach when multi languages produce same tokens\n\t\t\t\n\t\t\t\tAlthough i'm not convinced that's fundamentally true \u2013 or even beneficial: since any space savings from diff languages producing the same underlying \"term\" text may be offset by potential false positives in phrase matches (since we're assuming that even if multiple (guessed) languages may be specified at query time, the query string is expected to be in a single language and searching across those multiple languages should be done independently\n\t\t\t\n\t\t\t\n\t\t\n\t\t\n\t\n\t\n\n\n\n\n\tthe S2.1.STRAW1 approach seems like it would be harder to explain to novice users\n\t\n\t\tie: the special configuration of refering to (otherwise seemingly unused) fieldtypes from special fieldtypes\n\t\t\n\t\t\twe've had this in the psat with some things like ExternalFileField & CurrencyField and it's always confusing\n\t\t\n\t\t\n\t\tthe special prefix decoration of langs at indexing time also means this approach either requires users learn about & use the new update processor (ie: the features are locked together), or require some explanation of how clients must decorate the field values\n\t\twhich also means that this approach would also not play very nicely with people who have pre-translated field values at index time\n\t\t\n\t\t\twe could potentially offer an \"prepend lang code update processor\" to make it easy to massage their data for them\n\t\t\t\n\t\t\t\tex: title_es:\"Hola Juan\", title_en:\"Hello John\" ==> title:[\"es|Hola Juan\", \"en|Hello John\"]\n\t\t\t\n\t\t\t\n\t\t\n\t\t\n\t\tif we extend the SortableTextField (S1.1) idea...\n\t\t\n\t\t\tonly the trivial usecases (each logical field is only in one language) plays nicely with sorting\n\t\t\tif a user starts with multiple different \"translated\" fields \u2013 and has to consolidate them as multiple field values in a single field (with our hypothetical \"prepend lang code update processor\") then they don't really have any way to \"sort on the spanish title\" with this approach\n\t\t\t\n\t\t\t\tunless of course they also redundantly index every lang variant as it's own field \u2013 but then most of the benefits of this approach are out the window (ie: there are no fieldname/configuration/disk savings as compared to the other strawman)\n\t\t\t\n\t\t\t\n\t\t\n\t\t\n\t\tThe key upside i can think of for S2.1.STRAW1:\n\t\t\n\t\t\tIf we first focus on S2.2 (see below), then the schema syntax could potentially be simplified to remove the \"lang -> some other fieldType name\" mapping and instead use lots of nested analyzers named after each langauge\n\t\t\tthis might still be a bit confusing however if people want diff index/query(/multiTerm) analyzers for each langague ... would have to use some sort of regid naming convention?\n\t\t\n\t\t\n\t\n\t\n\n\n\n\nNOTE: If either strawman is implemented, we should strongly consider including an additional option/subclass of this new \"*LangAwareTextField\" to automatically use the langid plugin code at query time to try and \"guess\" the lang if it isn't specified in a 'lang' local/request params\n\n\tat least for language-detect (latest version), there are special models built just for short inputs\n\twe could potentially make the code use the guessed lang at query time only if above some configured confidence:\n\t\n\t\tor: if explicit 'lang' param, use only that lang \u2013 but if the langauge is guessed, query using both the field/analyzer for that specific lang as well as the 'default' field/analyzer\n\t\n\t\n\n\n\u00a0\n\n\u00a0 ",
            "author": "Hoss Man",
            "id": "comment-16341692"
        },
        {
            "date": "2018-01-26T22:22:37+0000",
            "content": "S2.2: Support configuring fieldTypes with many arbitrarily named analyzers\nS2.2G: Goal\n\nThe initial goal i considered was based solely on SOLR-5053:\n\n\tAdvanced users may want to use arbitrary analyzers at query time \u2013 either by \"name\" when parsing a query, or based on special logic in custom plugins.\n\n\n\nBut when considered in conjunction with some of the other Usecases discussed here, I realized there was a lot of potenial for general purpose improvements to the \"plumbing\" of IndexSchema to supporting multiple analyzers...\n\n\tMultilingual \"fields\" might benefit from having \"analyzer per lang\" configurable on a field type (see S2.1.STRAW1 above)\n\tIt would allow us to define arbitrary \"docValues\" analyzer for TextFields (see S1.3 below)\n\n\n\nS2.2BAD: Bad Ideas \u2013 aka: NOT-Suggested Approach(es)\n\nFor the sake of completeness, let's set aside for a moment the broader benefit of a robust solution to supporting arbitrary analyzers for TextField, and consider how we might tackle the \"user wants to pick an analyzer by name at query time\" with the least amount of development work (ie: \"rapid prototype\") ...\n\nBad Idea #1:\n\n\tsubclass of TextField\n\tat query time, getFieldQuery() looks for an \"ftanalyzer\" local param from QParser,\n\t\n\t\tif exists: use that to find some other FieldType whose Analyzer we use in place of our own\n\t\n\t\n\tNOTE: see S2.1.HITCH above about SolrQueryParserBase/QueryBuilder in previous topic \u2013 also apply here except in simple cases\n\t\n\t\tAlthough in a super special case situation like this, maybe a limitation of \"only works with 'field' QParser\" would be fine? ... but in that case, see Bad Idea #2...\n\t\n\t\n\n\n\nBad Idea #2:\n\n\tassume this usecase/situation is so niche, that we don't need general query parser support\n\tassume we can tell people the must use a specific QParser to do it\n\tNo need for a special TextField subclass \u2013 instead create a new 'ForceAnalyzerQParser'\n\t\n\t\tuse it just like the \"field\" QParser, but it also takes in a \"forceFieldType\" localparam\n\t\tuse the \"forceFieldType\" to pick a fieldType by name, and ask it for getFieldQuery(...) using the original field name\n\t\n\t\n\tExample:\n\n# query the 'title' field for \"how now brown cow\" using the analyzer from the 'nostopwords' <fieldType/>\nq={!forceanalyzer f=title forceFieldType='nostopwords'}how+now+brown+cow\n\n\n\n\n\nS2.2A: Suggested Approach \u2013 aka: Good Idea\n\nAFAICT, This is what it would take to support arbitrary analyzers on TextFields \"the right way\"...\n\n\tFieldType method deprecation/replacement\n\t\n\t\tdeprecate/replace these overly specific methods in FieldType...\n\npublic final void setQueryAnalyzer(Analyzer analyzer)\npublic void setIsExplicitQueryAnalyzer(boolean isExplicitQueryAnalyzer)\npublic boolean isExplicitQueryAnalyzer()\n//\npublic final void setIndexAnalyzer(Analyzer analyzer)\npublic void setIsExplicitAnalyzer(boolean explicitAnalyzer)\npublic boolean isExplicitAnalyzer()\n\n\n\t\n\t\n\n\n\n\n\t\n\t\n\t\tWith code like these...\n\n/** For setting the (explicitly) configured analyzers, key is type,\n    can throw an exception if a type is not allowed/supported,\n    but must ultimately call super for getExplicitAnalyzers() to work\n    \n    Default impl calls changeExplicitAnalyzers() for validation\n  */\npublic final void setExplicitAnalyzers(Map<String,Analyzer>) throws SolrException\n/** exactly what was configured/passed to setExplicitAnalyzers */\npublic final Map<String,Analyzer> getExplicitAnalyzers()\n/** can create & track any implicit /synthetic analyzers needed based on what's explicitly configured.\n    can throw an exception if an explicitly configured type is not allowed/supported.\n    See below for discussion of default impl\n  */\npublic void changeExplicitAnalyzers(Map<String,Analyzer>) throws SolrException\n/* returns either an explicit analyzer configured with that type,\n   or may return an alternate (or synthetic created) analyzer deemed suitable for that purpose,\n   or null if nothing suitable.\n   default impl only supports \"index\" and \"query\"\n   */\npublic Analyzer getAnalyzer(String type) throws SolrException\n\n\n\t\n\t\n\n\n\n\n\tFieldTypePluginLoader.create refactoring...\n\t\n\t\tinstead of looking for specific analyzers, call readAnalyzer on all \"./analyzer\" XML nodes\n\t\t\n\t\t\tif no type attribute, use type=null\n\t\t\n\t\t\n\t\tbuild up Map<String,Analyzer> using everything found\n\t\t\n\t\t\tif, as the Map is being built, any key already exists, fail w/exception about the field type having multiple analyzers with the same type.\n\t\t\n\t\t\n\t\tdelegate to FieldType.setExplicitAnalyzers()\n\t\t\n\t\t\tall the existing special case handling in this method should be refactored into FieldType.changeExplicitAnalyzers() ...\n\t\t\t\n\t\t\t\tHasImplicitIndexAnalyzer\n\t\t\t\tquery Analyzer is / is not null\n\t\t\t\t(index) Analyzer is/ is not null\n\t\t\t\tconstructMultiTermAnalyzer\n\t\t\t\n\t\t\t\n\t\t\tALLTHOUGH: the really special case stuff should actually be refactored into the specific classes:\n\t\t\t\n\t\t\t\tTextField should override setExplicitAnalyzers() and call constructMultiTermAnalyzer after super.setExplicitAnalyzers()\n\t\t\t\tPreAnalalyzedField (the only class that implements HasImplicitIndexAnalyzer) should override setExplicitAnalyzers() and do it's own ignoring/logging about explicit analyzers before delegating to super\n\t\t\t\tDeprecate/Keep the HasImplicitIndexAnalyzer check in FieldType.changeExplicitAnalyzers() for backcompat (in case custom field types use it) on stable branches, remove the interface completely from master\n\t\t\t\n\t\t\t\n\t\t\n\t\t\n\t\n\t\n\tFieldTypeDefinition\n\t\n\t\tdeprecate/replace these methods...\n\npublic AnalyzerDefinition getIndexAnalyzer()\npublic void setIndexAnalyzer(AnalyzerDefinition indexAnalyzer)\npublic AnalyzerDefinition getQueryAnalyzer()\npublic void setQueryAnalyzer(AnalyzerDefinition queryAnalyzer)\npublic AnalyzerDefinition getMultiTermAnalyzer()\npublic void setMultiTermAnalyzer(AnalyzerDefinition multiTermAnalyzer)\n\n\n\t\n\t\n\n\n\n\n\t\n\t\n\t\twith these methods...\n\npublic Map<String,AnalyzerDefinition} getAnalyzers()\npublic void setAnalyzers(Map<String,AnalyzerDefinition>)\n\n\n\t\n\t\n\n\n\n\n\t\n\t\n\t\tthis should be really straight forward, since these methods only deal with explicit analyzer configurations, and can just mutate a Map directly \u2013 or even be removed completley since the class is only used internally by other methods we'll be modifying below...\n\t\n\t\n\tAPI Structure \u2013 aka: SchemaRequest & SchemaResponse & FieldType.getNamedPropertyValues() & FieldTypeXmlAdapter\n\t\n\t\tthis is where things get really, really, messy\n\t\tThe current Schema API structure for field types with analyzer(s) looks like this...\n\n{\n     \"name\":\"myNewTextField\",\n     \"class\":\"solr.TextField\",\n     \"indexAnalyzer\":{\n        \"tokenizer\":{\n           \"class\":\"solr.PathHierarchyTokenizerFactory\", \n           \"delimiter\":\"/\" }},\n     \"queryAnalyzer\":{\n        \"class\":\"solr.KeywordAnalyzer\" }\n}\n\n\n\t\n\t\n\n\n\n\n\t\n\t\n\t\tMoving forward, In an ideal world where we support arbitrary analyzers, it should probably look something like...\n\n{\n     \"name\":\"myNewTextField\",\n     \"class\":\"solr.TextField\",\n     \"analyzers\":[\n       {  \"type\":\"index\",    // in the simplest case: '\"type\":null' or no type key at all\n          \"tokenizer\":{\n             \"class\":\"solr.PathHierarchyTokenizerFactory\", \n             \"delimiter\":\"/\" }},\n       { \"type\":\"query\",\n         \"class\":\"solr.KeywordAnalyzer\" },\n       { \"type\":\"what ever\",\n         \"class\":\"solr.WhateverAnalyzer\" } ]\n}\n\n\n\t\n\t\n\n\n\n\n\t\n\t\n\t\tHow do we get from here to there?\n\t\t\n\t\t\tChanging these classes to all read/write in the new format would be fairly easy\n\t\t\t\n\t\t\t\tBecause most of these code paths really only deal with \"explicit(ly configured)\" Analyzers the code changes are really simple and straight forward \u2013 the heavy lifting is all done by other method replacements disucssed above.\n\t\t\t\n\t\t\t\n\t\t\tChanging the necessary classes to be able to read either format (depending on what keys are found) would also be fairly simple\n\t\t\tThe hard part is knowing when to write in the old format for backcompat.\n\t\t\tUnder the new \"V2\" API model, we could potentially start versioning stuff ... but are we ready/willing to start saying this new fieldType request/response format is \"/v3\" (or \"/v2.1\" ) ?\n\t\t\t\n\t\t\t\tSOLR-11183 already eliminated the the /v2 path and replaced it with /api .. is bring it back (or using /api2.1 ) worthwhile?\n\t\t\t\tHell: Do the internal \"V2\" method APIs even give us enough info about the path to make this approach even viable?\n\t\t\t\n\t\t\t\n\t\t\tFWIW: We could, as an ugly shim/hack, ignore the \"ideal\" API structure, and instead extend the current fooAnalyzer syntax such that any FieldType attribute that ends in \"Analyzer\" is treated as an analyzer type...\n\n{\n     \"name\":\"myNewTextField\",\n     \"class\":\"solr.TextField\",\n     \"indexAnalyzer\":{\n        \"tokenizer\":{\n           \"class\":\"solr.PathHierarchyTokenizerFactory\", \n           \"delimiter\":\"/\" }},\n     \"queryAnalyzer\":{\n        \"class\":\"solr.KeywordAnalyzer\" },\n     \"what everAnalyzer\":{\n        \"class\":\"solr.WhateverAnalyzer\" }\n}\n\n\n...obviously we'd need to include special handling for the existing single-analyzer case of \"analyzer\" as the attribute name \u2013 but that would be trivial\n\t\t\n\t\t\n\t\n\t\n\n\n\n\n\t\n\t\n\t\t\n\t\t\n\t\t\t\n\t\t\t\n\t\t\t\tNOTE: I feel gross even suggesting this syntax, but it is something that would be easily achievable\n\t\t\t\tIn reality, if we did decide to \"version\" the response structure, this kind of \"shim\" structure (and the code to read/write it) might be needed anyway (example: in case a client requesting the \"old\" format hits a Solr where there are some FieldTypes w/arbitrary analyzers)\n\t\t\t\n\t\t\t\n\t\t\n\t\t\n\t\n\t\n\n\n\nWith the above changes, it would be a fairly simple matter to make methods like TextField.getFieldQuery ask the QParser if there is an analyzer localparam, and if so use it instead of the {\n{query}\n analyzer when parsing queries. As before: the S2.1.HITCH still applies and would also need to be \"fixed\" for this to work with non-trivila QParsers.\nS2.2E: Example Usage\n\nIn addition to how this might simplify S2.1.STRAW1 (above) and S1.3 (below) this would also make the expert level \"I want to be able to have lots of arbitrary analyzers I pick between arbitrarily at query time...\" usecase very clean...\n\n<!--\n  For the 'i want to do crazy things' users, a new 'allowAnyAnalyzer=\"true\"'\n  option could be added to TextField so that it doesn't fail on unexpected\n  analyzer types.\n     \n  Then methods like TextField.getFieldQuery could look for an 'analyzer' local\n  param so the user could do things like:\n\n    q={!field f=crazy analyzer=silliest}elephant\n\n  NOTE:\n   - failing on unexpected analyzer types by default is important to catch typos\n     - like 'type=\"qeury\"'\n   - Since this is a really niche case, an alternative to 'allowAnyAnalyzer=\"true\"'\n     would probably be to create a \"DynamicQueryAnalyzerTextField extends TextField\"\n     w/ this special behavior instead\n-->\n<field name=\"crazy\" type=\"text_crazy\" />\n<fieldType name=\"text_crazy\" class=\"solr.TextField\"\n           indexed=\"true\" multiValued=\"true\" allowAnyAnalyzer=\"true\">\n  <analyzer type=\"index\">\n   ...\n  </analyzer>\n  <analyzer type=\"query\">\n   ...\n  </analyzer>\n  <analyzer type=\"silly\">\n   ...\n  </analyzer>\n  <analyzer type=\"silliest\">\n   ...\n  </analyzer>\n</fieldType>\n\n\n\nS1.3: TextField supports a type=\"docValues\" analyzer\nS1.3G: Goal\n\nTextField should support docValues=\"true\" and it should be possible to configure an arbitrary analyzer (ie: <analyzer type=\"docValues\" .../> ) for determining what data gets put in the docValues of a text field for sorting/faceting \u2013 independently from the the index/query analyzer)\n\nFor back compatibility, a TextField with docValues=\"true\" but no type=\"docValues\" analyzer should use the type=\"index\" analyzer.\nS1.3E: Example Usage\n\nBuilding DocValues at index time to get same behavior as FieldCache w/o the query RAM/time cost...\n\n<!--\n  Faceting (or Sorting) on these 2 features_* fields (should) behave\n  identically, except that...\n   - features_fc would require uninversion of indexed terms (FieldCache)\n   - features_dv would use SortedSetDocValues made up of the same terms\n     (as created by the 'index' analyzer at indexing time)\n  -->\n<field name=\"features_fc\" type=\"text_general\" />\n<field name=\"features_dv\" type=\"text_general\" docValue=\"true\"/>\n<fieldType name=\"text_general\" class=\"solr.TextField\"\n           indexed=\"true\">\n  <analyzer type=\"index\">\n   ...\n  </analyzer>\n  <analyzer type=\"query\">\n   ...\n  </analyzer>\n</fieldType>\n\n\nSpecial Faceting/Sorting behavior, independent of search behavior...\n\n<!--\n  Stemming when searching, but we also want 'clean' terms for\n  'Tag Cloud' Faceting...\n  -->\n<fieldType name=\"text_keywords\" class=\"solr.TextField\"\n           indexed=\"true\" docValues=\"true\">\n  <analyzer> <!-- query and index -->\n    <tokenizer class=\"solr.StandardTokenizerFactory\"/>\n    <filter class=\"solr.LowerCaseFilterFactory\"/>\n    <filter class=\"solr.EnglishPossessiveFilterFactory\"/>\n    <filter class=\"solr.PorterStemFilterFactory\"/>\n  </analyzer>\n  <analyzer type=\"docValues\">\n    <tokenizer class=\"solr.WhitespaceTokenizerFactory\"/>\n    <filter class=\"solr.EnglishPossessiveFilterFactory\"/>\n  </analyzer>\n</fieldType>\n\n\n\n<!--\n  Lowercase sorting on the whole string, independent of\n  whatever search based analysis is done\n  -->\n<fieldType name=\"text_\" class=\"solr.TextField\"\n           indexed=\"true\" docValues=\"true\">\n  <analyzer> <!-- query and index -->\n    ...\n  </analyzer>\n  <analyzer type=\"docValues\">\n    <tokenizer class=\"solr.KeywordTokenizerFactory\"/>\n    <filter class=\"solr.LowerCaseFilterFactory\"/>\n    <filter class=\"solr.TrimFilterFactory\"/>\n  </analyzer>\n</fieldType>\n\n\nS1.3A: Suggested Approach\n\n\t90% of the work required here would be the bulk of the work from S2.2: Supporting the configuration of a \"docValues\" analyzer on TextField\n\t\n\t\tIt would be silly to attempt this S1.3 idea w/o also tackling the generalized idea in S2.2A (ie: we should stop adding special magic named analyzers to the logic in IndexSchema \u2013 the \"plumbing\" should be generic, and the FieldTypes should know what analyzer names they care about)\n\t\n\t\n\tOnce the plumbing is in place for IndexSchema to allow arbitrary named analyzers, the remaining work would be fairly trivial:\n\t\n\t\tMake TextField expect an analyzer named \"docValues\", implicitly defaulting to the effective \"index\" analyzer if there is no explicit \"docValues\" analyzer\n\t\tRefactor the core bit of logic from S1.2A (TermDocValuesTextField's \"TokenStream -> SortedSetDocValuesField\") down to TextField\n\t\t\n\t\t\tEither deprecate TermDocValuesTextField, or leave it as syntactic sugar for TextField w/ docValues=\"true\"\n\t\t\n\t\t\n\t\tRefactor SortableTextField (S1.1A) so that it's just syntactic sugar for TextField with:\n\t\t\n\t\t\tdocValues=\"true\"\n\t\t\ta \"docValues\" analyzer using KeywordTokenizer + a new \"Truncation\" filter (to limit the values to the confiured # of characters)\n\t\t\n\t\t\n\t\n\t\n\n ",
            "author": "Hoss Man",
            "id": "comment-16341693"
        }
    ]
}