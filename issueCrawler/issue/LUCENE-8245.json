{
    "id": "LUCENE-8245",
    "title": "GeoComplexPolygon fails when intersection of travel plane with edge is near polygon point",
    "details": {
        "labels": "",
        "priority": "Major",
        "resolution": "Fixed",
        "affect_versions": "None",
        "status": "Closed",
        "type": "Bug",
        "components": [
            "modules/spatial3d"
        ],
        "fix_versions": [
            "6.7",
            "7.4",
            "master (8.0)"
        ]
    },
    "description": "When a travel plane crosses an edge close to an edge point , it is possible that the above and below planes crosses different edges. In the current implementation one of the crosses is missed because we only check edges that are crossed by the main plain and the within result is wrong.\n\nOne possible fix is to check always the intersection of planes and edges regardless if they are crossed by main plane. That fixed the above issue but shows other issues like travel planes crossing two edges when it should be only one due to the fuzziness at edge intersections.\n\nNot sure of a fix so I add the test showing the issue.",
    "attachments": {
        "LUCENE-8245.jpg": "https://issues.apache.org/jira/secure/attachment/12918057/LUCENE-8245.jpg",
        "LUCENE-8245_Polygon.patch": "https://issues.apache.org/jira/secure/attachment/12918319/LUCENE-8245_Polygon.patch",
        "LUCENE-8245_case3.patch": "https://issues.apache.org/jira/secure/attachment/12918320/LUCENE-8245_case3.patch",
        "LUCENE-8245-case2.patch": "https://issues.apache.org/jira/secure/attachment/12918027/LUCENE-8245-case2.patch",
        "LUCENE-8245.patch": "https://issues.apache.org/jira/secure/attachment/12917973/LUCENE-8245.patch",
        "LUCENE-8245_Random.patch": "https://issues.apache.org/jira/secure/attachment/12918318/LUCENE-8245_Random.patch"
    },
    "issue_links": {},
    "comments": [
        {
            "id": "comment-16429686",
            "date": "2018-04-08T08:48:18+0000",
            "content": "The logic for crossing near polygon edges has been very carefully thought out, and the major commit made last weekend was designed to resolve those kinds of issues once and for all.  The comments in the code describe the algorithm, but basically we are only interested in edges that actually intersect or cross the travel planes.  The reason for above/below planes is to be able to accurately count links even when some polygon edges are wholly or in part contained within the envelope.\n\nSo it is immaterial that an edge crosses only one or the other envelope planes; that is the whole point of having the envelope planes, in fact.  But we do assume that the envelope is narrow enough that an edge that ends inside of it must intersect either the travel plane or the above/below planes; that assumption may be incorrect.\n\nI will not be able to analyze these cases until later today. ",
            "author": "Karl Wright"
        },
        {
            "id": "comment-16429712",
            "date": "2018-04-08T10:44:55+0000",
            "content": "Commit 348de9e8b59d1ba6cf37999fe4c11c8365147fdd in lucene-solr's branch refs/heads/master from Karl Wright\n[ https://git-wip-us.apache.org/repos/asf?p=lucene-solr.git;h=348de9e ]\n\nLUCENE-8245: Adjust envelope to not leave as big a gap between travel planes and above/below planes. ",
            "author": "ASF subversion and git services"
        },
        {
            "id": "comment-16429714",
            "date": "2018-04-08T10:45:42+0000",
            "content": "Commit aaddf2ee4267dea3b54990dfeb826a2392dc6fec in lucene-solr's branch refs/heads/branch_7x from Karl Wright\n[ https://git-wip-us.apache.org/repos/asf?p=lucene-solr.git;h=aaddf2e ]\n\nLUCENE-8245: Adjust envelope to not leave as big a gap between travel planes and above/below planes. ",
            "author": "ASF subversion and git services"
        },
        {
            "id": "comment-16429715",
            "date": "2018-04-08T10:46:17+0000",
            "content": "Commit 7690e010dfbbdda448a6d562d99e574cdb8b8d46 in lucene-solr's branch refs/heads/branch_6x from Karl Wright\n[ https://git-wip-us.apache.org/repos/asf?p=lucene-solr.git;h=7690e01 ]\n\nLUCENE-8245: Adjust envelope to not leave as big a gap between travel planes and above/below planes. ",
            "author": "ASF subversion and git services"
        },
        {
            "id": "comment-16429716",
            "date": "2018-04-08T10:47:31+0000",
            "content": "Adjusted the delta between travel planes and above/below planes to make it as small as possible. ",
            "author": "Karl Wright"
        },
        {
            "id": "comment-16430104",
            "date": "2018-04-09T05:45:43+0000",
            "content": "I can still reproduce the issue with other cases. I attach another test.\n\n\u00a0 ",
            "author": "Ignacio Vera"
        },
        {
            "id": "comment-16430185",
            "date": "2018-04-09T07:21:10+0000",
            "content": "This example has the opposite cause; instead of an edge crossing a bounding plane but not being detected as crossing the main plane, something different is happening.  The reason I needed to broaden the envelope in the first place beyond 1e-12 was because of numerical precision issues: sometimes we are detecting that we're crossing both bounding planes when we really are crossing just one, because of the precision of how we compute the intersection point.\n\nI'll have to analyze this case numerically to see if there is a solution to how we calculate this stuff.  No chance of having time to look at it until midweek or later. ",
            "author": "Karl Wright"
        },
        {
            "id": "comment-16430223",
            "date": "2018-04-09T07:55:33+0000",
            "content": "Turned on diagnostic output for this case.  Here it is:\n\n\n   [junit4]   1> Considering edge [lat=-0.6183600459696781, lon=-2.770488856855538([X=-0.7593628058597481, Y=-0.29549354861758625, Z=-0.5796996565482825])] -> [lat=-1.4506713533447755, lon=-1.2251247551355924([X=0.04060395941016342,\nY=-0.11274773940940182, Z=-0.9927936672533157])]\n   [junit4]   1>\n   [junit4]   1> The following edges should intersect the travel/testpoint planes:\n   [junit4]   1> Travel plane: [lat=-1.4506713533447755, lon=-1.2251247551355924([X=0.04060395941016342, Y=-0.11274773940940182, Z=-0.9927936672533157])] -> [lat=4.9E-324, lon=0.0([X=1.0, Y=0.0, Z=4.9E-324])]\n   [junit4]   1> Test point plane: [lat=-1.4506713533447755, lon=-1.2251247551355924([X=0.04060395941016342, Y=-0.11274773940940182, Z=-0.9927936672533157])] -> [lat=4.9E-324, lon=0.0([X=1.0, Y=0.0, Z=4.9E-324])]\n   [junit4]   1> Travel plane: [lat=4.9E-324, lon=0.0([X=1.0, Y=0.0, Z=4.9E-324])] -> [lat=0.13953211802880663, lon=-2.443438340098597([X=-0.7585849990851791, Y=-0.6365576248361361, Z=0.139079795174987])]\n   [junit4]   1>\n   [junit4]   1> Considering edge [lat=-1.4506713533447755, lon=-1.2251247551355924([X=0.04060395941016342, Y=-0.11274773940940182, Z=-0.9927936672533157])] -> [lat=4.9E-324, lon=0.0([X=1.0, Y=0.0, Z=4.9E-324])]\n   [junit4]   1>\n   [junit4]   1> The following edges should intersect the travel/testpoint planes:\n   [junit4]   1> Travel plane: [lat=-1.4506713533447755, lon=-1.2251247551355924([X=0.04060395941016342, Y=-0.11274773940940182, Z=-0.9927936672533157])] -> [lat=4.9E-324, lon=0.0([X=1.0, Y=0.0, Z=4.9E-324])]\n   [junit4]   1> Test point plane: [lat=-1.4506713533447755, lon=-1.2251247551355924([X=0.04060395941016342, Y=-0.11274773940940182, Z=-0.9927936672533157])] -> [lat=4.9E-324, lon=0.0([X=1.0, Y=0.0, Z=4.9E-324])]\n   [junit4]   1> Travel plane: [lat=4.9E-324, lon=0.0([X=1.0, Y=0.0, Z=4.9E-324])] -> [lat=0.13953211802880663, lon=-2.443438340098597([X=-0.7585849990851791, Y=-0.6365576248361361, Z=0.139079795174987])]\n   [junit4]   1>\n   [junit4]   1>   Travel inner point [X=1.0, Y=-1.336807223683658E-12, Z=-1.1771178322187736E-11]\n   [junit4]   1>   Test point inner point [X=0.7540698997149413, Y=-0.07411317803504912, Z=-0.6525992822440454]\n   [junit4]   1>  Edge added 2 to innerCrossingCount\n   [junit4]   1>   Test point outer point [X=0.7540698997131706, Y=-0.07411317803527853, Z=-0.6525992822460656]\n   [junit4]   1>  Edge added 1 to outerCrossingCount\n   [junit4]   1> Considering edge [lat=4.9E-324, lon=0.0([X=1.0, Y=0.0, Z=4.9E-324])] -> [lat=0.13953211802880663, lon=-2.443438340098597([X=-0.7585849990851791, Y=-0.6365576248361361, Z=0.139079795174987])]\n   [junit4]   1>\n   [junit4]   1> The following edges should intersect the travel/testpoint planes:\n   [junit4]   1> Travel plane: [lat=4.9E-324, lon=0.0([X=1.0, Y=0.0, Z=4.9E-324])] -> [lat=0.13953211802880663, lon=-2.443438340098597([X=-0.7585849990851791, Y=-0.6365576248361361, Z=0.139079795174987])]\n   [junit4]   1> Travel plane: [lat=-1.4506713533447755, lon=-1.2251247551355924([X=0.04060395941016342, Y=-0.11274773940940182, Z=-0.9927936672533157])] -> [lat=4.9E-324, lon=0.0([X=1.0, Y=0.0, Z=4.9E-324])]\n   [junit4]   1> Test point plane: [lat=-1.4506713533447755, lon=-1.2251247551355924([X=0.04060395941016342, Y=-0.11274773940940182, Z=-0.9927936672533157])] -> [lat=4.9E-324, lon=0.0([X=1.0, Y=0.0, Z=4.9E-324])]\n   [junit4]   1>\n   [junit4]   1>   Travel inner point [X=1.0, Y=-1.3368072236836578E-12, Z=2.920754816285907E-13]\n   [junit4]   1>  Edge added 1 to innerCrossingCount\n   [junit4]   1>   Travel outer point [X=1.0, Y=6.831927763163421E-13, Z=-1.4926898632243605E-13]\n   [junit4]   1>  Edge added 1 to outerCrossingCount\n\n ",
            "author": "Karl Wright"
        },
        {
            "id": "comment-16430235",
            "date": "2018-04-09T08:05:43+0000",
            "content": "Reformatted, for easier reading:\n\n\n   [junit4]   1> The following edges should intersect the travel/testpoint planes:\n   [junit4]   1> Travel plane: [lat=-1.4506713533447755, lon=-1.2251247551355924([X=0.04060395941016342, Y=-0.11274773940940182, Z=-0.9927936672533157])] -> [lat=4.9E-324, lon=0.0([X=1.0, Y=0.0, Z=4.9E-324])]\n   [junit4]   1> Test point plane: [lat=-1.4506713533447755, lon=-1.2251247551355924([X=0.04060395941016342, Y=-0.11274773940940182, Z=-0.9927936672533157])] -> [lat=4.9E-324, lon=0.0([X=1.0, Y=0.0, Z=4.9E-324])]\n   [junit4]   1> Travel plane: [lat=4.9E-324, lon=0.0([X=1.0, Y=0.0, Z=4.9E-324])] -> [lat=0.13953211802880663, lon=-2.443438340098597([X=-0.7585849990851791, Y=-0.6365576248361361, Z=0.139079795174987])]\n   [junit4]   1>\n   [junit4]   1> Considering edge [lat=-0.6183600459696781, lon=-2.770488856855538([X=-0.7593628058597481, Y=-0.29549354861758625, Z=-0.5796996565482825])] -> [lat=-1.4506713533447755, lon=-1.2251247551355924([X=0.04060395941016342, Y=-0.11274773940940182, Z=-0.9927936672533157])]\n   [junit4]   1>\n   [junit4]   1> Considering edge [lat=-1.4506713533447755, lon=-1.2251247551355924([X=0.04060395941016342, Y=-0.11274773940940182, Z=-0.9927936672533157])] -> [lat=4.9E-324, lon=0.0([X=1.0, Y=0.0, Z=4.9E-324])]\n   [junit4]   1>   Travel inner point [X=1.0, Y=-1.336807223683658E-12, Z=-1.1771178322187736E-11]\n   [junit4]   1>   Test point inner point [X=0.7540698997149413, Y=-0.07411317803504912, Z=-0.6525992822440454]\n   [junit4]   1>  Edge added 2 to innerCrossingCount\n   [junit4]   1>   Test point outer point [X=0.7540698997131706, Y=-0.07411317803527853, Z=-0.6525992822460656]\n   [junit4]   1>  Edge added 1 to outerCrossingCount\n   [junit4]   1>\n   [junit4]   1> Considering edge [lat=4.9E-324, lon=0.0([X=1.0, Y=0.0, Z=4.9E-324])] -> [lat=0.13953211802880663, lon=-2.443438340098597([X=-0.7585849990851791, Y=-0.6365576248361361, Z=0.139079795174987])]\n   [junit4]   1>   Travel inner point [X=1.0, Y=-1.3368072236836578E-12, Z=2.920754816285907E-13]\n   [junit4]   1>  Edge added 1 to innerCrossingCount\n   [junit4]   1>   Travel outer point [X=1.0, Y=6.831927763163421E-13, Z=-1.4926898632243605E-13]\n   [junit4]   1>  Edge added 1 to outerCrossingCount\n\n\n\nAs you can see, there's one edge that adds TWO inner crossings and one outer crossing.  Quite a feat.  Figuring out how it does that is the trick. ",
            "author": "Karl Wright"
        },
        {
            "id": "comment-16430311",
            "date": "2018-04-09T09:33:55+0000",
            "content": "Attached a visual representation of the shape and travel planes.\n\nI think the problem is the edge that adds an inner and an outer plane, it should only add one! ",
            "author": "Ignacio Vera"
        },
        {
            "id": "comment-16430353",
            "date": "2018-04-09T10:30:16+0000",
            "content": "What's right:\n\nThe graphic shows there are only two edges that intersect the travel plane and test point plane.  And we find two, which is good.  These are the ones we find:\n\n\n   [junit4]   1> Considering edge [lat=-1.4506713533447755, lon=-1.2251247551355924([X=0.04060395941016342, Y=-0.11274773940940182, Z=-0.9927936672533157])] -> [lat=4.9E-324, lon=0.0([X=1.0, Y=0.0, Z=4.9E-324])]\n\n\n\nand\n\n\n   [junit4]   1> Considering edge [lat=4.9E-324, lon=0.0([X=1.0, Y=0.0, Z=4.9E-324])] -> [lat=0.13953211802880663, lon=-2.443438340098597([X=-0.7585849990851791, Y=-0.6365576248361361, Z=0.139079795174987])]\n\n\n\nWe'd expect one of the planes to intersect both the travel and the test point planes, and the other to intersect just one.  The second edge intersects just the travel plane, and it crosses both inner and outer envelopes.  The first edge, therefore, should cross the test point plane, both inner and outer, and it does.  But since the second edge crossed both inner and outer travel plane envelopes, we'd expect that the first edge would do the same, but it doesn't; it only crosses the inner side.\n\nSo, either, the first edge should also cross the outer side of the travel plane, or the second edge should NOT cross the outer side of the travel plane.  We need to determine what the right behavior is by going deeper numerically \u2013 we need to evaluate the edge endpoint to see where it sits relative to the travel plane and to the inner and outer envelopes.  I will add evaluate() method calls to the diagnostics so we can see this.\n\nBut it's also clear we're looking at a numerical precision problem here.\n ",
            "author": "Karl Wright"
        },
        {
            "id": "comment-16430401",
            "date": "2018-04-09T11:31:20+0000",
            "content": "I checked the intersection point of the top edge with the travel plane and it is numerically identical to the edge start point and still contributes with an inner and outer crossing.\n\nMaybe this idea is too naive but if we calculate all intersection points we can assume the following:\n\n1) if the intersection point is not numericaly identical to start and end edges, then it should contribute with an inner and an outer crossing. (we don't really need to calculate the crossings)\n\n2) if the intersection point is numericaly identical to start or end edges, then it should contribute with just an inner or an outer crossing. (we just need to find out how to choose one...)\n\n\u00a0\n\n\u00a0\n\n\u00a0\n\n\u00a0 ",
            "author": "Ignacio Vera"
        },
        {
            "id": "comment-16430409",
            "date": "2018-04-09T11:37:15+0000",
            "content": "Here's the revised output for these two edges:\n\n\n   [junit4]   1> Considering edge [lat=-1.4506713533447755, lon=-1.2251247551355924([X=0.04060395941016342, Y=-0.11274773940940182, Z=-0.9927936672533157])] -> [lat=4.9E-324, lon=0.0([X=1.0, Y=0.0, Z=4.9E-324])]\n   [junit4]   1>  start point travel dist=-0.11274773940907501; end point travel dist=3.268072236836579E-13\n   [junit4]   1>  start point travel above dist=-0.11274773940806501; end point travel above dist=1.336807223683658E-12\n   [junit4]   1>  start point travel below dist=-0.11274773941008501; end point travel below dist=-6.831927763163422E-13\n   [junit4]   1>  start point testpoint dist=-0.34019438500826027; end point testpoint dist=0.6525992822450555\n   [junit4]   1>  start point testpoint above dist=-0.3401943850072502; end point testpoint above dist=0.6525992822460656\n   [junit4]   1>  start point testpoint below dist=-0.34019438500927035; end point testpoint below dist=0.6525992822440454\n   [junit4]   1>   Travel inner point [X=1.0, Y=-1.336807223683658E-12, Z=-1.1771178322187736E-11]\n   [junit4]   1>   Test point inner point [X=0.7540698997149413, Y=-0.07411317803504912, Z=-0.6525992822440454]\n   [junit4]   1>  Edge added 2 to innerCrossingCount\n   [junit4]   1>   Test point outer point [X=0.7540698997131706, Y=-0.07411317803527853, Z=-0.6525992822460656]\n   [junit4]   1>  Edge added 1 to outerCrossingCount\n   [junit4]   1>\n   [junit4]   1> Considering edge [lat=4.9E-324, lon=0.0([X=1.0, Y=0.0, Z=4.9E-324])] -> [lat=0.13953211802880663, lon=-2.443438340098597([X=-0.7585849990851791, Y=-0.6365576248361361, Z=0.139079795174987])]\n   [junit4]   1>  start point travel dist=3.268072236836579E-13; end point travel dist=-0.6365576248358092\n   [junit4]   1>  start point travel above dist=1.336807223683658E-12; end point travel above dist=-0.6365576248347993\n   [junit4]   1>  start point travel below dist=-6.831927763163422E-13; end point travel below dist=-0.6365576248368193\n   [junit4]   1>  start point testpoint dist=0.6525992822450555; end point testpoint dist=0.7916790774200425\n   [junit4]   1>  start point testpoint above dist=0.6525992822460656; end point testpoint above dist=0.7916790774210526\n   [junit4]   1>  start point testpoint below dist=0.6525992822440454; end point testpoint below dist=0.7916790774190324\n   [junit4]   1>   Travel inner point [X=1.0, Y=-1.3368072236836578E-12, Z=2.920754816285907E-13]\n   [junit4]   1>  Edge added 1 to innerCrossingCount\n   [junit4]   1>   Travel outer point [X=1.0, Y=6.831927763163421E-13, Z=-1.4926898632243605E-13]\n   [junit4]   1>  Edge added 1 to outerCrossingCount\n\n\n\nThe first edge's endpoint is on the \"below\" travel plane, but not the \"above\" one, and that's of course true as well for the start point of the second edge, since they're shared.  And indeed we see two \"inner\" crossings of the travel plane \u2013 one from each edge.  Those are correct.\n\nSo we're seeing an extra crossing of the outer plane that we should not, specifically this one:\n\n\n   [junit4]   1> Considering edge [lat=4.9E-324, lon=0.0([X=1.0, Y=0.0, Z=4.9E-324])] -> [lat=0.13953211802880663, lon=-2.443438340098597([X=-0.7585849990851791, Y=-0.6365576248361361, Z=0.139079795174987])]\n   [junit4]   1>   Travel outer point [X=1.0, Y=6.831927763163421E-13, Z=-1.4926898632243605E-13]\n   [junit4]   1>  Edge added 1 to outerCrossingCount\n\n\n\nWe compute this by calling Plane.findCrossings() between the outer travel plane and the edge plane, within the computed bounds planes.  We should not find this intersection, but we do anyway, and that is the cause of the problem.\n\nThe numeric precision of that method under these conditions is not adequate to this kind of find-grained envelope computation.  The next step is to see whether the point that it finds is off the two intersecting planes, and if so, by how much.  If that's what is going wrong, we may need to increase MINIMUM_RESOLUTION somewhat to cover the computation issues, maybe to 2e-12.  OR we can try a successive approximation approach to the intersection math \u2013 but I don't relish that idea, frankly.\n ",
            "author": "Karl Wright"
        },
        {
            "id": "comment-16430413",
            "date": "2018-04-09T11:42:59+0000",
            "content": "Ignacio Vera, I'm afraid that I don't think your solution is the right one. ",
            "author": "Karl Wright"
        },
        {
            "id": "comment-16430421",
            "date": "2018-04-09T11:52:28+0000",
            "content": "I don't think it either. I will add later today or tomorrow a random test that it is extremely good to find all these cases. It can be used to validate solutions. ",
            "author": "Ignacio Vera"
        },
        {
            "id": "comment-16430427",
            "date": "2018-04-09T12:05:31+0000",
            "content": "Ok, looking at the crossings we get, here's the complete output:\n\n\n   [junit4]   1>\n   [junit4]   1> Considering edge [lat=-1.4506713533447755, lon=-1.2251247551355924([X=0.04060395941016342, Y=-0.11274773940940182, Z=-0.9927936672533157])] -> [lat=4.9E-324, lon=0.0([X=1.0, Y=0.0, Z=4.9E-324])]\n   [junit4]   1>  start point travel dist=-0.11274773940907501; end point travel dist=3.268072236836579E-13\n   [junit4]   1>  start point travel above dist=-0.11274773940806501; end point travel above dist=1.336807223683658E-12\n   [junit4]   1>  start point travel below dist=-0.11274773941008501; end point travel below dist=-6.831927763163422E-13\n   [junit4]   1>  start point testpoint dist=-0.34019438500826027; end point testpoint dist=0.6525992822450555\n   [junit4]   1>  start point testpoint above dist=-0.3401943850072502; end point testpoint above dist=0.6525992822460656\n   [junit4]   1>  start point testpoint below dist=-0.34019438500927035; end point testpoint below dist=0.6525992822440454\n   [junit4]   1>   Travel inner point [X=1.0, Y=-1.336807223683658E-12, Z=-1.1771178322187736E-11]; edgeplane=0.0; travelInsidePlane=0.0\n   [junit4]   1>   Test point inner point [X=0.7540698997149413, Y=-0.07411317803504912, Z=-0.6525992822440454]; edgeplane=0.0; testPointInsidePlane=0.0\n   [junit4]   1>  Edge added 2 to innerCrossingCount\n   [junit4]   1>   Test point outer point [X=0.7540698997131706, Y=-0.07411317803527853, Z=-0.6525992822460656]; edgeplane=0.0; testPointOutsidePlane=0.0\n   [junit4]   1>  Edge added 1 to outerCrossingCount\n   [junit4]   1>\n   [junit4]   1> Considering edge [lat=4.9E-324, lon=0.0([X=1.0, Y=0.0, Z=4.9E-324])] -> [lat=0.13953211802880663, lon=-2.443438340098597([X=-0.7585849990851791, Y=-0.6365576248361361, Z=0.139079795174987])]\n   [junit4]   1>  start point travel dist=3.268072236836579E-13; end point travel dist=-0.6365576248358092\n   [junit4]   1>  start point travel above dist=1.336807223683658E-12; end point travel above dist=-0.6365576248347993\n   [junit4]   1>  start point travel below dist=-6.831927763163422E-13; end point travel below dist=-0.6365576248368193\n   [junit4]   1>  start point testpoint dist=0.6525992822450555; end point testpoint dist=0.7916790774200425\n   [junit4]   1>  start point testpoint above dist=0.6525992822460656; end point testpoint above dist=0.7916790774210526\n   [junit4]   1>  start point testpoint below dist=0.6525992822440454; end point testpoint below dist=0.7916790774190324\n   [junit4]   1>   Travel inner point [X=1.0, Y=-1.3368072236836578E-12, Z=2.920754816285907E-13]; edgeplane=-5.0487097934144756E-29; travelInsidePlane=2.0194839173657902E-28\n   [junit4]   1>  Edge added 1 to innerCrossingCount\n   [junit4]   1>   Travel outer point [X=1.0, Y=6.831927763163421E-13, Z=-1.4926898632243605E-13]; edgeplane=2.5243548967072378E-29; travelOutsidePlane=-1.0097419586828951E-28\n   [junit4]   1>  Edge added 1 to outerCrossingCount   \n\n\n\nThe travel outer point it incorrectly finds has a distance to each intersecting plane that's on the order of 1e-28.  That basically says it's a real intersection given the inputs.  So that second edge does intersect the outer envelope EVEN THOUGH it doesn't look like it should, based on the endpoint.\n\nThe only other thing that can be going wrong is that the edge endpoint's bounds are just sloppy enough to permit this intersection to be included in the crossings list, while it really should be rejected.  I'll need more diagnostics to rule that in or out as the underlying cause, but I'm getting busy at work now so that's not going to happen for a while. ",
            "author": "Karl Wright"
        },
        {
            "id": "comment-16430471",
            "date": "2018-04-09T12:45:02+0000",
            "content": "Last bit of debugging until later:\n\n\n   [junit4]   1>   Travel outer point [X=1.0, Y=6.831927763163421E-13, Z=-1.4926898632243605E-13]; edgeplane=2.5243548967072378E-29; travelOutsidePlane=-1.0097419586828951E-28; edgestartplane=-6.993093735168714E-13; edgeendplane=-0.6515740933786793\n   [junit4]   1>  Edge added 1 to outerCrossingCount\n\n\n\nThe bad crossing point it finds is (it appears) on the wrong side of the edge's start cutoff plane, at a value of  -6.993093735168714E-13, which is almost big enough to get it kicked out, but not quite.\n\nThe interesting thing is that the precision of sidedness checks in general (which is what this is, in fact) is MUCH higher than 1e-12.  But if we decreased MINIMUM_RESOLUTION globally, we would not fix the issue, because the above/below planes get closer to the travel plane by exactly a proportional amount.  Maybe it would be possible, though, to have a tighter bound on SidedPlane.isWithin() than we'd have elsewhere?  Or maybe we could apply an alternate, tighter filter in the case of the crossing points in GeoComplexPolygon alone.  I'll have to think this through. ",
            "author": "Karl Wright"
        },
        {
            "id": "comment-16430855",
            "date": "2018-04-09T16:46:02+0000",
            "content": "For fun, I tried to set it up so that the edge cutoff planes had a smaller MINIMUM_RESOLUTION they used than everything else.  This unexpectedly broke everything.  So then I tried having a smaller MINIMUM_RESOLUTION just for the start/end planes for edges.  This allowed me to get the current failing test to start passing, but the other tests committed on the weekend started failing instead.  In fact, I could find a value for this that's not much different than MINIMUM_RESOLUTION that led to ALL the complex polygon tests failing.  That's a rather worrisome development. ",
            "author": "Karl Wright"
        },
        {
            "id": "comment-16430931",
            "date": "2018-04-09T17:25:58+0000",
            "content": "Reasoning this through, the spacing between the travel plane and the above or below plane should be exactly 2.0 * MINIMUM_RESOLUTION.  That will guarantee that any point that falls between the two planes is detected in one or the other (or, very rarely, both).  When I set it up this way, the LUCENE8245 test starts passing, but the testAboveBelowCrossingDifferentEdges example now fails.  So I will next analyze why that occurs, and see if the problem in that case is more readily addressable. ",
            "author": "Karl Wright"
        },
        {
            "id": "comment-16430935",
            "date": "2018-04-09T17:30:44+0000",
            "content": "I can give you an answer why it fails: In that case the planes above and below cross different edges. Because we only consider edges that crosses the main plain we miss one cross. ",
            "author": "Ignacio Vera"
        },
        {
            "id": "comment-16431447",
            "date": "2018-04-09T22:44:44+0000",
            "content": "Ok, this is the debug output of the now-failing test:\n\n\n   [junit4] Suite: org.apache.lucene.spatial3d.geom.GeoPolygonTest\n   [junit4]   1> Considering edge [lat=1.5463873005088208E-34, lon=0.0([X=1.0, Y=0.0, Z=1.5463873005088208E-34])] -> [lat=-0.08842062843650192, lon=2.2837078580414776([X=-0.6514839583883643, Y=0.7535056721696336, Z=-0.08830545832969094])]\n   [junit4]   1>\n   [junit4]   1> The following edges should intersect the travel/testpoint planes:\n   [junit4]   1> Travel plane: [lat=0.7779906922732096, lon=2.728264320121337([X=-0.6523396177204123, Y=0.2861122564854598, Z=0.7018495564158925])] -> [lat=1.5463873005088208E-34, lon=0.0([X=1.0, Y=0.0, Z=1.5463873005088208E-34])]\n   [junit4]   1>\n   [junit4]   1> Considering edge [lat=-0.08842062843650192, lon=2.2837078580414776([X=-0.6514839583883643, Y=0.7535056721696336, Z=-0.08830545832969094])] -> [lat=0.379731892927642, lon=2.3485766139444504([X=-0.651713420845267, Y=0.\n6617191814215959, Z=0.370671474528177])]\n   [junit4]   1>\n   [junit4]   1> The following edges should intersect the travel/testpoint planes:\n   [junit4]   1> Travel plane: [lat=0.7779906922732096, lon=2.728264320121337([X=-0.6523396177204123, Y=0.2861122564854598, Z=0.7018495564158925])] -> [lat=1.5463873005088208E-34, lon=0.0([X=1.0, Y=0.0, Z=1.5463873005088208E-34])]\n   [junit4]   1>\n   [junit4]   1> Considering edge [lat=0.7779906922732096, lon=2.728264320121337([X=-0.6523396177204123, Y=0.2861122564854598, Z=0.7018495564158925])] -> [lat=1.5463873005088208E-34, lon=0.0([X=1.0, Y=0.0, Z=1.5463873005088208E-34])]\n\n   [junit4]   1>\n   [junit4]   1> The following edges should intersect the travel/testpoint planes:\n   [junit4]   1> Travel plane: [lat=0.7779906922732096, lon=2.728264320121337([X=-0.6523396177204123, Y=0.2861122564854598, Z=0.7018495564158925])] -> [lat=1.5463873005088208E-34, lon=0.0([X=1.0, Y=0.0, Z=1.5463873005088208E-34])]\n   [junit4]   1>\n   [junit4]   1>  start point travel dist=0.7018495564156595; end point travel dist=-2.330673801245995E-13\n   [junit4]   1>  start point travel above dist=0.7018495564176594; end point travel above dist=1.7669326198754006E-12\n   [junit4]   1>  start point travel below dist=0.7018495564136594; end point travel below dist=-2.2330673801246E-12\n   [junit4]   1>  start point testpoint dist=-0.4923642700993317; end point testpoint dist=-0.7784765265847915\n   [junit4]   1>  start point testpoint above dist=-0.49236427009733164; end point testpoint above dist=-0.7784765265827914\n   [junit4]   1>  start point testpoint below dist=-0.49236427010133177; end point testpoint below dist=-0.7784765265867916\n   [junit4]   1>   Travel inner point [X=1.0, Y=9.103203687613759E-13, Z=2.2330673801246004E-12]; edgeplane=-1.0097419586828951E-28; travelInsidePlane=4.0389678347315804E-28; edgestartplane=0.7579267927410742; edgeendplane=-2.4114877353945626E-12\n   [junit4]   1>  Edge added 1 to innerCrossingCount\n   [junit4]   1>  Edge added 0 to outerCrossingCount\n   [junit4] FAILURE 0.16s | GeoPolygonTest.testAboveBelowCrossingDifferentEdges <<<\n   [junit4]    > Throwable #1: java.lang.AssertionError\n   [junit4]    >        at org.apache.lucene.spatial3d.geom.GeoPolygonTest.testAboveBelowCrossingDifferentEdges(GeoPolygonTest.java:1486)\n   [junit4] Completed [1/1 (1!)] in 0.17s, 1 test, 1 failure <<< FAILURES!\n\n ",
            "author": "Karl Wright"
        },
        {
            "id": "comment-16431455",
            "date": "2018-04-09T22:51:57+0000",
            "content": "Ignacio Vera, that case should not occur.  The shared endpoint of two edges must either be in the +/- 1e-12 zone of main travel plane, or it's outside.  If it's within that zone, then BOTH edges should show up as an intersection candidate.\n\nThe tree structures underneath the edge iterator may be the problem, since I don't believe they include the necessary 1e-12 extra bounds needed to guarantee that we compute the intersection.  That's what I'm going to look for, since in the dump above it doesn't appear like we even consider more than one edge in the iterator. ",
            "author": "Karl Wright"
        },
        {
            "id": "comment-16431518",
            "date": "2018-04-09T23:55:47+0000",
            "content": "Here's the output of the two edges that get considered in this case:\n\n\n   [junit4]   1> Considering edge [lat=1.5463873005088208E-34, lon=0.0([X=1.0, Y=0.0, Z=1.5463873005088208E-34])] -> [lat=-0.08842062843650192, lon=2.2837078580414776([X=-0.6514839583883643, Y=0.7535056721696336, Z=-0.08830545832969094])]\n   [junit4]   1> Looking for intersection between plane [A=0.0, B=0.0; C=1.0; D=-2.330673801245995E-13] and plane [A=-1.5358762834889417E-34, B=0.11639624844359603; C=0.9932028560914717; D=0.0] within bounds\n   [junit4]   1>  Two points of intersection\n   [junit4]   1>   return no solutions\n   [junit4]   1> Looking for intersection between plane [A=0.0, B=1.0; C=0.0; D=-0.7784765265847915] and plane [A=-1.5358762834889417E-34, B=0.11639624844359603; C=0.9932028560914717; D=0.0] within bounds\n   [junit4]   1>  Two points of intersection\n   [junit4]   1>   return no solutions\n   \n   [junit4]   1> Considering edge [lat=-0.08842062843650192, lon=2.2837078580414776([X=-0.6514839583883643, Y=0.7535056721696336, Z=-0.08830545832969094])] -> [lat=0.379731892927642, lon=2.3485766139444504([X=-0.651713420845267, Y=0.6617191814215959, Z=0.370671474528177])]\n   [junit4]   1> Looking for intersection between plane [A=0.0, B=0.0; C=1.0; D=-2.330673801245995E-13] and plane [A=0.7421702138887571, B=0.6571273907443821; C=0.1317837848515384; D=0.0] within bounds\n   [junit4]   1>  Two points of intersection\n   [junit4]   1>   return no solutions\n   [junit4]   1> Looking for intersection between plane [A=0.0, B=1.0; C=0.0; D=-0.7784765265847915] and plane [A=0.7421702138887571, B=0.6571273907443821; C=0.1317837848515384; D=0.0] within bounds\n   [junit4]   1>  no solutions - no intersection\n   [junit4]   1> Considering edge [lat=0.7779906922732096, lon=2.728264320121337([X=-0.6523396177204123, Y=0.2861122564854598, Z=0.7018495564158925])] -> [lat=1.5463873005088208E-34, lon=0.0([X=1.0, Y=0.0, Z=1.5463873005088208E-34])]\n   [junit4]   1> Looking for intersection between plane [A=0.0, B=0.0; C=1.0; D=-2.330673801245995E-13] and plane [A=5.837507846237386E-35, B=0.9260123314536496; C=-0.377493260861404; D=0.0] within bounds\n   [junit4]   1>  Two points of intersection\n   [junit4]   1>   returning 1 solution\n   [junit4]   1>   Travel inner point [X=1.0, Y=9.103203687613759E-13, Z=2.2330673801246004E-12]; edgeplane=-1.0097419586828951E-28; travelInsidePlane=4.0389678347315804E-28; edgestartplane=0.7579267927410742; edgeendplane=-2.4114877353945626E-12\n   [junit4]   1>  Edge added 1 to innerCrossingCount\n   [junit4]   1>  Edge added 0 to outerCrossingCount\n\n\n\nThe second edge is detected as an intersection, but as you surmised, the first is not, even though it's properly found out of the tree.\n\nThe reason it's rejected is because of bounds; two points of intersection are in fact found, but apparently the bounding planes operate a bit too strenuously and do not permit either intersection point to remain.\n\nIt should be possible to bypass this case, however, since the case we're trying to catch is when an edge's endpoint is actually on the travel plane.  In that case, we've already got an intersection point to check.  I'll see if that solves this problem. \n ",
            "author": "Karl Wright"
        },
        {
            "id": "comment-16431537",
            "date": "2018-04-10T00:14:22+0000",
            "content": "Commit 9bd6d1305c8bbccf2f3a22079a523b483325e9eb in lucene-solr's branch refs/heads/master from Karl Wright\n[ https://git-wip-us.apache.org/repos/asf?p=lucene-solr.git;h=9bd6d13 ]\n\nLUCENE-8245: Don't rely only on 'intersects' code to determine whether we should bother looking for crossings; also see if endpoints lie on travel planes. ",
            "author": "ASF subversion and git services"
        },
        {
            "id": "comment-16431539",
            "date": "2018-04-10T00:15:24+0000",
            "content": "Not sure if it belongs on this issue, but this is a reproducing TestGeo3DPoint.testGeo3DRelations() failure, from https://jenkins.thetaphi.de/job/Lucene-Solr-master-MacOSX/4557/:\n\n\nChecking out Revision b82f5912a05ceffd28cf2a600c701e2fb387014d (refs/remotes/origin/master)\n[...]\n  [junit4] Suite: org.apache.lucene.spatial3d.TestGeo3DPoint\n  [junit4]   2> NOTE: reproduce with: ant test  -Dtestcase=TestGeo3DPoint -Dtests.method=testGeo3DRelations -Dtests.seed=7BAAE36CC3CC7C16 -Dtests.slow=true -Dtests.badapples=true -Dtests.locale=shi-Tfng-MA -Dtests.timezone=America/Swift_Current -Dtests.asserts=true -Dtests.file.encoding=UTF-8\n  [junit4] ERROR   0.67s J0 | TestGeo3DPoint.testGeo3DRelations <<<\n  [junit4]    > Throwable #1: java.lang.IllegalArgumentException: No off-plane intersection points were found; can't compute traversal\n  [junit4]    > \tat __randomizedtesting.SeedInfo.seed([7BAAE36CC3CC7C16:CBD59EF84C81D28A]:0)\n  [junit4]    > \tat org.apache.lucene.spatial3d.geom.GeoComplexPolygon$DualCrossingEdgeIterator.pickProximate(GeoComplexPolygon.java:1201)\n  [junit4]    > \tat org.apache.lucene.spatial3d.geom.GeoComplexPolygon$DualCrossingEdgeIterator.computeInsideOutside(GeoComplexPolygon.java:1181)\n  [junit4]    > \tat org.apache.lucene.spatial3d.geom.GeoComplexPolygon$DualCrossingEdgeIterator.matches(GeoComplexPolygon.java:1254)\n  [junit4]    > \tat org.apache.lucene.spatial3d.geom.GeoComplexPolygon$Node.traverse(GeoComplexPolygon.java:664)\n  [junit4]    > \tat org.apache.lucene.spatial3d.geom.GeoComplexPolygon$Tree.traverse(GeoComplexPolygon.java:760)\n  [junit4]    > \tat org.apache.lucene.spatial3d.geom.GeoComplexPolygon$Tree.traverse(GeoComplexPolygon.java:746)\n  [junit4]    > \tat org.apache.lucene.spatial3d.geom.GeoComplexPolygon.isWithin(GeoComplexPolygon.java:456)\n  [junit4]    > \tat org.apache.lucene.spatial3d.geom.GeoBaseMembershipShape.isWithin(GeoBaseMembershipShape.java:36)\n  [junit4]    > \tat org.apache.lucene.spatial3d.geom.BaseXYZSolid.isAreaInsideShape(BaseXYZSolid.java:130)\n  [junit4]    > \tat org.apache.lucene.spatial3d.geom.StandardXYZSolid.getRelationship(StandardXYZSolid.java:432)\n  [junit4]    > \tat org.apache.lucene.spatial3d.TestGeo3DPoint.testGeo3DRelations(TestGeo3DPoint.java:311)\n  [junit4]    > \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n  [junit4]    > \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n  [junit4]    > \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n  [junit4]    > \tat java.base/java.lang.reflect.Method.invoke(Method.java:564)\n  [junit4]    > \tat java.base/java.lang.Thread.run(Thread.java:844)\n[...]\n  [junit4]   2> NOTE: test params are: codec=Asserting(Lucene70): {id=BlockTreeOrds(blocksize=128)}, docValues:{id=DocValuesFormat(name=Lucene70), point=DocValuesFormat(name=Asserting)}, maxPointsInLeafNode=910, maxMBSortInHeap=5.851383459429137, sim=Asserting(org.apache.lucene.search.similarities.AssertingSimilarity@1f97fd1a), locale=shi-Tfng-MA, timezone=America/Swift_Current\n  [junit4]   2> NOTE: Mac OS X 10.11.6 x86_64/Oracle Corporation 9 (64-bit)/cpus=3,threads=1,free=30828472,total=54853632\n\n ",
            "author": "Steve Rowe"
        },
        {
            "id": "comment-16431540",
            "date": "2018-04-10T00:15:28+0000",
            "content": "Commit 2ef5c946c3e19a49c712047f0825c26d5db09cf6 in lucene-solr's branch refs/heads/branch_7x from Karl Wright\n[ https://git-wip-us.apache.org/repos/asf?p=lucene-solr.git;h=2ef5c94 ]\n\nLUCENE-8245: Don't rely only on 'intersects' code to determine whether we should bother looking for crossings; also see if endpoints lie on travel planes. ",
            "author": "ASF subversion and git services"
        },
        {
            "id": "comment-16431541",
            "date": "2018-04-10T00:15:53+0000",
            "content": "Commit 95435d4e738869a4dc46c5f47a59a7df44d0c593 in lucene-solr's branch refs/heads/branch_6x from Karl Wright\n[ https://git-wip-us.apache.org/repos/asf?p=lucene-solr.git;h=95435d4 ]\n\nLUCENE-8245: Don't rely only on 'intersects' code to determine whether we should bother looking for crossings; also see if endpoints lie on travel planes. ",
            "author": "ASF subversion and git services"
        },
        {
            "id": "comment-16431547",
            "date": "2018-04-10T00:19:56+0000",
            "content": "Not sure if it belongs on this issue, but this is a reproducing TestGeo3DPoint.testGeo3DRelations() failure, from https://jenkins.thetaphi.de/job/Lucene-Solr-master-MacOSX/4557/:\n\nAs of Karl's 9bd6d13 commit, this failure ^^ no longer reproduces. ",
            "author": "Steve Rowe"
        },
        {
            "id": "comment-16431770",
            "date": "2018-04-10T06:08:00+0000",
            "content": "I need to re-open again as I see still errors related with travel plane intersecting near a polygon point. ",
            "author": "Ignacio Vera"
        },
        {
            "id": "comment-16431777",
            "date": "2018-04-10T06:18:14+0000",
            "content": "I attached the patches:\n\ncase3: Contains three test cases.\n\n1) The first cases seems to fail because we need to increase the envelope for asserting if we need to look for inner and outer crossings. The following seems to help:\n\n\u00a0\n\nfinal GeoPoint[] travelCrossings = travelPlane.findIntersections(planetModel, edge.plane, checkPointCutoffPlane, checkPointOtherCutoffPlane, edge.startPlane, edge.endPlane);\nif (travelCrossings != null && travelCrossings.length == 0) {\n  final GeoPoint[] testPointCrossings = testPointPlane.findIntersections(planetModel, edge.plane, testPointCutoffPlane, testPointOtherCutoffPlane, edge.startPlane, edge.endPlane);\n  if (testPointCrossings != null && testPointCrossings.length == 0) {\n    // As a last resort, see if the edge endpoints are on either plane.  This is sometimes necessary because the\n    // intersection computation logic might not detect near-miss edges otherwise.\n    if (Math.abs(travelPlane.evaluate(edge.startPoint)) > Plane.MINIMUM_PLANE_OFFSET  &&\n        Math.abs(travelPlane.evaluate(edge.endPoint)) > Plane.MINIMUM_PLANE_OFFSET &&\n        Math.abs(testPointPlane.evaluate(edge.startPoint)) > Plane.MINIMUM_PLANE_OFFSET &&\n        Math.abs(testPointPlane.evaluate(edge.endPoint)) > Plane.MINIMUM_PLANE_OFFSET) {\n      return true;\n    }\n  }\n}\n\n\u00a0\n\n2)\u00a0 We miss crossings but the end point or start point are actually on the plane. I have changed the way we count crossings and it seems to help:\n\n\u00a0\n\nif (testPointInnerCrossings != null && testPointInnerCrossings.length > 0) {\n  for (final GeoPoint crossing : testPointInnerCrossings) {\n    //System.out.println(\"  Test point inner point \"+crossing+\"; edgeplane=\"+edge.plane.evaluate(crossing)+\"; testPointInsidePlane=\"+testPointInsidePlane.evaluate(crossing)+\"; edgestartplane=\"+edge.startPlane.evaluate(crossing)+\"; edgeendplane=\"+edge.endPlane.evaluate(crossing));\n    countingHash.add(crossing);\n  }\n} else if (testPointOuterCrossings != null && testPointOuterCrossings.length > 0) {\n  if (testPointInsidePlane.evaluateIsZero(edge.endPoint) || testPointInsidePlane.evaluateIsZero(edge.startPoint)) {\n    countingHash.add(edge.endPoint);\n  }\n}\n\n\u00a0\n\nI added the random test I am using to uncover all these cases. It still gets spurious errors but after the changes above they don't seem related with this case.\n\nThe last patch is my version of GeoComplexPolygon.\n\n\u00a0\n\n\u00a0\n\n\u00a0\n\n\u00a0 ",
            "author": "Ignacio Vera"
        },
        {
            "id": "comment-16432056",
            "date": "2018-04-10T10:58:00+0000",
            "content": "Commit 661fdf3a43e6d7a8b8b28254f69387209bafcd75 in lucene-solr's branch refs/heads/master from Karl Wright\n[ https://git-wip-us.apache.org/repos/asf?p=lucene-solr.git;h=661fdf3 ]\n\nLUCENE-8245: Add more tests that demonstrate problems with GeoComplexPolygon. ",
            "author": "ASF subversion and git services"
        },
        {
            "id": "comment-16432058",
            "date": "2018-04-10T10:58:32+0000",
            "content": "Commit 138e206547f7a6732dc6dd56a516ad440256eaf0 in lucene-solr's branch refs/heads/branch_7x from Karl Wright\n[ https://git-wip-us.apache.org/repos/asf?p=lucene-solr.git;h=138e206 ]\n\nLUCENE-8245: Add more tests that demonstrate problems with GeoComplexPolygon. ",
            "author": "ASF subversion and git services"
        },
        {
            "id": "comment-16432059",
            "date": "2018-04-10T10:59:05+0000",
            "content": "Commit 3a0aef1fe91039b397e4b023238fd0e0296459a3 in lucene-solr's branch refs/heads/branch_6x from Karl Wright\n[ https://git-wip-us.apache.org/repos/asf?p=lucene-solr.git;h=3a0aef1 ]\n\nLUCENE-8245: Add more tests that demonstrate problems with GeoComplexPolygon. ",
            "author": "ASF subversion and git services"
        },
        {
            "id": "comment-16432111",
            "date": "2018-04-10T11:39:30+0000",
            "content": "Ignacio Vera, I've committed the tests with the @AwaitsFix annotation.  I'm looking at them one at a time.\n\nPlease let me turn your attention to \"case2\".  Debug output from this case looks like this:\n\n\n   [junit4]   1>\n   [junit4]   1> The following edges should intersect the travel/testpoint planes:\n   [junit4]   1> Travel plane: [lat=-0.09183481853716734, lon=0.0([X=0.9957861458099824, Y=0.0, Z=-0.09170578941866683])] -> [lat=-0.3728403971990659, lon=-0.27395646628085935([X=0.8965665862615776, Y=-0.25195523953197785, Z=-0.3642621496554991])]\n   [junit4]   1>\n   [junit4]   1> Considering edge [lat=-0.09183481853716734, lon=0.0([X=0.9957861458099824, Y=0.0, Z=-0.09170578941866683])] -> [lat=-0.3728403971990659, lon=-0.27395646628085935([X=0.8965665862615776, Y=-0.25195523953197785, Z=-0.3642621496554991])]\n   [junit4]   1>  Intersection found with travel plane...\n   [junit4]   1>  Edge intersects travel or testPoint plane\n   [junit4]   1>  Edge added 0 to innerCrossingCount\n   [junit4]   1>  Edge added 1 to outerCrossingCount\n   [junit4]   1>\n   [junit4]   1> Considering edge [lat=-0.28073906699213097, lon=0.21188006007761473([X=0.9393636799476138, Y=0.20206530496788694, Z=-0.2770658573760249])] -> [lat=-0.1600017188310958, lon=0.0849758111192731([X=0.983664825750331, Y=0.08378949178268695, Z=-0.1593199034909639])]\n   [junit4]   1>  No intersections with travel plane...\n   [junit4]   1>  No intersections with testpoint plane...\n   [junit4]   1>\n   [junit4]   1> Considering edge [lat=-0.1600017188310958, lon=0.0849758111192731([X=0.983664825750331, Y=0.08378949178268695, Z=-0.1593199034909639])] -> [lat=-0.09183481853716734, lon=0.0([X=0.9957861458099824, Y=0.0, Z=-0.09170578941866683])]\n   [junit4]   1>  No intersections with travel plane...\n   [junit4]   1>  No intersections with testpoint plane...\n   [junit4]   1>\n   [junit4]   1> Considering edge [lat=-0.3728403971990659, lon=-0.27395646628085935([X=0.8965665862615776, Y=-0.25195523953197785, Z=-0.3642621496554991])] -> [lat=-0.4683367913453203, lon=0.09620752412577895([X=0.8881938751251655, Y=0.08571555484949944, Z=-0.4514027955684197])]\n   [junit4]   1>  No intersections with travel plane...\n   [junit4]   1>  No intersections with testpoint plane... \n \n\n\n\nSo, the sole edge that intersects with the travel plane does not intersect at either edge's endpoint; it intersects by virtue of an actual mathematical intersection being detected.  Since there is no detection of an intersection of the travel plane by any of the other edges, we can conclude, as you certainly have, that the edge's endpoints both lie outside of the zone where we would consider those endpoints to be on the travel plane.  So far, so good.  But let's be clear: this means, mathematically, that there is no intersection between any of the other edges and the travel plane.\n\nWhat we need to do is figure out how the edge winds up crossing just one side of the envelope, and not exiting anywhere, without intersecting either the inner or outer envelope planes.  We know that intersection computation is not guaranteed to come up with a plane intersection unless there's an actual crossing of the plane within the intersection bounds.  So, probably, the endpoint's intersection with the inner/outer envelope plane(s) is what's being missed.\n\nI'll try a fix and see how that does. ",
            "author": "Karl Wright"
        },
        {
            "id": "comment-16432129",
            "date": "2018-04-10T11:50:03+0000",
            "content": "The problem why the plane enters the polygon and never exists is because it reaches the intersection point. The actual travel plane is just outside of the polygon running in paralell (never crosses) and only the inner plane enters until the intersection point is reached.\n\nwhat we currently do is to check for crossing of all travel planes if either the test plane or the check plane has an intersections. Maybe we need to separate this logic. ",
            "author": "Ignacio Vera"
        },
        {
            "id": "comment-16432269",
            "date": "2018-04-10T13:37:30+0000",
            "content": "Hello, \nI'm afraid it may hurt precommit like https://jenkins.thetaphi.de/job/Lucene-Solr-7.x-Solaris/551/ \n\n[forbidden-apis] Forbidden method invocation: java.lang.Math#toDegrees(double) [Use home-grown methods instead]\n[forbidden-apis]   in org.apache.lucene.spatial3d.geom.RandomGeoPolygonTest (RandomGeoPolygonTest.java:177)\n[forbidden-apis] Forbidden method invocation: java.lang.Math#toDegrees(double) [Use home-grown methods instead]\n[forbidden-apis]   in org.apache.lucene.spatial3d.geom.RandomGeoPolygonTest (RandomGeoPolygonTest.java:177)\n[forbidden-apis] Forbidden method invocation: java.lang.Math#toDegrees(double) [Use home-grown methods instead]\n[forbidden-apis]   in org.apache.lucene.spatial3d.geom.RandomGeoPolygonTest (RandomGeoPolygonTest.java:214)\n[forbidden-apis] Forbidden method invocation: java.lang.Math#toDegrees(double) [Use home-grown methods instead]\n[forbidden-apis]   in org.apache.lucene.spatial3d.geom.RandomGeoPolygonTest (RandomGeoPolygonTest.java:214)\n[forbidden-apis] Forbidden method invocation: java.lang.Math#toDegrees(double) [Use home-grown methods instead]\n[forbidden-apis]   in org.apache.lucene.spatial3d.geom.RandomGeoPolygonTest (RandomGeoPolygonTest.java:216)\n[forbidden-apis] Forbidden method invocation: java.lang.Math#toDegrees(double) [Use home-grown methods instead]\n[forbidden-apis]   in org.apache.lucene.spatial3d.geom.RandomGeoPolygonTest (RandomGeoPolygonTest.java:216) ",
            "author": "Mikhail Khludnev"
        },
        {
            "id": "comment-16432431",
            "date": "2018-04-10T15:11:22+0000",
            "content": "Commit 14b313f42bbc061704232eda0d0c3ff1405fe9e3 in lucene-solr's branch refs/heads/master from Karl Wright\n[ https://git-wip-us.apache.org/repos/asf?p=lucene-solr.git;h=14b313f ]\n\nLUCENE-8245: Adopt a more-rigorous way of finding intersections with envelope planes. ",
            "author": "ASF subversion and git services"
        },
        {
            "id": "comment-16432436",
            "date": "2018-04-10T15:12:06+0000",
            "content": "Commit 99e5a411861fdd9a0af2eda4c09fa83b49e80d11 in lucene-solr's branch refs/heads/branch_7x from Karl Wright\n[ https://git-wip-us.apache.org/repos/asf?p=lucene-solr.git;h=99e5a41 ]\n\nLUCENE-8245: Adopt a more-rigorous way of finding intersections with envelope planes. ",
            "author": "ASF subversion and git services"
        },
        {
            "id": "comment-16432441",
            "date": "2018-04-10T15:12:29+0000",
            "content": "Commit 16e5ab161cc97a46c4dd115c409e8ed4ddf3b40f in lucene-solr's branch refs/heads/branch_6x from Karl Wright\n[ https://git-wip-us.apache.org/repos/asf?p=lucene-solr.git;h=16e5ab1 ]\n\nLUCENE-8245: Adopt a more-rigorous way of finding intersections with envelope planes. ",
            "author": "ASF subversion and git services"
        },
        {
            "id": "comment-16432450",
            "date": "2018-04-10T15:19:34+0000",
            "content": "Well, I have a fix committed for case2.  But the fix only narrowly applies to that failure, apparently.  The full fix requires new math: I need to be able to determine, somehow, if the surface path of a plane which connects two points stays everywhere within MINIMUM_RESOLUTION of another plane.  I'll have to think that through but there's no more time today. ",
            "author": "Karl Wright"
        },
        {
            "id": "comment-16432521",
            "date": "2018-04-10T16:01:17+0000",
            "content": "Commit 61c37551aca28341acef176d9dc088b37c84d307 in lucene-solr's branch refs/heads/master from Karl Wright\n[ https://git-wip-us.apache.org/repos/asf?p=lucene-solr.git;h=61c3755 ]\n\nLUCENE-8245: Fix precommit. ",
            "author": "ASF subversion and git services"
        },
        {
            "id": "comment-16432522",
            "date": "2018-04-10T16:01:55+0000",
            "content": "Commit b873d1fb3422206ff7adf756791258333f1bf9f0 in lucene-solr's branch refs/heads/branch_7x from Karl Wright\n[ https://git-wip-us.apache.org/repos/asf?p=lucene-solr.git;h=b873d1f ]\n\nLUCENE-8245: Fix precommit. ",
            "author": "ASF subversion and git services"
        },
        {
            "id": "comment-16432523",
            "date": "2018-04-10T16:02:18+0000",
            "content": "Commit 19feef73bf17796cad27215602a8f5cdad5266f1 in lucene-solr's branch refs/heads/branch_6x from Karl Wright\n[ https://git-wip-us.apache.org/repos/asf?p=lucene-solr.git;h=19feef7 ]\n\nLUCENE-8245: Fix precommit. ",
            "author": "ASF subversion and git services"
        },
        {
            "id": "comment-16432560",
            "date": "2018-04-10T16:41:27+0000",
            "content": "I'm still seeing precommit errors. Am about to push out a fix for them. ",
            "author": "Joel Bernstein"
        },
        {
            "id": "comment-16432569",
            "date": "2018-04-10T16:46:10+0000",
            "content": "Commit e90ab4bb8191644a19308c30a3e4752043d50985 in lucene-solr's branch refs/heads/master from Joel Bernstein\n[ https://git-wip-us.apache.org/repos/asf?p=lucene-solr.git;h=e90ab4b ]\n\nLUCENE-8245: Fix precommit ",
            "author": "ASF subversion and git services"
        },
        {
            "id": "comment-16432588",
            "date": "2018-04-10T17:02:46+0000",
            "content": "Commit 48325cf8ce8de647300409def9c0b18c116ea307 in lucene-solr's branch refs/heads/branch_7x from Joel Bernstein\n[ https://git-wip-us.apache.org/repos/asf?p=lucene-solr.git;h=48325cf ]\n\nLUCENE-8245: Fix precommit ",
            "author": "ASF subversion and git services"
        },
        {
            "id": "comment-16432884",
            "date": "2018-04-10T20:04:41+0000",
            "content": "Commit 6f68f74f7f36b0410dcfc29c03e5a970670c81ee in lucene-solr's branch refs/heads/branch_6x from Joel Bernstein\n[ https://git-wip-us.apache.org/repos/asf?p=lucene-solr.git;h=6f68f74 ]\n\nLUCENE-8245: Fix precommit ",
            "author": "ASF subversion and git services"
        },
        {
            "id": "comment-16433098",
            "date": "2018-04-10T22:38:54+0000",
            "content": "The more-rigorous way of properly discovering the above condition is sort of already present.  What's needed is to find the XYZBounds of the bit of arc between the intersection point and the end point of the arc, and make sure that it all fits within the envelope plane bounds.\n\nUnfortunately, this is all rather expensive to compute \u2013 mainly because of significant object creation being required.  Fortunately, it happens only in very specific cases so maybe it would be limited enough to not impact things too badly.  But no question it would need to happen every time an edge ends on an envelope plane, and the distance between the edge endpoint and the intersection point is greater than MINIMUM_RESOLUTION.\n\nI'm going to take a break from this particular part of the problem to give myself a chance to think it through to be sure there isn't a better way.  I'm also going to analyze case3 to see what the issue is there \u2013 tomorrow. ",
            "author": "Karl Wright"
        },
        {
            "id": "comment-16433488",
            "date": "2018-04-11T06:54:29+0000",
            "content": "Commit 8e77892443601d702071dae4336d4976d9a7564f in lucene-solr's branch refs/heads/master from Karl Wright\n[ https://git-wip-us.apache.org/repos/asf?p=lucene-solr.git;h=8e77892 ]\n\nLUCENE-8245: Handle parallel planes case properly. ",
            "author": "ASF subversion and git services"
        },
        {
            "id": "comment-16433490",
            "date": "2018-04-11T06:55:03+0000",
            "content": "Commit 2376b6c51c4fa7bb4ae8c1dfa04b1704a0d9f37a in lucene-solr's branch refs/heads/branch_7x from Karl Wright\n[ https://git-wip-us.apache.org/repos/asf?p=lucene-solr.git;h=2376b6c ]\n\nLUCENE-8245: Handle parallel planes case properly. ",
            "author": "ASF subversion and git services"
        },
        {
            "id": "comment-16433491",
            "date": "2018-04-11T06:55:34+0000",
            "content": "Commit 1f622d93dcad8ee5f2e1f772408201e077dc16c2 in lucene-solr's branch refs/heads/branch_6x from Karl Wright\n[ https://git-wip-us.apache.org/repos/asf?p=lucene-solr.git;h=1f622d9 ]\n\nLUCENE-8245: Handle parallel planes case properly. ",
            "author": "ASF subversion and git services"
        },
        {
            "id": "comment-16433823",
            "date": "2018-04-11T12:23:12+0000",
            "content": "I believe I've come up with a better way to do this.  It involves two basic changes:\n(1) using only actual intersections with the envelope planes, so no \"zone\" is needed, and the envelope planes go back to being exactly MINIMUM_RESOLUTION from the main travel planes; and\n(2) evaluating the envelope plane intersections, one at a time, for whether they constitute a \"crossing\" from the main travel plane \"zone\" outside of that \"zone\".\n\nThe second requires the generation of a pair of adjoining points, also on the edge plane, that are about MINIMUM_RESOLUTION away from the intersection.  We look at both points, and if one is inside the travel plane \"zone\" and the other is not, then we call it a crossing.\n\nI'm coding this up now but it's already a very busy work day and this probably won't be completed and debugged until tonight at the earliest. ",
            "author": "Karl Wright"
        },
        {
            "id": "comment-16434044",
            "date": "2018-04-11T15:06:01+0000",
            "content": "The adjoining points code I developed works OK for spheres but not for anything else, which is a problem.  Have to think of something better that's not too expensive.  No more time today. ",
            "author": "Karl Wright"
        },
        {
            "id": "comment-16434621",
            "date": "2018-04-11T21:54:44+0000",
            "content": "Commit 0c71503448a66e8766008ae0447e36115ffbdd08 in lucene-solr's branch refs/heads/master from Karl Wright\n[ https://git-wip-us.apache.org/repos/asf?p=lucene-solr.git;h=0c71503 ]\n\nLUCENE-8245: Change how crossings are computed. ",
            "author": "ASF subversion and git services"
        },
        {
            "id": "comment-16434622",
            "date": "2018-04-11T21:55:18+0000",
            "content": "Commit 6ce215d6f2e079e505c664e00b6898056dbcc324 in lucene-solr's branch refs/heads/branch_7x from Karl Wright\n[ https://git-wip-us.apache.org/repos/asf?p=lucene-solr.git;h=6ce215d ]\n\nLUCENE-8245: Change how crossings are computed. ",
            "author": "ASF subversion and git services"
        },
        {
            "id": "comment-16434623",
            "date": "2018-04-11T21:55:47+0000",
            "content": "Commit 6edfd9f2bd07412ed96c6402cd7c7c1495ae13db in lucene-solr's branch refs/heads/branch_6x from Karl Wright\n[ https://git-wip-us.apache.org/repos/asf?p=lucene-solr.git;h=6edfd9f ]\n\nLUCENE-8245: Change how crossings are computed. ",
            "author": "ASF subversion and git services"
        },
        {
            "id": "comment-16434925",
            "date": "2018-04-12T04:57:06+0000",
            "content": "Ignacio Vera, I committed revised code that I'm happy with, but I needed to disable tests for two cases in the GeoPolygonTest suite.  One of the tests fails again because it picks a bad path \u2013 I thought maybe you'd like to analyze that one while I look at the other.  This is the \"bad path picked\" bug:\n\n\nant test  -Dtestcase=GeoPolygonTest -Dtests.method=testComplexPolygonPlaneOutsideWorld\n\n\n ",
            "author": "Karl Wright"
        },
        {
            "id": "comment-16434960",
            "date": "2018-04-12T05:28:35+0000",
            "content": "Sure! I have a look time permitting. ",
            "author": "Ignacio Vera"
        },
        {
            "id": "comment-16434976",
            "date": "2018-04-12T05:48:51+0000",
            "content": "The remaining other failure is due to inconsistent detection of whether or not one of the envelope planes is intersected.  Two edges share the same endpoint, and that endpoint is very close to the envelope travel plane.  One of edges detects the intersection, but the other does not, and that leads to a miscount:\n\n\n   [junit4]   1> The following edges should intersect the travel/testpoint planes:\n   [junit4]   1> Travel plane: [lat=-1.4506713533447755, lon=-1.2251247551355924([X=0.04060395941016342, Y=-0.11274773940940182, Z=-0.9927936672533157])] -> [lat=4.9E-324, lon=0.0([X=1.0, Y=0.0, Z=4.9E-324])]\n   [junit4]   1> Test point plane: [lat=-1.4506713533447755, lon=-1.2251247551355924([X=0.04060395941016342, Y=-0.11274773940940182, Z=-0.9927936672533157])] -> [lat=4.9E-324, lon=0.0([X=1.0, Y=0.0, Z=4.9E-324])]\n   [junit4]   1> Travel plane: [lat=4.9E-324, lon=0.0([X=1.0, Y=0.0, Z=4.9E-324])] -> [lat=0.13953211802880663, lon=-2.443438340098597([X=-0.7585849990851791, Y=-0.6365576248361361, Z=0.139079795174987])]\n   [junit4]   1>\n   [junit4]   1> Considering edge [lat=-1.4506713533447755, lon=-1.2251247551355924([X=0.04060395941016342, Y=-0.11274773940940182, Z=-0.9927936672533157])] -> [lat=4.9E-324, lon=0.0([X=1.0, Y=0.0, Z=4.9E-324])]\n   [junit4]   1>  Edge intersects travel or testPoint plane\n   [junit4]   1>  Assessing inner crossings...\n   [junit4]   1>   Assessing travel intersection point [X=1.0, Y=-1.3268072236836583E-12, Z=-1.1683123903318337E-11]...\n   [junit4]   1>    Adjoining point [X=1.0, Y=-1.2139664266344454E-12, Z=-1.068951082242553E-11] (dist = 9.999999999999994E-13) is within\n   [junit4]   1>    Adjoining point [X=1.0, Y=-1.4396480207328712E-12, Z=-1.2676736984211145E-11] (dist = 9.999999999999994E-13) is not within\n   [junit4]   1>   Assessing testpoint intersection point [X=0.7540698997149328, Y=-0.07411317803505024, Z=-0.6525992822440554]...\n   [junit4]   1>    Adjoining point [X=0.7540698997155896, Y=-0.07411317803496516, Z=-0.6525992822433061] (dist = 1.0000354317132432E-12) is not within\n   [junit4]   1>    Adjoining point [X=0.7540698997142758, Y=-0.07411317803513531, Z=-0.6525992822448046] (dist = 1.000023996169918E-12) is within\n   [junit4]   1>  Assessing outer crossings...\n   // We don't get a travel outer intersection here!!!  But we did below, and that's the problem.  One crossing is direct, the other is oblique, and that's enough to allow\n   // numerical imprecision to give us different results even though the endpoint for both edges is the same.\n   [junit4]   1>   Assessing testpoint intersection point [X=0.7540698997131794, Y=-0.0741131780352774, Z=-0.6525992822460556]...\n   [junit4]   1>    Adjoining point [X=0.7540698997138362, Y=-0.07411317803519231, Z=-0.6525992822453063] (dist = 1.0000354317132432E-12) is within\n   [junit4]   1>    Adjoining point [X=0.7540698997125226, Y=-0.07411317803536248, Z=-0.6525992822468049] (dist = 1.0000354317132432E-12) is not within\n   [junit4]   1>\n   [junit4]   1> Considering edge [lat=4.9E-324, lon=0.0([X=1.0, Y=0.0, Z=4.9E-324])] -> [lat=0.13953211802880663, lon=-2.443438340098597([X=-0.7585849990851791, Y=-0.6365576248361361, Z=0.139079795174987])]\n   [junit4]   1>  Edge intersects travel or testPoint plane\n   [junit4]   1>  Assessing inner crossings...\n   [junit4]   1>   Assessing travel intersection point [X=1.0, Y=-1.326807223683658E-12, Z=2.8989060802487275E-13]...\n   [junit4]   1>    Adjoining point [X=1.0, Y=-2.3037607755580197E-12, Z=5.033426107797519E-13] (dist = 1.0E-12) is not within\n   [junit4]   1>    Adjoining point [X=1.0, Y=-3.4985367180929626E-13, Z=7.643860526999353E-14] (dist = 1.0000000000000002E-12) is within\n   [junit4]   1>  Assessing outer crossings...\n   [junit4]   1>   Assessing travel intersection point [X=1.0, Y=6.731927763163422E-13, Z=-1.470841127187181E-13]...\n   [junit4]   1>    Adjoining point [X=1.0, Y=-3.037607755580196E-13, Z=6.636789003616112E-14] (dist = 1.0000000000000002E-12) is within\n   [junit4]   1>    Adjoining point [X=1.0, Y=1.650146328190704E-12, Z=-3.6053611547359735E-13] (dist = 1.0E-12) is not within\n\n\n\nThis may be due to the angle of intersection; probably neither should be considered \"intersecting\", but 1e-12 extra along one is enough, but along the other is not.  The only simple way to correct this is to alternatively tighten the cutoff leeway, so that neither detects intersection, or loosen it enough that both edges would detect intersection. I fear that either solution would leave the same situation in place, albeit at a tighter range of values, so I need to think through alternatives.\n\nOne potential solution is to notice that the endpoint itself is within the envelope plane.  This works in the other case where we're trying to be sure we don't miss an intersection with the actual travel plane, but in that case it's part of a binary decision, and in this case it figures into a count, and we cannot afford to count twice.  It's possible we could use isNumericallyIdentical() to make sure there is no duplication; this would likely work because we already know that the edge endpoint is close to the intersection point in that case.  The riskier part is that we find intersections with the envelope plane that should not be there at all, such as edges that end within the envelope plane that never intersected the travel plane.  Fixing those would require horrific logic, I fear.\n\nStill gotta think about this, but I'm leaning towards the tighter bound for envelope edge ends.\n ",
            "author": "Karl Wright"
        },
        {
            "id": "comment-16435140",
            "date": "2018-04-12T08:21:25+0000",
            "content": "The issue with the testComplexPolygonPlaneOutsideWorld is straight forward:\n\nThe test build the following below plane which it is just outside of the world by just a bit:\n\n[A=1.0, B=0.0; C=0.0; D=-1.0000000000009952]\n\nBecause we are testing the validity of the plane in the following way:\n\nif (fixedXBelowPlane.D - planetModel.getMaximumXValue() >= Vector.MINIMUM_RESOLUTION || planetModel.getMinimumXValue() - fixedXBelowPlane.D >= Vector.MINIMUM_RESOLUTION) {\n    fixedXBelowPlane = null;\n}\n\nwe are allowing bellow planes that are just a bit outside of the world.I think we should change those checks to:\n\nPlane fixedXBelowPlane = new Plane(travelPlaneFixedX, false);\nif (fixedXBelowPlane.D - planetModel.getMaximumXValue() >= Vector.MINIMUM_RESOLUTION || fixedXBelowPlane.D - planetModel.getMinimumXValue() <= Vector.MINIMUM_RESOLUTION) {\n    fixedXBelowPlane = null;\n}\n\nSo below planes are never outside of the world.\n\n\u00a0\n\n\u00a0\n\n\u00a0 ",
            "author": "Ignacio Vera"
        },
        {
            "id": "comment-16435278",
            "date": "2018-04-12T10:09:28+0000",
            "content": "Ignacio Vera, I made that change but it did not fix the problem.\n\nHere's the code in question:\n\n\n    Plane fixedYAbovePlane = new Plane(testPointFixedYPlane, true);\n    if (fixedYAbovePlane.D - planetModel.getMaximumYValue() >= Vector.MINIMUM_RESOLUTION || planetModel.getMinimumYValue() - fixedYAbovePlane.D >= Vector.MINIMUM_RESOLUTION) {\n        fixedYAbovePlane = null;\n    }\n    this.testPointFixedYAbovePlane = fixedYAbovePlane;\n    \n    Plane fixedYBelowPlane = new Plane(testPointFixedYPlane, false);\n    if (fixedYBelowPlane.D - planetModel.getMaximumYValue() >= Vector.MINIMUM_RESOLUTION ||  planetModel.getMinimumYValue() - fixedYBelowPlane.D >= Vector.MINIMUM_RESOLUTION) {\n        fixedYBelowPlane = null;\n    }\n    this.testPointFixedYBelowPlane = fixedYBelowPlane;\n    \n    Plane fixedXAbovePlane = new Plane(testPointFixedXPlane, true);\n    if (fixedXAbovePlane.D - planetModel.getMaximumXValue() >= Vector.MINIMUM_RESOLUTION || planetModel.getMinimumXValue() - fixedXAbovePlane.D >= Vector.MINIMUM_RESOLUTION) {\n        fixedXAbovePlane = null;\n    }\n    this.testPointFixedXAbovePlane = fixedXAbovePlane;\n    \n    Plane fixedXBelowPlane = new Plane(testPointFixedXPlane, false);\n    if (fixedXBelowPlane.D - planetModel.getMaximumXValue() >= Vector.MINIMUM_RESOLUTION || planetModel.getMinimumXValue() - fixedXBelowPlane.D >= Vector.MINIMUM_RESOLUTION) {\n        fixedXBelowPlane = null;\n    }\n    this.testPointFixedXBelowPlane = fixedXBelowPlane;\n    \n    Plane fixedZAbovePlane = new Plane(testPointFixedZPlane, true);\n    if (fixedZAbovePlane.D - planetModel.getMaximumZValue() >= Vector.MINIMUM_RESOLUTION ||planetModel.getMinimumZValue() - fixedZAbovePlane.D >= Vector.MINIMUM_RESOLUTION) {\n        fixedZAbovePlane = null;\n    }\n    this.testPointFixedZAbovePlane = fixedZAbovePlane;\n    \n    Plane fixedZBelowPlane = new Plane(testPointFixedZPlane, false);\n    if (fixedZBelowPlane.D - planetModel.getMaximumZValue() >= Vector.MINIMUM_RESOLUTION || planetModel.getMinimumZValue() - fixedZBelowPlane.D >= Vector.MINIMUM_RESOLUTION) {\n        fixedZBelowPlane = null;\n    }\n    this.testPointFixedZBelowPlane = fixedZBelowPlane;\n\n\n\nThe version you have is just sign-reversed (multiplied everywhere by -1 in the second clauses).  I tried it anyways, made no difference.\n\nI think the test should be stricter and not include the Vector.MINIMUM_RESOLUTION \u2013 that is, all clauses should say \"> 0.0\".  But even when I make that change, the test still fails.\n ",
            "author": "Karl Wright"
        },
        {
            "id": "comment-16435296",
            "date": "2018-04-12T10:21:08+0000",
            "content": "You need to do it as well for the check point, that should fix the test.\n\n\u00a0 ",
            "author": "Ignacio Vera"
        },
        {
            "id": "comment-16435324",
            "date": "2018-04-12T10:40:06+0000",
            "content": "Commit 0b1e8ef72e2e9ae75a1929a00b7137dfb1a75b12 in lucene-solr's branch refs/heads/master from Karl Wright\n[ https://git-wip-us.apache.org/repos/asf?p=lucene-solr.git;h=0b1e8ef ]\n\nLUCENE-8245: Re-solve the 'intersection outside the world' case. ",
            "author": "ASF subversion and git services"
        },
        {
            "id": "comment-16435326",
            "date": "2018-04-12T10:40:39+0000",
            "content": "Commit 6bab34b15c515feb2dc84cadbe66e688177523f7 in lucene-solr's branch refs/heads/branch_7x from Karl Wright\n[ https://git-wip-us.apache.org/repos/asf?p=lucene-solr.git;h=6bab34b ]\n\nLUCENE-8245: Re-solve the 'intersection outside the world' case. ",
            "author": "ASF subversion and git services"
        },
        {
            "id": "comment-16435327",
            "date": "2018-04-12T10:41:06+0000",
            "content": "Commit 018886197563ce311b4907544034b022884f6143 in lucene-solr's branch refs/heads/branch_6x from Karl Wright\n[ https://git-wip-us.apache.org/repos/asf?p=lucene-solr.git;h=0188861 ]\n\nLUCENE-8245: Re-solve the 'intersection outside the world' case. ",
            "author": "ASF subversion and git services"
        },
        {
            "id": "comment-16435357",
            "date": "2018-04-12T11:09:40+0000",
            "content": "Commit 832e89748ea97e262437d420f54aac2a1b87b505 in lucene-solr's branch refs/heads/master from Karl Wright\n[ https://git-wip-us.apache.org/repos/asf?p=lucene-solr.git;h=832e897 ]\n\nLUCENE-8245: Use strict bounds checking for edge planes when assessing envelope crossings.  It's the only way to insure we don't overdetect or underdetect such intersections. ",
            "author": "ASF subversion and git services"
        },
        {
            "id": "comment-16435358",
            "date": "2018-04-12T11:10:30+0000",
            "content": "Commit 74de0591a07828ae7a531c3f93d5879feef434f3 in lucene-solr's branch refs/heads/branch_7x from Karl Wright\n[ https://git-wip-us.apache.org/repos/asf?p=lucene-solr.git;h=74de059 ]\n\nLUCENE-8245: Use strict bounds checking for edge planes when assessing envelope crossings.  It's the only way to insure we don't overdetect or underdetect such intersections. ",
            "author": "ASF subversion and git services"
        },
        {
            "id": "comment-16435878",
            "date": "2018-04-12T16:30:15+0000",
            "content": "Commit 4f694d5c7259355e7b3c20f5ceef2eb63e50c893 in lucene-solr's branch refs/heads/master from David Smiley\n[ https://git-wip-us.apache.org/repos/asf?p=lucene-solr.git;h=4f694d5 ]\n\nLUCENE-8245: fix unused import ",
            "author": "ASF subversion and git services"
        },
        {
            "id": "comment-16435981",
            "date": "2018-04-12T17:19:33+0000",
            "content": "Please remember ant precommit before committing. ",
            "author": "David Smiley"
        },
        {
            "id": "comment-16436131",
            "date": "2018-04-12T18:46:16+0000",
            "content": "Commit 34bbbc4282ad17a206575f9cbfe51416aba90432 in lucene-solr's branch refs/heads/branch_7x from David Smiley\n[ https://git-wip-us.apache.org/repos/asf?p=lucene-solr.git;h=34bbbc4 ]\n\nLUCENE-8245: fix unused import ",
            "author": "ASF subversion and git services"
        },
        {
            "id": "comment-16436134",
            "date": "2018-04-12T18:46:46+0000",
            "content": "Commit 9587e32b32964d77adff8b20b01baa7a0de440c5 in lucene-solr's branch refs/heads/branch_6x from David Smiley\n[ https://git-wip-us.apache.org/repos/asf?p=lucene-solr.git;h=9587e32 ]\n\nLUCENE-8245: fix unused import ",
            "author": "ASF subversion and git services"
        },
        {
            "id": "comment-16436139",
            "date": "2018-04-12T18:50:35+0000",
            "content": "David Smiley I ran it.  Took 25 minutes.\nDon't understand why it didn't detect this. ",
            "author": "Karl Wright"
        },
        {
            "id": "comment-16436747",
            "date": "2018-04-13T03:33:56+0000",
            "content": "Commit 1d201f3c18ef150132e329bac6bb8ecc3ca8c4e0 in lucene-solr's branch refs/heads/master from Karl Wright\n[ https://git-wip-us.apache.org/repos/asf?p=lucene-solr.git;h=1d201f3 ]\n\nLUCENE-8245: Make precommit happy, again. ",
            "author": "ASF subversion and git services"
        },
        {
            "id": "comment-16436748",
            "date": "2018-04-13T03:34:30+0000",
            "content": "Commit 539c7769b2a6ebf605fcdc075d92af4a22979e11 in lucene-solr's branch refs/heads/branch_7x from Karl Wright\n[ https://git-wip-us.apache.org/repos/asf?p=lucene-solr.git;h=539c776 ]\n\nLUCENE-8245: Make precommit happy, again. ",
            "author": "ASF subversion and git services"
        },
        {
            "id": "comment-16436750",
            "date": "2018-04-13T03:34:58+0000",
            "content": "Commit eedd3cea6504c836a6a5ff9c64602546e3a9ff65 in lucene-solr's branch refs/heads/branch_6x from Karl Wright\n[ https://git-wip-us.apache.org/repos/asf?p=lucene-solr.git;h=eedd3ce ]\n\nLUCENE-8245: Make precommit happy, again. ",
            "author": "ASF subversion and git services"
        },
        {
            "id": "comment-16437290",
            "date": "2018-04-13T13:24:23+0000",
            "content": "edit: I see LUCENE-8251 has been opened for the failing test below:\n\nReproducing seed for RandomGeoPolygonTest.testComparePolygons() from https://jenkins.thetaphi.de/job/Lucene-Solr-7.x-Windows/545/; reproduces for me on Linux:\n\n\nChecking out Revision 21f39627624fe4d2b80ca85fae8fdf2b26fd70b6 (refs/remotes/origin/branch_7x)\n[...]\n   [junit4]   2> NOTE: reproduce with: ant test  -Dtestcase=RandomGeoPolygonTest -Dtests.method=testComparePolygons -Dtests.seed=D6349E776359D46D -Dtests.slow=true -Dtests.locale=ms -Dtests.timezone=Asia/Makassar -Dtests.asserts=true -Dtests.file.encoding=Cp1252\n   [junit4] FAILURE 0.15s J0 | RandomGeoPolygonTest.testComparePolygons {seed=[D6349E776359D46D:C13F762B72BE3163]} <<<\n   [junit4]    > Throwable #1: java.lang.AssertionError: \n   [junit4]    > Standard polygon: GeoCompositePolygon: {[GeoConvexPolygon: {planetmodel=PlanetModel.WGS84, points=[[lat=-0.07623836285341265, lon=0.00454700984778178([X=0.998181035951336, Y=0.004538770280526402, Z=-0.07624825759433645])], [lat=-7.476157549743229E-245, lon=0.0([X=1.0011188539924791, Y=0.0, Z=-7.484522278466162E-245])], [lat=0.001511171483804436, lon=-9.688787797923482E-4([X=1.001117233304039, Y=-9.699615469421312E-4, Z=0.0015128616766053018])], [lat=-0.01412589292926225, lon=-0.004052102300342142([X=1.0010100824418215, Y=-0.004056217458151357, Z=-0.01414121792996793])]], internalEdges={}}]}\n   [junit4]    > Large polygon: GeoComplexPolygon: {planetmodel=PlanetModel.WGS84, number of shapes=1, address=b597f211, testPoint=[lat=-0.02220757682746917, lon=-1.218087190149091E-4([X=1.000870329530105, Y=-1.2191473334305646E-4, Z=-0.02223055955204728])], testPointInSet=true, shapes={ {[lat=-0.01412589292926225, lon=-0.004052102300342142([X=1.0010100824418215, Y=-0.004056217458151357, Z=-0.01414121792996793])], [lat=-0.07623836285341265, lon=0.00454700984778178([X=0.998181035951336, Y=0.004538770280526402, Z=-0.07624825759433645])], [lat=-7.476157549743229E-245, lon=0.0([X=1.0011188539924791, Y=0.0, Z=-7.484522278466162E-245])], [lat=0.001511171483804436, lon=-9.688787797923482E-4([X=1.001117233304039, Y=-9.699615469421312E-4, Z=0.0015128616766053018])]}}\n   [junit4]    > Point: [lat=3.310332671314249E-4, lon=-3.0E-323([X=1.0011187987699837, Y=-3.0E-323, Z=3.314036388489196E-4])]\n   [junit4]    > WKT: POLYGON((0.2605244736823189 -4.368136428487497,0.0 -4.283522745751538E-243,-0.05551266494188662 0.08658374814251642,-0.23216835996485705 -0.8093540467004184,0.2605244736823189 -4.368136428487497))\n   [junit4]    > WKT: POINT(-1.7E-321 0.018966809085057403)\n   [junit4]    > normal polygon: false\n   [junit4]    > large polygon: true\n   [junit4]    > \tat __randomizedtesting.SeedInfo.seed([D6349E776359D46D:C13F762B72BE3163]:0)\n   [junit4]    > \tat org.apache.lucene.spatial3d.geom.RandomGeoPolygonTest.testComparePolygons(RandomGeoPolygonTest.java:179)\n   [junit4]    > \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n   [junit4]    > \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n   [junit4]    > \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n   [junit4]    > \tat java.base/java.lang.reflect.Method.invoke(Method.java:564)\n   [junit4]    > \tat java.base/java.lang.Thread.run(Thread.java:841)\n   [junit4]   2> NOTE: test params are: codec=Lucene70, sim=RandomSimilarity(queryNorm=false): {}, locale=ms, timezone=Asia/Makassar\n   [junit4]   2> NOTE: Windows 10 10.0 amd64/Oracle Corporation 11-ea (64-bit)/cpus=3,threads=1,free=73360360,total=97320960\n\n ",
            "author": "Steve Rowe"
        }
    ]
}