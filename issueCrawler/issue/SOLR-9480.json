{
    "id": "SOLR-9480",
    "title": "Graph Traversal for Significantly Related Terms (Semantic Knowledge Graph)",
    "details": {
        "components": [],
        "type": "Improvement",
        "labels": "",
        "fix_versions": [
            "7.4",
            "master (8.0)"
        ],
        "affect_versions": "None",
        "status": "Closed",
        "resolution": "Fixed",
        "priority": "Major"
    },
    "description": "This issue is to track the contribution of the Semantic Knowledge Graph Solr Plugin (request handler), which exposes a graph-like interface for discovering and traversing significant relationships between entities within an inverted index.\n\nThis data model has been described in the following research paper: The Semantic Knowledge Graph: A compact, auto-generated model for real-time traversal and ranking of any relationship within a domain, as well as in presentations I gave in October 2015 at Lucene/Solr Revolution and November 2015 at the Bay Area Search Meetup.\n\nThe source code for this project is currently available at https://github.com/careerbuilder/semantic-knowledge-graph, and the folks at CareerBuilder (where this was built) have given me the go-ahead to now contribute this back to the Apache Solr Project, as well.\n\nCheck out the Github repository, research paper, or presentations for a more detailed description of this contribution. Initial patch coming soon.",
    "attachments": {
        "SOLR-9480.patch": "https://issues.apache.org/jira/secure/attachment/12829084/SOLR-9480.patch"
    },
    "issue_links": {},
    "comments": [
        {
            "date": "2016-09-18T03:23:01+0000",
            "author": "Trey Grainger",
            "content": "Initial patch to get the ball rolling here. Feature should now work as described in reference links in the description. Only real changes are an update from Solr 5.1.0 to master, and cleanup of most of the precommit issues.\n\nStill plenty of work to do, particularly in reworking some of the multi-threading code to follow Solr conventions, reducing the number of files for helper classes, and eventually getting this working correctly in distributed mode (was originally built for use cases involving a single Solr core as a \"representative model\"). Would also be good to make a getting started tutorial with example data so its easier get started with the feature and do something interesting out of the box.\n\nWill continue working on those items as I'm able. Feedback welcome. ",
            "id": "comment-15500148"
        },
        {
            "date": "2018-05-08T00:22:20+0000",
            "author": "Hoss Man",
            "content": "I've been playing with this \"SKG\" code off an on for a bit, and talking with trey about it offline, and I think I've come up with a nice strategy for integrating it directly into JSON Faceting as a handfull small improvements, to be able to leverage most of the existing JSON Facet code (including distributed refinement) w/o needing to be \"tacked on\" to the outside as much as the code in the older patch/github-repo does.\n\nThe attached patch includes the 3 most \"important\" of these improvements in order for this to work, along with lots of new tests...\n\n\tRefactoring the SlotAcc so that everytime it's asked to collect(...) a slot, it has the ability to ask for a Query that identifies this slot independent of the current context\n\t\n\t\tThis allows the new SKG code (described below) to have enough information about the current bucket that it can compute the full \"foreground\" that it wants, regardless of the bucket type or how the current bucket may be nested under other facets ... so SKG graphs can be built by nesting any types of facets (including range & query facets) regardless of how the top level q + fq params realted to the foreground query.\n\t\tthis happens via a IntFunction<Query> callback function \u2013 so there shouldn't be any overhead to existing FacetProcessor/SlotAcc usages that don't care about this extra info about the bucket \u2013 there's no extra TermQuery (or RangeQuery etc...) overhead when the accumulators only care about the final filtered set of documents for the current bucket/slot.\n\t\n\t\n\n\n\n\n\tAdd an skg(...) AggValueSource function that can be nested under any facet\n\t\n\t\tthis function takes in the \"foreground\" and \"background\" queries to use, which just like any existing (aggregate) function can be $variables pointing to existing request params\n\t\tthis means that, unlike the original SKG code linked from this issue, you could compute the SKG relatedness info only at certain points in the facet herirachy, or use different foreground/background queries in different places\n\t\tthis function actually produces JSON \"objects\" as the function result, containing the foreground/background popularities as well as the \"relatedness\" score \u2013 which is what's used if you sort on this function\n\t\tI originally experimented with implementing \"SKG\" as a new type of facet that could be nested under any (othe) facet, but implementing as a function means that we can leverage the existing code for sorting (parent) facet buckets by the (child) function's results \u2013 which is very powerful for SKG results (and it's not currently possible to \"sort\" on the results of a sub-facet, and doing so would be a lot of work given how sub-facet refinement is currently handled ... i looked into it briefly)\n\t\tbut sorting on the skg() function is optional, and not strictly neccessary when the clients care more about performance then accuracy \u2013 as with the existing SKG code trey contributed, the (default) sort on facet count could still be used, which means the existing JSON faceting code would only compute the (semi-expensive) skg() function on the final buckets to be returned, and the client could then post-process to re-sort them by the skg() values.\n\t\n\t\n\n\n\n\n\tAdd support for a \"explicit query domain\" via syntax like domain : {query:'foo:bar'}  (or any other JSON query syntax supported by the filters option) that let's you arbitrarily pick any set of queries you want to use as a \"domain\" for a facet, regardless of it's parent facets/bucket.\n\t\n\t\tthis provides an optional way to improve the \"top n\" accuracy of sub-facets in a deep SKG request, by letting you ignore the \"ancestor facet bucket filtering\" typically done in faceting, and instead request that all buckets under some arbitrarr query \u2013 like the original background query \u2013 be considered.\n\t\tSKG users that care more about speed & aproximations can ignore this feature, and just sort the regular facet terms by the skg() function to get a good aproximation of the top terms ... or as I mentioned before: trust the (default) sort on facet counts (w/or w/o using the $background_q as an explicit domain) to approximate the top N terms)\n\t\n\t\n\n\n\nAn example of what all these features together can look like right now...\n\nrows=0&\nq=type:QUESTION&\nfore=body:%22harry+potter%22&\nback=*:*&\njson.facet='{\n  tags : {\n    type : terms,\n    field : tags,\n    limit : 5,\n    sort : { skg: desc },\n    facet : {\n      skg : \"skg($fore,$back)\",\n      body : {\n        type : terms,\n  \tfield : body,\n        limit : 5,\n        domain : { query:{param:back} },\n        sort : { skg: desc },\n  \tfacet : {\n  \t  skg : \"skg($fore,$back)\"\n  \t}\n      }\n    }\n  }\n}'\n\n\nThere are still lots of things not included in the patch that could be added later to make all of this better and/or easier to use \u2013 and in most cases would be general improvements to JSON Faceting...\n\n\tAs noted in some TODO comments, I would love to enhance the syntax of the skg() function in a couple of ways...\n\t\n\t\tmaking the queries optional, and inheriting them from \"ancestor\" function instances higher up the tree...\n\n{\n  tags : {\n    type : terms,\n    field : tags,\n    facet : {\n      skg : \"skg($fore,$back)\",\n      body : {\n        type : terms,\n  \tfield : body,\n  \tfacet : {\n  \t  skg : \"skg()\" // inherits the $fore/$back queries from the 'skg' function of the parent facet\n  \t}\n      }\n    }\n  }\n}\n\n\n\t\n\t\n\n\n\n\n\t\n\t\n\t\tI'd also like to improve the way JSON Facet functions are parsed \u2013 along the lines of what's described in SOLR-11709 \u2013 in order to support more \"optional\" args that could be used by skg() to override some of it's default behavior...\n\t\t\n\t\t\tthis would be implemented under the covers by passing the extra map keys as the \"localParams\" for the ValueSourceParser\n\t\t\tExample: telling skg() that it's effective \"sort\" value should be based on the \"foreground_pop\" instead of the (default) \"relatedness\"...\n\ntags : {\n  type : terms,\n  field : tags,\n  sort : \"skg desc\",\n  facet : {\n    skg : { type : func,\n            func : \"skg($fore,$back)\",\n            sort_value : foreground_pop }\n  }\n}\n\n\n\t\t\n\t\t\n\t\n\t\n\n\n\n\n\t\n\t\n\t\t\n\t\t\n\t\t\tthis could also be used to implement a min_pop type value, that could be used to configure the skg() function to return a relatedness of -Infinity for any bucket that didn't have foreground/background popularity ratios at least as high as some user specified value.\n\t\t\n\t\t\n\t\n\t\n\tSimilar to how the rerank request param allows people to collect & score documents using a \"cheap\" query, and then re-score the top N using a ore expensive query, I think it would be handy if JSON Facets supported a resort option that could be used on any FacetRequestSorted instance right along side the sort param, using the same JSON syntax, so that clients could have Solr internaly sort all the facet buckets by something simple (like count) and then \"Re-Sort\" the top N=limit (or maybe ( N=limit+overrequest ?) using a more expensive function like skg()\n\n\n\n...however, I think most of this would be best left to other (future) Jiras, and they are only marked TODO in the current patch (if mentioned at all)\n\nMy current focus is on resolving the outstanding nocommits which tend to fall into these main categories (in order of importance) ...\n\n\tresolving randomized test failures\n\t\n\t\tI used TestCloudJSONFacetJoinDomain a imspiration for a new TestCloudJSONFacetSKG that similarly tries to generate random indexes & requests and then \"prove\" that the results of those requests are accurate via verification queries\n\t\ti initially thought using refine:true + mincount:0 + processEmpty:true would allow me to \"prove\" that the SKG results were accurate by executing the equivilent foreground/background queries for each bucket \u2013 but even with those options, i'm seeing some popularity ratios that are missing the denominator (size) from some shards when the numerator (count) is 0 ... making me think there is either some flaw in my reasoning about the provability, or some bug where the existing refinement logic isn't picking up the function contributions of some shards when the doc count is 0\n\t\teven if this test approach proves flawed, the functionality itself can still be useful since it's largely about computing statistical aproximations \u2013 but i want to be 100% sure i understand why the test is failing before writting it off\n\t\n\t\n\trefactoring some similar code\n\t\n\t\tthe SKG distributed merging data structure is currently completely independent from the single-shard \"SlotVal\" objects ... this hsould be refactored to share code\n\t\n\t\n\tcan the distributed results be more efficient?\n\t\n\t\tright now the redundent fore & back \"size\" values (which are the same for every slot/bucket) are returned for every bucket ... i'd like to try and figure out if i can put that data in the facet \"context\" to reduce the shard response size.\n\t\n\t\n\tfiguring out what/how/where to put info in the facetDebug output\n\t\n\t\tit seems like it could be handy for people to be able to access the raw fore & back / count & size values for each bucket when debugging facets \u2013 i just have to figure out how to do that\n\t\n\t\n\tjavadocs\n\tnaming\n\t\n\t\t\"Semantic Knowledge Graph\" seems like a good name for the concept of how these features can be used/combined, but the current function skg(...) seems like it should probably have name more specific to the underlying relatedness forumla ... but i still don't really understand where exactly that formula comes from, so i'm not really clear yet on what a better name might be.\n\t\n\t\n\n\n\n\n\nAny feedback/comments/concerns about this approachwould be appreciated  ",
            "id": "comment-16466664"
        },
        {
            "date": "2018-05-14T16:22:33+0000",
            "author": "Hoss Man",
            "content": "Updated patch...\n\n... some bug where the existing refinement logic isn't picking up the function contributions of some shards when the doc count is 0 ...\n\nI tracked down the problems I was seeing to SOLR-12343 \u2013 knowning that bug exists, I've made the test \"self regulate\" itself to avoid it: first it picks a random sort option, and then if the sort is one that might result in that bug causing incorect stat values, i force the limit option to be big enough that all posible field values will be refined & returned to the client.  This let me relax a lot of the other constraints I had put on the test based on earlier misdiagnoses of what was causing these types of problems.\n\n\n\n\tright now the redundent fore & back \"size\" values (which are the same for every slot/bucket) are returned for every bucket ... i'd like to try and figure out if i can put that data in the facet \"context\" to reduce the shard response size.\n...\n\tfiguring out what/how/where to put info in the facetDebug output\n\n\n\n...neither of these really seem possible at the moment for similar/overlapping reasons...\n\n\n\tThere are currently no \"per bucket\" facet debug information, everything is reported at the \"Per-Facet\" level\n\tAggValueSources/SlotAccs currently don't know what their \"key\" is in the parent facet/context ...\n\t\n\t\twhich means there is no \"safe\" key for the accumulator to use if it tried to put data directly into the (parent) facet response, or if it tried to put any stat specific debug info in the FacetDebugInfo Map\n\t\n\t\n\n\n\n(This situation of \"what is my instances key/name?\" is something we probably want to solve eventually, if not for optimizing the response size and/or adding debuging info then for the \"making the queries optional, and inheriting them from \"ancestor\" function instances higher up the tree\" type functionality i mentioned in my previous comment)\n\n...so i went ahead and removed those nocommits from the patch.\n ",
            "id": "comment-16474425"
        },
        {
            "date": "2018-05-14T23:14:18+0000",
            "author": "Hoss Man",
            "content": "Updated patch...\n\nThis includes cleanup of some test & javadoc nocommits, but the biggest change is renaming skg(...) to relatedness(...) \u2013 that's the best name I could come up with.\n\nIt occured to me I never really posted a full example of what generating an SKG looks like with this approach of implementing relatedness as an Aggregate function, so here's a complete request/response example using stackexchange \"scifi\" data...\n\n\ncurl -sS -X POST http://localhost:8983/solr/scifi/query -d 'rows=0&q=type:QUESTION&fore=body:%22harry+potter%22&back=*:*&json.facet={\n  tags : {\n    type : terms,\n    field : tags,\n    limit : 5,\n    sort : { skg: desc },\n    facet : {\n      skg : \"relatedness($fore,$back)\",\n      body : {\n        type : terms,\n  \tfield : body,\n        limit : 5,\n  \t  sort : { skg: desc },\n  \t  facet : {\n  \t    skg : \"relatedness($fore,$back)\"\n  \t  }\n      }\n    }\n  }\n}'\n\n\n\n\n\n{\n  \"responseHeader\":{\n    \"status\":0,\n    \"QTime\":4402,\n    \"params\":{\n      \"q\":\"type:QUESTION\",\n      \"json.facet\":\"{\\n  tags : {\\n    type : terms,\\n    field : tags,\\n    limit : 5,\\n    sort : { skg: desc },\\n    facet : {\\n      skg : \\\"relatedness($fore,$back)\\\",\\n      body : {\\n        type : terms,\\n  field : body,\\n        limit : 5,\\n    sort : { skg: desc },\\n    facet : {\\n      skg : \\\"relatedness($fore,$back)\\\"\\n    }\\n      }\\n    }\\n  }\\n}\",\n      \"back\":\"*:*\",\n      \"rows\":\"0\",\n      \"fore\":\"body:\\\"harry potter\\\"\"}},\n  \"response\":{\"numFound\":46598,\"start\":0,\"docs\":[]\n  },\n  \"facets\":{\n    \"count\":46598,\n    \"tags\":{\n      \"buckets\":[{\n          \"val\":\"harry-potter\",\n          \"count\":5141,\n          \"skg\":{\n            \"relatedness\":0.70795,\n            \"foreground_popularity\":0.01113,\n            \"background_popularity\":0.03627},\n          \"body\":{\n            \"buckets\":[{\n                \"val\":\"potter\",\n                \"count\":1715,\n                \"skg\":{\n                  \"relatedness\":0.83699,\n                  \"foreground_popularity\":0.01113,\n                  \"background_popularity\":0.03555}},\n              {\n                \"val\":\"harry\",\n                \"count\":2944,\n                \"skg\":{\n                  \"relatedness\":0.76488,\n                  \"foreground_popularity\":0.01113,\n                  \"background_popularity\":0.07392}},\n              {\n                \"val\":\"deathly\",\n                \"count\":516,\n                \"skg\":{\n                  \"relatedness\":0.41314,\n                  \"foreground_popularity\":0.0017,\n                  \"background_popularity\":0.01308}},\n              {\n                \"val\":\"hallows\",\n                \"count\":525,\n                \"skg\":{\n                  \"relatedness\":0.4125,\n                  \"foreground_popularity\":0.00171,\n                  \"background_popularity\":0.01333}},\n              {\n                \"val\":\"hogwarts\",\n                \"count\":1061,\n                \"skg\":{\n                  \"relatedness\":0.39054,\n                  \"foreground_popularity\":0.00229,\n                  \"background_popularity\":0.02585}}]}},\n        {\n          \"val\":\"jk-rowling\",\n          \"count\":107,\n          \"skg\":{\n            \"relatedness\":0.23501,\n            \"foreground_popularity\":3.7E-4,\n            \"background_popularity\":7.5E-4},\n          \"body\":{\n            \"buckets\":[{\n                \"val\":\"attender\",\n                \"count\":1,\n                \"skg\":{\n                  \"relatedness\":0.4322,\n                  \"foreground_popularity\":1.0E-5,\n                  \"background_popularity\":1.0E-5}},\n              {\n                \"val\":\"escapers\",\n                \"count\":1,\n                \"skg\":{\n                  \"relatedness\":0.4322,\n                  \"foreground_popularity\":1.0E-5,\n                  \"background_popularity\":1.0E-5}},\n              {\n                \"val\":\"l'etat\",\n                \"count\":1,\n                \"skg\":{\n                  \"relatedness\":0.4322,\n                  \"foreground_popularity\":1.0E-5,\n                  \"background_popularity\":1.0E-5}},\n              {\n                \"val\":\"mugglenet's\",\n                \"count\":1,\n                \"skg\":{\n                  \"relatedness\":0.4322,\n                  \"foreground_popularity\":1.0E-5,\n                  \"background_popularity\":1.0E-5}},\n              {\n                \"val\":\"pocketeded\",\n                \"count\":1,\n                \"skg\":{\n                  \"relatedness\":0.4322,\n                  \"foreground_popularity\":1.0E-5,\n                  \"background_popularity\":1.0E-5}}]}},\n        {\n          \"val\":\"the-cursed-child\",\n          \"count\":60,\n          \"skg\":{\n            \"relatedness\":0.23294,\n            \"foreground_popularity\":2.7E-4,\n            \"background_popularity\":4.2E-4},\n          \"body\":{\n            \"buckets\":[{\n                \"val\":\"cursed\",\n                \"count\":45,\n                \"skg\":{\n                  \"relatedness\":0.6238,\n                  \"foreground_popularity\":2.6E-4,\n                  \"background_popularity\":0.00459}},\n              {\n                \"val\":\"delphi\",\n                \"count\":10,\n                \"skg\":{\n                  \"relatedness\":0.50766,\n                  \"foreground_popularity\":5.0E-5,\n                  \"background_popularity\":2.9E-4}},\n              {\n                \"val\":\"scorpius\",\n                \"count\":14,\n                \"skg\":{\n                  \"relatedness\":0.48154,\n                  \"foreground_popularity\":7.0E-5,\n                  \"background_popularity\":6.9E-4}},\n              {\n                \"val\":\"neutralising\",\n                \"count\":1,\n                \"skg\":{\n                  \"relatedness\":0.479,\n                  \"foreground_popularity\":1.0E-5,\n                  \"background_popularity\":1.0E-5}},\n              {\n                \"val\":\"noselessness\",\n                \"count\":1,\n                \"skg\":{\n                  \"relatedness\":0.479,\n                  \"foreground_popularity\":1.0E-5,\n                  \"background_popularity\":1.0E-5}}]}},\n        {\n          \"val\":\"voldemort\",\n          \"count\":460,\n          \"skg\":{\n            \"relatedness\":0.21765,\n            \"foreground_popularity\":7.6E-4,\n            \"background_popularity\":0.00324},\n          \"body\":{\n            \"buckets\":[{\n                \"val\":\"potter\",\n                \"count\":118,\n                \"skg\":{\n                  \"relatedness\":0.44277,\n                  \"foreground_popularity\":7.6E-4,\n                  \"background_popularity\":0.03555}},\n              {\n                \"val\":\"voldemort\",\n                \"count\":384,\n                \"skg\":{\n                  \"relatedness\":0.42619,\n                  \"foreground_popularity\":6.7E-4,\n                  \"background_popularity\":0.03074}},\n              {\n                \"val\":\"harry\",\n                \"count\":278,\n                \"skg\":{\n                  \"relatedness\":0.33236,\n                  \"foreground_popularity\":7.6E-4,\n                  \"background_popularity\":0.07392}},\n              {\n                \"val\":\"948\",\n                \"count\":1,\n                \"skg\":{\n                  \"relatedness\":0.32771,\n                  \"foreground_popularity\":1.0E-5,\n                  \"background_popularity\":1.0E-5}},\n              {\n                \"val\":\"chernyshov\",\n                \"count\":1,\n                \"skg\":{\n                  \"relatedness\":0.32771,\n                  \"foreground_popularity\":1.0E-5,\n                  \"background_popularity\":1.0E-5}}]}},\n        {\n          \"val\":\"spells\",\n          \"count\":175,\n          \"skg\":{\n            \"relatedness\":0.19104,\n            \"foreground_popularity\":4.0E-4,\n            \"background_popularity\":0.00123},\n          \"body\":{\n            \"buckets\":[{\n                \"val\":\"bitingly\",\n                \"count\":1,\n                \"skg\":{\n                  \"relatedness\":0.42157,\n                  \"foreground_popularity\":1.0E-5,\n                  \"background_popularity\":1.0E-5}},\n              {\n                \"val\":\"centrari\",\n                \"count\":1,\n                \"skg\":{\n                  \"relatedness\":0.42157,\n                  \"foreground_popularity\":1.0E-5,\n                  \"background_popularity\":1.0E-5}},\n              {\n                \"val\":\"counterspelling\",\n                \"count\":1,\n                \"skg\":{\n                  \"relatedness\":0.42157,\n                  \"foreground_popularity\":1.0E-5,\n                  \"background_popularity\":1.0E-5}},\n              {\n                \"val\":\"effectivly\",\n                \"count\":1,\n                \"skg\":{\n                  \"relatedness\":0.42157,\n                  \"foreground_popularity\":1.0E-5,\n                  \"background_popularity\":1.0E-5}},\n              {\n                \"val\":\"expelliarus\",\n                \"count\":1,\n                \"skg\":{\n                  \"relatedness\":0.42157,\n                  \"foreground_popularity\":1.0E-5,\n                  \"background_popularity\":1.0E-5}}]}}]}}}\n\n\n\n\n\nNow that the randomized tests seem really reliable, I'll work on refactoring the Slot collection vs distributed Merging to reduce code duplication ... but in general I think this is getting really close to being committable. ",
            "id": "comment-16475025"
        },
        {
            "date": "2018-05-16T16:46:41+0000",
            "author": "Hoss Man",
            "content": "Now that the randomized tests seem really reliable, I'll work on refactoring the Slot collection vs distributed Merging to reduce code duplication...\n\nThis is done, along with a lot of other misc nocommit sanity checking & cleanup.\n\nI also went back and cleaned up the SlotAcc changes I made, so that slotQFunc isn't such a special case \u2013 now instead of an IntegerFunc<Query> there is an IntegerFunc<SlotContext> where the (new) SlotContext class encapsulates the Query, and could potentially encapsulate other info we might wnat to make available to Slot Accumulators down the road (but it's still optional, and by passing as an IntFunction callback shouldn't add any overhead for existing collectors that don't care)\n\nI think the only work outstanding is ref-guide updates & a few remaining nocommits for a few remaining things I want to go back and sanity check about existing JSON Facet internals. ",
            "id": "comment-16477713"
        },
        {
            "date": "2018-05-16T17:52:10+0000",
            "author": "Mikhail Khludnev",
            "content": "TLDR;\n\ncan you give a clue what are $fore,$back ?\u00a0 ",
            "id": "comment-16477805"
        },
        {
            "date": "2018-05-16T17:52:16+0000",
            "author": "Mikhail Khludnev",
            "content": "TLDR;\n\ncan you give a clue what are $fore,$back ?\u00a0 ",
            "id": "comment-16477806"
        },
        {
            "date": "2018-05-18T00:42:20+0000",
            "author": "Hoss Man",
            "content": "Updated patch with all nocommits resolved and new ref-guide content on the relatedness() aggregate function and using them to build SKGs.\n\nI think this is pretty much good to go.\n\ncan you give a clue what are $fore,$back ?\nI'm not sure if i understand your question... are you asking about the syntax, or about the general concepts of foreground/background query as used in the relatedness function scores?\n\nSyntactically they are regular query param $variable references passed as function arguments ... the sample request in the comment you replied to defined them as fore=body:%22harry+potter%22&back=*:* ...but they can also just be passed in as string literals.\n\nIn general, the relatedness() function takes 2 parameters that define a \"foreground query\" and a \"background query\" which are then used to compute the hueristic score indicating what sort of statistical corrolation there is between the query for each facet bucket and the foreground set, relative to the background set.\n\nThere's a more self contained example in the ref-guide edits included in the latest patch...\n\n.Sample Documents\n[source,bash,subs=\"verbatim,callouts\"]\n----\ncurl -sS -X POST 'http://localhost:8983/solr/gettingstarted/update?commit=true' -d '[\n{\"id\":\"01\",age:15,\"state\":\"AZ\",\"hobbies\":[\"soccer\",\"painting\",\"cycling\"]},\n{\"id\":\"02\",age:22,\"state\":\"AZ\",\"hobbies\":[\"swimming\",\"darts\",\"cycling\"]},\n{\"id\":\"03\",age:27,\"state\":\"AZ\",\"hobbies\":[\"swimming\",\"frisbee\",\"painting\"]},\n{\"id\":\"04\",age:33,\"state\":\"AZ\",\"hobbies\":[\"darts\"]},\n{\"id\":\"05\",age:42,\"state\":\"AZ\",\"hobbies\":[\"swimming\",\"golf\",\"painting\"]},\n{\"id\":\"06\",age:54,\"state\":\"AZ\",\"hobbies\":[\"swimming\",\"golf\"]},\n{\"id\":\"07\",age:67,\"state\":\"AZ\",\"hobbies\":[\"golf\",\"painting\"]},\n{\"id\":\"08\",age:71,\"state\":\"AZ\",\"hobbies\":[\"painting\"]},\n{\"id\":\"09\",age:14,\"state\":\"CO\",\"hobbies\":[\"soccer\",\"frisbee\",\"skiing\",\"swimming\",\"skating\"]},\n{\"id\":\"10\",age:23,\"state\":\"CO\",\"hobbies\":[\"skiing\",\"darts\",\"cycling\",\"swimming\"]},\n{\"id\":\"11\",age:26,\"state\":\"CO\",\"hobbies\":[\"skiing\",\"golf\"]},\n{\"id\":\"12\",age:35,\"state\":\"CO\",\"hobbies\":[\"golf\",\"frisbee\",\"painting\",\"skiing\"]},\n{\"id\":\"13\",age:47,\"state\":\"CO\",\"hobbies\":[\"skiing\",\"darts\",\"painting\",\"skating\"]},\n{\"id\":\"14\",age:51,\"state\":\"CO\",\"hobbies\":[\"skiing\",\"golf\"]},\n{\"id\":\"15\",age:64,\"state\":\"CO\",\"hobbies\":[\"skating\",\"cycling\"]},\n{\"id\":\"16\",age:73,\"state\":\"CO\",\"hobbies\":[\"painting\"]},\n]'\n----\n\n.Example Query\n[source,bash,subs=\"verbatim,callouts\"]\n----\ncurl -sS -X POST http://localhost:8983/solr/gettingstarted/query -d 'rows=0&q=*:*\n&back=*:*                                  # <1>\n&fore=age:[35 TO *]                        # <2>\n&json.facet={\n  hobby : {\n    type : terms,\n    field : hobbies,\n    limit : 5,\n    sort : { r1: desc },                   # <3>\n    facet : {\n      r1 : \"relatedness($fore,$back)\",     # <4>\n      location : {\n        type : terms,\n        field : state,\n        limit : 2,\n        sort : { r2: desc },               # <3>\n        facet : {\n          r2 : \"relatedness($fore,$back)\"  # <4>\n        }\n      }\n    }\n  }\n}'\n----\n<1> Use the entire collection as our \"Background Set\"\n<2> Use a query for \"age >= 35\" to define our (initial) \"Foreground Set\"\n<3> For both the top level `hobbies` facet & the sub-facet on `state` we will be sorting on the `relatedness(...)` values\n<4> In both calls to the `relatedness(...)` function, we use <<local-parameters-in-queries.adoc#parameter-dereferencing,Parameter Variables>> to refer to the previously defined `fore` and `back` queries. \n\n.The Facet Response\n[source,javascript,subs=\"verbatim,callouts\"]\n----\n\"facets\":{\n  \"count\":16,\n  \"hobby\":{\n    \"buckets\":[{\n        \"val\":\"golf\",\n        \"count\":6,                                // <1>\n        \"r1\":{\n          \"relatedness\":0.01225,\n          \"foreground_popularity\":0.3125,         // <2>\n          \"background_popularity\":0.375},         // <3>\n        \"location\":{\n          \"buckets\":[{\n              \"val\":\"az\",\n              \"count\":3,\n              \"r2\":{\n                \"relatedness\":0.00496,            // <4>\n                \"foreground_popularity\":0.1875,   // <6>\n                \"background_popularity\":0.5}},    // <7>\n            {\n              \"val\":\"co\",\n              \"count\":3,\n              \"r2\":{\n                \"relatedness\":-0.00496,           // <5>\n                \"foreground_popularity\":0.125,\n                \"background_popularity\":0.5}}]}},\n      {\n        \"val\":\"painting\",\n        \"count\":8,                                // <1>\n        \"r1\":{\n          \"relatedness\":0.01097,\n          \"foreground_popularity\":0.375,\n          \"background_popularity\":0.5},\n        \"location\":{\n          \"buckets\":[{\n            ...\n----\n<1> Even though `hobbies:golf` has a lower total facet `count` then `hobbies:painting`, it has a higher `relatedness` score, indicating that relative to the Background Set (the entire collection) Golf has a stronger correlation to our Foreground Set (people age 35+) then Painting. \n<2> The number of documents matching `age:[35 TO *]` _and_ `hobbies:golf` is 31.25% of the total number of documents in the Background Set\n<3> 37.5% of the documents in the Background Set match `hobbies:golf`\n<4> The state of Arizona (AZ) has a _positive_ relatedness correlation with the _nested_ Foreground Set (people ages 35+ who play Golf) compared to the Background Set -- ie: \"People in Arizona are statistically more likely to be '35+ year old Golfers' then the country as a whole.\"\n<5> The state of Colorado (CO) has a _negative_ correlation with the nested Foreground Set -- ie: \"People in Colorado are statistically less likely to be '35+ year old Golfers' then the country as a whole.\"\n<6> The number documents matching `age:[35 TO *]` _and_ `hobbies:golf` _and_ `state:AZ` is 18.75% of the total number of documents in the Background Set\n<7> 50% of the documents in the Background Set match `state:AZ`\n\nNOTE: While it's very common to define the Background Set as `\\*:*`, or some other super-set of the Foreground Query, it is not strictly required.  The `relatedness(...)` function can be used to compare the statistical relatedness of sets of documents to orthogonal foreground/background queries.\n\n\n ",
            "id": "comment-16479952"
        },
        {
            "date": "2018-05-18T05:16:57+0000",
            "author": "Mikhail Khludnev",
            "content": "Great answer. Thanks, Hoss Man! ",
            "id": "comment-16480172"
        },
        {
            "date": "2018-05-21T15:23:12+0000",
            "author": "ASF subversion and git services",
            "content": "Commit 669b9e7a5343c625e265a075c9dbf24fcbff7363 in lucene-solr's branch refs/heads/master from Chris Hostetter\n[ https://git-wip-us.apache.org/repos/asf?p=lucene-solr.git;h=669b9e7 ]\n\nSOLR-9480: A new 'relatedness()' aggregate function for JSON Faceting to enable building Semantic Knowledge Graphs ",
            "id": "comment-16482620"
        },
        {
            "date": "2018-05-21T16:35:44+0000",
            "author": "ASF subversion and git services",
            "content": "Commit f0d6a0e638b13ddf4f5acfffdcd390e977572b67 in lucene-solr's branch refs/heads/branch_7x from Chris Hostetter\n[ https://git-wip-us.apache.org/repos/asf?p=lucene-solr.git;h=f0d6a0e ]\n\nSOLR-9480: A new 'relatedness()' aggregate function for JSON Faceting to enable building Semantic Knowledge Graphs\n\n(cherry picked from commit 669b9e7a5343c625e265a075c9dbf24fcbff7363) ",
            "id": "comment-16482696"
        },
        {
            "date": "2018-05-21T23:18:34+0000",
            "author": "ASF subversion and git services",
            "content": "Commit 0bf1eae92c4117659e2608111a8d64294009cc98 in lucene-solr's branch refs/heads/master from Chris Hostetter\n[ https://git-wip-us.apache.org/repos/asf?p=lucene-solr.git;h=0bf1eae ]\n\nSOLR-9480 followup: remove/abstract deprecated implementations on master ",
            "id": "comment-16483191"
        },
        {
            "date": "2018-05-22T17:08:33+0000",
            "author": "Steve Rowe",
            "content": "+1, I found a couple nits\u00a0in a quick review:\n\n\tIn RelatednessAgg.SKGSlotAcc, fgFilters and bgSet are assigned but never used (never referenced outside\u00a0the ctor)\n\tIn RelatednessAgg.SKGSlotAcc.processSlot(), a code comment includes a reference to a function named skg(), which has since been renamed to relatedness().\u00a0\n\n ",
            "id": "comment-16484301"
        },
        {
            "date": "2018-05-22T17:21:15+0000",
            "author": "Alessandro Benedetti",
            "content": "+1 very interesting !\n I opened a Jira issue long time ago ( and nver worked on it, which seems quite related [1] )\n I remember at the time I investigate some different relatedness metrics ( some of them are available in Elasticsearch [2])\u00a0\n\nGreat work, I am curious to take a look to the implementation!\n\n[1] \u00a0https://issues.apache.org/jira/browse/SOLR-9851\n [2] \u00a0https://www.elastic.co/blog/significant-terms-aggregation ",
            "id": "comment-16484313"
        },
        {
            "date": "2018-05-22T17:42:06+0000",
            "author": "ASF subversion and git services",
            "content": "Commit f9091473e0587a3470751f705e143e5b5796714c in lucene-solr's branch refs/heads/master from Chris Hostetter\n[ https://git-wip-us.apache.org/repos/asf?p=lucene-solr.git;h=f909147 ]\n\nSOLR-9480: minor cleanup of nits found by sarowe ",
            "id": "comment-16484342"
        },
        {
            "date": "2018-05-22T18:00:25+0000",
            "author": "ASF subversion and git services",
            "content": "Commit 4ea26fbca2f14cb45aa38f00d821c99079939120 in lucene-solr's branch refs/heads/branch_7x from Chris Hostetter\n[ https://git-wip-us.apache.org/repos/asf?p=lucene-solr.git;h=4ea26fb ]\n\nSOLR-9480: minor cleanup of nits found by sarowe\n\n(cherry picked from commit f9091473e0587a3470751f705e143e5b5796714c) ",
            "id": "comment-16484367"
        },
        {
            "date": "2018-05-22T18:01:07+0000",
            "author": "Hoss Man",
            "content": "+1, I found a couple nits in a quick review:\n\nthanks steve, those were left over from a partial refactoring... should be all good now. ",
            "id": "comment-16484369"
        },
        {
            "date": "2018-06-11T17:02:31+0000",
            "author": "ASF subversion and git services",
            "content": "Commit 74576b008311a0d2f84a8ad196957cbad1b3fc05 in lucene-solr's branch refs/heads/master from Cassandra Targett\n[ https://git-wip-us.apache.org/repos/asf?p=lucene-solr.git;h=74576b0 ]\n\nSOLR-9480: Ref Guide minor typo cleanup; remove outdated/unnecessary anchors ",
            "id": "comment-16508378"
        },
        {
            "date": "2018-06-11T17:02:56+0000",
            "author": "ASF subversion and git services",
            "content": "Commit eb9493552ac2709b7e656c685967a14ec66ddb8b in lucene-solr's branch refs/heads/branch_7x from Cassandra Targett\n[ https://git-wip-us.apache.org/repos/asf?p=lucene-solr.git;h=eb94935 ]\n\nSOLR-9480: Ref Guide minor typo cleanup; remove outdated/unnecessary anchors ",
            "id": "comment-16508380"
        },
        {
            "date": "2018-06-11T17:03:15+0000",
            "author": "ASF subversion and git services",
            "content": "Commit 5ad72490a0d0bfca045549f11fff3deb655fec3c in lucene-solr's branch refs/heads/branch_7_4 from Cassandra Targett\n[ https://git-wip-us.apache.org/repos/asf?p=lucene-solr.git;h=5ad7249 ]\n\nSOLR-9480: Ref Guide minor typo cleanup; remove outdated/unnecessary anchors ",
            "id": "comment-16508381"
        }
    ]
}