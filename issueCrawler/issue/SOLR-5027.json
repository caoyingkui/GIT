{
    "id": "SOLR-5027",
    "title": "Field Collapsing PostFilter",
    "details": {
        "affect_versions": "6.0",
        "status": "Resolved",
        "fix_versions": [
            "4.6",
            "6.0"
        ],
        "components": [
            "search"
        ],
        "type": "New Feature",
        "priority": "Minor",
        "labels": "",
        "resolution": "Fixed"
    },
    "description": "This ticket introduces the CollapsingQParserPlugin \n\nThe CollapsingQParserPlugin is a PostFilter that performs field collapsing. This is a high performance alternative to standard Solr field collapsing (with ngroups) when the number of distinct groups in the result set is high.\n\nFor example in one performance test, a search with 10 million full results and 1 million collapsed groups:\nStandard grouping with ngroups : 17 seconds.\nCollapsingQParserPlugin: 300 milli-seconds.\n\nSample syntax:\n\nCollapse based on the highest scoring document:\n\n\nfq=(!collapse field=<field_name>}\n\n\n\nCollapse based on the min value of a numeric field:\n\nfq={!collapse field=<field_name> min=<field_name>}\n\n\n\nCollapse based on the max value of a numeric field:\n\nfq={!collapse field=<field_name> max=<field_name>}\n\n\n\nCollapse with a null policy:\n\nfq={!collapse field=<field_name> nullPolicy=<null_policy>}\n\n\nThere are three null policies:\nignore : removes docs with a null value in the collapse field (default).\nexpand : treats each doc with a null value in the collapse field as a separate group.\ncollapse : collapses all docs with a null value into a single group using either highest score, or min/max.\n\nThe CollapsingQParserPlugin also fully supports the QueryElevationComponent\n\nNote:  The July 16 patch also includes and ExpandComponent that expands the collapsed groups for the current search result page. This functionality will be moved to it's own ticket.",
    "attachments": {
        "SOLR-5027.patch": "https://issues.apache.org/jira/secure/attachment/12591677/SOLR-5027.patch"
    },
    "issue_links": {},
    "comments": [
        {
            "author": "Joel Bernstein",
            "id": "comment-13704771",
            "date": "2013-07-10T17:16:49+0000",
            "content": "Initial patch for review. "
        },
        {
            "author": "Otis Gospodnetic",
            "id": "comment-13705427",
            "date": "2013-07-11T03:13:40+0000",
            "content": "Q: when you refer to collapsing and grouping, are you saying this is an alternative implementation to the current impl for field collapsing/grouping?\n\nquery results cache is commented out in the patch, on purpose? "
        },
        {
            "author": "Joel Bernstein",
            "id": "comment-13705779",
            "date": "2013-07-11T13:04:19+0000",
            "content": "This is an alternative for field collapsing. It only collapses the groups. This is the first step of moving grouping into the main search flow. The second step is to create a separate search component that works with the collapsed doclist and expands the groups for a single page. The two combined would be a replacement for the current grouping functionality.\n\nWith this approach to field collapsing the main doclist/docset are collapsed. So there is no concept of ngroups or group facets. The result count and facet counts automatically line up with the collapsed doclist/docset. \n\nThe query result cache was commented out for performance testing only. In later patches I'll leave this out.\n\n "
        },
        {
            "author": "Otis Gospodnetic",
            "id": "comment-13705835",
            "date": "2013-07-11T13:46:30+0000",
            "content": "Thanks for the clarification.  Will this perform better than current grouping? "
        },
        {
            "author": "Joel Bernstein",
            "id": "comment-13705899",
            "date": "2013-07-11T15:05:49+0000",
            "content": "It should perform much better then the combination of ngroups and group facets, which have a pretty steep performance penalty as ngroups rises. More testing is needed though to see how this plays out.\n "
        },
        {
            "author": "Joel Bernstein",
            "id": "comment-13707146",
            "date": "2013-07-12T17:48:19+0000",
            "content": "Added small initial test case. "
        },
        {
            "author": "Simon Endele",
            "id": "comment-13765381",
            "date": "2013-09-12T12:23:04+0000",
            "content": "What do you mean exactly by \"there is no concept of ngroups or group facets\"? Does that include that there will be no possibility to return the number of groups, like the request parameter \"group.ngroups\" currently does?\n\nWill it still be possible to decide if the faceting is done before/after collapsing, similar to \"group.facet\"? "
        },
        {
            "author": "Joel Bernstein",
            "id": "comment-13765389",
            "date": "2013-09-12T12:37:38+0000",
            "content": "When the CollapsingQParserPlugin is used, the number of groups is simply numFound. So you get ngroups automatically.\n\nAs for faceting. The initial release of this will only return post collapse facet counts, which is often what people want.\n\nThis ticket though is part of a larger design that includes SOLR-5045, which is designed to have facets and other aggregate functions calculated as PostFilter \"Aggregators\". This would allow you to use the \"cost\" PostFilter parameter to choose the order the PostFilter is applied. So in the same query you could have some aggregates/facets calculated pre-collapse and some calculated post collapse.\n\nOne of the central ideas of this design is to allow for pluggable collapse and aggregating functions, through the PostFilter mechanism.\n "
        },
        {
            "author": "Simon Endele",
            "id": "comment-13777303",
            "date": "2013-09-25T09:16:21+0000",
            "content": "Sounds good.\n\nI propose to add an additional parameter \"expand.fq\" to restrict the expanded documents to a certain filter query.\nSometimes the complete groups are very large and should only be expanded by one or a few representatives of that group (which can be addressed with a filter query). Other group members that are not hit by the main query are not interesting (at least in the first place).\n\nNote that this is different from adding a basic filter query, since documents that are hit by the main query but not by expand.fq are kept.\nExample: Group consisting of: representative \"A\", more group members \"B\" and \"C\".\nQuery hits \"B\", group is expanded by \"A\" (due to expand.fq), but not \"C\" => Result: \"A\", \"B\"\nA filter query before expanding would filter out \"B\" and thus yield no results for this group.\nA filter query after expanding would filter out \"B\" and \"C\" thus keep only \"A\".\n\nIs that technically possible? Maybe this is worth a separate issue...  "
        },
        {
            "author": "Joel Bernstein",
            "id": "comment-13779278",
            "date": "2013-09-26T21:32:15+0000",
            "content": "Lastest work on the CollapsingQParserPlugin. The ExpandComponent was removed from this patch, in order to first focus on the collapse. "
        },
        {
            "author": "Joel Bernstein",
            "id": "comment-13780136",
            "date": "2013-09-27T17:40:52+0000",
            "content": "Simon,\n\nYour idea sounds good and should be no problem to implement. When I finish up the work on the Expand component I'll work on getting this in.\n "
        },
        {
            "author": "Joel Bernstein",
            "id": "comment-13784530",
            "date": "2013-10-02T22:13:59+0000",
            "content": "Added test cases "
        },
        {
            "author": "Prabha Satya",
            "id": "comment-13787909",
            "date": "2013-10-07T05:21:48+0000",
            "content": "Hi Joel,\nBy the comments above I could make out that collapse plugin would allow us to do aggregations. But I am not sure whether this collapse plugin help me achieve something like this, I would express it in sql language for better understanding.\n\nSchema:\n=======\nStudent id \nsubject\nmarks\n\nQuery:  \n=====\nSelect subject,max(marks) from Student group by subject. "
        },
        {
            "author": "Joel Bernstein",
            "id": "comment-13788112",
            "date": "2013-10-07T12:41:53+0000",
            "content": "fq=\n{!collapse field=student max=marks}\n\nWill be similar to the sql statement that you want. But that is a little deceiving because only max and min are supported, other aggregation functions such as sum() are not. You could pair the CollapsingQParserPlugin with the stats component or in the future SOLR-5045 to do true aggregation. \n\nNote that solr field collasping/grouping can do similar functionality to this ticket and is available now. This ticket is still under development.  "
        },
        {
            "author": "Joel Bernstein",
            "id": "comment-13790699",
            "date": "2013-10-09T18:39:52+0000",
            "content": "Added support for the QueryElevationComponent and test case. "
        },
        {
            "author": "Joel Bernstein",
            "id": "comment-13790963",
            "date": "2013-10-09T22:56:26+0000",
            "content": "Fixed broken test, added javadoc "
        },
        {
            "author": "Joel Bernstein",
            "id": "comment-13792300",
            "date": "2013-10-11T03:27:26+0000",
            "content": "Patch for 4x and trunk. All tests passing. "
        },
        {
            "author": "Joel Bernstein",
            "id": "comment-13793035",
            "date": "2013-10-11T20:49:14+0000",
            "content": "Patch that passes precommit for trunk "
        },
        {
            "author": "shruti suri",
            "id": "comment-13794944",
            "date": "2013-10-15T07:01:06+0000",
            "content": "Hi,\n\nCan I apply this patch on solr-4.2.1 version?\n\nRegards\nShruti "
        },
        {
            "author": "Joel Bernstein",
            "id": "comment-13795167",
            "date": "2013-10-15T13:17:53+0000",
            "content": "Shruti,\n\nI think it should work on 4.2+. Below that it won't. This patch was tested on 4.4+.\n\nJoel "
        },
        {
            "author": "shruti suri",
            "id": "comment-13796404",
            "date": "2013-10-16T04:25:22+0000",
            "content": "Hi,\n\nI am Applying this patch on solr-4.2.1 with below steps\n\n$ cd <your Solr trunk checkout dir>\n$ svn up\n$ wget https://issues.apache.org/jira/secure/attachment/12607941/SOLR-5027.patch -O - | patch -p0 --dry-run\n\nBut i got some error during the operation\n\npatching file SOLR-5027.patch\nHunk #1 FAILED at 39.\n1 out of 1 hunk FAILED \u2013 saving rejects to file SOLR-5027.patch.rej\npatching file core/src/test/org/apache/solr/search/TestCollapseQParserPlugin.java\ncan't find file to patch at input line 150\nPerhaps you used the wrong -p or --strip option?\nThe text leading up to this was:\n--------------------------\n\n\n\nIndex: solr/core/src/test/org/apache/solr/search/QueryEqualityTest.java\n\n\n===================================================================\n\n\n\u2014 solr/core/src/test/org/apache/solr/search/QueryEqualityTest.java    (revision 1531006)\n\n\n+++ solr/core/src/test/org/apache/solr/search/QueryEqualityTest.java    (working copy)\n--------------------------\nFile to patch:\n\n\n\n\n\nCan you please help me solve this problem?\n\nRegards\nShruti "
        },
        {
            "author": "Joel Bernstein",
            "id": "comment-13796750",
            "date": "2013-10-16T12:55:35+0000",
            "content": "I had problems applying this patch to 4.2.1 as well. The patch is applied from the Lucene/Solr root below. You'll see though that my errors are different. There are two files ivy.xml and QParserPlugin.java that are different enough that the patch did not apply. I'm not sure exactly the issue with your error. I'll see if I can create a patch that will work with 4.2.1.\n\n$ patch -p0 < SOLR-5027.patch \npatching file solr/core/ivy.xml\nHunk #1 FAILED at 39.\n1 out of 1 hunk FAILED \u2013 saving rejects to file solr/core/ivy.xml.rej\npatching file solr/core/src/test/org/apache/solr/search/TestCollapseQParserPlugin.java\npatching file solr/core/src/test/org/apache/solr/search/QueryEqualityTest.java\npatching file solr/core/src/test-files/solr/collection1/conf/solrconfig-collapseqparser.xml\npatching file solr/core/src/java/org/apache/solr/search/CollapsingQParserPlugin.java\npatching file solr/core/src/java/org/apache/solr/search/QParserPlugin.java\nHunk #1 FAILED at 51.\n1 out of 1 hunk FAILED \u2013 saving rejects to file solr/core/src/java/org/apache/solr/search/QParserPlugin.java.rej "
        },
        {
            "author": "Joel Bernstein",
            "id": "comment-13798183",
            "date": "2013-10-17T17:56:55+0000",
            "content": "Shruti,\n\nI got the patch applied, but it won't compile on 4.2. You'd also need to apply SOLR-5020 and there is another issue with the TermsEnum interface which I suspect will be harder solve. So I think the best approach would be to upgrade to altleast 4.4. SOLR-5020 is part of 4.5.\n\nJoel "
        },
        {
            "author": "ASF subversion and git services",
            "id": "comment-13803532",
            "date": "2013-10-23T23:19:13+0000",
            "content": "Commit 1535208 from Joel Bernstein in branch 'dev/trunk'\n[ https://svn.apache.org/r1535208 ]\n\nSOLR-5027 CollapsingQParserPlugin "
        },
        {
            "author": "ASF subversion and git services",
            "id": "comment-13803655",
            "date": "2013-10-24T01:45:52+0000",
            "content": "Commit 1535259 from Joel Bernstein in branch 'dev/branches/branch_4x'\n[ https://svn.apache.org/r1535259 ]\n\nSOLR-5027 CollapsingQParserPlugin "
        },
        {
            "author": "ASF subversion and git services",
            "id": "comment-13804955",
            "date": "2013-10-25T02:50:35+0000",
            "content": "Commit 1535614 from Joel Bernstein in branch 'dev/trunk'\n[ https://svn.apache.org/r1535614 ]\n\nSOLR-5027: Added error handling to CollapsingQParserPlugin "
        },
        {
            "author": "ASF subversion and git services",
            "id": "comment-13804958",
            "date": "2013-10-25T02:56:19+0000",
            "content": "Commit 1535615 from Joel Bernstein in branch 'dev/branches/branch_4x'\n[ https://svn.apache.org/r1535615 ]\n\nSOLR-5027: Added error handling to CollapsingQParserPlugin "
        },
        {
            "author": "shruti suri",
            "id": "comment-13806220",
            "date": "2013-10-27T04:31:12+0000",
            "content": "Hi,\n\nI am facing some problems while implementing this patch in Solr-4.5. Please tell if this patch can be applied to solr-4.5.\n\nRegards\nShruti  "
        },
        {
            "author": "Shawn Heisey",
            "id": "comment-13806373",
            "date": "2013-10-27T16:21:40+0000",
            "content": "shruti suri, the following commands will use SVN to check out the 4.5.1 source code and apply the commits for this issue to it.  You must have subversion (1.7 or later preferred) on your computer already:\n\n\nsvn co https://svn.apache.org/repos/asf/lucene/dev/tags/lucene_solr_4_5_1\ncd lucene_solr_4_5_1/\nsvn merge --accept postpone -c 1535208 https://svn.apache.org/repos/asf/lucene/dev/trunk\nsvn merge -c 1535614 https://svn.apache.org/repos/asf/lucene/dev/trunk\n\n\n\nThere is one merge conflict that cannot be automatically resolved, but it is on CHANGES.txt, which is not required for the patch to operate.  The '--accept postpone' argument that I have put on the first merge command will cause this to be skipped.\n\nWe strongly recommend running 4.5.1, not 4.5.0, because there are a number of critical bugs that have been fixed. "
        },
        {
            "author": "shruti suri",
            "id": "comment-13806605",
            "date": "2013-10-28T07:39:57+0000",
            "content": "Hi,\n\nI implemented above solution and run following commands\n\ncd lucene_solr_4_5_1/solr \nant dist\n\nI again got some error.\n\n[ivy:retrieve] \t  http://mirror.netcologne.de/maven2/com/carrotsearch/hppc/${/com.carrotsearch/hppc}/hppc-${/com.carrotsearch/hppc}.jar\n[ivy:retrieve] \t\t::::::::::::::::::::::::::::::::::::::::::::::\n[ivy:retrieve] \t\t::          UNRESOLVED DEPENDENCIES         ::\n[ivy:retrieve] \t\t::::::::::::::::::::::::::::::::::::::::::::::\n[ivy:retrieve] \t\t:: com.carrotsearch#hppc;${/com.carrotsearch/hppc}: not found\n[ivy:retrieve] \t\t::::::::::::::::::::::::::::::::::::::::::::::\n[ivy:retrieve] \n[ivy:retrieve] :: USE VERBOSE OR DEBUG MESSAGE LEVEL FOR MORE DETAILS\n\nBUILD FAILED\n/lucene_solr_4_5_1/solr/common-build.xml:354: The following error occurred while executing this line:\n/lucene_solr_4_5_1/solr/core/build.xml:55: impossible to resolve dependencies:\n\tresolve failed - see output for details\n\nRegards\nshruti "
        },
        {
            "author": "Shawn Heisey",
            "id": "comment-13807110",
            "date": "2013-10-28T18:53:12+0000",
            "content": "shruti suri I see that happening too.  I never had a chance to actually try building it with the commits merged.  I have no idea how to fix problems with ivy.\n\nThe ivy.xml change for hppc that is not working is in branch_4x as well, and that branch compiles.  This problem is beyond my skills. "
        },
        {
            "author": "Steve Rowe",
            "id": "comment-13807125",
            "date": "2013-10-28T19:08:08+0000",
            "content": "shruti suri, the problem is that as of Lucene/Solr 4.6, all ivy.xml versions are pulled from lucene/ivy-versions.properties - see LUCENE-5249 and LUCENE-5257 - but not in the lucene_solr_4_5 branch.\n\nYou can look up the correct ivy.xml version to use in the 4.6 branch, rather than the /com.carrotsearch/hppc thing that's on branch_4x.  "
        },
        {
            "author": "Shawn Heisey",
            "id": "comment-13807136",
            "date": "2013-10-28T19:20:21+0000",
            "content": "Thanks Steve Rowe! shruti suri, if you edit solr/core/ivy.xml after the merge, you can change the /com.carrotsearch/hppc property substitution to 0.5.2 and it should work properly.  That was the version I found in branch_4x for the hppc component.\n\nI was trying to boil it down to a patch, but ran into some problems.  Fixing the one line manually is easier. "
        },
        {
            "author": "shruti suri",
            "id": "comment-13807879",
            "date": "2013-10-29T11:23:23+0000",
            "content": "Thanks a lot my patch worked.. "
        },
        {
            "author": "David Boychuck",
            "id": "comment-13810891",
            "date": "2013-11-01T00:26:39+0000",
            "content": "Getting the following error please advise how to fix:\n\n3095070 [http-bio-8080-exec-8] ERROR org.apache.solr.core.SolrCore  \u2013 java.lang.NullPointerException\n\tat org.apache.solr.search.CollapsingQParserPlugin$CollapsingScoreCollector.collect(CollapsingQParserPlugin.java:409)\n\tat org.apache.solr.search.SolrIndexSearcher.getDocSet(SolrIndexSearcher.java:910)\n\tat org.apache.solr.request.SimpleFacets.parseParams(SimpleFacets.java:219)\n\tat org.apache.solr.request.SimpleFacets.getFacetFieldCounts(SimpleFacets.java:549)\n\tat org.apache.solr.request.SimpleFacets.getFacetCounts(SimpleFacets.java:265)\n\tat org.apache.solr.handler.component.FacetComponent.process(FacetComponent.java:78)\n\tat org.apache.solr.handler.component.SearchHandler.handleRequestBody(SearchHandler.java:208)\n\tat org.apache.solr.handler.RequestHandlerBase.handleRequest(RequestHandlerBase.java:135)\n\tat org.apache.solr.core.SolrCore.execute(SolrCore.java:1859)\n\tat org.apache.solr.servlet.SolrDispatchFilter.execute(SolrDispatchFilter.java:703)\n\tat org.apache.solr.servlet.SolrDispatchFilter.doFilter(SolrDispatchFilter.java:406)\n\tat org.apache.solr.servlet.SolrDispatchFilter.doFilter(SolrDispatchFilter.java:195)\n\tat org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:243)\n\tat org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:210)\n\tat org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:222)\n\tat org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:123)\n\tat org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:171)\n\tat org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:99)\n\tat org.apache.catalina.valves.AccessLogValve.invoke(AccessLogValve.java:953)\n\tat org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:118)\n\tat org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:408)\n\tat org.apache.coyote.http11.AbstractHttp11Processor.process(AbstractHttp11Processor.java:1008)\n\tat org.apache.coyote.AbstractProtocol$AbstractConnectionHandler.process(AbstractProtocol.java:589)\n\tat org.apache.tomcat.util.net.JIoEndpoint$SocketProcessor.run(JIoEndpoint.java:310)\n\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1110)\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:603)\n\tat java.lang.Thread.run(Thread.java:722)\n\n13095072 [http-bio-8080-exec-8] ERROR org.apache.solr.servlet.SolrDispatchFilter  \u2013 null:java.lang.NullPointerException\n\tat org.apache.solr.search.CollapsingQParserPlugin$CollapsingScoreCollector.collect(CollapsingQParserPlugin.java:409)\n\tat org.apache.solr.search.SolrIndexSearcher.getDocSet(SolrIndexSearcher.java:910)\n\tat org.apache.solr.request.SimpleFacets.parseParams(SimpleFacets.java:219)\n\tat org.apache.solr.request.SimpleFacets.getFacetFieldCounts(SimpleFacets.java:549)\n\tat org.apache.solr.request.SimpleFacets.getFacetCounts(SimpleFacets.java:265)\n\tat org.apache.solr.handler.component.FacetComponent.process(FacetComponent.java:78)\n\tat org.apache.solr.handler.component.SearchHandler.handleRequestBody(SearchHandler.java:208)\n\tat org.apache.solr.handler.RequestHandlerBase.handleRequest(RequestHandlerBase.java:135)\n\tat org.apache.solr.core.SolrCore.execute(SolrCore.java:1859)\n\tat org.apache.solr.servlet.SolrDispatchFilter.execute(SolrDispatchFilter.java:703)\n\tat org.apache.solr.servlet.SolrDispatchFilter.doFilter(SolrDispatchFilter.java:406)\n\tat org.apache.solr.servlet.SolrDispatchFilter.doFilter(SolrDispatchFilter.java:195)\n\tat org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:243)\n\tat org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:210)\n\tat org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:222)\n\tat org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:123)\n\tat org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:171)\n\tat org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:99)\n\tat org.apache.catalina.valves.AccessLogValve.invoke(AccessLogValve.java:953)\n\tat org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:118)\n\tat org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:408)\n\tat org.apache.coyote.http11.AbstractHttp11Processor.process(AbstractHttp11Processor.java:1008)\n\tat org.apache.coyote.AbstractProtocol$AbstractConnectionHandler.process(AbstractProtocol.java:589)\n\tat org.apache.tomcat.util.net.JIoEndpoint$SocketProcessor.run(JIoEndpoint.java:310)\n\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1110)\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:603)\n\tat java.lang.Thread.run(Thread.java:722) "
        },
        {
            "author": "David Boychuck",
            "id": "comment-13810910",
            "date": "2013-11-01T00:46:36+0000",
            "content": "Looks like the error is only happening on queries that I use tagging on "
        },
        {
            "author": "David Boychuck",
            "id": "comment-13810924",
            "date": "2013-11-01T00:59:01+0000",
            "content": "Here is an example query where i'm getting the error: \n\n/productQuery?fq=discontinued:false&fq=\n{!tag=manufacturer_string}\nmanufacturer_string\"delta\"%20OR%20\"kohler\")&fq=siteid:82&sort=score%20desc&facet=true&facet.mincount=1&facet.sort=index&start=0&rows=48&fl=productid,manufacturer,uniqueFinish,uniqueid,productCompositeid,score&facet.query=\n{!ex=onSale}\nonSale:true&facet.query=\n{!ex=rating}rating:[4%20TO%20*]&facet.query={!ex=rating}\nrating:[3%20TO%20*]&facet.query=\n{!ex=rating}rating:[2%20TO%20*]&facet.query={!ex=rating}\nrating:[1%20TO%20*]&facet.query=\n{!ex=MadeinAmerica_boolean}\nMadeinAmerica_boolean:yes&facet.query=\n{!ex=inStock}\ninStock:true&facet.query=\n{!ex=PulloutSpray_string}\nPulloutSpray_string:yes&facet.query=\n{!ex=HandlesIncluded_string}\nHandlesIncluded_string:yes&facet.query=\n{!ex=Electronic_string}\nElectronic_string:yes&facet.query=\n{!ex=FlowRateGPM_numeric}FlowRateGPM_numeric:[0%20TO%201]&facet.query={!ex=FlowRateGPM_numeric}\nFlowRateGPM_numeric:[1%20TO%202]&facet.query=\n{!ex=FlowRateGPM_numeric}FlowRateGPM_numeric:[2%20TO%203]&facet.query={!ex=FlowRateGPM_numeric}\nFlowRateGPM_numeric:[4%20TO%205]&facet.query=\n{!ex=FlowRateGPM_numeric}FlowRateGPM_numeric:[3%20TO%204]&facet.query={!ex=FlowRateGPM_numeric}\nFlowRateGPM_numeric:[5%20TO%20*]&facet.query=\n{!ex=ADA_string}\nADA_string:yes&facet.query=\n{!ex=WaterSenseCertified_string}\nWaterSenseCertified_string:yes&facet.query=\n{!ex=WaterfallFaucet_boolean}\nWaterfallFaucet_boolean:yes&facet.query=\n{!ex=InstallationAvailable_string}\nInstallationAvailable_string:yes&facet.query=\n{!ex=LowLeadCompliant_string}\nLowLeadCompliant_string:yes&facet.query=\n{!ex=DrainAssemblyIncluded_string}\nDrainAssemblyIncluded_string:yes&facet.query=\n{!ex=EscutcheonIncluded_string}\nEscutcheonIncluded_string:yes&facet.field=NumberOfHandles_numeric&facet.field=pricebook_1_fs&facet.field=SpoutReach_numeric&facet.field=SpoutHeight_numeric&facet.field=FaucetCenters_numeric&facet.field=OverallHeight_numeric&facet.field=FaucetHoles_numeric&facet.field=HandleStyle_string&facet.field=masterFinish_string&facet.field=\n{!ex=manufacturer_string}\nmanufacturer_string&facet.field=HandleMaterial_string&facet.field=ValveType_string&facet.field=Theme_string&facet.field=MountingType_string&qt=/productQuery&qf=sku^9.0%20upc^9.1%20keywords_82_txtws^1.9%20uniqueid^9.0%20series^2.8%20productTitle^1.2%20productid^9.0%20manufacturer^4.0%20masterFinish^1.5%20theme^1.1%20categoryNames_82_txt^0.2%20finish^1.4&pf=keywords_82_txtws^2.1%20productTitle^1.5%20manufacturer^4.0%20finish^1.9&bf=linear(popularity_82_i,1,2)^3.0&q.alt=categories_82_is:108503 "
        },
        {
            "author": "David Boychuck",
            "id": "comment-13810939",
            "date": "2013-11-01T01:39:17+0000",
            "content": "When I take the \n{!tag}\n out I don't get the error. It looks like the CollapsingQParserPlugin doesn't work with tagging? Can you confirm? "
        },
        {
            "author": "David Boychuck",
            "id": "comment-13810941",
            "date": "2013-11-01T01:46:37+0000",
            "content": "I have posted this information on Solr User: http://lucene.472066.n3.nabble.com/Error-with-CollapsingQParserPlugin-when-trying-to-use-tagging-td4098709.html "
        },
        {
            "author": "David Boychuck",
            "id": "comment-13811540",
            "date": "2013-11-01T18:30:23+0000",
            "content": "I created the following unit test in TestCollapseQParserPlugin.java to illustrate the bug:\n\n\n ModifiableSolrParams params = new ModifiableSolrParams();\n    params.add(\"q\", \"*:*\");\n    params.add(\"fq\", \"{!collapse field=group_s}\");\n    params.add(\"defType\", \"edismax\");\n    params.add(\"bf\", \"field(test_ti)\");\n    params.add(\"fq\",\"{!tag=test_ti}test_ti:5\");\n    params.add(\"facet\",\"true\");\n    params.add(\"facet.field\",\"{!ex=test_ti}test_ti\");\n    assertQ(req(params), \"*[count(//doc)=1]\", \"//doc[./int[@name='test_ti']='5']\");\n\n "
        },
        {
            "author": "Greg Harris",
            "id": "comment-13814418",
            "date": "2013-11-05T23:48:38+0000",
            "content": "I have a request from a customer on this who would really benefit from this filter \u2013 Ability to sort by two fields. I have looked into the code and understand this may not be easily feasible. Just getting it out there.  "
        },
        {
            "author": "Joel Bernstein",
            "id": "comment-13817257",
            "date": "2013-11-08T13:09:04+0000",
            "content": "David,\n\nI was reading your comments while I was away on vacation but my mobile device wasn't playing nicely with the jira site, so I held off on replying until I got back.\n\nI see the issue that you've reported and I'll be working on it through the jira that you created. I'll be posting to that jira with my thoughts soon.\n\nJoel\n "
        },
        {
            "author": "Joel Bernstein",
            "id": "comment-13817260",
            "date": "2013-11-08T13:15:06+0000",
            "content": "Greg,\n\nAre you asking for the ability to use full sort spec as the collapse criteria? I believe you are, but I just want to clarify.\n\nYou can currently use the full sort spec now to sort the collasped result set. But only min/max of a numeric field as collapse criteria.\n\nJoel\n "
        },
        {
            "author": "David Boychuck",
            "id": "comment-13817573",
            "date": "2013-11-08T18:56:46+0000",
            "content": "Joel,\n\nI submitted a fix in https://issues.apache.org/jira/browse/SOLR-5416 \n\nLet me know if you think this is problematic. "
        },
        {
            "author": "Gabe Enslein",
            "id": "comment-13838010",
            "date": "2013-12-03T18:37:58+0000",
            "content": "Hey Joel,\n\nAfter reviewing the functionality as an alternative to using ngroups for performance reasons, I have a use case that needs sorting specified in the search to be respected before collapsing. I have documents that can have the same score but when collapsing is performed, this only takes the first received document. Many cases this document is less important or relevant and would normally be lower in results if sorting pre-collapse was respected. Is there a possibility that something could be done to either adapt this functionality to respect sorting before collapsing? "
        },
        {
            "author": "Joel Bernstein",
            "id": "comment-13838882",
            "date": "2013-12-04T13:29:57+0000",
            "content": "Hi Gabe,\n\nWhat I was planning to implement first is group head selection based on min/max value of a function output. After that I was planning to implement group head selection based on a combination of score and one other criteria. I'd like to have function based collapse criteria by the Solr 4.7 release.  \n\nJoel "
        },
        {
            "author": "Trey Grainger",
            "id": "comment-13839665",
            "date": "2013-12-05T01:40:30+0000",
            "content": "Interesting.  I've been playing around with the Collapsing QParser and, because of the reason Gabe mentioned, I can think very few use cases for it in it's current implementation.  Specifically, because there is no way to break a tie between multiple documents with the same value (the way sorting does), a search that is sorted by score desc, modifieddt desc (newer documents break the tie) is not possible... it just collapses based upon the first document in the index with the duplicate score.  Many of my use cases are even trickier... something like sort by displaypriority desc, score desc, modifieddt desc.\n\nJust brainstorming here, but if sorting documents before collapsing is not possible (due to where in the code stack the collapsing occurs), then it might be possible to just implement a \"sort\" function (ValueSource) that gave an ordinal score to each document based upon the position it would occur within all documents.  If I understand what you mean when you say \"group head selection based upon the min/max of the function\", then this would effectively allow collapsing sorted values, because the sort function would return higher values for documents which would sort higher.  In that case, the sort function (which could read in the current sort parameter from the search request) could even be the default used by collapsing, since that is probably what user's are expecting to happen (this is consistent with how grouping works, for example).\n\nThoughts? "
        },
        {
            "author": "Trey Grainger",
            "id": "comment-13839754",
            "date": "2013-12-05T03:20:25+0000",
            "content": "Thinking more about this more, it's probably going to be hard to implement an efficient \"sort\" ValueSource, as it would probably have to loop through all docs in the index during construction and sort them, caching the sort order for all docs so that it is available later when the value for each document is asked for separately.\n\nIt would probably functionally work, but it seems like there's got to be a better way in the Collapse QParser itself... "
        },
        {
            "author": "Joel Bernstein",
            "id": "comment-13839770",
            "date": "2013-12-05T03:45:36+0000",
            "content": "With ValueSource collapse criteria you will be able to break the tie.\n\nI'll also need to provide a ValueSource that returns the score of the current document being collapsed. Let's call that function:\n\ncollapseScore()\n\nWhen you call this function it simply returns the score of the document being collapsed at that time. You could then have a compound function like this:\n\n\nsum(collapseScore(), field(tie_break_field))\n\n\n\nAnd the tie is broken.\n\nSo the syntax would look something like this:\n\n\nfq={!collapse field=<field_name> max=sum(collapseScore(), field(x))}\n\n\n\n\n\n\n\n\n\n\n\n "
        },
        {
            "author": "shruti suri",
            "id": "comment-13845242",
            "date": "2013-12-11T09:56:34+0000",
            "content": "Hi Joel,\n\nI am facing some ordering difference in collapse post filter with following queries.\nQuery1\nfq=\n{!collapse field=company_id}\nQuery2\nfq=\n{!collapse field=comany_id min=price}\n\nThis difference in queries which is the min parameter should only change the id (offering id) and give company_id in same order. But instead the order of company_id changes. \nPlease check why the order of company id changes.\n\nRegards\nShruti "
        },
        {
            "author": "Joel Bernstein",
            "id": "comment-13845333",
            "date": "2013-12-11T11:55:18+0000",
            "content": "Shruti,\n\nWhat is your sorting/ranking criteria? Can you post your full query.\n\nOrdering can change when you add the min=price. The reason is that ordering is done on the collapsed document set. So if the collapsed document set changes, your ordering will likely change. For example the documents with a higher or lower price may have a higher or lower score.\n\nThat being said I wouldn't rule out a bug. But I'll need more examples of how the ordering changed to be sure.\n "
        },
        {
            "author": "Deepak Mishra",
            "id": "comment-13846229",
            "date": "2013-12-12T10:25:38+0000",
            "content": "Hi Joel\nI context with the Shruti's comment. We faced the ordering issue without passing any sorting parameter and same filters in both queries.\n\nQuery1\nfq=\n{!collapse field=company_id}\n\nQuery2\nfq=\n{!collapse field=comany_id min=price}\n \n\nQuery3\nFor debugging Query2, we added score field in fl=score,offering_id,company_id...\nThat actually solved the document order issue\n\nQuery4\nBut when we passed selective exclude in facet field of Query3, it give document in correct order but with NullPointerException in error and no facet (not the one in SOLR-5416).\nfacet.field=\n{!ex=\"samsung\"}\nbrand\nfq=\n{!tag=\"samsung\"}\n(brand:\"samsung\")\nThe error is\nNullPointerException at org.apache.solr.search.CollapsingQParserPlugin$FloatValueCollapse.collapse(CollapsingQParserPlugin.java:852) \n\nQuery5\nRemoving score from fl in Query 4 removes the error "
        },
        {
            "author": "Joel Bernstein",
            "id": "comment-13846307",
            "date": "2013-12-12T13:44:47+0000",
            "content": "Deepak,\n\nCan you create a new jira for this. In the description of the ticket please post your entire query and stack trace. I'll see if I can create a test to recreate it.\n\nThanks,\nJoel "
        },
        {
            "author": "Joel Bernstein",
            "id": "comment-13846567",
            "date": "2013-12-12T18:39:18+0000",
            "content": "Deepak,\n\nI tested with the CollapsingQParserPlugin in SOLR-5416 and I wasn't able to reproduce the bugs.\n\nBoth the sort ordering seems to be working and the I'm not getting the exception. The test I'm using incorporates: \ncollapsing with max=float_field, \nimplied ordering by score, \nfl with score,\nfaceting with tag and exclude \n\n\n   params = new ModifiableSolrParams();\n   params.add(\"q\", \"*:*\");\n   params.add(\"fq\", \"{!collapse field=group_s max=test_tf}\");\n   params.add(\"defType\", \"edismax\");\n   params.add(\"bf\", \"field(id)\");\n   params.add(\"fl\", \"score, id\");\n   params.add(\"facet\",\"true\");\n   params.add(\"fq\", \"{!tag=test}term_s:YYYY\");\n   params.add(\"facet.field\", \"{!ex=test}term_s\");\n\n    assertQ(req(params), \"*[count(//doc)=2]\",\n        \"//result/doc[1]/float[@name='id'][.='5.0']\",\n        \"//result/doc[2]/float[@name='id'][.='1.0']\");\n\n\n "
        },
        {
            "author": "Deepak Mishra",
            "id": "comment-13847343",
            "date": "2013-12-13T09:50:08+0000",
            "content": "Joel, I created a new JIRA and attached the queries in SOLR-5554 "
        },
        {
            "author": "Deepak Mishra",
            "id": "comment-13848876",
            "date": "2013-12-16T07:05:39+0000",
            "content": "Joel check the JIRA SOLR-5554 again. I have attached the details to reproduce the error and the error log in FINE mode. "
        },
        {
            "author": "Phil John",
            "id": "comment-13853820",
            "date": "2013-12-20T09:40:29+0000",
            "content": "The one thing this doesn't seem to do, which the current field collapsing solution does, is say how many items there are in each group - which is useful if you want to display the top result, but also have a link saying \"X other available\". Our use case is collapsing down multiple manifestations of a bibliographic work (i.e. multiple editions of the same work), so with the grouping feature we get a count back of the size of the group and can go \"5 other editions also available\" and then link to a search on the key we collapsed by.\n\nIs this planned, or will that come in the more generic aggregation support planned for 5.0? "
        },
        {
            "author": "Joel Bernstein",
            "id": "comment-13854869",
            "date": "2013-12-21T14:39:16+0000",
            "content": "Phil,\n\nThis functionality is planned. The description in this ticket mentions an ExpandComponent, which will expand the groups for a single page of search results. The planned roadmap for the collapse/expand work is to push out SOLR-5408 and SOLR-5416, which are bug fixes in Solr 4.6.1. Followed by SOLR-5536 (possibly in Solr 4.7), which is an enhancement to the CollapsingQParserPlugin. Then the ExpandComponent is the next planned feature.  \n\nJoel "
        },
        {
            "author": "Phil John",
            "id": "comment-13854870",
            "date": "2013-12-21T14:46:04+0000",
            "content": "Hi Joel,\n\nThanks for the clarification - I wondered if it would be in the expander, but came away a bit confused as to what that would end up doing.\n\nNice to know it'll come, and as a workaround we can just query for counts from our DB grouped by collapse key until it lands in trunk.\n\nThanks,\n\nPhil. "
        },
        {
            "author": "shruti suri",
            "id": "comment-13857395",
            "date": "2013-12-27T09:14:36+0000",
            "content": "Hi Joel,\nCan i perform the functionality of group.facet=true with collapsing PostFilter.\n\nshruti "
        },
        {
            "author": "Joel Bernstein",
            "id": "comment-13857603",
            "date": "2013-12-27T18:06:12+0000",
            "content": "Hi Shruti,\n\nThe collapsing post filter separates collapsing and faceting completely. You have access to all of Solr's faceting capability on the collapsed set. If you need to create a facet on the uncollapsed set for a particular facet, you can use tag/exclude facet functionality to remove the collapsed filter for a specific facet.\n\nIt looks like combining the collapsing postfilter with Solr pivot facets might give you the type of functionality you are looking for.\n\nJoel "
        },
        {
            "author": "Simon Endele",
            "id": "comment-13894749",
            "date": "2014-02-07T17:23:13+0000",
            "content": "Hi Joel,\n\na similar question to Phil John's one: Is it correct that no equivalent for \"group.limit\" of the old grouping is/will be available?\nI.e. only one document is returned for each group and the ExpandComponent can be used to get more, right?\n\nI always thought that the aim of the ExpandComponent is to return additional docs in a sense that these documents were not hit by the query (we wrote a component by ourselves for that based on the old grouping functionality).\nWill that be possible with the ExpandComponent, or will it only be possible to fetch n (or all) documents of each group that were hit and collapsed by the CollapsingQParserPlugin (each only for a single page, of course)?\n\nSee also my question above concerning a filter query for the ExpandComponent.\n\nThanks in advance,\nSimon "
        },
        {
            "author": "Joel Bernstein",
            "id": "comment-13894965",
            "date": "2014-02-07T20:08:09+0000",
            "content": "Simon,\n\nThe \"limit\" on group size will be available in the expand component. You are correct that the CollapsingQParserPlugin only returns the one document per group and the Expand component will bring back the rest.\n\nThe initial functionality of the Expand component will return only group members that hit the query. We can iterate on this design to include a limiting filter query and also change the main query to allow retrieval of group members that were not in the original main query. If time allows I can try to get all this in the initial release but I'm shooting if possible to have this ready for Solr 4.7. Whatever doesn't make it in can be added in future releases.\n\nThe initial implementation of the expand component is being worked on in my GitHub fork:\n\nhttps://github.com/joelbernstein2013/heliosearch/tree/expand\n\nI'll be creating a jira ticket for this soon.\n\nJoel\n\n\n "
        },
        {
            "author": "Joel Bernstein",
            "id": "comment-13905445",
            "date": "2014-02-19T13:46:08+0000",
            "content": "The ExpandComponent jira ticket is SOLR-5720.  "
        }
    ]
}