{
    "id": "SOLR-8311",
    "title": "SolrCoreAware and ResourceLoaderAware lifecyel is fragile - particularly with objects that can be created after SolrCore is live",
    "details": {
        "components": [],
        "type": "Bug",
        "labels": "",
        "fix_versions": [],
        "affect_versions": "None",
        "status": "Open",
        "resolution": "Unresolved",
        "priority": "Major"
    },
    "description": "In general, the situation of when/how ResourceLoaderAware & SolrCoreAware instances are \"informed\" of the ResourceLoader & SolrCore is very kludgy and involves a lot of special casees.\n\nFor objects initialized before the SolrCore goes \"live\", SolrResourceLoader tracks these instances internally, and calls inform() on all of them \u2013 but for instances created after the SolrCore is live (ex: schema pieces created via runtime REST calls), SolrResourceLoader does nothing to ensure they are later informed (and typically can't because that must happen after whatever type specific 'init' logic takes place).  So there is a lot of special case handling to call inform methods sprinkled through out he code\n\nThis issue serves as a refrence point to track/link various comments on the situation, and to cite in comments warning developers about how finicky it is to muck with the list of SolrCoreAware & ResourceLoaderAware allowed implementations.",
    "attachments": {},
    "issue_links": {},
    "comments": [
        {
            "date": "2015-11-18T18:00:27+0000",
            "author": "Hoss Man",
            "content": "\nThe motivation for filing this issue was SOLR-8280, where I realized that even though SimilarityFactory was an allowed SolrCoreAware API, there were situations when dealing with managed schema that would result in a new SimilariyFactory getting inited at run time w/o ever having inform(SolrCore) called...\n\n\nThe root problem seems to be that when using the SolrResourceLoader to create newInstances of objects, the loader is tracking what things are SolrCoreAware, ResourceLoaderAware, and/or SolrInfoMBean.  Then, just before the SolrCore finishes initialiing itself, it calls a method on SolrResourceLoader to take appropriate action on to inform those instances (and/or add them to the MBean registry)\n\nThe problem happens when any new instances are created by the SolrResourceLoader after the SolrCore is up and running \u2013 it currently has a live boolean it uses to just flat out ignore wether or not these instances are SolrCoreAware, ResourceLoaderAware, and/or SolrInfoMBean, meaning that nothing in the call stack ever informs them about the SolrCore.\n\nIt looks like SOLR-4658 included a bit of a hack work arround for the ResourceLoaderAware schema elements (see IndexSchema's constructor which call's loader.inform(loader);...\n\nhttp://svn.apache.org/viewvc/lucene/dev/trunk/solr/core/src/java/org/apache/solr/schema/IndexSchema.java?r1=1463182&r2=1463181&pathrev=1463182\n\n...this seems realy sketchy because it causes any ResourceLoaderAware plugins inited so far by the core to be {{inform(ResourceLoader)}}ed once the first IndexSchema is created \u2013 even though that's not suppose to happen until mutch later in the SolrCore constructor just before the CountDownLatch is released.\n\nWhat it does do however is ensure that when a new schema gets loaded later (by the REST API, or a schemaless update processor) and ResourceLoaderAware fieldtypes/analyzers are good to go \u2013 but that doesn't do anything to help SolrCoreAware plugins like SimilarityFactory.\n\n\nThis issue also led to the discovery that SimilariyFactory.inform(SolrCore) already had special handling because even on startup it had to be called before other any other SolrCoreAware impls might be informed by SolrResourceLoader incase they tried to access the core's searcher (which depends on the Similarity)...\n\n\n\n\tThere was already a special kludge for SolrCoreAware SimFactories in SolrCore.initSchema\n\t\n\t\tlooks like this was originally for ensuring that the SimFactories was usable when other SolrCoreAware things (like listeners) got informed of the SolrCore and tried to use the SolrIndexSearcher (which depended on the sim)\nSo i think the most straight forward solution to the problem (SimilarityFactory-ies that implement SolrCoreAware playing nice with managed schema) is to refactor that existing kludge from SolrCore.initSchema to SolrCore.setLatestSchema\n\t\n\t\n\n\n\n\n\n\nSOLR-8280 also contained some discussion about the problem of trying to make a general fix for this in SolrResourceLoader...\n\nHOSS:\n\nI'm attaching a work in progress patch where I attempted to fix the underlying problem with SolrResourceLoader by having it keep a refrence to the SolrCore it's tied to such that any new instances after that the would be immediately informed of the SorlCore/ResourceLoader. This fixes some of the tests I mentioned before in this issue that have problems with SchemaSimilarityFactory but causes other failures in other existing test that reload the schema \u2013 because any FieldType that is ResourceLoader aware is now being \"informed\" of the loader as soon as it's instantiated \u2013 before even basic init() methods are called. Which makes sense in hind sight \u2013 my whole approach here is flawed because the contract is suppoes to be that the init methods will always be called first, and any (valid) inform methods will be called at some point after that once the core/loader is available, but before the instance is used ... calling \"new\" then \"inform\" then \"init\" is maddness.\n\nI honestly don't know if there is a sane way to solve this problem in the general case...\n\nAlan:\n\nI have a half-implemented patch hanging around somewhere that tried to clean this up a bit. I think the root problem is that there are two circumstances in which we're using SolrResourceLoader, a) during core initialization when we need to call init() immediately, but wait to call inform() until after the loading latch has been released, and then b) to create new objects once the core is up and serving queries. I tried to split this out into two separate SRL implementations, one of which is private to SolrCore and used only in the constructor, and does the call-init-and-then-delay-inform dance, and the other of which is returned by SolrCore.getResourceLoader() and inits() and informs() before it returns. To be honest though, I get so confused by the code paths here that I'm not sure whether or not that would help in this case... ",
            "id": "comment-15011549"
        }
    ]
}