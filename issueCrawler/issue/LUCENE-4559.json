{
    "id": "LUCENE-4559",
    "title": "PerFieldSimilarityWrapper issue with queryNorm() and coord()",
    "details": {
        "components": [],
        "fix_versions": [],
        "affect_versions": "4.0",
        "priority": "Minor",
        "labels": "",
        "type": "Improvement",
        "resolution": "Unresolved",
        "status": "Open"
    },
    "description": "This issue requests that documentation be clarified for the current\nbehavior of queryNorm() and coord() on PerFieldAnalyzerWrapper and\nthat support is added for the use case described below.\n\nThe documentation for PerFieldAnalyzerWrapper (lucene 4.0) says:\n\n\n  Subclasses should implement get(String) to return an appropriate\n  Similarity (for example, using field-specific parameter values) for\n  the field.\n\n\n\nThis is misleading because of the behavior for queryNorm() and\ncoord().  The Similarity returned from get() is not accessed for these\nmethods.  Instead, the PerFieldAnalyzerWrapper subclass methods are\ncalled.  I understand that this is because these methods apply to the\nquery as a whole rather than per field.  However, consider the\nfollowing.  A PerFieldAnalyzerWrapper with no per-field behavior (just\nreturns DefaultSimilarity in get()) behaves differently than\nDefaultSimilarity itself:\n\n\nclass MyPerFieldSimilarity1 extends PerFieldSimilarityWrapper {\n    @Override\n    public Similarity get(String name) {\n        return new DefaultSimilarity();\n    }\n}\n\npublic class PerFieldSimilarityWrapperTest {    \n    private float runQuery(Similarity similarity) throws IOException {\n        IndexWriterConfig config = new IndexWriterConfig(Version.LUCENE_40, new WhitespaceAnalyzer(Version.LUCENE_40));\n        config.setSimilarity(similarity);\n        Directory dir = new RAMDirectory();\n        IndexWriter writer = new IndexWriter(dir, config);\n        Document doc = new Document();\n        doc.add(new TextField(\"A-field\", \"first\", Store.YES));\n        writer.addDocument(doc);\n        writer.commit();\n        \n        IndexReader reader = DirectoryReader.open(dir);\n        IndexSearcher searcher = new IndexSearcher(reader);\n        searcher.setSimilarity(similarity);\n        TermQuery query = new TermQuery(new Term(\"A-field\", \"first\"));\n        TopDocs topDocs = searcher.search(query, 1);\n        return topDocs.scoreDocs[0].score;\n    }\n    \n    @Test\n    public void testSimple() throws Exception {\n        float score1 = runQuery(new DefaultSimilarity());\n        float score2 = runQuery(new MyPerFieldSimilarity1());\n        assertEquals(score1, score2, 0.0001);\n\t// java.lang.AssertionError:\n\t//   expected:<0.3068528175354004> but was:<0.09415864944458008>\n    }\n\n\n\nOne solution is to override and forward, e.g.\n\n\nclass MyPerFieldSimilarity1 extends PerFieldSimilarityWrapper {\n    @Override\n    public Similarity get(String name) {\n        return new DefaultSimilarity();\n    }\n    @Override\n    public float coord(int overlap, int maxOverlap) {\n        return get(\"dummy\").coord(overlap, maxOverlap);\n    }\n    @Override\n    public float queryNorm(float valueForNormalization) {\n        return get(\"dummy\").queryNorm(valueForNormalization);\n    }\n}\n\n\n\nHowever, these methods don't have access to query field data, thus the\n\"dummy\" argument.\n\nSuppose an application arranges documents so that there are two\ndistinct field groupings:\n\n\nDocument:\n  A-field1\n  A-field2\n  A-field3\n  B-field1\n  B-field2\n  B-field3\n\n\n\nThe application creates queries that use the A fields, or the B\nfields, but never both A and B in the same query.  Then it seems\nreasonable that PerFieldAnalyzerWrapper should provide a way for\nqueryNorm() and coord() to operate on these sets of fields.  This\ncannot be done with the current implementation.",
    "attachments": {},
    "issue_links": {},
    "comments": []
}