{
    "id": "LUCENE-1658",
    "title": "Absorb NIOFSDirectory into FSDirectory",
    "details": {
        "labels": "",
        "priority": "Minor",
        "components": [
            "core/store"
        ],
        "type": "Improvement",
        "fix_versions": [
            "2.9"
        ],
        "affect_versions": "None",
        "resolution": "Fixed",
        "status": "Closed"
    },
    "description": "I think whether one uses java.io.* vs java.nio.* or eventually\njava.nio2.*, or some other means, is an under-the-hood implementation\ndetail of FSDirectory and doesn't merit a whole separate class.\n\nI think FSDirectory should be the core class one uses when one's index\nis in the filesystem.\n\nSo, I'd like to deprecate NIOFSDirectory, absorbing it into\nFSDirectory, and add a setting \"useNIO\" to FSDirectory.  It should\ndefault to \"true\" for non-Windows OSs, because it gives far better\nconcurrent performance on all platforms but Windows (due to known Sun\nJRE issue http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6265734).",
    "attachments": {
        "LUCENE-1658-take2.patch": "https://issues.apache.org/jira/secure/attachment/12409484/LUCENE-1658-take2.patch",
        "LUCENE-1658-take3.patch": "https://issues.apache.org/jira/secure/attachment/12409505/LUCENE-1658-take3.patch",
        "LUCENE-1658.patch": "https://issues.apache.org/jira/secure/attachment/12408909/LUCENE-1658.patch"
    },
    "issue_links": {},
    "comments": [
        {
            "date": "2009-05-24T16:29:48+0000",
            "content": "Attached patch.  I plan to commit in a day or two. ",
            "author": "Michael McCandless",
            "id": "comment-12712572"
        },
        {
            "date": "2009-05-24T22:46:42+0000",
            "content": "Hi Mike,\nmaybe not use a boolean for the mode, instead an enum? ",
            "author": "Uwe Schindler",
            "id": "comment-12712614"
        },
        {
            "date": "2009-05-24T23:07:11+0000",
            "content": "enum\njava 1.5, unless you're going to write it by hand\n\nMike, are you going to absorb MMapDirectory into FSDirectory as well? It fits \"when one's index is in the filesystem\". ",
            "author": "Earwin Burrfoot",
            "id": "comment-12712615"
        },
        {
            "date": "2009-05-24T23:21:37+0000",
            "content": "java 1.5, unless you're going to write it by hand\nLucene has the o.a.l.utils.Parameter class for that, whih is used for e.g. Field.Store. ",
            "author": "Uwe Schindler",
            "id": "comment-12712617"
        },
        {
            "date": "2009-05-25T10:09:31+0000",
            "content": "maybe not use a boolean for the mode, instead an enum? \n\nOK I'll switch to oal.Parameter enum emulator. \n\nMike, are you going to absorb MMapDirectory into FSDirectory as well? It fits \"when one's index is in the filesystem\". \n\nExcellent point \u2013 I think that makes sense. I'll fold it in as well. ",
            "author": "Michael McCandless",
            "id": "comment-12712679"
        },
        {
            "date": "2009-05-25T11:23:00+0000",
            "content": "Excellent point - I think that makes sense. I'll fold it in as well.\nDoesn't make sense to me. :/ MMapD has different characteristics. It can also have it's own configurable properties, which are irrelevant for NIOFSD and FSD.\n\nFor example, my version of MMapD uses MappedByteBuffer.load() on creating MMapIndexInput. That way the cost of loading stuff into memory is paid upfront on reopening the reader, instead of during first several searches.\nIf we want to publish this feature into trunk, we'll end up with additional parameter on MMapD constructor, that governs whether we want to preload mmapped files, or not.\nNow imagine constructor for FSD-that-folds-it-all, which has 'type', and a boolean setting that's relevant only for one of the types.\n\nI also think of trying to use mmap for writing. If that proves to be beneficial, MMapD won't share much with FSD anymore.\n\nIn the end, I'm unsure if it's a good idea to fold anything into FSD at all. Too much different stuff in one class becons for spahetti code  I assume your initial aim is to provide users with best impl for current platform without making them think. What about static factory that chooses between several impls? We had static factory before, it stinked because you had to chose impl through system property, it pooled directories and we had no public constructors. But now we have public constructors  If one needs, he uses constructor directly. If one is lazy and wants us to choose for him he uses old API, that simply changes semantics a bit. ",
            "author": "Earwin Burrfoot",
            "id": "comment-12712696"
        },
        {
            "date": "2009-05-25T13:13:07+0000",
            "content": "In the end, I'm unsure if it's a good idea to fold anything into FSD at all. Too much different stuff in one class becons for spahetti code  I assume your initial aim is to provide users with best impl for current platform without making them think.\n\nThat is my problem with the whole issue, too. For me, the three directory impl are too different, to be merged together. Especially if writing is also affected.\n\nUsing an additional parameter in the ctor specifying the type of directory is almost the same like three classes with much cleaner code. The only thing you do not get is the automatic directory impl choosing for filesystem dirs. But the solution to this are static factories.\n\nWhat about static factory that chooses between several impls? We had static factory before, it stinked because you had to chose impl through system property, it pooled directories and we had no public constructors. But now we have public constructors  If one needs, he uses constructor directly. If one is lazy and wants us to choose for him he uses old API, that simply changes semantics a bit.\n\nThat would be great. As the separate public constructors and deprecation of FSDirectory.open() is new in 2.9, we can change it. Maybe an automatism behind open() if the System.property is unset would be good. Advanced users may still instantiate the directories using the public ctor. ",
            "author": "Uwe Schindler",
            "id": "comment-12712715"
        },
        {
            "date": "2009-05-25T18:53:33+0000",
            "content": "In the end, I'm unsure if it's a good idea to fold anything into FSD at all.\n\nOK, you convinced me: let's keep separate classes.\n\nBut I'd like to split the current FSDir into an abstract FSDir and a\nsubclass SimpleFSDir.  Then, we have three subclasses of FSDir\n(Simple, NIO, MMap).  And strengthen the javadocs so SimpleFSDir's\nconcurrency limitations are clear.\n\nI assume your initial aim is to provide users with best impl for current platform without making them think. What about static factory that chooses between several impls?\n\nRight, that's my goal: there should be a single obvious way to ask for\na Directory that uses the file system, and that way should have good\ndefaults.\n\nFSDirectory is unfortunately the obvious way now, but it's usually a\npoor choice.\n\nFor example, my version of MMapD uses MappedByteBuffer.load() on creating MMapIndexInput.\n\nIs this something you could share?  Sounds useful!  Likewise if you\nextend MMapDir for writing...\n\nDoes anyone have a strong sense of when MMapDir is / is not an\nappropriate choice?  I've seen some users report good performance, eg:\n\n  http://mail-archives.apache.org/mod_mbox/lucene-java-user/200603.mbox/%3C20060313025744.18818.qmail@station174.com%3E\n\nMMap eats into the virtual memory of the process, so on 32 bit JRE\nthat obviously a very real concern.\n\nAs the separate public constructors and deprecation of FSDirectory.open() is new in 2.9\n\nRight we are free to change things still (hmm: a nice side effect of\nNOT releasing very often; incentives aren't quite right...).\n\nBut the old API was FSDirectory.getDirectory.\n\nI think we should add a static FSDirectory.create() that returns a\ngood default impl given your OS. ",
            "author": "Michael McCandless",
            "id": "comment-12712773"
        },
        {
            "date": "2009-05-25T19:59:44+0000",
            "content": "Attached patch:\n\n\n\tI created SimpleFSDir (the renaming for FSDir), and left FSDir to\n    be the base class (in 3.0 it will become abstract).  FSDir\n    implements most methods, handles locking, etc., so the subclass\n    will just have to implement openInput/createOutput.\n\n\n\n\n\tAdded FSDir.open static methods; currently they simply choose\n    NIOFSDir on non-Windows OS, and FSDir on Windows OS.  I was\n    tempted to choose MMapDir on 64 bit Windows JRE, but it makes me\n    nervous...\n\n\n\n\n\tStrengthened javadocs\n\n\n\n\n\tCutover most unit tests to FSDir.open\n\n ",
            "author": "Michael McCandless",
            "id": "comment-12712785"
        },
        {
            "date": "2009-05-26T09:59:41+0000",
            "content": "Yay for base class + three concrete impls (haven't yet looked at the patch).\n\nI was tempted to choose MMapDir on 64 bit Windows JRE, but it makes me nervous...\nNot completely sure why, but MMap failed for me on Win32 some time ago\n\nIs this something you could share? Sounds useful! Likewise if you extend MMapDir for writing...\nIt's a one-liner. I can make a patch, but while it works better than vanilla MMapD, I'm not yet sure it's the best approach. As for writing - okay, I'll tell you if it turns out to be anything good.\n\nDoes anyone have a strong sense of when MMapDir is / is not an appropriate choice?\nThere are a lot of variables. Just as you said, on 32bit systems you have to take care of address space. So, nice for small indexes, bad for big ones. But, mmap in Java cannot be explicitly closed, it is closed in finalizer, so even for a small index if you update really often, you can hit an OOM even though you have enough memory. MMapD failed for me on windows. But it is fast. It is absolutely, totally, uber-indespensible, if you have a 64bit system, fat index, memory to spare and require lots of fast searches.\n\nSo, you can probably enable it for non-Win 64bit? ",
            "author": "Earwin Burrfoot",
            "id": "comment-12712930"
        },
        {
            "date": "2009-05-26T10:41:20+0000",
            "content": "Not completely sure why, but MMap failed for me on Win32 some time ago\n\nI think on 32 bit JRE we shouldn't choose MMap in FSDir.open().\n\nIt's a one-liner. I can make a patch, but while it works better than vanilla MMapD, I'm not yet sure it's the best approach. As for writing - okay, I'll tell you if it turns out to be anything good.\n\nWhich way do you think \"prime all bytes up front on open\" should default?\n\n\nThere are a lot of variables. Just as you said, on 32bit systems you have to take care of address space. So, nice for small indexes, bad for big ones. But, mmap in Java cannot be explicitly closed, it is closed in finalizer, so even for a small index if you update really often, you can hit an OOM even though you have enough memory. MMapD failed for me on windows. But it is fast. It is absolutely, totally, uber-indespensible, if you have a 64bit system, fat index, memory to spare and require lots of fast searches.\n\nSo, you can probably enable it for non-Win 64bit?\n\nWait, are you saying Win 64 bit has problems w/ MMapDir?  (I thought you just said Win 32 bit, above).\n\nIs MMapDir fine w/ concurrency?  (I'd assume so).  So, if you had the choice (ie, you're running in env w/ plenty of virtual mem), MMapDir would be preferred over NIOFSDir?\n\nOn a 64 bit env that doesn't have that much RAM, MMapDir should fare no worse than NIOFSDir, right?  Ie both are competing for the same IO cache.  And so on a 64 bit JRE perhaps the default should always be MMAPDir. ",
            "author": "Michael McCandless",
            "id": "comment-12712952"
        },
        {
            "date": "2009-05-26T11:07:23+0000",
            "content": "From my experiences, MMap is always preferred, if you have 64 bit system. In this case, Java maps the file into address space like a swap file and often used parts are in real memory. So in my opinion, it is always preferable on 64 bit systems. If you have much RAM it is even better (because caching).\nOn Linux/Solaris you can see the used address space with TOP. I have a webserver with an about 7 GB big index using nmap. It is reopened very often, so the used address space sometimes goes up to >50 Gigabytes, but this is not a problem, as it is not real memory, its just like a \"swap file\". The finalizer removes the mapped adress space fairly fast (dependent on usage/closing of old segements).\nThe index in this directory is really fast, especially, if you have lots of real RAM, that can be used for buffering. You can even load stored fields for thousands of documents very fast, uninversion is also fast.\nConcurrency is no problem as the mapped file is handled like RAM.\n\nI always recommend users, who want to use lucene: Use 64 bit systems, -d64 JVM parameter (this enables Java in 64 bit on Solaris), a lot of RAM and MMapDirectory. ",
            "author": "Uwe Schindler",
            "id": "comment-12712957"
        },
        {
            "date": "2009-05-26T13:07:20+0000",
            "content": "Wait, are you saying Win 64 bit has problems w/ MMapDir? (I thought you just said Win 32 bit, above).\nI have no lucene experience with Win64, and so I extrapolated from 32bit (as I felt it was more of a Windows issue than anything else). Would be nice if someone actually tries.\nIf it works, then the rule sounds like - MMap for all 64bit systems, NIO for 32bit non-win, Simple for 32bit win.\n\nIs MMapDir fine w/ concurrency?\nIt's cool with it if you have enough memory (no frequent paging occurs). I'm not sure about NIOFS vs MMap on memory-constrained systems, if you're competing for disk cache.\n\nWhich way do you think \"prime all bytes up front on open\" should default?\nThis has a side-effect of pushing previous mmaps out of memory if you're memory-constrained. Thus, under certain usage conditions (frequent merging, or something like that + low memory) this feature theoretically could be a disadvantage.\nFor me it works well enough to be hardcoded to true \n\nIf anybody's interested, I can also repost an alternative for MMapD - MemoryMirroredD, which wraps any given D and explicitly preloads files in non-chunked byte arrays. It's a bit faster than MMapD and MemoryD (for reading), but has certain disadvantages, like stressing your GC and throwing OOM on merges/optimize if you don't have enough heap (unlike MMapD that silently swaps out). ",
            "author": "Earwin Burrfoot",
            "id": "comment-12712997"
        },
        {
            "date": "2009-05-26T17:25:47+0000",
            "content": "OK so I think FSDir.open should default to MMapDir on 64 bit machine,\nNIOFSDir on non-windows machines, and SimpleFSDir on windows 32 bit\nmachines.  I'll rev the patch.\n\nNext question: does anyone know how to reliably determine if the\nrunning JRE is 32 or 64 bit?  I found this:\n\n    http://forums.java.net/jive/message.jspa?messageID=274406\n\nbut I'm worried about how portable that solution is... ",
            "author": "Michael McCandless",
            "id": "comment-12713128"
        },
        {
            "date": "2009-05-26T22:51:53+0000",
            "content": "Attached patch w/ new defaults.  I plan to commit in a day or two. ",
            "author": "Michael McCandless",
            "id": "comment-12713311"
        },
        {
            "date": "2009-05-30T22:17:47+0000",
            "content": "This issue has some more problems after committing.\nAnd there are also inconsistencies.\nI am working on a patch, that also un-deprecates FSDir.getDirectory() and removes FSDir.open() again. FSDir.getDirectory() will return the platform-optimal directory, if no system property specifying the directory is set. Also removes some duplicate code in the FSDir.IndexInput/Output by subclassing from SimpleFSDir.IndexInput (but mark deprecated).\nMy patch will remove the whole FSDir caching (so getDirectory will always return a new directory) and thus again LUCENE-1453 comes in my mind: LUCENE-1453 currently has the problem, that it only works correct with FSDir.getDirectory() instances, but not with self-instantiated implementations. ",
            "author": "Uwe Schindler",
            "id": "comment-12714784"
        },
        {
            "date": "2009-05-30T22:48:50+0000",
            "content": "This issue breaks some platforms (if FSDirectory.open() is used in some tests)! ",
            "author": "Uwe Schindler",
            "id": "comment-12714790"
        },
        {
            "date": "2009-05-30T23:38:48+0000",
            "content": "This is a revised patch (on current trunk):\n\n\tFSDir.open() was removed, the logic was included into FSDir.getDirectory and this un-deprectated: If the system property is missing, the same like in Mikes open() happens: choosing the best impl for platform\n\tCaching of FSDirs was completely removed\n\tFSDir.IndexInput/Output (deprected) was removed (suplicate code) and simply replaced by (deprecated) subclasses of SimpleFSDir ones). This is OK for backwards compatibility.\n\tprotected/package-private ctors were removed, getDirectory uses now reflection to find the (File,LockFactory) ctor\n\n\n\nSome tests currently fail:\n\n\tTestCompoundFile (do not know why)\n\tTestLockFactory (test is obsolete, execption can only occur on cached dirs)\n\tSometimes reopen does not work because already closed (see LUCENE-1453)\n\n\n\nTODO:\n\n\tRemove the caching code completely (currently comented out)\n\tFix 1453, because if somebody uses a self-instantiated FSDir and not the default, the reopened dir would use the default again! So fix (maybe clone of FSDir, or LUCENE-1453 is obsolete without caching?).\n\n\n\nThis patch also contains an overflow fix in MMapDir for files <2 GB but large. \"int*int\" should be written as \"(long)int*int\", if the result maybe large (thanks Earwin!). ",
            "author": "Uwe Schindler",
            "id": "comment-12714793"
        },
        {
            "date": "2009-05-30T23:59:23+0000",
            "content": "One comment:\nThe part with the reflection and the ctor may be non-backwards compatible, because if somebody overwrites the old FSDir and does not provide the wanted ctor (only the default one), it would fail. The default ctor would not even work, as the init() private internal method (used by the old getDirectory()) is no longer available.\nBut this is the same like in the discussion about backwards compatibility. In my opinion, for 2.9, we should make FSDir abstract, too. It is sooooooo seldom, that somebody may create a file based dir impl (nio.2 or what else? Or Earwins MemoryCopiedDir). But if somebody does this, he knows what he does and can fix the compilation errors easily! ",
            "author": "Uwe Schindler",
            "id": "comment-12714795"
        },
        {
            "date": "2009-05-31T00:29:48+0000",
            "content": "New patch: Now only TestCompoundFile fails, some more imporvements. ",
            "author": "Uwe Schindler",
            "id": "comment-12714798"
        },
        {
            "date": "2009-05-31T10:28:46+0000",
            "content": "\nUgh, I'm sorry... I had run the tests only on OS X, Java 1.5, which is\nnot 64 bit by default (must specify -d64) \u2013 I should have tested the\ndifferent OS's and JREs before committing.\n\nThanks for jumping on this, Uwe and Earwin!\n\nFSDir.open() was removed, the logic was included into FSDir.getDirectory and this un-deprectated: If the system property is missing, the same like in Mikes open() happens: choosing the best impl for platform\n\nBut: the removal of the cache is not back-compatible?  (I'm not sure\nhow/whether anyone relies on that behavior).  And, we are wanting to\nmove away from that global System property in choosing the class for\nyour FSDir.  This is why I switched to open instead of back to\ngetDirectory.\n\nCaching of FSDirs was completely removed\n\nI think this must wait until 3.0, ie when we remove all getDirectory\nmethods.\n\nFSDir.IndexInput/Output (deprected) was removed (suplicate code) and simply replaced by (deprecated) subclasses of SimpleFSDir ones). This is OK for backwards compatibility.\n\nExcellent! ",
            "author": "Michael McCandless",
            "id": "comment-12714848"
        },
        {
            "date": "2009-05-31T10:37:50+0000",
            "content": "\nCaching of FSDirs was completely removed\n\nI think this must wait until 3.0, ie when we remove all getDirectory\nmethods.\n\nI am currently playing with this. For the end-user it is not really needed, that directories are cached. Even if he gets a directory that it is cached, he can see it as a alone one. he can close it (because of refcounting and so on) and do everything, he can do with a single directory, too.\n\nSo why is it not backwards compatible, when we remove caching? All tests pass here!\n\nMore, the mixing of cached and uncached dirs bring more problems (I am currently investigating).\n\nI will supply a new patch shortly, with all other bugs fixed (there were more, e.g. with some tests in _TestHelper and so on). The move from FSDir to SimpleFSDir is more complicated than it seems. In my opinion, it would be a question, if this move should wait until 3.0. ",
            "author": "Uwe Schindler",
            "id": "comment-12714850"
        },
        {
            "date": "2009-05-31T10:47:38+0000",
            "content": "I am currently playing with this. For the end-user it is not really needed, that directories are cached. Even if he gets a directory that it is cached, he can see it as a alone one. he can close it (because of refcounting and so on) and do everything, he can do with a single directory, too.\n\nThe original purpose of the cache was to ensure each unique  directory in the filesystem alway mapped to a single instance of FSDir, so that you could synchronize on that instance and be certain that this is equivalent to synchronizing access to that underlying filesystem directory.\n\nLucene had relied on this at one point, but no longer does.  I'm not sure if any apps out there still rely on this, so it's dangerous to simply remove it, especially when we have another option (using a new method \"open\") that won't break such apps.\n\nMore, the mixing of cached and uncached dirs bring more problems (I am currently investigating).\n\nWe should get to the bottom of this, but these problems are pre-existing to this issue, right?  (One could already directly instantiate each directory).\n\nThe move from FSDir to SimpleFSDir is more complicated than it seems. In my opinion, it would be a question, if this move should wait until 3.0.\n\nAs long as we preserve the old getDirectory, back-compatible, this change should have no impact on back-compatibility.\n\nIe, it's only if you use the new FSDir.open() API that you get the new behavior.  I intentionally went and fixed tests to use FSDir.open so that we stress the new functionality, which then led us to discover tests making invalid assumptions, which we should then fix. ",
            "author": "Michael McCandless",
            "id": "comment-12714851"
        },
        {
            "date": "2009-05-31T11:05:38+0000",
            "content": "bq The original purpose of the cache was to ensure each unique directory in the filesystem alway mapped to a single instance of FSDir, so that you could synchronize on that instance and be certain that this is equivalent to synchronizing access to that underlying filesystem directory.\n\nIn my opinion, the cached directories vs. instantiated directories have one big advantage:\nThey are forced to use the same locking mechanism. So if somebody creates a directory using one LockFactory, writes to the index and in a parallel thread uses another locking mechanism with a separate dir instance, he corrupts his index. So from that point of view, only have one directory instance per resource is a good thing (it does not work from different JVM processes, sure).\n\nIe, it's only if you use the new FSDir.open() API that you get the new behavior. I intentionally went and fixed tests to use FSDir.open so that we stress the new functionality, which then led us to discover tests making invalid assumptions, which we should then fix.\n\nThis is correct. For unit testing, I found out now, that it is much simplier to check, if all tests would also work with other platforms, if you set the FSDir system property when running the tests. With open() this is currently not possible.\n\nMaybe I un-comment-out the caching again, but let getDirectory still use the new behaviour, if the system property is not set. We could then in 3.0 just remove the caching, but let getDirectory() alive. I am not sure.\n\nIn my opinion, this is not really a more serious bw-change than a small behaviour change, that can be written into CHANGES.txt. We have more serious ones.\n\nI would strongly tend to remove the cache at all and write a warning into CHANGES.txt.\n\nAt all, I do not really think anybody has implemented an own subclass of FSDir. The current patch's bw-change is more, that the protected no-arg ctors no longer exist and are no longer used. ",
            "author": "Uwe Schindler",
            "id": "comment-12714853"
        },
        {
            "date": "2009-05-31T11:21:53+0000",
            "content": "\nIn my opinion, the cached directories vs. instantiated directories have one big advantage:\nThey are forced to use the same locking mechanism. So if somebody creates a directory using one LockFactory, writes to the index and in a parallel thread uses another locking mechanism with a separate dir instance, he corrupts his index. So from that point of view, only have one directory instance per resource is a good thing (it does not work from different JVM processes, sure).\n\nI agree.\n\nBut, I don't think this is a strong enough reason for Lucene to be\ndoing such magic under-the-hood, going forward.  This magic leads to\nother problems (like LUCENE-1453).\n\n\n> Ie, it's only if you use the new FSDir.open() API that you get the new behavior. I intentionally went and fixed tests to use FSDir.open so that we stress the new functionality, which then led us to discover tests making invalid assumptions, which we should then fix.\n\nThis is correct. For unit testing, I found out now, that it is much simplier to check, if all tests would also work with other platforms, if you set the FSDir system property when running the tests. With open() this is currently not possible.\n\nExcellent!\n\nBefore committing we should confirm all tests pass if we temporarily\nhardwire open to return each of the 3 FSDir impls.\n\nBut I don't think this is reason enough to leave the global system\nproperty in place for real usage of Lucene.\n\n\nMaybe I un-comment-out the caching again, but let getDirectory still use the new behaviour, if the system property is not set. We could then in 3.0 just remove the caching, but let getDirectory() alive. I am not sure.\n\nBut you've still unnecessarily broken back-compat with that.  By\nmaking a new method (open), which does neither the magic singleton\ncaching nor the global system prop, back-compat users are guaranteed\nto see no changes.\n\n\nIn my opinion, this is not really a more serious bw-change than a small behaviour change, that can be written into CHANGES.txt. We have more serious ones.\n\nI would strongly tend to remove the cache at all and write a warning into CHANGES.txt.\n\nAt all, I do not really think anybody has implemented an own subclass of FSDir. The current patch's bw-change is more, that the protected no-arg ctors no longer exist and are no longer used.\n\nWhy take that chance unnecessarily?  What are we gaining by changing\ngetDirectory so much in place, vs switching to a new (open) API?  It's\nentirely possible apps have subclassed FSDir, rely on the singleton\ncache and rely on the global system prop.  Making a new API, and\ndeprecating in favor of that, won't affect back-compat users at all. ",
            "author": "Michael McCandless",
            "id": "comment-12714855"
        },
        {
            "date": "2009-05-31T14:00:36+0000",
            "content": "I am not so happy , but I work on it.\n\nCurrently my problem is more a failure for the test in LUCENE-1453. After reopening a DirectoryIndexReader, sometimes (not always) the directory is closed, even with the 1453-workaround.\n\nThis failure depends on the random seed in testFSDirectoryReopen2() and is reproducible also with the current version of FSDirectory. It seems that 1453 is not completely fixed. I am looking now since 5 hourcs and cannot find the error, the code consists of a lot of printlns and so on. \n\nWhen I found out, what the problem is, I will perhaps open an additional issue, but it seems, that the problem has to do with the FSDirectory changes. Somewhere the directory is closed, although it should be stay open. But what I can say: The error is simplier to reproduce, if the directory is not cached!\n\nI have a lot of other fixes for the failing tests on some platforms, I will post a revised patch some time with getDirectory deprecated and open() again.\n\nOne thing: For investigating this bug, I changed the IndexReader.open() methods to use a non-cached directory. I think we should do this in the final version, too (also for Indexwriter). So also replace FSDir.getDirectory() by open for all these ctors and opens() that get a String with the index directory. If we do not want to do this, I suggest to deprecate all these methods and tell the user to open the directory themselfes and pass Directory instances to Writer/Reader. This would help cleaning up the code immense later, because we can remove all these closeDirectory checks/pass-throughs everywhere, which are silly... This makes the code completely not-understandable. In my opinion, one should open/close the directory himself and close it after usage. ",
            "author": "Uwe Schindler",
            "id": "comment-12714864"
        },
        {
            "date": "2009-05-31T14:15:28+0000",
            "content": "\nI am not so happy , but I work on it.\n\nI am looking now since 5 hourcs and cannot find the error, the code consists of a lot of printlns and so on. \n\nWe can tag-team if you want   Let me know if you want me to take over...\n\nThis failure depends on the random seed in testFSDirectoryReopen2() and is reproducible also with the current version of FSDirectory. It seems that 1453 is not completely fixed.\n\nYikes \u2013 you mean there's a pre-existing issue with the fix in LUCENE-1453, before this issue was committed?  I agree that code is very spooky, and I'll be very happy once we remove (in 3.0) the cache/refCounting done by FSDir.getDirectory....\n\nIf we do not want to do this, I suggest to deprecate all these methods and tell the user to open the directory themselfes and pass Directory instances to Writer/Reader\n\nI like this (deprecating the open methods that take File/String) best!\n\nI have a lot of other fixes for the failing tests on some platforms, I will post a revised patch some time with getDirectory deprecated and open() again.\n\nOK thanks. ",
            "author": "Michael McCandless",
            "id": "comment-12714865"
        },
        {
            "date": "2009-05-31T14:32:13+0000",
            "content": "Yikes - you mean there's a pre-existing issue with the fix in LUCENE-1453, before this issue was committed? I agree that code is very spooky, and I'll be very happy once we remove (in 3.0) the cache/refCounting done by FSDir.getDirectory....\n\nThe problem is not really the caching/refcounting. The reopen code sometimes seems to close the directory, even than it should not. There is no difference if the directory is cached (and the number of opens() is tracked by refCount) or standalone. The problem is that SegmentReader's readNorms() hits AlreadyClosedException then...\n\nThe interesting thing is that ou can more easy reproduce it with stand-alone dirs (because I removed the caching, you know). The 1453 fix is also needed for stand-alone dirs (so everytime codeDirectory=true), because, if they are closed during an error/whatever, the same happens. It does not happen so easy with cached dirs, because the old reader is normally closed after the new reopened one, so during the reopen, the refcount is big enough.\n\nIn my opinion, the only good solution is to remove the whole directory-close stuff from readers/writers in 3.0, as said before. And this can be done by removing the string-type dir arguments from Reader/Writer. And: As these use currently FSDir.getDirectory() they should be changed to FSDir.open() or deprecated, I tend to the last one. ",
            "author": "Uwe Schindler",
            "id": "comment-12714866"
        },
        {
            "date": "2009-05-31T14:39:34+0000",
            "content": "To conclude:\nThe error, I found is only relevant, if the string-type dir arguments to IndexReader are passed to FSDir.open() and are separate instances without refcounting. The reopen code sometimes closes the directory, although it should not, which leads to problems, if the directories are separate instances.\nWith cached dirs, its no problem. So if we deprecate the string directory arguments and inside that methods let FSDir.getDirectory() stay alive, we have no problem. In 3.0, one could then remove all this code like refcounting/changing dirs and the everywhere arguments closeDirectory in SegmentReader/DirectoryIndexReader/MultiSegmentReader/... Then 1453 is completely solved. ",
            "author": "Uwe Schindler",
            "id": "comment-12714869"
        },
        {
            "date": "2009-05-31T16:06:01+0000",
            "content": "This patch fixes the failing tests and contains the other improvements. ",
            "author": "Uwe Schindler",
            "id": "comment-12714890"
        },
        {
            "date": "2009-05-31T16:13:35+0000",
            "content": "Previous patch missed correct ctor for SimpleFSDir for reflection. ",
            "author": "Uwe Schindler",
            "id": "comment-12714892"
        },
        {
            "date": "2009-05-31T16:39:11+0000",
            "content": "Patch looks good, thanks Uwe!\n\nI still see failures when I use MMapDir (some tests are assuming they'll always get an FSDir).\n\nI can tackle these if you haven't already? ",
            "author": "Michael McCandless",
            "id": "comment-12714897"
        },
        {
            "date": "2009-05-31T17:09:40+0000",
            "content": "I think I forgot them when I reverted my changes. Currently I am running the tests again with MMap and after that with NIO. ",
            "author": "Uwe Schindler",
            "id": "comment-12714901"
        },
        {
            "date": "2009-05-31T17:15:01+0000",
            "content": "Oh shit, on windows, a very lot of tests are failing with MMap. Windows says, you cannot delete or modify files, which have a mapping, with Solaris it works without problems:\ne.g. TestAtomicUpdates:\n    [junit] C:\\Projects\\lucene\\trunk\\build\\test\\19.cfs_12.cfs (Der Vorgang ist\nbei einer Datei mit einem ge\u00f6ffneten Bereich, der einem Benutzer zugeordnet ist,\n nicht anwendbar)\n\nThis is the problem on windows: http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=4724038\n\nThe problem is, that a memory mapped area is not released on close() in Java, it is released, when GC frees it.\nSo the problem may be that MMap can only be used for reading indexes (so only read-only IndexReaders) on windows.\n\nWhat should we do, again disable MMap and only use NIOFSDir? ",
            "author": "Uwe Schindler",
            "id": "comment-12714902"
        },
        {
            "date": "2009-05-31T20:15:14+0000",
            "content": "a very lot of tests are failing with MMap.\n\nIt looks like all but one (see below) of the failures are \"innocent\",\neg the test hits an exception while cleaning up (removing the index\ndirectory it had created), or the test is trying to overwrite a file.\n\nI agree this will be a hassle for normal usage of Lucene, so let's\nchange the default on Win64 to SimpleFSDir (can't be NIOFSDir because\nof another Sun bug).  So, for open(), on non-Windows 32 bit we use\nNIOFSDir, on non-Windows 64 bit we use MMapDir, and on Windows 32 or\n64 we use SimpleFSDir.  Crazy how many challenges there are with IO on\nWindows from Java...\n\nThis is the problem on windows: http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=4724038\n\nSheesh that's alot of votes!\n\nCan you add that bug into the toplevel javadocs of FSDir explaining\nwhy MMapDir is not a great choice on even Win64?\n\nThere was one odd failure I noticed, on Win64 when running tests from\na mounted remote (CIFS) drive:\n\n\n    [junit] Testcase: testIndexAndMerge(org.apache.lucene.index.TestDoc):\tFAILED\n    [junit] junit.framework.AssertionFailedError:\n    [junit] \tat org.apache.lucene.index.FieldsWriter.addRawDocuments(FieldsWriter.java:249)\n    [junit] \tat org.apache.lucene.index.SegmentMerger.mergeFields(SegmentMerger.java:350)\n    [junit] \tat org.apache.lucene.index.SegmentMerger.merge(SegmentMerger.java:139)\n    [junit] \tat org.apache.lucene.index.SegmentMerger.merge(SegmentMerger.java:116)\n    [junit] \tat org.apache.lucene.index.TestDoc.merge(TestDoc.java:182)\n    [junit] \tat org.apache.lucene.index.TestDoc.testIndexAndMerge(TestDoc.java:117)\n    [junit] \tat org.apache.lucene.util.LuceneTestCase.runTest(LuceneTestCase.java:88)\n\n\n\nI dug down and found that this test illegally opens SegmentReaders on\nfiles that IndexWriter still has open for writing, and somehow this\ncauses problems when using an MMapDir.  I'll open a separate issue and\nput details there. ",
            "author": "Michael McCandless",
            "id": "comment-12714921"
        },
        {
            "date": "2009-05-31T20:31:36+0000",
            "content": "I dug down and found that this test illegally opens SegmentReaders on files that IndexWriter still has open for writing, and somehow this causes problems when using an MMapDir. I'll open a separate issue and\nput details there.\n\nThis is a NIO bug in windows, I assume. In Google I found a report at sun about this, too. Mapped buffers from UNC-pathes have wrong bytes in their buffer.\n\nBy the way, the other failing tests are easy to fix:\nSome tests check, if the IndexInput throws an IOException when reading past eof. When doing this with a Byte buffer, the get() throws an BufferUnderflowException. It can be fixed like this in MMapIndexInputs:\n\n    public byte readByte() throws IOException {\n      try {\n        return buffer.get();\n      } catch (BufferUnderflowException e) {\n        throw new IOException(\"read past eof\");\n      }\n    }\n\n\n\nThe other failures are harmless, but it would be good to fix them. I am working on that and then test extensive.\n\nThe problem with not freeing the buffer can be fixed on windows using the bad hack with this sun.misc.Cleaner class and PrivilegedAction (described in the bug report), but this depends on Sun's internals and works only with Sun's JRE. And it may fail on some under-priviledged environments like web containers.\n\nBut nevertheless, with this bad hack, my local version works now without any failing test on Win32 using MMap. ",
            "author": "Uwe Schindler",
            "id": "comment-12714925"
        },
        {
            "date": "2009-05-31T21:49:14+0000",
            "content": "Atached is a patch that now works (at least on windows) for all three versions of FSDir. One additional test was fixed to SimpleFSDir (because it assumesan BufferedIndexInput).\n\nThis patch contains the tweaked MMapDir that has the following features:\n\n\tThrows correct IOExceptions on read past EOF\n\tIs able to unmap the buffer when close is called (for cloned inputs nothing is done, this is similar to other FSDirs). This unmapping is an \"illegal and unsecure hack\" according to Sun, but I have seen other open source projects, that use it.\n\n\n\nThe problems with unmapping are: It may fail on specific non-Sun VMs and may hit SecurityExceptions. If this happens, the close() call will throw an IOException. The good thing is: The virtual memory usage is lower and with small indexes, the 32 bit VMs do not hit OOMs, if buffers are not unmapped by GC early.\n\nWhat do you think? Should we supply this \"extended\" MMapDirectory?\nEarwin, did you try this, too?\n\nAll tests pass now  JUHU! ",
            "author": "Uwe Schindler",
            "id": "comment-12714931"
        },
        {
            "date": "2009-05-31T22:41:36+0000",
            "content": "Some cleanups with initOutput (remove duplicate code) and unneeded methods in MMapDir.\nAll tests pass. Will try tomorrow also on Solaris x64 with MMap. ",
            "author": "Uwe Schindler",
            "id": "comment-12714934"
        },
        {
            "date": "2009-06-01T00:39:14+0000",
            "content": "All tests pass now  JUHU!\n\nExcellent!\n\nIt may fail on specific non-Sun VMs and may hit SecurityExceptions. If this happens, the close() call will throw an IOException.\n\nI think we should do the hack.  It seems better than nothing.\n\nBut: I think we shouldn't throw an exception if the hack fails?  Ie, just fallback to relying on GC to eventually unmap?  (What MMapDir does today).\n\nAnd then we can make the default on Windows 64 be MMapDir again?\n\nAlso, can you reference this bug from FSDir's/MMapDir's javadocs? ",
            "author": "Michael McCandless",
            "id": "comment-12714946"
        },
        {
            "date": "2009-06-01T00:54:46+0000",
            "content": "I'm seeing this failure:\n\n    [junit] Testcase: testIndexInputMethods(org.apache.lucene.store.TestMMapDirectory):\tFAILED\n    [junit] FSDirectory has method public org.apache.lucene.store.IndexInput org.apache.lucene.store.FSDirectory.openInput(java.lang.String) throws java.io.IOException but MMapDirectory does not override\n    [junit] junit.framework.AssertionFailedError: FSDirectory has method public org.apache.lucene.store.IndexInput org.apache.lucene.store.FSDirectory.openInput(java.lang.String) throws java.io.IOException but MMapDirectory does not override\n    [junit] \tat org.apache.lucene.store.TestMMapDirectory.testIndexInputMethods(TestMMapDirectory.java:43)\n    [junit] \tat org.apache.lucene.util.LuceneTestCase.runTest(LuceneTestCase.java:88)\n\nI think we should fix the test to make an exception... ",
            "author": "Michael McCandless",
            "id": "comment-12714949"
        },
        {
            "date": "2009-06-01T05:49:45+0000",
            "content": "I think we should fix the test to make an exception...\n\nI removed the test completely here, but forgot to include this into the patch. The test is now invalid with the new class hierarchy of FSDir. If FSDir gets abstract in 3.0, it is clear which methods need to be overridden and so on. The intention behind the test was, to check, if MMap does not overwrite all FSDir Methods, and because of this one of the calls could falsely return the standard FSDir impl of IndexInput. After Lucene 3.0, this is not possible, as MMapDir does not extend SimpleFSDir.\n\nIf we remove the test and then backwards-tag tests fail because of this, we could easily fix this by adding the method, simply calling super(). Or remove the test in backwards-tag, too.\n\n\nBut: I think we shouldn't throw an exception if the hack fails? Ie, just fallback to relying on GC to eventually unmap? (What MMapDir does today).\n\nAnd then we can make the default on Windows 64 be MMapDir again?\n\nAlso, can you reference this bug from FSDir's/MMapDir's javadocs?\n\nGood idea. The problem is, if the hack fails, IndexReader may suddenly fail later on windows to delete files. Or was this only a problem in the tests. What happens, if e.g. IndexWriter wants to write a new segments.gen file and so on, but it is still mmapped? So I preferred to throw the IOException, but I can disable this easily.\n\nI would suggest to check on windows, if class sun.misc.Cleaner is available and if not, return SimpleFSDir. For Unix, it is enough to simply ignore the cleanup (throw no exception). ",
            "author": "Uwe Schindler",
            "id": "comment-12714983"
        },
        {
            "date": "2009-06-01T07:48:52+0000",
            "content": "I told you, Java mmap doesn't work on Windows.\nAnd please, don't use the unmap hack! If it doesn't work, it doesn't work. Let's for all windows versions use SimpleFSD.\nLook, what are you going to do if you unmap a buffer and then access it by accident? Crash JVM? ",
            "author": "Earwin Burrfoot",
            "id": "comment-12715008"
        },
        {
            "date": "2009-06-01T07:52:10+0000",
            "content": "The buffer is nulled directly after unmapping. ",
            "author": "Uwe Schindler",
            "id": "comment-12715011"
        },
        {
            "date": "2009-06-01T08:08:04+0000",
            "content": "Here the patch with conditionalized MMapDirectory on windows. I am a bit nervous...\nWe should discuss it a little bit and commit it. But everybody should test it extensive before releasing!\nUsers still using FSDir.getDirectory would not be affected, so it would not break existing apps. ",
            "author": "Uwe Schindler",
            "id": "comment-12715015"
        },
        {
            "date": "2009-06-01T08:14:22+0000",
            "content": "The buffer is nulled directly after unmapping. \nReally? Let me quote some code (MacOS, Java 1.6):\n\nunsafe.freeMemory(address);\naddress = 0;\nBits.unreserveMemory(capacity);\n\nDoes windows version differ? What we see here is 'zeroing', not 'nulling'. When doing get/set, buffer never checks for address to have sense, so the next access will yield a GPF \nThe guys from Sun explained the absence of unmap() in the original design - the only way of closing mapped buffer and not getting unpredictable behaviour is to introduce a synchronized isClosed check on each read/write operation, which kills the performance even if the sync method used is just a volatile variable. ",
            "author": "Earwin Burrfoot",
            "id": "comment-12715016"
        },
        {
            "date": "2009-06-01T08:15:14+0000",
            "content": "Updated patch: I forgot to add a check, if the IndexInput was already closed. ",
            "author": "Uwe Schindler",
            "id": "comment-12715017"
        },
        {
            "date": "2009-06-01T08:18:44+0000",
            "content": "Ah! You was referring to your code. It's not thread-safe still. Someone could access the closed buffer before it sees the now-null reference to it.\nYou also employ the hack on non-windows machines, that work quite well without it. What for? ",
            "author": "Earwin Burrfoot",
            "id": "comment-12715018"
        },
        {
            "date": "2009-06-01T08:20:46+0000",
            "content": "I know this code , its on every platform the same. For our MMapDirectory this is not a problem, as nobody can accidently read/write the buffer, because the reference to it is nulled in our code. The buffer member itsself is private, so nobody can access it from outside. So after closing the IndexInput, nothing can access the buffer.\nThis is what I meant with \"nulling\". ",
            "author": "Uwe Schindler",
            "id": "comment-12715019"
        },
        {
            "date": "2009-06-01T08:26:07+0000",
            "content": "You also employ the hack on non-windows machines, that work quite well without it. What for?\n\nIt uses less virtual memory \n\nAh! You was referring to your code. It's not thread-safe still. Someone could access the closed buffer before it sees the now-null reference to it. \n\nFor the thread-safety, youre correct. To solve this, we have to add the synchronized isClosed check on our side, which kills performance. I wanted to check, what happens, if somebody really accesses the buffer after unmapping, does it crash the JVM? ",
            "author": "Uwe Schindler",
            "id": "comment-12715020"
        },
        {
            "date": "2009-06-01T08:42:41+0000",
            "content": "I tested on MacOS:\n\nInvalid memory access of location 8b55a000 rip=0110c367\n\n\tHere JVM quietly dies. non-null return code, all threads are killed, no diagnostic files created.\n\n ",
            "author": "Earwin Burrfoot",
            "id": "comment-12715026"
        },
        {
            "date": "2009-06-01T08:44:14+0000",
            "content": "It uses less virtual memory \n64bit systems have an abundance of said valuable resource. Why taint them with dangerous hacks for the sake of zero returns? ",
            "author": "Earwin Burrfoot",
            "id": "comment-12715027"
        },
        {
            "date": "2009-06-01T09:23:21+0000",
            "content": "You are right, it is quite dangerous, if somebody e.g. closes an IndexReader in one thread and another thread still accesses it (this happens often). ",
            "author": "Uwe Schindler",
            "id": "comment-12715033"
        },
        {
            "date": "2009-06-01T09:58:22+0000",
            "content": "OK the hack now scares me!\n\nLet's just return SimpleFSDir on all Windows?  And, note this bug in the FSDir & MMapDir javadocs.\n\nAlso: I think we should fix the open logic so that on an unknown platform (not unix, not windows, not 64 bit), return SimpleFSDir? ",
            "author": "Michael McCandless",
            "id": "comment-12715038"
        },
        {
            "date": "2009-06-01T10:02:55+0000",
            "content": "I'm a bit nervous about creating MMapDirectory automatically for any OS, not just Windows. Imagine a large index which is suddenly mapped to MMB w/o anyone intending to do so.\n\nI think that because of the memory implications of using MMapDir we should let apps explicitly create it, and not under the covers, because of OS parameter. I think that using MMapDir goes far beyond just OS, and hence why it's dangerous to create it under the covers. ",
            "author": "Shai Erera",
            "id": "comment-12715040"
        },
        {
            "date": "2009-06-01T10:07:15+0000",
            "content": "I removed the test completely here, but forgot to include this into the patch.\n\nOK that makes sense.  When you commit this, you can also just remove the test from the back-compat branch...\n\nThe \"hack\" also saves transient disk space, on all systems, right?  Just because the file name link is deleted on Unix, the bytes are still consuming disk space.  So, Uwe in javadoc'ing Sun's bug, can you note  that the bug causes higher transient disk usage?  Maybe we all should go vote for the bug... but it seems our votes will be in the noise.  I'll go add this bug to http://wiki.apache.org/lucene-java/SunJavaBugs ",
            "author": "Michael McCandless",
            "id": "comment-12715042"
        },
        {
            "date": "2009-06-01T10:26:26+0000",
            "content": "I'm a bit nervous about creating MMapDirectory automatically for any OS, not just Windows. Imagine a large index which is suddenly mapped to MMB w/o anyone intending to do so.\n\nThis would not be a problem, because MMaped files does not \"consume\" real memory. If a part of the index is seen in \"real memory\" still is in the responsibility of the operating system. I have a mmaped index here that is updated very often. It leads to a lot of assigned address space in top for the process but does not affect system performance or swapping (sometimes beyond the physical limit of the machine (mem + swap). Memory mapping files does not consume RAM, it just consumes address space (this is why I changed the javadocs a little bit to clarify this).\n\nThe \"hack\" also saves transient disk space, on all systems, right? Just because the file name link is deleted on Unix, the bytes are still consuming disk space.\n\nYes, this is why I let the fix enabled for any OS.\n\nAlso: I think we should fix the open logic so that on an unknown platform (not unix, not windows, not 64 bit), return SimpleFSDir?\n\nI would not do this.\n\nNIO2 still has no solution for the problem. But they have a 64 bit buffer, so you could use it instead of many buffers. On the Amsterdam ApacheCon conference, this was part of the discussion with the guy from sun, but I forgot what the conclusion was! Maybe Oracle helps here \n\nMaybe we should move this hack to contrib ( a class that extends MMapDirectory by adding a close method) with a big warning! ",
            "author": "Uwe Schindler",
            "id": "comment-12715049"
        },
        {
            "date": "2009-06-01T10:58:00+0000",
            "content": "I'm a bit nervous about creating MMapDirectory automatically for any OS, not just Windows.\nIt's almost okay for 64bit systems.\n\nThe \"hack\" also saves transient disk space, on all systems, right?\nThat's a nice catch. Now I have some of the non-buggy-but-weird behaviour my app exhibits explained.\n\nBut they have a 64 bit buffer, so you could use it instead of many buffers.\nThey don't. When NIO2 project was merged into OpenJDK, they left some stuff unmerged, including 64bit buffers. Currently they aren't present in OpenJDK and Java7 preview builds, and not even a rough estimate is given on whether they are going to make it through, and when.\n\nMaybe we should move this hack to contrib ( a class that extends MMapDirectory by adding a close method) with a big warning!\nI support this. The hack has some merits if carefully applied, but is outright too dangerous to ship it as default. ",
            "author": "Earwin Burrfoot",
            "id": "comment-12715057"
        },
        {
            "date": "2009-06-01T11:09:04+0000",
            "content": "Perhaps I didn't phrase it well. I wasn't worried about memory consumption per sei, but the behavior. On a couple of projects I've worked in, they were very reluctant to having packages allocate memory outside the JVM, and that's my understanding of memory mapped buffers. So what worries me is that by calling FSDir.get()/open(), I will unknowingly do that ...\n\nWhile creating SimpleFSDir/NIOFSDir has smaller effect, I think this is not the case with MMapDir. But if you decide to include MMapDir in that auto-create logic, I hope there will be a way to instantiate a specific FSDir, in case we'll have problems with that logic. ",
            "author": "Shai Erera",
            "id": "comment-12715061"
        },
        {
            "date": "2009-06-01T11:14:25+0000",
            "content": "On a couple of projects I've worked in, they were very reluctant to having packages allocate memory outside the JVM, and that's my understanding of memory mapped buffers.\nmmap does not allocate memory. It allocates address space, and uses the same disk cache system already has.\nFor example, you can't cause OOM in your (or another co-existing) app with mmaps (except eating up your own address space on 32bit systems).\n\nBut if you decide to include MMapDir in that auto-create logic, I hope there will be a way to instantiate a specific FSDir, in case we'll have problems with that logic.\nPublic constructors for all D variants are a must, and for me they are the best that this patch has to offer  ",
            "author": "Earwin Burrfoot",
            "id": "comment-12715063"
        },
        {
            "date": "2009-06-01T12:30:12+0000",
            "content": "I'm thinking MMapDirectory is too problematic to return by default from open(), because of the unexpected increase transient disk usage.\n\nI think we should add the hack to MMapDir, disabled by default, and add a setter to enable it (with javadocs clear about the warnings).  When used appropriately it can make MMapdir very usable, as a workaround until Sun fixes the bug.\n\nSo I think we should:\n\n\n\tFix open to return NIOFSDir on all non-Windows plaforms, and SimpleFSDir on Windows\n\n\n\n\n\tDocument the sun bug in MMapDir & FSDir\n\n\n\n\n\tInclude hack in MMapDir, disabled by default\n\n ",
            "author": "Michael McCandless",
            "id": "comment-12715074"
        },
        {
            "date": "2009-06-01T13:05:44+0000",
            "content": "I am working on this, because I had the same idea. I added an method setUseUnmap(boolean) and getter to enable this. This method throws IAE if unmap is not supported on the platform.\nI also reenabled the IOException on close(), if there was an error during unmapping.\n\nJust one additional question: Should I add an additional ctor to the three classes, only taking the dir name, this would then be conformant to FSDir.open()? ",
            "author": "Uwe Schindler",
            "id": "comment-12715079"
        },
        {
            "date": "2009-06-01T13:34:31+0000",
            "content": "New patch with all suggestions, updated Javadocs, additional Ctors with path name only (like static open() method). I also corrected some deprecations and so on. MMapDirectory is no longer returned by open(), the logic is simple now: Windows -> Simple, other -> NIO\n\nIf everybody is fine, I will commit later! ",
            "author": "Uwe Schindler",
            "id": "comment-12715083"
        },
        {
            "date": "2009-06-01T14:54:44+0000",
            "content": "Looks good \u2013 thanks Uwe \u2013 a few small things:\n\n\n\n\tCan you remove the a/b from the LUCENE-1658 in CHANGES.txt?  (I\n    think it may confuse the changes-to-html generation)\n\n\n\n\n\tCan you point out that MMapDirectory will consume transient disk\n    space, regardless of platform, because of this sun bug?  Ie, this\n    bug is not just a \"you can't delete the files on Windows\"\n    problem; it's a problem for unix as well.  Maybe something like\n    this:\n    .\n    Due to <a href=\"http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=4724038\">this bug</a>\n    in Sun's JRE, MMapDirectory's IndexInput.close is unable to close\n    the underlying OS file handle.  Only when GC finally collects the\n    underlying objects, which could be quite some time later, will the file\n    handle be closed.\n    .\n    This will consume additional transient disk usage: on Windows,\n    attempts to delete or overwrite the files will result in an\n    exception; on other platforms, which typically have a \"delete on\n    last close\" semantics, while such operations will succeed, the bytes\n    are still consuming space on disk.  For many applications this\n    limitation is not a problem (eg if you have plenty of disk space,\n    and you don't rely on overwriting files on Windows) but it's still\n    an important limitation to be aware of.\n\n\n\n\n\tMaybe don't make MMapDir.cleanUnmapping final, so subclasses could\n    tweak it?  I'm still nervous about throwing IOException from that\n    method if the unmap fails, but if we make it non-final then we can\n    leave the IOException as is and users can subclass it if need be.\n\n\n\n\n\tCan you embed the try/catch inside cleanMapping within { }'s?  The\n    run-on (if -> try) is confusing now.\n\n\n ",
            "author": "Michael McCandless",
            "id": "comment-12715105"
        },
        {
            "date": "2009-06-01T15:12:09+0000",
            "content": "Maybe don't make MMapDir.cleanUnmapping final, so subclasses could tweak it? I'm still nervous about throwing IOException from that method if the unmap fails, but if we make it non-final then we can leave the IOException as is and users can subclass it if need be. \n\nI reactivated this exception (it was disabled before). In my opinion, we should enable it to notify the user on any problems (e.g. that he may must raise security privileges to enable it correctly). If the user hits an IOException, he can switch off the tweak easily. By the way, switching on the tweak throws IAE if the platform does not support it.\n\ncleanUnmapping is currently not really overrideable, because package-private. I can unfinal it and make protected, if needed (I wanted to hide this dangerous method from other usages, not that anyboy calls it for own ByteBuffers and crashes his JVM).\n\nI will do the other changes, no problem. ",
            "author": "Uwe Schindler",
            "id": "comment-12715110"
        },
        {
            "date": "2009-06-01T15:28:48+0000",
            "content": "bq I reactivated this exception (it was disabled before). In my opinion, we should enable it to notify the user on any problems (e.g. that he may must raise security privileges to enable it correctly). If the user hits an IOException, he can switch off the tweak easily. By the way, switching on the tweak throws IAE if the platform does not support it.\n\nYeah I agree it's good to be brittle, so one knows to raise security privileges.  But: how intermittent are the exceptions thrown from this code?  Is it a situation where it will always fail or always succeed?  In which case, I agree we can leave it as it is. ",
            "author": "Michael McCandless",
            "id": "comment-12715124"
        },
        {
            "date": "2009-06-01T17:49:26+0000",
            "content": "Attached a patch with all changes. I also reworked the exception part in the hack (use the correct PrivilegedException pass-through an init the cause of the IOException, so user knows, if e.g. the security settings were too low).\n\nI commit shortly. ",
            "author": "Uwe Schindler",
            "id": "comment-12715170"
        },
        {
            "date": "2009-06-01T17:51:26+0000",
            "content": "hrrrrrm, outdated patch. Missing was the a/b in changes, no fixed. ",
            "author": "Uwe Schindler",
            "id": "comment-12715173"
        },
        {
            "date": "2009-06-01T18:35:01+0000",
            "content": "Committed revision 780770 ",
            "author": "Uwe Schindler",
            "id": "comment-12715194"
        },
        {
            "date": "2009-06-01T19:58:55+0000",
            "content": "Uwe - I had code which did new FSDirectory(File, LockFactory), however that ctor is now protected, and my code does not compile. I didn't see any mentions about this in CHANGES. Since this break compat, I think we should either deprecate this ctor (revert it to public), or document in CHANGES under the \"changes to back-compat policy\". Right? ",
            "author": "Shai Erera",
            "id": "comment-12715222"
        },
        {
            "date": "2009-06-01T20:09:06+0000",
            "content": "This codeyou are mentioning was not yet released! So before 2.9 there was no ctor for FSDirectory that was public: http://lucene.apache.org/java/2_4_1/api/core/org/apache/lucene/store/FSDirectory.html\n\nBut SimpleFSDirectory can be instantiated. FSDirectory will get abstract in 3.0 and is only the base class and factory anymore. ",
            "author": "Uwe Schindler",
            "id": "comment-12715231"
        },
        {
            "date": "2009-06-01T20:17:26+0000",
            "content": "Ok. I did work against trunk, so that explains. Thanks ! (maybe we should start using @since in all future issues, to avoid the confusion) ",
            "author": "Shai Erera",
            "id": "comment-12715237"
        }
    ]
}