{
    "id": "SOLR-3608",
    "title": "Spellchecker: String index out of range: -1",
    "details": {
        "affect_versions": "3.6,                                            4.0-ALPHA",
        "status": "Open",
        "fix_versions": [],
        "components": [
            "spellchecker"
        ],
        "type": "Bug",
        "priority": "Minor",
        "labels": "",
        "resolution": "Unresolved"
    },
    "description": "Spell check component throws StringIndexOutOfBoundsException on multiterm search.\n\nStack trace: \n\nSEVERE: java.lang.StringIndexOutOfBoundsException: String index out of range: -1\n\tat java.lang.AbstractStringBuilder.replace(AbstractStringBuilder.java:789)\n\tat java.lang.StringBuilder.replace(StringBuilder.java:266)\n\tat org.apache.solr.spelling.SpellCheckCollator.getCollation(SpellCheckCollator.java:128)\n\tat org.apache.solr.spelling.SpellCheckCollator.collate(SpellCheckCollator.java:69)\n\tat org.apache.solr.handler.component.SpellCheckComponent.addCollationsToResponse(SpellCheckComponent.java:179)\n\tat org.apache.solr.handler.component.SpellCheckComponent.process(SpellCheckComponent.java:156)\n\tat org.apache.solr.handler.component.SearchHandler.handleRequestBody(SearchHandler.java:186)\n\tat org.apache.solr.handler.RequestHandlerBase.handleRequest(RequestHandlerBase.java:129)\n\tat org.apache.solr.core.SolrCore.execute(SolrCore.java:1376)\n\n...\n\n\n\nI have dug some debug info at org.apache.solr.spelling.SpellCheckCollator:69\n\n      String collationQueryStr = getCollation(originalQuery, possibility.getCorrections());\n\n\noriginalQuery is \"casa saja\"\npossibility is \"rank=0     casa>cal (-1)     saja>sala (-1)     casa saja>casa de (-1)\"\n\nThe replace function fails on 3rd correction \"casa saja>casa de (-1)\". I hope this makes any sense.",
    "attachments": {},
    "issue_links": {},
    "comments": [
        {
            "author": "James Dyer",
            "id": "comment-13409591",
            "date": "2012-07-09T16:00:39+0000",
            "content": "It looks like you're using shingles to try to get it to correct whole phrases, right?  I'm curious if you've written a custom QueryConverter to handle this, or if you use \"spellcheck.q\" to bypass using a QueryConverter at all.  But in the end, I think its safe to say that the collation feature won't work well with a shingle dictionary.\n\nYou might be able to get it to do what you want without using shingles...Have you looked at the \"maxCollationTries\" parameter? (see http://wiki.apache.org/solr/SpellCheckComponent#spellcheck.maxCollationTries).  Also, if you need it to correct word-break misspellings take a look at SOLR-2993, which is included in Solr4.0-Alpha.\n\nEven if you're using shingles, I do think we should do something to fix this.  At the least it should fail gracefully and not throw AIOOB.  On the other hand the case involving shingles is more of a \"minor\" bug.  Certainly not a \"blocker\", which means it needs to be fixed or it would hold up the next release.  Agree? "
        },
        {
            "author": "dalius",
            "id": "comment-13409617",
            "date": "2012-07-09T16:33:12+0000",
            "content": "Hello, I am not using shingles. There is my fieldTypes:\n\n\n    <fieldType name=\"text_general\" class=\"solr.TextField\" positionIncrementGap=\"100\">\n      <analyzer type=\"index\">\n        <tokenizer class=\"solr.PatternTokenizerFactory\" pattern=\"\\.|,|;|\\?|!|\\s+\" />\n        <filter class=\"solr.ICUFoldingFilterFactory\"/>\n      </analyzer>\n      <analyzer type=\"query\">\n        <tokenizer class=\"solr.PatternTokenizerFactory\" pattern=\"\\.|,|;|\\?|!|\\s+\" />\n        <filter class=\"solr.ICUFoldingFilterFactory\"/>\n      </analyzer>\n    </fieldType>\n\n    <fieldType name=\"xml\" class=\"solr.TextField\" positionIncrementGap=\"100\">\n      <analyzer type=\"index\">\n        <charFilter class=\"solr.HTMLStripCharFilterFactory\"/>\n        <tokenizer class=\"solr.StandardTokenizerFactory\"/>\n        <filter class=\"solr.ICUFoldingFilterFactory\"/>\n      </analyzer>\n      <analyzer type=\"query\">\n        <tokenizer class=\"solr.StandardTokenizerFactory\"/>\n        <filter class=\"solr.ICUFoldingFilterFactory\"/>\n      </analyzer>\n    </fieldType>\n\n    <fieldType name=\"xml_whitespace_token\" class=\"solr.TextField\" positionIncrementGap=\"100\">\n      <analyzer type=\"index\">\n        <charFilter class=\"solr.HTMLStripCharFilterFactory\"/>\n        <tokenizer class=\"solr.WhitespaceTokenizerFactory\"/>\n        <filter class=\"solr.ICUFoldingFilterFactory\"/>\n      </analyzer>\n      <analyzer type=\"query\">\n        <tokenizer class=\"solr.WhitespaceTokenizerFactory\"/>\n        <filter class=\"solr.ICUFoldingFilterFactory\"/>\n      </analyzer>\n    </fieldType>\n\n\n\nNo special query converter was written. I just pass the query string \"casa saja\" to my request handler.\n\n?spellcheck=on&start=0&q=casa+saja&spellcheck.collate=true&rows=10&version=2\n\n\n\nThis is my request handler:\n\n    <requestHandler name=\"search\" class=\"solr.SearchHandler\" default=\"true\">\n         <lst name=\"defaults\">\n           <str name=\"echoParams\">all</str>\n           <str name=\"defType\">edismax</str>\n           <str name=\"mm\">2&lt;-25%</str>\n           <str name=\"hl\">true</str>\n           <str name=\"hl.fl\">\n              search_dc_title\n              search_title\n              search_phrases\n              search_definitions\n              search_full_definitions\n              search_examples\n              search_works\n              search_bibliographies\n              search_theme\n              search_date_of_birth\n              search_date_of_death\n              search_state_of_birth\n              search_state_of_death\n              search_place_of_birth\n              search_place_of_death\n              search_photographies\n           </str>\n           <str name=\"hl.fragsize\">500</str>\n           <str name=\"qf\">\n              search_dc_title^3\n              search_title\n              search_phrases\n              search_definitions\n              search_full_definitions\n              search_examples\n              search_works\n              search_bibliographies\n              search_theme\n              search_date_of_birth\n              search_date_of_death\n              search_state_of_birth\n              search_state_of_death\n              search_place_of_birth\n              search_place_of_death\n              search_photographies\n           </str>\n           <int name=\"rows\">10</int>\n           <str name=\"sort\">score desc, weight desc</str>\n           <str name=\"spellcheck.onlyMorePopular\">true</str>\n           <str name=\"spellcheck.extendedResults\">false</str>\n           <str name=\"spellcheck.count\">1</str>\n         </lst>\n        <arr name=\"last-components\">\n          <str>spellcheck</str>\n        </arr>\n    </requestHandler>\n\n\n\nAll these fields are either text_general, xml or xml_whitespace_token type. "
        },
        {
            "author": "James Dyer",
            "id": "comment-13409651",
            "date": "2012-07-09T17:15:48+0000",
            "content": "From solrconfig.xml, can you paste here what you've got in this block:\n <searchComponent name=\"...\" class=\"solr.SpellCheckComponent\" />\nAnd also this block, if it exists:\n <queryConverter />\n?\n\nAlso, can you set \"spellcheck.collate=false\" and \"spellcheck.extendedResults=true\", run the query again, then paste in the spellcheck response?\n\nWhat is confusing me is that you said for the 2-word query \"casa saja\", it is trying to make 3 word corrections:\n1. casa>cal \n2. saja>sala\n3. casa saja>casa de\nThis third one doesn't make sense because SpellingQueryConverter breaks your query up on whitespace.  Also, it seems your fields are all tokenized on whitespace.  So for the spellchecker to try replacing the whole phrase as if it is a single token, it doesn't add up. "
        },
        {
            "author": "dalius",
            "id": "comment-13410184",
            "date": "2012-07-10T09:46:02+0000",
            "content": "My bad. I told that there are no query converter, but actually there is one...\n\npublic class MultiTermQueryConverter extends SpellingQueryConverter {\n    private static Joiner space = Joiner.on(' ');\n    \n    @Override\n    public Collection<Token> convert(String original) {\n        if (original == null) { // this can happen with q.alt = and no query\n            return Collections.emptyList();\n        }\n        Collection<Token> convert = super.convert(original);\n        if(convert.size() > 1){\n            String joined = space.join(convert);\n            int min = 100, max = 0;\n            for(Token t : convert){\n               min = Math.min(min, t.startOffset());\n               max = Math.max(max, t.endOffset());\n            }\n            convert.add(new Token(joined, min, max));\n        }\n        return convert;\n    }\n}\n\n\n\n\n  <searchComponent class=\"solr.SpellCheckComponent\" name=\"suggest\">\n    <lst name=\"spellchecker\">\n      <str name=\"name\">suggest</str>\n      <str name=\"classname\">org.apache.solr.spelling.suggest.Suggester</str>\n      <str name=\"lookupImpl\">org.apache.solr.spelling.suggest.tst.TSTLookup</str>\n      <!-- Alternatives to lookupImpl: \n           org.apache.solr.spelling.suggest.fst.FSTLookup   [finite state automaton]\n           org.apache.solr.spelling.suggest.jaspell.JaspellLookup [default, jaspell-based]\n           org.apache.solr.spelling.suggest.tst.TSTLookup   [ternary trees]\n      -->\n      <str name=\"field\">suggest</str>  <!-- the indexed field to derive suggestions from -->\n      <float name=\"threshold\">0.00001</float>\n      <str name=\"buildOnOptimize\">true</str>\n      <str name=\"buildOnCommit\">false</str>\n    <!--   <str name=\"sourceLocation\">spellings.txt</str> -->\n    </lst>\n  </searchComponent>\n\n\n\nIt adds additional token that is a join of all tokens separating with space. Shouldn't it just ignore the token that can not be replaced instead?\n\nSorry for that. "
        },
        {
            "author": "James Dyer",
            "id": "comment-13410396",
            "date": "2012-07-10T14:49:57+0000",
            "content": "I'm not sure what your QueryConverter is supposed to do as I'm not at all familiar with how you need to set up the spellchecker to use it for autosuggest (as it appears you're doing).  You should probably re-post a summary of all this one the solr-user mailing list to get more help.  (you might also want to see this overview:  http://stackoverflow.com/questions/10547438/solr-returns-only-one-collation-for-suggester-component)\n\nMy understanding is that the \"collate\" functionality was only designed to work with \"normal\" query converters.  So if you throw shingled phrases at it from a custom query converter all bets are off.  I also think when people use shingles like this it is because they are trying to work around the limitations of \"collate\", and not use it at all.  But many of these limitations have been removed, particularly with the addition of \"maxCollationTries\".  But see SOLR-3240, which aims in improving the performance of \"maxCollationTries\" so that it would be more useful in an autosuggest situation.\n\nI think for the purposes of this JIRA issue, we need to make the spell check collator more resilient when users throw funny things at it, like in this case.  At the least it shouldn't throw an exception.  Maybe it could log a warning in some cases and others be more capable and actually produce a good collation.  In the \"casa saja\" case, it could just throw out the 3rd replacement and go on with life. "
        },
        {
            "author": "James Dyer",
            "id": "comment-13410397",
            "date": "2012-07-10T14:51:10+0000",
            "content": "Changing to \"minor\" as this is just a manifestation with a longstanding limitation of the \"collate\" functionality.  But we should improve it, so leaving the issue open and adding 4.0 as an \"affected\" version. "
        }
    ]
}