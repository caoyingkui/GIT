{
    "id": "SOLR-12371",
    "title": "SecurityConfHandlerLocal fails to read back security.json meta version (SecurityConfig.getVersion() always -1), never increased",
    "details": {
        "labels": "",
        "priority": "Major",
        "components": [
            "JSON Request API",
            "security"
        ],
        "type": "Bug",
        "fix_versions": [],
        "affect_versions": "6.6.3",
        "resolution": "Unresolved",
        "status": "Open"
    },
    "description": "Hello again,\n\nWe use 6.6.3 and I was trying to update my security.json (in solr home, non-zookeeper) using:\n\ncurl -u myuser:mypass -H 'Content-type:application/json' -d '{\"set-user-role\":{\"dummy\":\"dummy\"}}' http://localhost:8080/solr/admin/authorization\n\n\nThe first time this is called, the security.json is written AND reloaded in memory correctly. The output json then contains at the end:\n\n\"\":{\"v\":0}\n\n\nHowever, subsequent calls using the same command, no matter the users specifed, always output the same meta version, 0.\n\nThe result is that the the security.json file is correctly updated, but the RuleBasedAuthorizationPlugin is never reloaded in memory, so the new settings never take effect.\n\nThe version never increases, so this condition in org.apache.solr.core.CoreContainer.initializeAuthorizationPlugin always returns and memory plugin reload is skipped:\n\nif (old != null && old.getZnodeVersion() == readVersion(authorizationConf)) {\n  return;\n}\n\n\nThe core of the issue is somewhere in org.apache.solr.handler.admin.SecurityConfHandler.doEdit:\n\n\u00a0\u00a0\u00a0\u00a0\u00a0 SecurityConfig securityConfig = getSecurityConfig(true);\n\u00a0\u00a0\u00a0\u00a0\u00a0 Map<String, Object> data = securityConfig.getData();\n\u00a0\u00a0\u00a0\u00a0\u00a0 Map<String, Object> latestConf = (Map<String, Object>) data.get(key);\n\u00a0\u00a0\u00a0\u00a0\u00a0 if (latestConf == null) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 throw new SolrException(SERVER_ERROR, \"No configuration present for \" + key);\n\u00a0\u00a0\u00a0\u00a0\u00a0 }\n\u00a0\u00a0\u00a0\u00a0\u00a0 List<CommandOperation> commandsCopy = CommandOperation.clone(ops);\n\u00a0\u00a0\u00a0\u00a0\u00a0 Map<String, Object> out = configEditablePlugin.edit(Utils.getDeepCopy(latestConf, 4) , commandsCopy);\n\u00a0\u00a0\u00a0\u00a0\u00a0 if (out == null) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 List<Map> errs = CommandOperation.captureErrors(commandsCopy);\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 if (!errs.isEmpty()) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 rsp.add(CommandOperation.ERR_MSGS, errs);\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 return;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 }\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 log.debug(\"No edits made\");\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 return;\n\u00a0\u00a0\u00a0\u00a0\u00a0 } else {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 if(!Objects.equals(latestConf.get(\"class\") , out.get(\"class\"))){\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 throw new SolrException(SERVER_ERROR, \"class cannot be modified\");\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 }\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 Map meta = getMapValue(out, \"\");\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 meta.put(\"v\", securityConfig.getVersion()+1);//encode the expected zkversion\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 data.put(key, out);\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 if(persistConf(securityConfig)) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 securityConfEdited();\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 return;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 }\n\u00a0\u00a0\u00a0\u00a0\u00a0 }\n\n\nIn my case, getSecurityConfig(true) delegates to org.apache.solr.handler.admin.SecurityConfHandlerLocal.getSecurityConfig(boolean)\n\nBut the instance variable SecurityConfig.version is never set to anything other than -1; it is not read back from security.json in other words the data map, such that\n\nmeta.put(\"v\", securityConfig.getVersion()+1);//encode the expected zkversion\n\n\nalways puts a value of 0 for the version, leading to the aforementioned memory reload skip.\n\nThere does not seem to be any code calling SecurityConfig.setVersion anywhere or any of SecurityConfig's methods updating the version variable.\n\nThe only code that does call it is in the SecurityConfHandlerZk for zookeeper, but we are not using zookeeper.\n\nUltimately, I can't seem to use the set-user-role command because of this. I hope this is just a duplicate. Thanks",
    "attachments": {},
    "issue_links": {},
    "comments": [
        {
            "date": "2018-05-17T18:40:05+0000",
            "content": "For reference, here is what the zookeeper handler does: org.apache.solr.handler.admin.SecurityConfHandlerZk.getSecurityConfig(boolean)\n\n\u00a0 @Override\n\u00a0 public SecurityConfig getSecurityConfig(boolean getFresh) {\n\u00a0\u00a0\u00a0 ZkStateReader.ConfigData configDataFromZk = cores.getZkController().getZkStateReader().getSecurityProps(getFresh);\n\u00a0\u00a0\u00a0 return configDataFromZk == null ?\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 new SecurityConfig() :\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 new SecurityConfig().setData(configDataFromZk.data).setVersion(configDataFromZk.version);\n\u00a0 }\n\n\nSo presumably org.apache.solr.handler.admin.SecurityConfHandlerLocal.getSecurityConfig(boolean) is missing a call to setVersion after calling setData:\n\n\u00a0 @Override\n  public SecurityConfig getSecurityConfig(boolean getFresh) {\n\u00a0\u00a0\u00a0 if (Files.exists(securityJsonPath)) {\n\u00a0\u00a0\u00a0\u00a0\u00a0 try (InputStream securityJsonIs = Files.newInputStream(securityJsonPath)) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 return new SecurityConfig().setData(securityJsonIs);\n\u00a0\u00a0\u00a0\u00a0\u00a0 } catch (Exception e) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Failed opening existing security.json file: \" + securityJsonPath, e);\n\u00a0\u00a0\u00a0\u00a0\u00a0 }\n\u00a0\u00a0\u00a0 }\n\u00a0\u00a0\u00a0 return new SecurityConfig();\n\u00a0 }\n\n\n\u00a0(or SecurityConfig could encapsulate the initialization of version from data, but I have no idea if that can be generalized there)\n\n\u00a0 ",
            "author": "Pascal Proulx",
            "id": "comment-16479536"
        }
    ]
}