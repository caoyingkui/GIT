{
    "id": "LUCENE-2793",
    "title": "Directory createOutput and openInput should take an IOContext",
    "details": {
        "labels": "",
        "priority": "Major",
        "components": [
            "core/store"
        ],
        "type": "Improvement",
        "fix_versions": [
            "4.0-ALPHA",
            "IOContext branch"
        ],
        "affect_versions": "None",
        "resolution": "Fixed",
        "status": "Closed"
    },
    "description": "Today for merging we pass down a larger readBufferSize than for searching because we get better performance.\n\nI think we should generalize this to a class (IOContext), which would hold the buffer size, but then could hold other flags like DIRECT (bypass OS's buffer cache), SEQUENTIAL, etc.\n\nThen, we can make the DirectIOLinuxDirectory fully usable because we would only use DIRECT/SEQUENTIAL during merging.\n\nThis will require fixing how IW pools readers, so that a reader opened for merging is not then used for searching, and vice/versa.  Really, it's only all the open file handles that need to be different \u2013 we could in theory share del docs, norms, etc, if that were somehow possible.",
    "attachments": {
        "LUCENE-2793-nrt.patch": "https://issues.apache.org/jira/secure/attachment/12483690/LUCENE-2793-nrt.patch",
        "LUCENE-2793.patch": "https://issues.apache.org/jira/secure/attachment/12468030/LUCENE-2793.patch",
        "LUCENE-2793_final.patch": "https://issues.apache.org/jira/secure/attachment/12485568/LUCENE-2793_final.patch"
    },
    "issue_links": {},
    "comments": [
        {
            "date": "2010-12-03T16:05:46+0000",
            "content": "Sounds great, at least in theory we could do the DIRECT thing on windows too for this case.\nand we can certainly give the sequential hint.\n\nin general hints like this are probably good for custom dir impls too, we never know what they are doing\nbut its good to somehow inform them of our intentions so they have a chance to be optimal. ",
            "author": "Robert Muir",
            "id": "comment-12966564"
        },
        {
            "date": "2010-12-03T16:12:23+0000",
            "content": "And MMapDir should return a simple/optimized direct FSIndexInput also. Because MMapping for merging is just wasted resources/address space. ",
            "author": "Uwe Schindler",
            "id": "comment-12966566"
        },
        {
            "date": "2010-12-05T15:05:53+0000",
            "content": "There is another problem we should solve here, and that is the buffersize problem.\n\nThis is totally broken at the moment for custom directories, here's an example.\nI wanted to set the buffersize by default to 4096 (since i measured this is like a 20% improvement for my directory impl).\n\nlooking at the apis you would think that you simply override the openInput that takes no buffer size like this:\n\n  @Override\n  public IndexInput openInput(String name) throws IOException {\n    return openInput(name, 4096);\n  }\n\n\n\nunfortunately this doesnt work at all! instead you have to do something like this for it to actually \"work\":\n\n   @Override\n   public IndexInput openInput(String name, int bufferSize) throws IOException {\n      ensureOpen();\n      return new IndexInput(name, Math.max(bufferSize, 4096));\n   }\n\n\n\nThe problem is, throughout lucene's APIs, the directory's \"default\" is never used, instead the static BufferedIndexInput.BUFFER_SIZE is used everywhere... eg SegmentReader.get:\n\n\n  public static SegmentReader get(boolean readOnly, SegmentInfo si, int termInfosIndexDivisor) throws CorruptIndexException, IOException {\n    return get(readOnly, si.dir, si, BufferedIndexInput.BUFFER_SIZE, true, termInfosIndexDivisor);\n  }\n\n\n\nSo I think lucene's apis should never specify buffersize, we should remove it completely from the codecs api, and it should be replaced with IOContext. ",
            "author": "Robert Muir",
            "id": "comment-12966963"
        },
        {
            "date": "2010-12-11T21:43:46+0000",
            "content": "Perhaps we can add the ability to throttle Directory level IO to this issue.    ",
            "author": "Jason Rutherglen",
            "id": "comment-12970530"
        },
        {
            "date": "2011-01-10T20:08:30+0000",
            "content": "Shall I take this one?  With the plan being to add config options to IWC so that IW uses the DirectIOLinuxDirectory (and it's variants) only for merging? ",
            "author": "Jason Rutherglen",
            "id": "comment-12979728"
        },
        {
            "date": "2011-01-10T20:12:57+0000",
            "content": "Yes please!\n\nBut, this issue only adds the IOContext, threading it down to when you open an input / create an output.  That context should hold enough \"information\" to allow the Dir impl to make decisions like buffer sizes and avoiding buffer cache, etc. ",
            "author": "Michael McCandless",
            "id": "comment-12979731"
        },
        {
            "date": "2011-01-10T20:21:11+0000",
            "content": "this issue only adds the IOContext, threading it down to when you open an input / create an output\n\nDoes this mean we're not implementing this part?\n\nThis will require fixing how IW pools readers, so that a reader opened for merging is not then used for searching, and vice/versa. Really, it's only all the open file handles that need to be different - we could in theory share del docs, norms, etc, if that were somehow possible. ",
            "author": "Jason Rutherglen",
            "id": "comment-12979736"
        },
        {
            "date": "2011-01-10T20:30:28+0000",
            "content": "Sorry, I think we should also do that as part of this issue.  Basically the IOContext needs to become part of the cache key uses in IW's ReaderPool? ",
            "author": "Michael McCandless",
            "id": "comment-12979738"
        },
        {
            "date": "2011-01-10T20:33:20+0000",
            "content": "Basically the IOContext needs to become part of the cache key uses in IW's ReaderPool? \n\nGreat, I'll implement this. ",
            "author": "Jason Rutherglen",
            "id": "comment-12979740"
        },
        {
            "date": "2011-01-11T17:52:10+0000",
            "content": "Ok, I created an IOFactory class that generates input and output streams.  It's settable on IOContext.  The merge IOContext may be set on IWC.  I will test once the object model gets the nod... ",
            "author": "Jason Rutherglen",
            "id": "comment-12980214"
        },
        {
            "date": "2011-01-11T22:43:38+0000",
            "content": "Looks crazy. In a bad tangled way.\nYou get IOFactory from Directory, put into IOContext, and then invoke it, passing it (wow!) an IOContext and a Directory. What if you pass totally different Directory? Different IOContext? It blows up eerily.\n\nAnd there's no justification for this - we already have an IOFactory, it's called Directory! It just needs an extra parameter on its factory methods (createInput/Output), that's all. ",
            "author": "Earwin Burrfoot",
            "id": "comment-12980400"
        },
        {
            "date": "2011-01-11T23:35:31+0000",
            "content": "You get IOFactory from Directory\n\nThat's for the default, the main use is the static IOFactory class.\n\nwe already have an IOFactory, it's called Directory\n\nRight, however we're basically trying to intermix Directory's, which doesn't work when pointed at the same underlying File.  I thought about a meta-Directory that routes based on the IOContext, however we'd still need a way to create an IndexInput and IndexOutput, from different Directory implementations.   ",
            "author": "Jason Rutherglen",
            "id": "comment-12980435"
        },
        {
            "date": "2011-01-12T00:06:12+0000",
            "content": "\nYou get IOFactory from Directory\nThat's for the default, the main use is the static IOFactory class.\nYou lost me here. If you got A from B, you don't have to pass B again to invoke A, if you do - that's 99% a design mistake.\nBut still, my point was that you don't need IOFactory at all.\n\nRight, however we're basically trying to intermix Directory's, which doesn't work when pointed at the same underlying File. I thought about a meta-Directory that routes based on the IOContext, however we'd still need a way to create an IndexInput and IndexOutput, from different Directory implementations. \nWhat Directories are you trying to intermix? What for?\n\nI thought the only thing done in that issue is an attempt to give Directory hints as to why we're going to open its streams.\nA simple enum IOContext and extra parameter on createOutput/Input would suffice. But with Lucene's micromanagement attitude, an enum turns into slightly more complex thing, with bufferSizes and whatnot.\nStill - no need for mixing Directories. ",
            "author": "Earwin Burrfoot",
            "id": "comment-12980454"
        },
        {
            "date": "2011-01-12T00:24:46+0000",
            "content": "In fact, I suggest dropping bufferSize altogether. As far as I can recall, it was introduced as a precursor to IOContext and can now be safely replaced.\n\nEven if we want to give user control over buffer size for all streams, or only those opened in specific IOContext, he can pass these numbers as config parameters to his Directory impl.\nThat makes total sense, as:\n1. IndexWriter/IndexReader couldn't care less about buffer sizes, it just passes them to the Directory. It's not their concern.\n2. A bunch of Directories doesn't use said bufferSize at all, making this parameter not only private Directory affairs, but even further - implementation-specific.\n\nSo my bet is - introduce IOContext as a simple Enum, change bufferSize parameter on createInput/Output to IOContext, done. ",
            "author": "Earwin Burrfoot",
            "id": "comment-12980458"
        },
        {
            "date": "2011-01-12T00:43:32+0000",
            "content": "In fact, I suggest dropping bufferSize altogether.\n\n+1\n\nhttps://issues.apache.org/jira/browse/LUCENE-2793?focusedCommentId=12966963&page=com.atlassian.jira.plugin.system.issuetabpanels:comment-tabpanel#action_12966963\n\nSo my bet is - introduce IOContext as a simple Enum, change bufferSize parameter on createInput/Output to IOContext, done.\n\nI agree, its the directories job to then take that IOContext and create an appropriate IndexOutput. ",
            "author": "Robert Muir",
            "id": "comment-12980470"
        },
        {
            "date": "2011-01-12T03:30:55+0000",
            "content": "Ok, lets remove bufferSize.  \n\nits the directories job to then take that IOContext and create an appropriate IndexOutput.\n\nThat's how the patch works.  If that doesn't look good, the other option is placing the logic in FSDirectory and removing the FSDirectory subclasses? ",
            "author": "Jason Rutherglen",
            "id": "comment-12980533"
        },
        {
            "date": "2011-01-12T04:08:41+0000",
            "content": "That's how the patch works. If that doesn't look good, the other option is placing the logic in FSDirectory and removing the FSDirectory subclasses?\n\nWe don't need to make any changes to Directory itself here, other than openInput/createOutput taking IOContext instead of bufferSize.\nThe directory is the factory for opening the correct openInput/createOutput based on its parameters, this just needs to be one.\n\nAs Mike said, the important thing is to not re-use an input that was opened with IOContext=Merging for search.\nIf you ask the directory to openInput with IOContext=merging, thats all it should be used for, because that Directory \ncould be implementing that with O_DIRECT or similar, which is slow for searching.\n\nwe can muck with DirectIOLinuxDirectory later on another issue (e.g. make it a directory wrapper that just overrides \nopenInput and only does something interesting when IOContext=Merging, or NIOFSDirectory subclass, or whatever\nwe end up deciding). ",
            "author": "Robert Muir",
            "id": "comment-12980543"
        },
        {
            "date": "2011-01-12T04:24:22+0000",
            "content": "The directory is the factory for opening the correct openInput/createOutput based on its parameters, this just needs to be one.\n\nRight, however which Directory impl is going to do this?  Today they're tied to their specific implementations of IndexInputs and IndexOutputs, eg, NIOFSIndexInput, DirectIOLinuxIndexInput, etc.  In order to get an NIOFSIndexInput we need to instantiate NIOFSDirectory, however if we also want to use DirectIOLinuxDirectory, then (in today's model) we need to instantiate it as well.  To create an index or output, all we need is a parent FSDIrectory and the rest is encapsulated in the underlying input/output implementation.   ",
            "author": "Jason Rutherglen",
            "id": "comment-12980546"
        },
        {
            "date": "2011-01-12T04:33:34+0000",
            "content": "If we drop bufferSize, how will I be able to tell Lucene I'm willing to spare, say, 1 MB buffer for this IndexInput/Output? Am I supposed to create my own Directory and open II/IO, depending on the IOContext.Mode and decide on the buffer size then?\n\nIf so, then I don't understand how this would work (think that's what Jason is asking) - if I impl MyDirectory (extending Directory? FSDirectory?) which is probably going to be a wrapper Directory, what II/IO impl should I invoke? I'll need to extend BufferedIndexInput/Output, impl its abstract methods, just for delegating to the wrapped Directory's II/IO?\n\nIf I misunderstood the intentions, I'd appreciate if you can clarify them. But if not, I think IOContext should include a bufferSize hint. If the Directory does not intend to do anything special for 'merging', then it can take bufferSize into account. If however it's a Linux Directory that wants to set the O_DIRECT, then it can ignore bufferSize. But I think it's a useful hint. ",
            "author": "Shai Erera",
            "id": "comment-12980551"
        },
        {
            "date": "2011-01-12T04:41:00+0000",
            "content": "In the patch the bufferSize is an int member of IOContext.  We could feasibly go to a map of attributes model if we think there'll be a lot more options in the future?  Or the IOContext class can be subclassed.\n\nAlso, in the patch the IOContext for searching and merging is set in IWC, then should be reused.  This way the bufferSize is settable by the user, which I don't think is easily possible today (perhaps the main motivation for this issue?). ",
            "author": "Jason Rutherglen",
            "id": "comment-12980555"
        },
        {
            "date": "2011-01-12T04:47:56+0000",
            "content": "If we drop bufferSize, how will I be able to tell Lucene I'm willing to spare, say, 1 MB buffer for this IndexInput/Output? Am I supposed to create my own Directory and open II/IO, depending on the IOContext.Mode and decide on the buffer size then?\n\nwith .setBufferSize. The only place in lucene that intelligently uses buffersize (Skiplist reading) sets it this way, not with the ctor param.\n\notherwise, i think you are confused if you think lucene actually passes any intelligent value for this ctor parameter.\nit doesn't... it usually passes the static BufferedIndexInput.BUFFER_SIZE\n\nIf so, then I don't understand how this would work (think that's what Jason is asking) - if I impl MyDirectory (extending Directory? FSDirectory?) which is probably going to be a wrapper Directory, what II/IO impl should I invoke? I'll need to extend BufferedIndexInput/Output, impl its abstract methods, just for delegating to the wrapped Directory's II/IO?\n\nI don't understand whats so terribly difficult about:\n\nif (context == MERGING)\n return mySpecialmergingInput();\nelse\n return super.openInput(...);\n\n ",
            "author": "Robert Muir",
            "id": "comment-12980557"
        },
        {
            "date": "2011-01-12T04:54:24+0000",
            "content": "This way the bufferSize is settable by the user, which I don't think is easily possible today (perhaps the main motivation for this issue?)\n\nExactly ! That's what I thought of this issue in the first place - allow the app to more easily control the size of the buffers used by Lucene. That that IOContext will allow me to set different bufferSizes per the work that Lucene's doing (i.e. merge, search) is a bonus for me .\n\nI still think bufferSize can be used as a hint by the specific Directory impl, but it should be there.\n\nIf we want to allow control of different buffer sizes per operation, then maybe we can do the following:\n\n\tSet a default buffer size on IOContext.\n\tAdd a setBufferSize(OpType type, int/long bufferSize)\n\tAdd getBufferSize(OpType) \u2013 returns the set buffer size, or the default if not set.\n\n\n\nI don't think it's too complicated and gives enough control to the application? ",
            "author": "Shai Erera",
            "id": "comment-12980559"
        },
        {
            "date": "2011-01-12T04:57:18+0000",
            "content": "Robert, nothing is too difficult to understand. But your code example tells me that if I want to control the buffer size used by Lucene (whether it's done intelligently or not today is what we try to fix here), I need to create my own Dir impl. That seems an overkill to me, for just controlling the bufferSize !? ",
            "author": "Shai Erera",
            "id": "comment-12980561"
        },
        {
            "date": "2011-01-12T05:22:25+0000",
            "content": "But your code example tells me that if I want to control the buffer size used by Lucene (whether it's done intelligently or not today is what we try to fix here), I need to create my own Dir impl. That seems an overkill to me, for just controlling the bufferSize !?\n\nNo you dont... you can also call the .setBufferSize like the skiplist reader does.\n\n\nIndexInput input = dir.openInput(....)\nif (input instanceof BufferedIndexInput)\n...setBufferSize(whatever_you_want);\n\n\n\nBecause after all, buffersize only makes sense on Buffered*.\n\nIt makes no sense to be on Directory's openInput, e.g. it makes no sense for directories like MMapDirectory. ",
            "author": "Robert Muir",
            "id": "comment-12980564"
        },
        {
            "date": "2011-01-12T08:51:22+0000",
            "content": "No you dont... you can also call the .setBufferSize like the skiplist reader does.\n\nI'd still need to impl my Directory though right? That's the overkill I'm trying to avoid.\n\nBut, I've been thinking about how would a merge/search code, which can only tell the Directory it's in SEARCH / MERGE context, get the buffer size the application wanted to use in that context. I don't think it has a way to do so without either using a static class, something we try to avoid, or propagating those settings down everywhere, which does not make sense either.\n\nSo, Robert, I think you're right \u2013 bufferSize should not exist on IOContext. A custom Directory impl seems unavoided. So I think it'd be good if we can create a BufferedDirectoryWrapper which wraps a Directory and offers a BufferedIndexInput/OutputWrapper which delegate the necessary calls to the wrapped Directory. We've found ourselves needing to implement that kind of Directory several times already, and it'd be good if Lucene can offer one.\n\nThat Directory would then take IOContext -> bufferSize map/properties/whatever and can take that into account in openInput/createOutput.\n\nIf users will need to impl Directory wrapping, if they want to control buffer sizes, I suggest we make that as painless as possible. ",
            "author": "Shai Erera",
            "id": "comment-12980625"
        },
        {
            "date": "2011-01-12T10:20:26+0000",
            "content": "What's with ongoing crazyness? \n\nDirectIOLinuxDirectory\nFirst you introduce a kind of directory that is utterly useless except certain special situations. Then, instead of fixing the directory/folding its code somewhere normal, you try to workaround by switching between directories. What's the point of using abstract classes or interfaces, if you leak their implementation's logic all over the place?\nOr making DIOLD wrap something. Yeah! Wrap my RAMDir!\n\nbufferSize\nThis value is only meaningful to a certain subset of Directory implementations. So the only logical place we want to see this value set - is these very impls.\nSample code:\n\nDirectory ramDir = new RAMDirectory();\nramDir.createIndexInput(name, context);\n// See, ma? No bufferSizes, they are pointless for RAMDir\n\nDirectory fsDir = new NIOFSDirectory();\nfsDir.setBufferSize(IOContext.NORMAL_READ, 1024);\nfsDir.setBufferSize(IOContext.MERGE, 4096);\nfsDir.createIndexInput(name, context)\n// See, ma? The only one who's really concerned with 'actual' buffer size is this concrete Directory impl\n// All client code is only concerned with the context.\n// It's NIOFSDirectory's business to give meaningful interpretation for IOContext and assign the buffer sizes.\n\n\n\nYou don't need custom Directory impls to make DIOLD work, you should freakin' fix it.\nThe proper way is to test out the things, and then move DirectIO code to the only place it makes sense in - FSDir? Probably make it switch on/off-able, maybe not.\n\nYou don't need custom Directory impls to set buffer sizes (neither cast to BufferedIndexInput!), you should add the setting to these Directories, which make sense of it. ",
            "author": "Earwin Burrfoot",
            "id": "comment-12980649"
        },
        {
            "date": "2011-01-12T14:28:35+0000",
            "content": "I assume you mean setBufferSize(IOContext, size) should be added to specific Directory impls, and not Directory? Because in your example code above, it looks like it's added to Directory itself. Though we can add it to Directory as well, and do nothing there. It simplifies matters as you don't need to check whether the Dir you receive supports setting buffer size (in case you're not the one creating it).\n\nAt any rate, this looks like it can work too. ",
            "author": "Shai Erera",
            "id": "comment-12980727"
        },
        {
            "date": "2011-01-12T14:37:59+0000",
            "content": "The proper way is to test out the things, and then move DirectIO code to the only place it makes sense in - FSDir? Probably make it switch on/off-able, maybe not. \n\nI'm not sure it should be there... at least not soon. its not even something you can implement in pure java? \nwe definitely have to keep it still simple and possible for people to use the java library in a platform-indepedent way. \nits also a bit dangerous, whenever JNI is involved....even if its working. \n\nSo I think its craziness, to put this direct-io stuff in fsdirectory itself. \n\nAs I said before though, i wouldn't mind if we had something more like a 'modules/native' and FSDirectory checked, if this was available and automagically used it... \nbut I can't see myself thinking that we should put this logic into fsdir itself, sorry. \n\nSample code \n\nMy problem with your sample code is that it appears that the .setBufferSize method is on Directory itself. \nAgain i disagree with this because: \n\n\tits useless to certain directories like MMapDirectory\n\tits dangerous in the direct-io case (different platforms have strict requirements that things be sector-aligned etc, see the mac case where it actually 'works' if the buffer isnt, but is just slow).\n\n\n\nI definitely don't like the confusion regarding buffersizes now. A very small % of the time its actually meaningful and should be respected, \nbut most of the time the value is completely bogus.  ",
            "author": "Robert Muir",
            "id": "comment-12980731"
        },
        {
            "date": "2011-01-12T14:47:31+0000",
            "content": "Because in your example code above, it looks like it's added to Directory itself.\nMy problem with your sample code is that it appears that the .setBufferSize method is on Directory itself. \n\nOhoho. My fault, sorry. It should look like:\n\nRAMDirectory ramDir = new RAMDirectory();\nramDir.setBufferSize(whatever) // Compilation error!\nramDir.createIndexInput(name, context);\n\nNIOFSDirectory fsDir = new NIOFSDirectory();\nfsDir.setBufferSize(IOContext.NORMAL_READ, 1024);\nfsDir.setBufferSize(IOContext.MERGE, 4096);\nfsDir.createIndexInput(name, context)\n\n ",
            "author": "Earwin Burrfoot",
            "id": "comment-12980732"
        },
        {
            "date": "2011-01-12T14:51:36+0000",
            "content": "\nAs I said before though, i wouldn't mind if we had something more like a 'modules/native' and FSDirectory checked, if this was available and automagically used it...\nbut I can't see myself thinking that we should put this logic into fsdir itself, sorry. \nI'm perfectly OK with that approach (having some module FSDir checks). I also feel uneasy having JNI in core.\nWhat I don't want to see, is Directory impls that you can't use on their own. If you can only use it for merging, then it's not a Directory, it breaks the contract! - move the code elsewhere. ",
            "author": "Earwin Burrfoot",
            "id": "comment-12980736"
        },
        {
            "date": "2011-01-12T15:00:53+0000",
            "content": "\nI'm perfectly OK with that approach (having some module FSDir checks). I also feel uneasy having JNI in core.\nWhat I don't want to see, is Directory impls that you can't use on their own. If you can only use it for merging, then it's not a Directory, it breaks the contract! - move the code elsewhere.\n\nRight, i think we all agree we want to fix the DirectIOLinuxDirectory into being a 'real' directory?\n\nAs i said before, from a practical perspective, it could be named LinuxDirectory, extend NIOFS, \nand when openInput(IOContext=Merge) it opens its special input. but personally i don't care how \nwe actually implement it 'becoming a real directory'. this is another issue, unrelated to this one really.\n\nthis issue is enough and should stand on its own... we should be able to do enough nice things\nhere without dealing with JNI: improving our existing directory impls to use larger buffer sizes by \ndefault when merging, etc (like in your example). ",
            "author": "Robert Muir",
            "id": "comment-12980740"
        },
        {
            "date": "2011-04-05T07:26:23+0000",
            "content": "Hi. I would be interested in taking this up as a GSOC project . Are there any resource that I can read to understand the problem in depth ? ",
            "author": "Varun Thacker",
            "id": "comment-13015785"
        },
        {
            "date": "2011-04-05T07:42:22+0000",
            "content": "Hi. I would be interested in taking this up as a GSOC project . Are there any resource that I can read to understand the problem in depth ?\nHey, I just marked it as GSoC-able  so you are free to take it. I would also volunteer to mentor on this issue if mike doesn't want to take it though. Let me try to explain you quickly what this issue is about:\n\nLucene uses Directory as an abstraction on top of the filesystem or RAM or any other storage to write the index data. Yet, Lucene has different \"stages\" where we have different requirements to the underlying storage / directory. When you index documents you eventually flush the index to disk and continue indexing until you created enough \"segments\" on disk that you need to merged them. This operations should if possible not pollute the FS cache since its really just housekeeping. With Java such its currently not possible to use some flags like DIRECT / SEQUENTIAL, this is what we have the native DirectIODirectory implementations in contrib for. Yet, for reading stuff from the index while searching we want to have the FS cache helping us as much as possible so this has again different requriements. What we currently do is that we pass different read buffer sizes to the directory to improve performance. All those kinds of information should be passed to the directory on a IndexInput / IndexOutput (similar to Input and OutputStream just tailored & enhanced for Lucene) basis and this is what this issue is about. \n\nhope that helps. ",
            "author": "Simon Willnauer",
            "id": "comment-13015790"
        },
        {
            "date": "2011-05-13T12:37:50+0000",
            "content": "For LUCENE-3092, it would be nice if the IOContext would optionally include the OneMerge if in fact the file is being opened for merging... this lets the Dir impl be smart if it wants to customize its behavior according to overall properties of the merge (eg total merged bytes). ",
            "author": "Michael McCandless",
            "id": "comment-13032992"
        },
        {
            "date": "2011-05-13T20:50:49+0000",
            "content": "As mentioned @LUCENE-3092, it would be nice not to include the OneMerge, but some meaningful value like 'expectedSize', 'expectedSegmentSize' or whatnot, that would work both for merges and flushes, and also won't introduce needless dependency on MergePolicy. ",
            "author": "Earwin Burrfoot",
            "id": "comment-13033279"
        },
        {
            "date": "2011-05-29T18:24:32+0000",
            "content": "I have made a class IOContext and added a IOContext object to the Directory createOutput and openInput method parameters. \n\nIf this is the right way to go ? ",
            "author": "Varun Thacker",
            "id": "comment-13040844"
        },
        {
            "date": "2011-05-29T18:34:29+0000",
            "content": "I already posted a patch to this issue a while back, https://issues.apache.org/jira/secure/attachment/12468030/LUCENE-2793.patch  It seems we're looping here. ",
            "author": "Jason Rutherglen",
            "id": "comment-13040845"
        },
        {
            "date": "2011-05-29T18:46:57+0000",
            "content": "I should have seen the patch! I have taken this up as a GSoC project. I'll try to use that patch too if it's ok. ",
            "author": "Varun Thacker",
            "id": "comment-13040850"
        },
        {
            "date": "2011-05-30T00:19:17+0000",
            "content": "I already posted a patch to this issue a while back...\n\nJason I appreciate that you are still around on this issue. Varun is doing his GSoC project on this issue and others so there might be some duplication here and there or similarities with you patch but in this case this is ok though. He needs to get started as well as getting a feeling how things work here. So I hope you don't mind. I can only encourage you to help reviewing and commenting!\n\n\nIf this is the right way to go ?\n\nThanks for the patch man! Good to get started eventually. here are some comments for you patch:\n\n\n\tWhen I look at IOContext I think it should be a little more sophisticated. What I have in mind is something similar to ScorerContext in org.apache.lucene.search.Weight.java. Some kind of a copy-on-write builder pattern that lets us provide some defaults for Merging, Searching and Indexing so by default we can reuse the same instance in many places. If we follow a this copy on write model we could also make this class non-final to let people customize the context if they needs to.\n\tI am not sure if we really need the enumeration in IO Context unless me make decisions based on what an input / output is used for. IMO it might make more sense to have default instances for Searching Indexing and Merging and set the flags like SEQUENTIAL and the buffers to good defaults and only tweak them when we are aware of the context ie. when we pull the input / output. The most of the usecases need good defaults and only some need tweaks but if we hold the use-case information on IOContext some directories might want to be very smart and this might duplicate code.\n\tI wonder if it makes sense to bind the IO Context instance to the directory and add a factory to the directory like Directory#getIOContext(Merge|Search|Index) to enable the directory impl to set platform specific defaults. I think that would make things easier and customization would be straight forward.\n\tYou should add a space after a comma in the arguments list like here: int bufferSize,IOContext context)\n\tEnum elements should be CamelCase and start with a leading Uppercase character\n\n\n\n ",
            "author": "Simon Willnauer",
            "id": "comment-13040906"
        },
        {
            "date": "2011-05-30T18:24:55+0000",
            "content": "I edited IOContext . \n\nI'm not sure on where to go from here. Should I add the context to all the createOutput/openImput parameters in the Directory implementations or add getIOContext method to Directory? ",
            "author": "Varun Thacker",
            "id": "comment-13041223"
        },
        {
            "date": "2011-05-30T18:28:35+0000",
            "content": "Great to see your patch here Varun!\n\nI think we should start with only high level details in the IOContext?\nIe, the Merge/Search(Reader?)/Writer is great, but I think low level\nstuff (bufferSize, sequential/direct) should stay private to the Dir\nimpl?\n\nIdeally, I would also like to see details about the\nmerge/reader/writer \"context\", eg for merging I'd like to see the\nOneMerge instance, for Reader/Writer maybe a SegmentInfo instance?\n\nThis would then make Dir impls like NRTCachingDirectory (LUCENE-3092)\n\"clean\" (vs the sneaky ConcurrentMergeScheduler entangling it now must\ndo), though, in that particular case we could accomplish this by only\nadding an estimatedSegmentSizeBytes to the IOCtx.\n\nWe should remove the bufferSize that now plumbs all up and down\nthe APIs, and replace it with IOCtx? ",
            "author": "Michael McCandless",
            "id": "comment-13041224"
        },
        {
            "date": "2011-05-30T18:32:21+0000",
            "content": "Some kind of a copy-on-write builder pattern\n\nWhy not use a normal struct/bean like class here?\n\nI wonder if it makes sense to bind the IO Context instance to the directory and add a factory to the directory like Directory#getIOContext(Merge|Search|Index) to enable the directory impl to set platform specific defaults\n\nHmm, but, if the IOCtxt is 'high level', and then details (bufferSize, seq/direct flags, etc.) are private to the dir impl, I think we (Lucene) can create the IOCtx and pass it down?  Ie this is a one-way communication, I think (Lucene -> Dir impl). ",
            "author": "Michael McCandless",
            "id": "comment-13041225"
        },
        {
            "date": "2011-05-30T19:19:49+0000",
            "content": "I removed bufferSize from all the Directory implementations and made it part of IOContext.\n ",
            "author": "Varun Thacker",
            "id": "comment-13041241"
        },
        {
            "date": "2011-05-30T19:34:22+0000",
            "content": "I removed bufferSize from all the Directory implementations and made it part of IOContext.\n\nI think it shouldn't even be part of IOCtx?  Ie this is private to the Dir impl?\n\nAnother thing we have to do is add IOCtx into the cache key used in IndexWriter's ReaderPool inner class.  Ie, a reader opened for merging cannot be later shared with a reader opened for searching. ",
            "author": "Michael McCandless",
            "id": "comment-13041248"
        },
        {
            "date": "2011-05-31T12:48:11+0000",
            "content": "Why not use a normal struct/bean like class here?\n\nWhat I had in mind here is a more sophisticated IOContext. I'd like to see some default IOCtx for Merge, Search, Write etc. that folks can simply modify if needed. For that to work it should be immutable. The question here is if we go the high level way like you suggested and make the most of the properties private to the dir (like buffersize etc) or is we should make it available to the user of the API. Some Dirs might have different defaults than others though. \n\nI can see why this should be private to the directory and it might make more sense to simply indicate what the input / output is used for and let the directory figure out the details. So yeah +1 to keep it high level. If bean or copy-on-write builder I need to see what properties should be on it. so lets keep that for later.\n\n\nIdeally, I would also like to see details about the\nmerge/reader/writer \"context\", eg for merging I'd like to see the\nOneMerge instance, for Reader/Writer maybe a SegmentInfo instance?\n\nI really don't like the idea of exploiting OneMerge to the Directory. We might introduce some other internface that holds enough metadata to get the info and let OneMerge implement this but we should not pass it down to the dir. Same is true for SI I don't want directory mess around with those classes.  ",
            "author": "Simon Willnauer",
            "id": "comment-13041560"
        },
        {
            "date": "2011-05-31T15:13:06+0000",
            "content": "If bean or copy-on-write builder I need to see what properties should be on it. so lets keep that for later.\n\nOK let's defer this decision for now.\n\nI just see \"builder pattern\" being too much of a hammer in search of\nnails...\n\n\nI really don't like the idea of exploiting OneMerge to the Directory. We might introduce some other internface that holds enough metadata to get the info and let OneMerge implement this but we should not pass it down to the dir. Same is true for SI I don't want directory mess around with those classes.\n\nI agree, it's spooky letting such a low level class (Dir) have access\nto high level stuff (OneMerge, SegmentInfo)... but it's really the\nonly way to ensure we don't \"miss\" useful context about this file?\n\nIe these high level classes already encompass the full context for a\ngiven file.\n\nSo, if we really don't want to include these classes, and instead pick &\nchoose what \"digested\" properties to include... then we risk some Dir\nimpl not having access to something \"interesting\" because we forgot to\ninclude it, which means they'll have to hack something up, like\nNRTCachingDir does now in coupling threads to OneMerge instances.\n\nBut, maybe the restrictions won't be so bad in practice... if we can\ntry to brainstorm what Dirs may want to \"know\" about the full context\nand include that in IOCtx.\n\nFor example, just by adding estimatedFullSegmentSizeBytes, for both\nMerge and Write (hmm: maybe Flush?), NRTCachingDir can cutover to\nIOCtx. ",
            "author": "Michael McCandless",
            "id": "comment-13041617"
        },
        {
            "date": "2011-05-31T16:03:59+0000",
            "content": "\nSo, if we really don't want to include these classes, and instead pick &\nchoose what \"digested\" properties to include... then we risk some Dir\nimpl not having access to something \"interesting\" because we forgot to\ninclude it, which means they'll have to hack something up, like\nNRTCachingDir does now in coupling threads to OneMerge instances.\n\nBut, maybe the restrictions won't be so bad in practice... if we can\ntry to brainstorm what Dirs may want to \"know\" about the full context\nand include that in IOCtx.\n\nI think the alternatives to this are definitely worse.  I've been trying to think of some sort of intermediary component that could decouple the interests of Directories from the sources of that info, but it just seems to make everything way more complicated.  I agree it seems best to stick to what Dirs want to know, present that as the IOCtx, and then work out the sources of that information. ",
            "author": "Chris Male",
            "id": "comment-13041642"
        },
        {
            "date": "2011-06-02T14:27:39+0000",
            "content": "I have edited org.apache.lucene.store and org.apache.index where needed. If this is correct I'll change the codecs too ",
            "author": "Varun Thacker",
            "id": "comment-13042790"
        },
        {
            "date": "2011-06-02T15:22:11+0000",
            "content": "Patch is looking good!  Some feedback:\n\n\n\tI think CompoundFileReader should not store the IOCtx passed to\n    the ctor?  It should just fwd to the dir.openInput...?  It used to\n    have to store the readBufferSize in case openInput was called w/o\n    a readBufferSize, but we now require IOCtx to openInput.\n\n\n\n\n\tIs IOCtx never allowed to be null?  (I think so?).  In which case\n    we should jdoc this, and Dir impls can rely on it.\n\n\n\n\n\tI don't think NRTCachingDir.unCache should take an IOCtx?\n\n\n\n\n\tI think NRTCachineDir.doCacheWrite should take the IOCtx, and, we\n    should remove all the merge thread hacks that it now does.\n\n\n\n\n\tThe super(bufferSize) call is needed in SimpleFSDir (and others).\n    I think what must happen here is SimpleFSDir look @ the IOCtx and\n    decides what buffer size to use (the logic in IW should be moved\n    down into here), with getters/setters to be able to change\n    read/write buffer size for merging vs reading/flushing.\n\n\n\n\n\tIOContext.Context should also have Flush?  And maybe rename Search\n    -> Read?\n\n\n\n\n\tIndexWriter ctor shouldn't take an incoming IOCtx; instead,\n    IndexWriter should create a new IOCtx each time it opens reader /\n    flushes segments / does merging.\n\n\n\n\n\tThe ReaderPool.get* methods (inside IndexWriter) should take an\n    IOCtx, and the .context from that IOCtx should be part of the key\n    used to cache that reader in the pool.\n\n ",
            "author": "Michael McCandless",
            "id": "comment-13042824"
        },
        {
            "date": "2011-06-07T08:09:21+0000",
            "content": "I have made the required changes. There are places where I have made the Context=Other , some of which might be wrong. Please suggest me where to make the necessary changes.  ",
            "author": "Varun Thacker",
            "id": "comment-13045315"
        },
        {
            "date": "2011-06-07T08:29:01+0000",
            "content": "Very very quick review:\n\n\n\tI think OneMerge should not be required for createing a IOContext we maybe should add a default ctor.\n\tIOContext.Other is confusing I think. If a IOContext doesn't make lots of sense somewhere we should not need to pass it in. Can't we simply have overloaded methods? maybe I just don't like the name, maybe use DEFAULT?\n\tIOContext seem to pretty straight forward you either read or write but it seems to be confused with high level operations like Merge and Flush. Either with go on a high level or we only have read and write here. Since read / write is implicit (you either pull input or output) we should make this high-level only. So maybe we have Query or Search instead of Read here? Maybe it makes sense to specify stuff like Consume or Sequential here too some high level APIs define sequential access so I think it does not conflict?\n\n ",
            "author": "Simon Willnauer",
            "id": "comment-13045322"
        },
        {
            "date": "2011-06-07T10:38:58+0000",
            "content": "Patch looks great!  Comments:\n\n\n\tI think IOCtx should have ctor taking only OneMerge, which would\n    set the OneMerge and set the context as Merge?\n\n\n\n\n\tLikewise, a ctor taking a SegmentInfo to mean context = Flush?\n\n\n\n\n\tAnd finally a default ctor that maps to Other (or Default or\n    Unknown or Unspecified or something)\n\n\n\n\n\tYou don't need to create the IOCtx in IW.maybeMerge?\n\n\n\n\n\tMaybe we want a \"readOnce\" boolean in IOCtx?  When we read del\n    docs, norms, terms index, doc values, segments file /\n    segments.gen, we would set this?  (And UnixDir would send eg\n    NO_REUSE down to the OS).\n\n\n\n\n\tI think we'll need a NativeMMapDir as well as NativeDir (or\n    NativeUnix/WindowsDir), because mmap can also take flags giving\n    hints about access patterns.  I'll open a new issue...\n\n\n\n\n\tWhy does SegmentCoreReaders hang onto the IOCtx?  Seems like\n    classes shouldn't hang onto it... (also: PreFlexFields).\n\n\n\n\n\tHmm.... does createOutput even need an IOCtx...?  What would a dir\n    do with this?  I suppose if it's a merge and we had io\n    prioritization (someday) we could set lower prio... OK let's keep\n    it.\n\n\n\n\n\tI think Codec.fieldsProducer/Consumer should take an IOCtx?\n\n\n\n\n\tStill need to fix IW's ReaderPool to key off of IOCtx.Context plus\n    the info.  Maybe put a // nocommit in there so we remember...?\n    Eg, where you commented out the readBufferSize = ... inside\n    ReaderPool.get is a good place.\n\n ",
            "author": "Michael McCandless",
            "id": "comment-13045354"
        },
        {
            "date": "2011-06-07T14:39:37+0000",
            "content": "\nI think we'll need a NativeMMapDir as well as NativeDir (or\nNativeUnix/WindowsDir), because mmap can also take flags giving\nhints about access patterns. I'll open a new issue...\n\nI opened LUCENE-3178. ",
            "author": "Michael McCandless",
            "id": "comment-13045455"
        },
        {
            "date": "2011-06-08T07:47:42+0000",
            "content": "I just put up the IOContext class. If this is looking good then I'll make the necessary changes to the other classes. ",
            "author": "Varun Thacker",
            "id": "comment-13045824"
        },
        {
            "date": "2011-06-09T08:48:53+0000",
            "content": "Hey varun,\n\nhere are some more comments for the latest complete patch:\n\n\n\tWe should have a static instance for IOContext with Context.Other which you can use in BitVector / CheckIndex for instance Maybe IOContext#DEFAULT_CONTEXT\n\tIt seems that we don't need to provide IOContext to FieldInfos and SegmentInfo since we are reading them into memory anyway. I think you can just use a default context here without changing the constructors. Same is true for SegmentInfos\n\tThis is unrelated to your patch but in PreFlexFields we should use IndexFileNames.segmentFileName(info.name, \"\", PreFlexCodec.FREQ_EXTENSION) and IndexFileNames.segmentFileName(info.name, \"\", PreFlexCodec.PROX_EXTENSION) instead of info.name + \".frq\"  and info.name + \".prx\"\n\tit seems that we should communicate the IOContext to the codec somehow. I suggest we put IOContext to SegmentWriteState and SegmentReadState that way we don't need to change the Codec interface and clutter it with internals. This would also fix mikes comment for FieldsConsumer etc.\n\tTermVectorsWriter is only used in Merges so maybe it should also get a Context.Merge for consistency?\n\tI really don't like OneMerge  I think we should add an abstract class  (maybe MergeInfo) that exposes the estimatedMergeBytes, totalDocCount for now.\n\tsmall typo in RamDirectory, there is a space missing after the second file here: dir.copy(this, file, file,context);\n\tSegmentReader should also use the static Default IOContext - make sure its used where needed \n\n\n\nRegarding the IOContext class I think we should design for what we have right now and since SegementInfo is not used anywhere (as far as I can see) we should add it once we need it. OneMerge should not go in there but rather the interface / abstract class I talked about above.  ",
            "author": "Simon Willnauer",
            "id": "comment-13046403"
        },
        {
            "date": "2011-06-09T15:54:31+0000",
            "content": "It seems that we don't need to provide IOContext to FieldInfos and SegmentInfo since we are reading them into memory anyway. I think you can just use a default context here without changing the constructors. Same is true for SegmentInfo\n\nI think we should pass down \"readOnce=true\" for these cases?  EG some\nkind of caching dir (or something) would know not to bother caching\nsuch files...\n\nSame for del docs, terms index, doc values (well, sometimes), etc.\n\nit seems that we should communicate the IOContext to the codec somehow. I suggest we put IOContext to SegmentWriteState and SegmentReadState that way we don't need to change the Codec interface and clutter it with internals. This would also fix mikes comment for FieldsConsumer etc.\n\n+1 that's great.\n\nI really don't like OneMerge  I think we should add an abstract class (maybe MergeInfo) that exposes the estimatedMergeBytes, totalDocCount for now.\n\nIf we can't include OneMerge, and I agree it'd be nice not to, I think\nwe should try hard to pull stuff out of OneMerge that may be of\ninterest to a Dir impl?  Maybe:\n\n\n\testimatedTotalSegmentSizeBytes\n\n\n\n\n\tdocCount\n\n\n\n\n\toptimize/expungeDeletes\n\n\n\n\n\tisExternal (so Dir can know if this is addIndexes vs \"normal\" merging)\n\n\n\nRegarding the IOContext class I think we should design for what we have right now and since SegementInfo is not used anywhere (as far as I can see) we should add it once we need it. OneMerge should not go in there but rather the interface / abstract class I talked about above.\n\nI agree, let's wait until we have a need.\n\nIn fact... SegmentInfo for flush won't work: we go and open all files\nfor flushing, write to them, close them, and only then do we make the\nSegmentInfo.\n\nSo it seems like we should also have some abtracted stuff about the\nto-be-flushed segment?  Maybe for starters the\nestimatedSegmentSizeBytes?  EG, NRTCachingDir could use this to decide\nwhether to cache the new segment (today it fragile-ly relies on the\napp to open new NRT reader frequently enough). ",
            "author": "Michael McCandless",
            "id": "comment-13046635"
        },
        {
            "date": "2011-06-10T13:58:54+0000",
            "content": "I think I have successfully threaded IOContext to the codecs and index package wherever required. There might be instances where I have used Context.Default wrongly.\n\nI'll begin adding documentation.\n\nIn NRTCachingDir.doCacheWrite method where IOContext is used if the context has it's OnceMergeInfo field null might lead to a bug ? Should cases like those added to the docs ? ",
            "author": "Varun Thacker",
            "id": "comment-13047197"
        },
        {
            "date": "2011-06-10T14:49:04+0000",
            "content": "I had messed up the patch using eclipse. This should be ok. ",
            "author": "Varun Thacker",
            "id": "comment-13047230"
        },
        {
            "date": "2011-06-10T15:04:24+0000",
            "content": "Varun, your patch doesn't apply cleanly to my latest trunk. i think you should update your local copy again!\n\nI have trouble to understand how you use MergeInfo etc. I figure there might be a misunderstanding so here is what I had in mind roughly: \n\n\nIndex: lucene/src/java/org/apache/lucene/index/MergePolicy.java\n===================================================================\n--- lucene/src/java/org/apache/lucene/index/MergePolicy.java\t(revision 1134335)\n+++ lucene/src/java/org/apache/lucene/index/MergePolicy.java\t(working copy)\n@@ -64,7 +64,7 @@\n    *  subset of segments to be merged as well as whether the\n    *  new segment should use the compound file format. */\n \n-  public static class OneMerge {\n+  public static class OneMerge extends MergeInfo {\n \n     SegmentInfo info;               // used by IndexWriter\n     boolean optimize;               // used by IndexWriter\n@@ -72,25 +72,26 @@\n     long mergeGen;                  // used by IndexWriter\n     boolean isExternal;             // used by IndexWriter\n     int maxNumSegmentsOptimize;     // used by IndexWriter\n-    public long estimatedMergeBytes;       // used by IndexWriter\n     List<SegmentReader> readers;        // used by IndexWriter\n     List<SegmentReader> readerClones;   // used by IndexWriter\n-    public final List<SegmentInfo> segments;\n-    public final int totalDocCount;\n+    public final List<SegmentInfo> segments = new ArrayList<SegmentInfo>();\n     boolean aborted;\n     Throwable error;\n     boolean paused;\n \n     public OneMerge(List<SegmentInfo> segments) {\n+      super(getSegments(segments));\n+    }\n+\n+    private static int getSegments(List<SegmentInfo> segments) {\n       if (0 == segments.size())\n         throw new RuntimeException(\"segments must include at least one segment\");\n       // clone the list, as the in list may be based off original SegmentInfos and may be modified\n-      this.segments = new ArrayList<SegmentInfo>(segments);\n       int count = 0;\n       for(SegmentInfo info : segments) {\n         count += info.docCount;\n       }\n-      totalDocCount = count;\n+      return count;\n     }\n \n     /** Record that an exception occurred while executing\n\n ",
            "author": "Simon Willnauer",
            "id": "comment-13047234"
        },
        {
            "date": "2011-06-11T16:50:57+0000",
            "content": "I hope this time I haven't messed up the making the patch. I corrected MergeInfo too. ",
            "author": "Varun Thacker",
            "id": "comment-13047945"
        },
        {
            "date": "2011-06-11T18:50:58+0000",
            "content": "hi varun,\n\nlooks good, some quick comments, \n\n\n\tCan OneMerge extend MergeInfo?\n\tCan we introduce a static IOContext instance like public static final IOContext DEFAULT = new IOContext() and use this everywhere where we need to use the default. All those object creations are unnecessary.\n\tCan IOContext() call this(false) instead of manually setting the values\n\tI think IOContext should take MergeInfo instead of OneMerge if you extend MergeInfo in OneMerge you can just pass OneMerge and you are done.\n\n\n\nI will have a closer look tomorrow\n\nsimon ",
            "author": "Simon Willnauer",
            "id": "comment-13047970"
        },
        {
            "date": "2011-06-12T09:56:20+0000",
            "content": "\nPatch is looking good!\n\n\n\tI thinkt the Context enum values should be ALL_CAPS\n\n\n\n\n\tFieldsWriter's ctor should take an IOContext?  Generally low level\n    places shouldn't create a new IOContext; they should be passed\n    one (though there are exceptions... eg I think it's fine that\n    SegmentInfos.run uses DEFAULT).\n\n\n\n\n\tSame for values/IntsImpl, values/Bytes, values/Floats,\n    SegmentReader.get, TermVectorsTermsReader, TermVectorsWriter,\n    DefaultSegmentInfosWriter, DefaultSegmentInfosReader,\n    FixedGapTermsIndexReader, VariableGapTermsIndexReader,\n    NormsWriter, BitVector (read & write)\n\n\n\n\n\tI think MP.OneMerge should not extend the new MergeInfo; I'm\n    worried about cases where classes hang onto the IOContext (eg,\n    various places save the IOContxt away as a member) because this\n    could then risk holding refs to the SegmentReaders created for\n    merging.  I think it's less risky to fully decouple the MergeInfo\n    from OneMerge.  Then, maybe MergeInfo should be a static inner\n    class inside IOContext?\n\n\n\n\n\tIndexWriter.ReaderPool.get should pass the IOCtx down to\n    SegmentReader.get\n\n\n\n\n\tIndexWriter.prepareFlushedSegment should be FLUSH not DEFAULT\n    context.\n\n\n\n\n\tCan you add assert inside IOContext: if the ctx is MERGE then the\n    MergeInfo must not be null (ie in the ctor that takes only a\n    Context).\n\n\n\n\n\tMergeInfo needs a few more fields (eg optimize, isExternal)\n\n\n\n\n\tWhen IndexWriter.addIndexes makes the MERGE context it should pass\n    a MergeInfo with isExternal true\n\n\n\n\n\tIn IndexWriter.mergeMiddle, you should make a single IOCtx(MERGE)\n    up front and pass to all readerPool.get calls\n\n\n\n\n\tAt the end of IndexWriter.mergeMiddle, when we open the\n    mergedReader... we should not pass MERGE context here, somehow,\n    because this open is very different than when we open the\n    to-be-merged segments.  IE, we are opening the merged segment.\n    Hmm, maybe, we can add a new flag to the MergeInfo,\n    \"isMergedSegment\"?  Alternatively... we use Context.READ, but then\n    I think we need something else that states what \"READ\" this really\n    is \u2013 eg NRT reader, merged segment reader, \"normal\" (IR.open)\n    reader?\n\n\n\n\n\tTermVectorsTermsWriter should be a Context.FLUSH\n\n\n\n\n\tSegmentWriteState.context can be final\n\n\n\n\n\tSomehow, PerFieldCodecWrapper.java shows as deleted...\n\n\n\n\n\tMergeInfo.java needs copygirht header & javadoc.\n\n\n\n\n\tNeed whitespace around '=', eg \"this.context=context;\" should be\n    \"this.context = context;\"\n\n ",
            "author": "Michael McCandless",
            "id": "comment-13048283"
        },
        {
            "date": "2011-06-12T09:59:17+0000",
            "content": "Can OneMerge extend MergeInfo?\n\nI think this is risky because it then makes IOContext an unexpectedly\nheavy object, since OneMerge holds SegmentReaders used for merging.\n\nThere are already some places that save away an IOContext instance as\na member (to be used later), and if something ever does this for a MERGE\nthen we can unexpectedly hold keep a lot of garbage alive.\n\nI think, instead, when the context is MERGE, we should make a new\n(lightweight) MergeInfo instance that pulls the necessary details from\nthe OneMerge, ie fully decouples from the OneMerge instance. ",
            "author": "Michael McCandless",
            "id": "comment-13048285"
        },
        {
            "date": "2011-06-14T17:25:19+0000",
            "content": "LUCENE-3203 is another example where a Dir needs the IOContext so it can optionally rate limit the bytes/second if it's a merge. ",
            "author": "Michael McCandless",
            "id": "comment-13049293"
        },
        {
            "date": "2011-06-16T10:29:40+0000",
            "content": "I made the changes. I also fixed test-framework but haven't touched the test cases yet.  ",
            "author": "Varun Thacker",
            "id": "comment-13050336"
        },
        {
            "date": "2011-06-16T14:28:45+0000",
            "content": "hey varun\n\npatch looks close!\n\nhere are some comments:\n\n\n\tthe assert context == Context.MERGE should be assert context != Context.MERGE || mergeInfo != null;\n\tcan you move that assert into IOContext(Context, MergeInfo) and let other related constructors call this(context, mergeInfo) instead of initializing all members themself?\n\tI think there should be a public static final IOContext READONCE = new IOContext(true); then you can make the corresponding constructor private. I think the context should be Context.READ instead of default in that case right?\n\tIOContext(MergePolicy.OneMerge) seems to be unnecessary. I think you should add a method to OneMerge to get a MergeInfo from it and only have a MergeInfo ctor. Then you can move MergeInfo into OneMerge too.\n\tPerFieldCodecWrapper still seems to be deleted\n\tIn IndexReader IOContext context=null; should be IOContext context= new IOContext(READ); no?\n\tno commit should be nocommit - we have a script on jenkins that checks this \n\tI still see some whitespace problems in SegmentWriteState.java\n\tI think IOContext.DEFAULT_IOCONTEXT should be IOContext.DEFAULT since IOContext is implicit\n\n\n\n\nI am waiting for you fixing the tests before I review further. Yet, what is missing is still the decision what buffer size to used down in direcotries etc.\n\ngood work so far!\n ",
            "author": "Simon Willnauer",
            "id": "comment-13050444"
        },
        {
            "date": "2011-06-16T14:30:39+0000",
            "content": "Sorry for messing up the patch again!  ",
            "author": "Varun Thacker",
            "id": "comment-13050448"
        },
        {
            "date": "2011-06-16T21:18:27+0000",
            "content": "I have made changes suggested by Simon and have added Context to the test cases, though I've used DEFAULT in most of it. \n\nAlso do we need the test- TestBufferedIndexInput ? I have added a IOContext.DEFAULT and fixed it though.  ",
            "author": "Varun Thacker",
            "id": "comment-13050738"
        },
        {
            "date": "2011-06-18T08:16:33+0000",
            "content": "I made some more changes to the earlier patch. I tried putting a nocommit wherever I thought the code was leading to a assertError or a bufferSize as 0 error.  ",
            "author": "Varun Thacker",
            "id": "comment-13051473"
        },
        {
            "date": "2011-06-19T10:08:07+0000",
            "content": "hey varun thanks for the new patch, some comments:\n\n\n\tthe nocommit in IW you should maybe add a second ctor to MergeInfo that takes arguments and then use something like this in IW: final IOContext context = new IOContext(new MergeInfo(info.docCount, info.sizeInBytes(true), true, false));\n\tIt seems kind of odd to always prefix MergeInfo with OneMerge so maybe move it into its own file\n\tregarding the read buffer problem, can you simply use BufferedIndexInput.BUFFER_SIZE to initialize it and put a TODO / nocommit on top\n\tYou should look into contrib/misc there are some compile errors in AppendingCodec as well as in solr land.\n\tI think in Directory the openInput method should be abstract:   public abstract IndexInput openInput(String name, IOContext context) throws IOException; and FSDirectory should not specify this method at all. Currently your code would produce a stack overflow since it calls itself.\n\n\n\nIf I fix the nocommits in your patch test-core passes without problems. Looking good man we are getting closer!\n\nSimon ",
            "author": "Simon Willnauer",
            "id": "comment-13051665"
        },
        {
            "date": "2011-06-19T19:06:43+0000",
            "content": "Made the changes and I get a Build Successful too ! ",
            "author": "Varun Thacker",
            "id": "comment-13051720"
        },
        {
            "date": "2011-06-20T09:01:40+0000",
            "content": "I created a branch for this issue and follow up issues here: https://svn.apache.org/repos/asf/lucene/dev/branches/LUCENE2793/ ",
            "author": "Simon Willnauer",
            "id": "comment-13051857"
        },
        {
            "date": "2011-06-20T14:11:07+0000",
            "content": "For the record - I went through the latest patch and added some nocommits where needed. I will take this patch and commit it to the branch. We should now work on that branch to fix all the remaining issues. ",
            "author": "Simon Willnauer",
            "id": "comment-13051983"
        },
        {
            "date": "2011-06-22T20:11:10+0000",
            "content": "I am not sure whether the MergeInfo used in SegmentMerger#mergeFields\n\nI have kept most of the nocommits there even after correcting it for reference.\n\nIn MockDirectoryWrapper#crash() to randomize IOContext I have used either a READONCE or DEFAULT or Merge context. Is this the correct way to go?\n\nIn LuceneTeseCase#newDirectory(), MockDirectoryWrapper#createOutput(), MockDirectoryWrapper#openInput() will randomizing the context here help?  ",
            "author": "Varun Thacker",
            "id": "comment-13053437"
        },
        {
            "date": "2011-06-24T10:51:38+0000",
            "content": "Patch, fixing NRTCachingDir to no longer have anything to do with the merge scheduler (yay!). ",
            "author": "Michael McCandless",
            "id": "comment-13054358"
        },
        {
            "date": "2011-06-24T10:52:43+0000",
            "content": "I took quick look @ the branch \u2013 it's looking good!  Some small stuff:\n\n\n\n\n\n\tShould IOContext and MergeInfo be in oal.store not .index?\n\n\n\n\n\tI think SegmentMerger should receive an IOCtx from its caller, and\n    then apss that to all the IO ops it invokes?  But the code has a\n    nocommit about tripping an assert \u2013 which one?\n\n\n\n\n\tI think on flush IOContext should include num docs and estimated\n    segment size (we can roughly pull this from RAM used for the\n    segment), but we should include comment that this is only approx.\n\n\n\n\n\tSomehow, lucene/contrib/demo/data is deleted on the branch.  We\n    should check if anything else is missing!\n\n ",
            "author": "Michael McCandless",
            "id": "comment-13054359"
        },
        {
            "date": "2011-06-27T16:52:40+0000",
            "content": "Should IOContext and MergeInfo be in oal.store not .index?\n+1\n\nI think SegmentMerger should receive an IOCtx from its caller, and\nyeah I think we should pass the IOContext in via the ctor. Yet, for IW#addIndexes you can simply build a best effort IOContext like:\n\n\n\n for (IndexReader indexReader : readers) \n{\n   numDocs += indexReader.numDocs();\n }\n final IOContext context = new IOContext(new MergeInfo(numDocs, -1, true, false));\n}\n\nI think on flush IOContext should include num docs and estimated\n+1 I think that is good no?\n\nSomehow, lucene/contrib/demo/data is deleted on the branch. We should check if anything else is missing!\noh man... I will check\n\nyou use new IOContext(Context.FLUSH) and new IOContext(Context.READ) in your patch but we have some static like IOContext.READ maybe we need FLUSH too?\n\nfor the tests I think we should start randomizing the IOContext. I think you should add a newIOContext(Random random) to LuceneTestCase and get the context from there in a unit test. At the end of the day we should see same behavior whatever context you pass in right?\n\nsimon\n\n\n\n ",
            "author": "Simon Willnauer",
            "id": "comment-13055649"
        },
        {
            "date": "2011-06-27T23:15:30+0000",
            "content": "I have made the necessary changes. Still I might have missed out changing couple of Test Cases to random IOContext. \n\nI wanted to put it our so that you'll can have a look as soon as possible.  ",
            "author": "Varun Thacker",
            "id": "comment-13056188"
        },
        {
            "date": "2011-06-28T11:19:23+0000",
            "content": "Varun, patch looks great!\n\nhere are some comments:\n\n\n\tin LuceneTestCase#newIOContext(Random) your switch statement misses necessary break; statements no matter what you will always get a flush\ncontext. I think you should also randominze the numbers for numDocs and sizeInBytes. nobody should rely on these number they are just best effort.\n\tin  o.a.l.i.values.Bytes#getValues, o.a.l.i.StoredFieldsWriter#initFieldsWriter, o.a.l.i.SegmentMerger#mergeVectors, MemoryCodec#fieldsProducer, MockSingleIntIndexOutput#MockSingleIntIndexOutput you can remove the nocommit\n\tthe public members in FlushInfo should be final\n\tthe MergeInfo ctors javadoc should either describe the arguments or omit them. In this case I think you can simply omit them since they are pretty self explained. I think what we need on MergeInfo as well as on FlushInfo is a javadoc comment that says that the values are estimates not necessarily real / correct values.\n\ton private IOContext (Context context, MergeInfo mergeInfo ) I don't understand the assert why is there a context != Flush?\n\tin MockDirectoryWrapper there is a nocommit that says randomize the IOContext. Maybe we should put the newIOContext to _TestUtils and delegate to this from LuceneTestCase?\n\n\n\nOverall I think we are really close here. Once those comments are fixed I will commit the patch to the branch and we go through the remaining nocommits. Once this is done we should close this and create a new issue to fix all the buffer sizes just like LUCENE-3248. \n\ngood job varun ",
            "author": "Simon Willnauer",
            "id": "comment-13056449"
        },
        {
            "date": "2011-06-29T09:59:06+0000",
            "content": "I also removed nocommits from \no.a.l/index/codecs/DefaultDocValuesProducer.java\no.a.l/index/values/VarStraightBytesImpl.java\no.a.l/index/values/FixedStraightBytesImpl.java\no.a.l/index/codecs/appending/AppendingCodec.java ",
            "author": "Varun Thacker",
            "id": "comment-13057133"
        },
        {
            "date": "2011-06-30T16:01:29+0000",
            "content": "Varun this patch looks great. I am about to commit it. Can you now work through the nocommits, fix them or post questions here?\n\nsimon ",
            "author": "Simon Willnauer",
            "id": "comment-13057903"
        },
        {
            "date": "2011-06-30T16:16:57+0000",
            "content": "Varun, \n\nthe latest patch is committed. I added some minor cleanups and removed invalid nocommits. We are in good shape already ",
            "author": "Simon Willnauer",
            "id": "comment-13057911"
        },
        {
            "date": "2011-06-30T22:48:46+0000",
            "content": "To address the nocommits about losing the larger buffer size during merging, should we add set/getMergeBufferSize and set/getDefaultBufferSize to those Dir impls that do buffering?  (And default to what they are today on trunk, I think 1 KB and 4 KB?) ",
            "author": "Michael McCandless",
            "id": "comment-13058116"
        },
        {
            "date": "2011-07-03T22:24:40+0000",
            "content": "I am not sure on the way I have tried to correct the nocommits on how to use buffer sizes based on IOContext. Let me know if this is not the correct way of doing it or are there any changes required.  ",
            "author": "Varun Thacker",
            "id": "comment-13059293"
        },
        {
            "date": "2011-07-04T17:56:52+0000",
            "content": "I think BufferedIndexInput doesn't need a set/getMergeBufferSize?  Ie, BII only knows its bufferSize, regardless of the context from its parent.\n\nOtherwise I think your patch is good: today on trunk we hardwire the 4 KB buffer size for merges, which is the same thing your patch is doing; the only difference is the constant MERGE_BUFFER_SIZE has moved from IW to BII, and each Dir impl now has the \"if\".  As a future improvement we can add a set/getMergeBufferSize to each Dir impl... ",
            "author": "Michael McCandless",
            "id": "comment-13059527"
        },
        {
            "date": "2011-07-05T10:30:13+0000",
            "content": "Made the necessary changes and hopefully addressed all the nocommits.  ",
            "author": "Varun Thacker",
            "id": "comment-13059825"
        },
        {
            "date": "2011-07-05T11:14:18+0000",
            "content": "Made some more changes... ",
            "author": "Varun Thacker",
            "id": "comment-13059838"
        },
        {
            "date": "2011-07-06T12:43:01+0000",
            "content": "Made the necessary changes and hopefully addressed all the nocommits.\nvarun, I still see lots of nocommits here. Would be good if you could address them this week. You don't need to solve them but discuss them here with us. you can do that in a patch and add your comments to the parts where you are not sure how to resolve.\n\nI would like to commit the patches this week so we can merge to trunk soonish.\n\nSimon ",
            "author": "Simon Willnauer",
            "id": "comment-13060537"
        },
        {
            "date": "2011-07-06T12:48:16+0000",
            "content": "+1 ",
            "author": "Michael McCandless",
            "id": "comment-13060538"
        },
        {
            "date": "2011-07-06T13:53:12+0000",
            "content": "I removed all the remaining nocommits as I think all of them had been addressed to. ",
            "author": "Varun Thacker",
            "id": "comment-13060581"
        },
        {
            "date": "2011-07-06T16:12:53+0000",
            "content": "I took varuns patch and cleaned a couple of things up. I think this is ready, if nobody objects I will go ahead and commit this to the branch, merge up with trunk and upload a new patch to integrate this into trunk.\n\nOnce this is on trunk we can follow up with native stuff etc.\n\nThoughts? ",
            "author": "Simon Willnauer",
            "id": "comment-13060663"
        },
        {
            "date": "2011-07-06T16:28:41+0000",
            "content": "s/4069/4096 ",
            "author": "Simon Willnauer",
            "id": "comment-13060671"
        },
        {
            "date": "2011-07-07T10:56:51+0000",
            "content": "I committed the latest patch, merged the branch with trunk and created a final diff for review. I think this is ready and I would like to reintegrate rather sooner than later.\n\nreviews welcome ",
            "author": "Simon Willnauer",
            "id": "comment-13061197"
        },
        {
            "date": "2011-07-07T17:01:58+0000",
            "content": "Looks good!  +1 to land it!\n\nJust a few things:\n\n\n\tShouldn't WindowsDirectory also call BII.bufferSize(context) and\n    do the same Math.max it used to do?\n\n\n\n\n\tShould VarGapTermsIndexReader should pass READONCE context down when it\n    opens/reads the FST?  Hmm, though, it should just replace the ctx\n    passed in, ie if we are merging vs reading we want to\n    differentiate.  Let's open separate issue for this and address\n    post merge?\n\n\n\n\n\tCan you open an issue for this one: \"// TODO: context should be\n    part of the key used to cache that reader in the pool.\"?  This is\n    pretty important, else you can get NRT readers with too-large\n    buffer sizes because the readers had been opened for merging\n    first.\n\n\n\n\n\tExtra space in SegmentInfo.java: IOContext.READONCE );\n\n ",
            "author": "Michael McCandless",
            "id": "comment-13061439"
        },
        {
            "date": "2011-07-08T08:10:39+0000",
            "content": "I fixed the two minor things from above, created two followup issues (LUCENE-3292 & LUCENE-3293) for the remaining TODOs and will go ahead reintegrating the branch now. ",
            "author": "Simon Willnauer",
            "id": "comment-13061836"
        },
        {
            "date": "2011-07-08T08:53:32+0000",
            "content": "I reintegrated the branch and committed to trunk in revision 1144196. I will now go ahead and delete the branch. all further developments should happen on trunk. @Varun make sure you move you current work in progress to trunk and be careful with svn update on the branch since some of your changes might get lost.\n\nThanks Varun... good job! ",
            "author": "Simon Willnauer",
            "id": "comment-13061849"
        }
    ]
}