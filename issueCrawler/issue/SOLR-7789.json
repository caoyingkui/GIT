{
    "id": "SOLR-7789",
    "title": "Introduce a ConfigSet management API at /admin/configs",
    "details": {
        "components": [],
        "type": "New Feature",
        "labels": "",
        "fix_versions": [
            "5.4",
            "6.0"
        ],
        "affect_versions": "None",
        "status": "Closed",
        "resolution": "Fixed",
        "priority": "Major"
    },
    "description": "SOLR-5955 describes a feature to automatically create a ConfigSet, based on another one, from a collection API call (i.e. one step collection creation).  Discussion there yielded SOLR-7742, Immutable ConfigSet support.  To close the loop, we need support for a ConfigSet management API.\n\nThe simplest ConfigSet API could have one operation:\ncreate a new config set, based on an existing one, possible modifying the ConfigSet properties.  Note you need to be able to modify the ConfigSet properties at creation time because otherwise Immutable could not be changed.\n\nAnother logical operation to support is ConfigSet deletion; that may be more complicated to implement than creation because you need to handle the case where a collection is already using the configuration.",
    "attachments": {
        "SOLR-7789.patch": "https://issues.apache.org/jira/secure/attachment/12751393/SOLR-7789.patch"
    },
    "issue_links": {},
    "comments": [
        {
            "date": "2015-08-20T02:13:57+0000",
            "author": "Gregory Chanan",
            "content": "Here is a patch that implements a ConfigSets API for SolrCloud with two entry points:\n\n\n\tCREATE: Create a ConfigSet, based on an existing ConfigSet\nParameters:\n\n\n\nKey\nType\nRequired\nDefault\nDescription\n\n\nname\nString\nYes\n\u00a0\nConfigSet to be created\n\n\nbaseConfigSet\nString\nYes\n\u00a0\nConfigSet to copy as a base\n\n\nconfigSetProp.name=value\nString\nNo\n\u00a0\nConfigSet property from base to override\n\n\n\n\n\n\n\n\n\tDELETE: Delete a ConfigSet\nParameters:\n\n\n\nKey\nType\nRequired\nDefault\nDescription\n\n\nname\nString\nYes\n\u00a0\nConfigSet to be deleted\n\n\n\n\n\n\n\nThe implementation is based on the Collections API and in fact uses the same OverseerProcessor at this time.  The handling code between the ConfigSets API and the CollectionsAPI is completely separate so it should be easy to move to its own OverseerProcessor in the future.  Using one OverseerProcessor seemed reasonable given the above operations should be fast.\n\nSome notes:\n1) DELETE does not check that a ConfigSet is not referenced.  This is equivalent to the existing method of deleting a ConfigSet via the zkcli.  The exception to this rule is with task exclusivity: a ConfigSet deletion won't go through if there is an on going operation referencing that ConfigSet (e.g. as a Base ConfigSet in a create).  There is a bit of complexity in implementing that efficiently (simulating a read/write lock for exclusivity so we don't block on multiple ConfigSets being reated with the same Base ConfigSet).\n\n2) The name for the ConfigSet properties file is always assumed to be \"configsetprops.json\".  This is necessary to handle deletions correctly; if we allowed the user to specify in the API call what the file was called they could point at another or non-existing file to be able to avoid the immutable check.  This is a little strange because the CoreDescriptor lets you override the name of this file, but I guess this is equivalent to solrconfig.xml and schema.xml being special in ZK even though they can also be overriden in the CoreDescriptor.\n\n3) The handling of the Overseer.getConfigSetQueue isn't as nice as I would like.  Because we use the same OverseerProcessor, we need some way of figuring out which MessageHandler to dispatch to; we do this by prefixing the action in ZK with \"configsets:\".  Both the ConfigSetsHandler and the OverseerConfigSetsMessageHandler need to be aware of this.  Ideally, the queue returned from Overseer.getConfigSetQueue would just handle this when an item was inserted into the queue, so only the Overseer has to worry about how the messages are actually handled.  This was difficult to do given the DistributedQueue API is just byte arrays.  I think the correct thing to do here is change at least the offer API to be JSON based \u2013 all the non-test calls already immediately convert JSON to bytes anyway \u2013 but this seemed like a larger change for this patch.\n\nSome testing notes:\nT1) I wanted to be able to test the case where the CREATE failed half way through, so we end up with partial state in ZK that needed to be cleaned up.  I found the easiest way to do this was to override the ZKDatabase that the ZKTestServer uses.  So, you can now get/set the ZKDatabase in the ZKTestServer and pass your own ZKTestServer to the MiniSolrCloudCluster.\n\nT2) There's also an \"exclusivity\" test to ensure that actions on the same ConfigSet don't trample each other.  This is done by concurrently doing DELETEs/CREATEs and ensuring the exceptions indicate that the operations ran sequentially. ",
            "id": "comment-14704171"
        },
        {
            "date": "2015-08-20T19:44:26+0000",
            "author": "Mark Miller",
            "content": "I'm having a little trouble applying the latest patch because it's out of date.\n\nDo you know what svn revision it is based on? ",
            "id": "comment-14705631"
        },
        {
            "date": "2015-08-20T20:08:25+0000",
            "author": "Gregory Chanan",
            "content": "Here's a rebased version of the patch on top of \ngit-svn-id: https://svn.apache.org/repos/asf/lucene/dev/trunk@1696834 13f79535-47bb-0310-9956-ffa450edef68 ",
            "id": "comment-14705677"
        },
        {
            "date": "2015-08-21T13:49:52+0000",
            "author": "Mark Miller",
            "content": "I still cant apply this patch cleanly against 1696834. Do you have an svn version of the patch? ",
            "id": "comment-14706749"
        },
        {
            "date": "2015-08-21T17:25:42+0000",
            "author": "Gregory Chanan",
            "content": "Sorry about that, I don't know what the issue is.  I'll generate an svn version.\n\nI'm not sure how much we care about this, but one issue I realized with the patch is that it is a little aggresive about cleaning up failed CREATE attempts.  If someone concurrently is using the zkcli to add a config and using CREATE via the API (so exclusivity checking doesn't apply), the following can happen:\n\n\tCREATE call checks that config doesn't exist\n\tzkcli adds config\n\tCREATE tries to create and fails\n\tCREATE removes config as part of failure cleanup\n\n\n\nFirst, we should recommend that people don't use the zkcli and the ConfigSET API concurrently (I would argue people shouldn't use zkcli at all).  But we could be a little smarter about this case, e.g. track if the CREATE call actually wrote anything and only clean up if something was actually written. ",
            "id": "comment-14707076"
        },
        {
            "date": "2015-08-21T20:03:30+0000",
            "author": "Gregory Chanan",
            "content": "Generated an svn patch, let me know if this works, Mark. ",
            "id": "comment-14707379"
        },
        {
            "date": "2015-08-21T20:08:36+0000",
            "author": "Mark Miller",
            "content": "Clean apply, thanks! ",
            "id": "comment-14707386"
        },
        {
            "date": "2015-08-21T20:25:51+0000",
            "author": "Gregory Chanan",
            "content": "Looks like there are some small semantic conflicts with SOLR-6760, I'm working to address. ",
            "id": "comment-14707411"
        },
        {
            "date": "2015-08-21T21:04:31+0000",
            "author": "Gregory Chanan",
            "content": "Commented in SOLR-6760 with a plan for how to address: https://issues.apache.org/jira/browse/SOLR-6760?focusedCommentId=14707457&page=com.atlassian.jira.plugin.system.issuetabpanels:comment-tabpanel#comment-14707457 ",
            "id": "comment-14707459"
        },
        {
            "date": "2015-08-22T01:49:40+0000",
            "author": "Gregory Chanan",
            "content": "attached a new version of the patch with two changes:\n1) renamed OverseerCollectionQueue to OverseerTaskQueue, as discussed in SOLR-6760\n2) only cleans up CREATE if the CREATE call actually wrote something to ZK ",
            "id": "comment-14707779"
        },
        {
            "date": "2015-08-22T12:04:30+0000",
            "author": "Shalin Shekhar Mangar",
            "content": "\nI am trying to accomplish the following:\n#1 Add another OverseerMessageHandler (OverseerConfigSetMessageHandler) to handle ConfigSet-related operations.\n#2 From the perspective of the non-overseer (i.e. the ConfigSetsHandler), it looks like the operations are written to a separate queue from the collection queue, i.e. getOverseerConfigSetQueue()\n#3 Since the ConfigSet operations are most likely rare and fast, it made sense to just use the existing collections queue \"under the covers\" and handle the dispatch separately. The naming here breaks the illusion of #2, i.e. if I return an OverseerCollectionQueue it's pretty obvious to the non-overseer what's going on.\n\nWhy should there be a separate queue for such operations? i.e. Why should ZkController have method called getOverseerConfigSetQueue() at all? It should just use the collection queue. Similarily why does this API need a new ConfigSetsHandler and not use CollectionsHandler?\n\nShort term: rename OverseerCollectionQueue to something more generic...DistributedTaskQueue? DistributedAsyncAwareQueue? There's nothing in there that is actually collection specific (which is why it works for the ConfigSet operations)\n\nThe only reason why it is called a OverseerCollectionQueue is to indicate that it is the queue for OverseerCollectionProcessor.\n\nTBH, all this refactoring of OverseerCollectionProcessor confuses me very much. It looks like you want the APIs and tasks run in the overseer to be pluggable but I haven't noticed you saying that anywhere. In the absence of them being truly pluggable, the current API has become more complicated than it was before. We do not need complex dispatch mechanisms in the collection processor. If you think that it is wrong to perform tasks that do not involve a Collection then it could simply be renamed to OverseerTaskProcessor and we can be done. Btw we have had APIs such as clusterprops and request_status in the overseer collection processor and I don't think it is confusing anyone. ",
            "id": "comment-14708011"
        },
        {
            "date": "2015-08-22T20:55:14+0000",
            "author": "Gregory Chanan",
            "content": "Thanks for the comments, Shalin.\n\nWhy should there be a separate queue for such operations? i.e. Why should ZkController have method called getOverseerConfigSetQueue() at all? It should just use the collection queue. Similarily why does this API need a new ConfigSetsHandler and not use CollectionsHandler?\n\nLet's start with the second question.  There is a ConfigSetsHandler because it operates on a separate end point \u2013 it doesn't make sense to send ConfigSet-related commands to /admin/collections, it makes more sense from the end user perspective to send ConfigSet-related commands to /admin/configs.  Given separate end points, separate handlers also make sense.\n\nOn the second question, the concern is a little more subtle.  The point I am trying to make is that how the Overseer processes ConfigSet operations is an implementation detail of the Overseer.  The ConfigSetHandler (which is not part of the Overseer) just needs an interface in order to tell the Overseer that it wants a ConfigSet operation processed, it shouldn't be concerned with the implementation details.  Right now we happen to use the same queue under the covers, but maybe we find in the future that's a bad idea (e.g. users have different QoS expectations between ConfigSet and Collection operations and we add ConfigSet operations that are long lived and block important Collection operations).  If the interface between the Overseer and the ConfigSet handler doesn't refer to collections, we don't need to change anything outside of the Overseer if we change the processing in the future.\n\nThe only reason why it is called a OverseerCollectionQueue is to indicate that it is the queue for OverseerCollectionProcessor.\n\nThat can be indicated with a variable/method name, not the type name.\n\nTBH, all this refactoring of OverseerCollectionProcessor confuses me very much. It looks like you want the APIs and tasks run in the overseer to be pluggable but I haven't noticed you saying that anywhere. In the absence of them being truly pluggable, the current API has become more complicated than it was before. We do not need complex dispatch mechanisms in the collection processor.\n\nI don't wish to make the API/tasks pluggable so I understand your concern.  That being said, there is a middle ground between API/tasks being pluggable and putting everything in the collection processor.  All I'm arguing for is clean interfaces.  Take SOLR-7855 as an example; because we had Overseer/role related commands in the collection processor it made refactoring much more difficult.  Doing what you suggest in my opinion would have the same effect.\n\nWe do not need complex dispatch mechanisms in the collection processor. If you think that it is wrong to perform tasks that do not involve a Collection then it could simply be renamed to OverseerTaskProcessor and we can be done.\n\nI don't think the dispatching here is complex and it is completely contained in the Overseer.  I'm not sure what you mean by OverseerTaskProcessor, this seems like a separate issue.  After SOLR-7855 we have an OverseerCollectionMessageHandler to handle overseer collection messages.  If you are suggesting throwing the ConfigSet related commands in there (from OverseerConfigSetMessageHandler), you've just moved the dispatch code somewhere else.\n\nBtw we have had APIs such as clusterprops and request_status in the overseer collection processor and I don't think it is confusing anyone.\n\nI gave the example above the overseer/role related commands making code hard to refactor.  I agree with you that clusterprops and request_status aren't particularly confusing \u2013 that doesn't mean we can't do better.\n ",
            "id": "comment-14708173"
        },
        {
            "date": "2015-08-24T17:22:18+0000",
            "author": "Shalin Shekhar Mangar",
            "content": "There is a ConfigSetsHandler because it operates on a separate end point \u2013 it doesn't make sense to send ConfigSet-related commands to /admin/collections, it makes more sense from the end user perspective to send ConfigSet-related commands to /admin/configs. Given separate end points, separate handlers also make sense.\n\nOkay, that is reasonable.\n\nThe point I am trying to make is that how the Overseer processes ConfigSet operations is an implementation detail of the Overseer. The ConfigSetHandler (which is not part of the Overseer) just needs an interface in order to tell the Overseer that it wants a ConfigSet operation processed, it shouldn't be concerned with the implementation details.\n\nIn my mind, it makes the opposite impression. The fact that we have a ZkController.getOverseerCollectionQueue and a different ZkController.getOverseerConfigSetQueue() suggests that the two queues are different but they are not, at least not yet. So why does this feature try to suggest that their implementation might be different at all? These things are easily changed so lets refactor it when we actually need to have different queues.\n\nRight now we happen to use the same queue under the covers, but maybe we find in the future that's a bad idea (e.g. users have different QoS expectations between ConfigSet and Collection operations and we add ConfigSet operations that are long lived and block important Collection operations). If the interface between the Overseer and the ConfigSet handler doesn't refer to collections, we don't need to change anything outside of the Overseer if we change the processing in the future.\n\nThere are already different QoS expectations within the existing operations. For example, operations for different collections never block each other and operations such as cluster status, overseer status and request status never block. However, they are all managed by the same overseer and it can continue to be the case. Yes, what operations block what is not formally defined or enforced, which is something that can use some love.\n\n\nThe only reason why it is called a OverseerCollectionQueue is to indicate that it is the queue for OverseerCollectionProcessor.\nThat can be indicated with a variable/method name, not the type name.\n\nSure it could be if it is a generic queue but it is only used for the overseer collection processor and I don't see the need for another queue in Solr right now.\n\nI don't wish to make the API/tasks pluggable so I understand your concern. That being said, there is a middle ground between API/tasks being pluggable and putting everything in the collection processor. All I'm arguing for is clean interfaces. Take SOLR-7855 as an example; because we had Overseer/role related commands in the collection processor it made refactoring much more difficult. Doing what you suggest in my opinion would have the same effect\n\nI understand what you are saying. I did the same for Overseer in SOLR-6554 which grouped all related operations and moved them into their own classes (ClusterStateMutator, SliceMutator etc). In fact, I'd argue that SOLR-7855 didn't go far enough \u2013 it'd be great to have individual operations completely separate from the message processor such that they can be easily unit tested. I am very much on board with that.\n\nI'm just a bit confused why we have an interface if we have just one implementation (YAGNI!) e.g. OverseerMessageHandler and OverseerMessageHandlerSelector. Similarily, OverseerCollectionProcessor doesn't add much over OverseerProcessor except for the static getOverseerMessageHandlerSelector method.\n\nI don't think the dispatching here is complex and it is completely contained in the Overseer. After SOLR-7855 we have an OverseerCollectionMessageHandler to handle overseer collection messages. If you are suggesting throwing the ConfigSet related commands in there (from OverseerConfigSetMessageHandler), you've just moved the dispatch code somewhere else.\n\nI was referring to the OverseerMessageHandlerSelector actually. I assumed that you foresee more than one implementation in the future which would make the dispatching more complex, hence the comment. So to dispatch a request, at level 1, you have the OverseerMessageHandlerSelector and at level 2, you have an OverseerMessageHandler and at level 3, you have the processMessage inside the OverseerMessageHandler which sends the request to the right handler method. This is the complexity that I was referring to. Perhaps, we can get rid of OverseerMessageHandlerSelector?\n\nSorry for the vague comment earlier. I don't want to block you anymore than I already have. We can always refactor this in future. Thank you for cleaning up the mess in OverseerCollectionProcessor! ",
            "id": "comment-14709658"
        },
        {
            "date": "2015-08-24T18:15:25+0000",
            "author": "Gregory Chanan",
            "content": "In my mind, it makes the opposite impression. The fact that we have a ZkController.getOverseerCollectionQueue and a different ZkController.getOverseerConfigSetQueue() suggests that the two queues are different but they are not, at least not yet. So why does this feature try to suggest that their implementation might be different at all? These things are easily changed so lets refactor it when we actually need to have different queues.\n\nI think part of the difference of opinion here is you are viewing the interface as \"this is the collection queue and this is the configset queue\" \u2013 given that the interface is a queue your line of thinking makes sense, but perhaps having queue as part of the interface is leaking too many implementation details already.  I'm viewing the interface as \"this is where I send Collection operation requests and this is where I send ConfigSet operation requests.\"  There's no same vs separate queue discussion if that is the interface.  If that were the interface, you would be arguing for a single \"this is where I send Overseer operation requests.\"\n\nTo be honest, I don't think this makes a huge difference either way right now.  The central issue, imo, is how you the RequestHandler differentiates which messages are intended for which MessageHandler.  In the naive way of just throwing everything in the OCP (not saying you are arguing for that), you'd have conflicts with say, the Collection.CREATE and ConfigSet.CREATE and would need to make sure all the names don't conflict (a mess).  So, you'd either need to differentiate the message at the Overseer interface level \"this is where I send Collection requests and this is where I send ConfigSet operation requests\" (this is essentially what I've chosen) or each handler puts enough content in the message so that the overseer can differentiate itself.  The later could certainly be the right way to go \u2013 I just didn't choose it because 1) it would require changing the existing message format and we'd have to deal with backwards incompatibility 2) we'd need to invent some grouping concept of operations (what are CollectionActions vs ConfigSetActions \u2013 groups of actions?  action sets?).  If we solve #1 and #2 I certainly have no objection to having a single \"this is where I send Overseer operation requests\" interface.\n\nThere are already different QoS expectations within the existing operations. For example, operations for different collections never block each other and operations such as cluster status, overseer status and request status never block. However, they are all managed by the same overseer and it can continue to be the case. Yes, what operations block what is not formally defined or enforced, which is something that can use some love.\n\nSure, that's just a hypothetical.  I think what I wrote above is the central issue.\n\nI understand what you are saying. I did the same for Overseer in SOLR-6554 which grouped all related operations and moved them into their own classes (ClusterStateMutator, SliceMutator etc). In fact, I'd argue that SOLR-7855 didn't go far enough \u2013 it'd be great to have individual operations completely separate from the message processor such that they can be easily unit tested. I am very much on board with that.\nI'm just a bit confused why we have an interface if we have just one implementation (YAGNI!) e.g. OverseerMessageHandler and OverseerMessageHandlerSelector. Similarily, OverseerCollectionProcessor doesn't add much over OverseerProcessor except for the static getOverseerMessageHandlerSelector method.\n\nWell there are two OverseerMessageHandlers now .  I see below your concern is mainly with the Selector.\n\nI was referring to the OverseerMessageHandlerSelector actually. I assumed that you foresee more than one implementation in the future which would make the dispatching more complex, hence the comment. So to dispatch a request, at level 1, you have the OverseerMessageHandlerSelector and at level 2, you have an OverseerMessageHandler and at level 3, you have the processMessage inside the OverseerMessageHandler which sends the request to the right handler method. This is the complexity that I was referring to. Perhaps, we can get rid of OverseerMessageHandlerSelector?\n\nThe OverseerMessageHandlerSelector was really just some scaffolding to help me with the refactor.  I don't have an objection to making a single non-interface implementation of it.  Or even a canonical implementation if we adopt the \"single this is where I send Overseer operation requests\" interface (e.g. it could just do some generic logic mapping the expanded info in the message with the set of available message handlers).  That should be another jira though. ",
            "id": "comment-14709774"
        },
        {
            "date": "2015-08-25T13:19:50+0000",
            "author": "Mark Miller",
            "content": "This all looks pretty nice and well tested to me.\n\nRE the API for accessing the queue, I first leaned towards Shalin's thinking, but Greg has sold me. What queue you get is really an implementation detail. As long as this is commented nicely somewhere, I think it makes sense.\n\nGeneral Notes:\n\nI think having separate end points for /collections and /configs and separating the code the best we can as well, rather than dumping it all in one class, makes sense to me.\n\nSometimes we use ConfigSet and sometimes ConfigSets? Do we have the right distinction? Can we call it out explicitly somewhere?\n\nMore comments giving overview and rationale of class breakup? As Shalin noted, the class hierarchy is a bit denser to get a handle on.\n\nNot the biggest fan of adding more tests with easymock - this stuff is such a pain to ramp up on for most committers when refactoring or making changes. I guess what can you do though. Many committers have expressed dislike with having to deal with the collections API test like this, but it\u2019s hard to argue around once someone presents working, useful tests. Some deeper things are just difficult to build simple mocks for.\n\n\nOverseerCollectionConfigSetProcessor\n\n\n\tTypo -  * 1) collection-related Overseer messagess\n\n\n\n\n\tShould we just pass the zkclient and simplify this constructor a bit? These boilerplate type class have such long constructors.\n\n\n\n        Overseer.getCollectionQueue(zkStateReader.getZkClient(), stats),\n        Overseer.getRunningMap(zkStateReader.getZkClient()),\u00e5\n        Overseer.getCompletedMap(zkStateReader.getZkClient()),\n        Overseer.getFailureMap(zkStateReader.getZkClient())\n\nTests \n\nI looked at a bit at what new tests I could easily overwhelm.\n\nTestConfigSetsAPIExclusivity\n\n\n\tBeasting Test fails:\n\n\n\n\n   [junit4]   2> NOTE: reproduce with: ant test  -Dtestcase=TestConfigSetsAPIExclusivity -Dtests.method=testAPIExclusivity -Dtests.seed=586D6E5E92126B0D -Dtests.slow=true -Dtests.locale=ar_LB -Dtests.timezone=America/Nassau -Dtests.asserts=true -Dtests.file.encoding=UTF-8\n   [junit4] FAILURE  190s | TestConfigSetsAPIExclusivity.testAPIExclusivity <<<\n   [junit4]    > Throwable #1: java.lang.AssertionError: Unexpected exception: org.apache.solr.client.solrj.impl.HttpSolrClient$RemoteSolrException: Error from server at http://127.0.0.1:50330/solr: create the configset time out:180s expected:<0> but was:<1>\n   [junit4]    > \tat __randomizedtesting.SeedInfo.seed([586D6E5E92126B0D:251877A5CBB6D244]:0)\n   [junit4]    > \tat org.apache.solr.cloud.TestConfigSetsAPIExclusivity.testAPIExclusivity(TestConfigSetsAPIExclusivity.java:95)\n   [junit4]    > \tat java.lang.Thread.run(Thread.java:745)\n   [junit4]   2> 189719 INFO  (SUITE-TestConfigSetsAPIExclusivity-seed#[586D6E5E92126B0D]-worker) [    ] o.a.s.SolrTestCaseJ4 ###deleteCore\n\n\n\n   [junit4]   2> NOTE: reproduce with: ant test  -Dtestcase=TestConfigSetsAPIExclusivity -Dtests.method=testAPIExclusivity -Dtests.seed=A74936D70D0532AD -Dtests.slow=true -Dtests.locale=ar_MA -Dtests.timezone=America/Resolute -Dtests.asserts=true -Dtests.file.encoding=UTF-8\n   [junit4] FAILURE  188s | TestConfigSetsAPIExclusivity.testAPIExclusivity <<<\n   [junit4]    > Throwable #1: java.lang.AssertionError: Unexpected exception: org.apache.solr.client.solrj.impl.HttpSolrClient$RemoteSolrException: Error from server at http://127.0.0.1:40187/solr: delete the configset time out:180s expected:<0> but was:<1>\n   [junit4]    > \tat __randomizedtesting.SeedInfo.seed([A74936D70D0532AD:DA3C2F2C54A18BE4]:0)\n   [junit4]    > \tat org.apache.solr.cloud.TestConfigSetsAPIExclusivity.testAPIExclusivity(TestConfigSetsAPIExclusivity.java:95)\n   [junit4]    > \tat java.lang.Thread.run(Thread.java:745)\n\n\n\nEverything else looks okay to me. ",
            "id": "comment-14711244"
        },
        {
            "date": "2015-08-25T21:45:16+0000",
            "author": "Gregory Chanan",
            "content": "Sometimes we use ConfigSet and sometimes ConfigSets? Do we have the right distinction? Can we call it out explicitly somewhere?\n\nI tried to follow the Collection(s) example, sometimes it is Collection (e.g. OverseerCollectionProcessor), sometimes it is Collections (CollectionsHandler).  I agree that this can be cleaned up, but would rather do it in a future patch.\n\nMore comments giving overview and rationale of class breakup? As Shalin noted, the class hierarchy is a bit denser to get a handle on.\n\nGood idea, I'll probably just get rid of the Selector interface as Shalin suggested and see where we stand there.\n\nNot the biggest fan of adding more tests with easymock - this stuff is such a pain to ramp up on for most committers when refactoring or making changes. I guess what can you do though. Many committers have expressed dislike with having to deal with the collections API test like this, but it\u2019s hard to argue around once someone presents working, useful tests. Some deeper things are just difficult to build simple mocks for.\n\nThere's actually no EasyMock additions in this patch \u2013 that's just showing up in the diff for some reason because some of the files are renamed.  I'll make sure to use \"svn move\" or whatever is the correct command when I commit.\n\nTypo - * 1) collection-related Overseer messagess\n\nWill fix.\n\n\n    Should we just pass the zkclient and simplify this constructor a bit? These boilerplate type class have such long constructors.\n\nOverseer.getCollectionQueue(zkStateReader.getZkClient(), stats),\nOverseer.getRunningMap(zkStateReader.getZkClient()),\u00e5\nOverseer.getCompletedMap(zkStateReader.getZkClient()),\nOverseer.getFailureMap(zkStateReader.getZkClient())\n\nThat's a good idea, was going to leave for another JIRA but we could do it here.\n\nBeasting Test fails:\n\nNot too concerning because they are timeouts, most likely just means we need to scale down the number of iterations.  I'll try out the beasting script. ",
            "id": "comment-14712032"
        },
        {
            "date": "2015-08-25T22:19:11+0000",
            "author": "Yonik Seeley",
            "content": "Not the biggest fan of adding more tests with easymock - this stuff is such a pain to ramp up on for most committers when refactoring or making changes.\n\nI'll +1 that in general (I know Greg said he's not adding additional easymock tests here)... there are probably niches where it's the best fit, but in the general case it seems prone to over-test, making it difficult to refactor. ",
            "id": "comment-14712073"
        },
        {
            "date": "2015-08-25T22:55:10+0000",
            "author": "Gregory Chanan",
            "content": "\n\n\n    Should we just pass the zkclient and simplify this constructor a bit? These boilerplate type class have such long constructors.\n\n    Overseer.getCollectionQueue(zkStateReader.getZkClient(), stats),\n    Overseer.getRunningMap(zkStateReader.getZkClient()),\u00e5\n    Overseer.getCompletedMap(zkStateReader.getZkClient()),\n    Overseer.getFailureMap(zkStateReader.getZkClient())\n\nActually, I think this is a little more complicated.  The runningMap/completedMap/failureMap are used by the CollectionsHandler to check for async tasks.  If the collection queue is collection specific the maps should be as well.  It probably makes sense to just group this stuff together in a single object, like \"OverseerTaskQueueState\" or \"OverseerTaskQueueAsyncState\" that just holds these objects.  Then there can be just a \"getCollectionQueueState\" and \"getConfigSetQueueState\" or whatever.  That would simplify the constructor above as well.  But I think this should be in another jira. ",
            "id": "comment-14712131"
        },
        {
            "date": "2015-08-26T23:54:50+0000",
            "author": "Gregory Chanan",
            "content": "Here's a new version of the patch.  Changes:\n\n\n\trebased to lastest trunk\n\tFixed typo pointed out by Mark\n\tAdded comment to OverseerCollectionMessageHandler\n\tRenamed OverseerProcessor -> OverseerTaskProcessor to go along with the OverseerTaskQueue name.\n\n\n\nI plan on committing this soon if I don't hear any objections and will file follow on jiras for the suggestions above. ",
            "id": "comment-14715772"
        },
        {
            "date": "2015-08-26T23:59:58+0000",
            "author": "Gregory Chanan",
            "content": "Oh and forgot to mention, I was able to reproduce with failures with the beasting script and just turning down the number of iterations allowed it to pass with 100 iterations, 8 concurrent. ",
            "id": "comment-14715775"
        },
        {
            "date": "2015-08-27T02:18:38+0000",
            "author": "ASF subversion and git services",
            "content": "Commit 1698043 from gchanan@apache.org in branch 'dev/trunk'\n[ https://svn.apache.org/r1698043 ]\n\nSOLR-7789: Introduce a ConfigSet management API ",
            "id": "comment-14715938"
        },
        {
            "date": "2015-08-27T04:51:31+0000",
            "author": "ASF subversion and git services",
            "content": "Commit 1698072 from gchanan@apache.org in branch 'dev/trunk'\n[ https://svn.apache.org/r1698072 ]\n\nSOLR-7789: fix jira number in CHANGES.txt ",
            "id": "comment-14716088"
        },
        {
            "date": "2015-08-27T05:16:09+0000",
            "author": "ASF subversion and git services",
            "content": "Commit 1698079 from gchanan@apache.org in branch 'dev/branches/branch_5x'\n[ https://svn.apache.org/r1698079 ]\n\nSOLR-7789: Introduce a ConfigSet management API ",
            "id": "comment-14716099"
        },
        {
            "date": "2015-08-27T20:25:57+0000",
            "author": "Gregory Chanan",
            "content": "Thanks for the reviews Mark and Shalin.  Committed to 5.4 and trunk.\n\nI tried to incorporate all the discussion into SOLR-7985; if there's something you think I missed, please feel free to add it there. ",
            "id": "comment-14717463"
        },
        {
            "date": "2015-08-28T14:54:57+0000",
            "author": "Mark Miller",
            "content": "I just hit one of those fails on a normal 'ant test' run. I think we may have to raise this 180 second timeout to be something that is a little more hearty.\n\n\n   [junit4] FAILURE  181s J1  | TestConfigSetsAPIExclusivity.testAPIExclusivity <<<\n   [junit4]    > Throwable #1: java.lang.AssertionError: Unexpected exception: org.apache.solr.client.solrj.impl.HttpSolrClient$RemoteSolrException: Error from server at http://127.0.0.1:57409/solr: create the configset time out:180s expected:<0> but was:<2>\n   [junit4]    > \tat __randomizedtesting.SeedInfo.seed([36DBA95D885A778C:4BAEB0A6D1FECEC5]:0)\n   [junit4]    > \tat org.apache.solr.cloud.TestConfigSetsAPIExclusivity.testAPIExclusivity(TestConfigSetsAPIExclusivity.java:95)\n   [junit4]    > \tat java.lang.Thread.run(Thread.java:745)\n   [junit4]   2> 361809 INFO  (SUITE-TestConfigSetsAPIExclusivity-seed#[36DBA95D885A778C]-worker) [    ] o.a.s.SolrTestCaseJ4 ###deleteCore\n\n\n\n\n ",
            "id": "comment-14719301"
        },
        {
            "date": "2015-08-28T17:43:45+0000",
            "author": "Gregory Chanan",
            "content": "I'll increase the timeout to 5 minutes and lower the number of trials.  If this hits us again I'll change the tests to make timeouts okay if a decent percentage of requests succeed. ",
            "id": "comment-14720305"
        },
        {
            "date": "2015-08-29T01:16:20+0000",
            "author": "ASF subversion and git services",
            "content": "Commit 1698436 from gchanan@apache.org in branch 'dev/trunk'\n[ https://svn.apache.org/r1698436 ]\n\nSOLR-7789: Increase ConfigSets API timeout ",
            "id": "comment-14720879"
        },
        {
            "date": "2015-08-29T01:17:34+0000",
            "author": "ASF subversion and git services",
            "content": "Commit 1698437 from gchanan@apache.org in branch 'dev/branches/branch_5x'\n[ https://svn.apache.org/r1698437 ]\n\nSOLR-7789: Increase ConfigSets API timeout ",
            "id": "comment-14720882"
        },
        {
            "date": "2015-08-31T09:31:26+0000",
            "author": "Upayavira",
            "content": "Is there a LIST option? I'd love to use this in the admin UI and would rather avoid having to do Zookeeper lookups in order to make it work. All I need (initially) is to be able to get a list of configset names. ",
            "id": "comment-14723261"
        },
        {
            "date": "2015-08-31T13:17:55+0000",
            "author": "Noble Paul",
            "content": "I wish there are a few examples added in the description so that I don't have to go through the tests to figure out how it looks like to a user ",
            "id": "comment-14723385"
        },
        {
            "date": "2015-08-31T14:01:09+0000",
            "author": "Mark Miller",
            "content": "Uh, the first comment is pretty detailed. Stretch that imagination of yours. ",
            "id": "comment-14723427"
        },
        {
            "date": "2015-08-31T14:03:18+0000",
            "author": "Noble Paul",
            "content": "I does not specify what is the end point ",
            "id": "comment-14723431"
        },
        {
            "date": "2015-08-31T14:07:41+0000",
            "author": "Mark Miller",
            "content": "It's /configs. It's mentioned a few times in the comments and is in the patch. ",
            "id": "comment-14723438"
        },
        {
            "date": "2015-08-31T14:13:08+0000",
            "author": "Noble Paul",
            "content": "It's there in the comments (and the patch) . But there is no harm in putting it right there in the description. The description is editable for a reason\n ",
            "id": "comment-14723444"
        },
        {
            "date": "2015-08-31T18:23:12+0000",
            "author": "Gregory Chanan",
            "content": "Is there a LIST option? I'd love to use this in the admin UI and would rather avoid having to do Zookeeper lookups in order to make it work. All I need (initially) is to be able to get a list of configset names.\n\nThere is not currently, but that's a good idea.  I filed SOLR-7995 to add it.\n\nI wish there are a few examples added in the description so that I don't have to go through the tests to figure out how it looks like to a user\n\nI'm happy to turn the first comment into a page on the cwiki.  I modeled that comment after the https://cwiki.apache.org/confluence/display/solr/Collections+API page so it would be easy to do.  Is it okay to add the page now, even though there is no release with this feature yet?  That seems like a more fruitful place to have discussions about making it easier to understand for end users. ",
            "id": "comment-14723816"
        },
        {
            "date": "2015-08-31T18:37:02+0000",
            "author": "Noble Paul",
            "content": "There is no wrong time to add a wiki doc ",
            "id": "comment-14723832"
        },
        {
            "date": "2015-08-31T19:45:43+0000",
            "author": "Upayavira",
            "content": "yes, the wiki is always the source for the next, as yet unreleased, reference guide. ",
            "id": "comment-14723930"
        },
        {
            "date": "2015-08-31T19:46:23+0000",
            "author": "Upayavira",
            "content": "and thanks for creating SOLR-7995! ",
            "id": "comment-14723932"
        },
        {
            "date": "2015-10-07T01:32:48+0000",
            "author": "Gregory Chanan",
            "content": "FYI I created a cwiki page on the the API here: https://cwiki.apache.org/confluence/display/solr/ConfigSets+API ",
            "id": "comment-14946116"
        }
    ]
}