{
    "id": "SOLR-9112",
    "title": "Null Pointer Exception if @Field (child = true) is annotated at getter which takes collection of child docs",
    "details": {
        "components": [
            "clients - java"
        ],
        "type": "Bug",
        "labels": "",
        "fix_versions": [],
        "affect_versions": "6.0",
        "status": "Open",
        "resolution": "Unresolved",
        "priority": "Minor"
    },
    "description": "See: http://stackoverflow.com/questions/37241489/solrj-6-0-0-insertion-of-a-bean-object-which-associate-list-of-bean-object-is-g\nfor defect description.\n\nDefect is caused by below piece of code if annotation is present at setter for list of child:\n\npublic DocField(AccessibleObject member) {\n      if (member instanceof java.lang.reflect.Field) \n{\n        field = (java.lang.reflect.Field) member; // It is null here\n      }\n else \n{\n        setter = (Method) member; // initialized as annotation is at setter\n      }\n      annotation = member.getAnnotation(Field.class);\n      storeName(annotation);\n      storeType(); // giving null pointer exception as field is null see below\n\n      // Look for a matching getter\n      if (setter != null) {\n        String gname = setter.getName();\n        if (gname.startsWith(\"set\")) {\n          gname = \"get\" + gname.substring(3);\n          try \n{\n            getter = setter.getDeclaringClass().getMethod(gname, (Class[]) null);\n          }\n catch (Exception ex) {\n            // no getter \u2013 don't worry about it...\n            if (type == Boolean.class) {\n              gname = \"is\" + setter.getName().substring(3);\n              try \n{\n                getter = setter.getDeclaringClass().getMethod(gname, (Class[]) null);\n              }\n catch(Exception ex2) \n{\n                // no getter -- don't worry about it...\n              }\n            }\n          }\n        }\n      }\n    }\n\nprivate void storeType() {\n      if (field != null) \n{\n        type = field.getType();\n      }\n else {\n        Class[] params = setter.getParameterTypes();\n        if (params.length != 1) \n{\n          throw new BindingException(\"Invalid setter method. Must have one and only one parameter\");\n        }\n        type = params[0];\n      }\n\n      if (type == Collection.class || type == List.class || type == ArrayList.class) {\n        isList = true;\n        if (annotation.child()) \n{\n          populateChild(field.getGenericType()); //giving null pointer exception //as field is null here\n        }\n else \n{\n          type = Object.class;\n        }\n      } else if (type == byte[].class) \n{\n        //no op\n      }\n else if (type.isArray()) {\n        isArray = true;\n        if (annotation.child()) \n{\n          populateChild(type.getComponentType());\n        }\n else \n{\n          type = type.getComponentType();\n        }\n      } else if (type == Map.class || type == HashMap.class) { //corresponding to the support for dynamicFields\n        if (annotation.child()) throw new BindingException(\"Map should is not a valid type for a child document\");\n        isContainedInMap = true;\n        //assigned a default type\n        type = Object.class;\n        if (field != null) {\n          if (field.getGenericType() instanceof ParameterizedType) {\n            //check what are the generic values\n            ParameterizedType parameterizedType = (ParameterizedType) field.getGenericType();\n            Type[] types = parameterizedType.getActualTypeArguments();\n            if (types != null && types.length == 2 && types[0] == String.class) {\n              //the key should always be String\n              //Raw and primitive types\n              if (types[1] instanceof Class) {\n                //the value could be multivalued then it is a List, Collection, ArrayList\n                if (types[1] == Collection.class || types[1] == List.class || types[1] == ArrayList.class) \n{\n                  type = Object.class;\n                  isList = true;\n                } else {\n                  //else assume it is a primitive and put in the source type itself\n                  type = (Class) types[1];\n                }\n              } else if (types[1] instanceof ParameterizedType) { //Of all the Parameterized types, only List is supported\n                Type rawType = ((ParameterizedType) types[1]).getRawType();\n                if (rawType == Collection.class || rawType == List.class || rawType == ArrayList.class) {                  type = Object.class;                  isList = true;                }\n              } else if (types[1] instanceof GenericArrayType) \n{ //Array types\n                type = (Class) ((GenericArrayType) types[1]).getGenericComponentType();\n                isArray = true;\n              }\n else \n{ //Throw an Exception if types are not known\n                throw new BindingException(\"Allowed type for values of mapping a dynamicField are : \" +\n                    \"Object, Object[] and List\");\n              }\n            }\n          }\n        }\n      } else {\n        if (annotation.child()) \n{\n          populateChild(type);\n        }\n      }\n    }",
    "attachments": {},
    "issue_links": {},
    "comments": []
}