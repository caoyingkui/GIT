{
    "id": "SOLR-10969",
    "title": "Backup API call failure leaves the backup directory undeleted",
    "details": {
        "labels": "",
        "priority": "Minor",
        "components": [
            "Backup/Restore",
            "SolrCloud"
        ],
        "type": "Bug",
        "fix_versions": [],
        "affect_versions": "6.6",
        "resolution": "Unresolved",
        "status": "Open"
    },
    "description": "1. Invoke the Backup API on Solr cloud\n2. Backup API fails\n3. A directory is created in the location=/path/to/location with name=myBackupname (as specified) in the backup API call.\n4. In case of backup API failure the directory should be automatically deleted since, when recalling the API the backup api will fail stating directory already exists\n\nSolr 6.6.0 (fresh install, 4 node solr cluster):\n1. Create a collection in Solr called citibike:\nhttp://localhost:8983/solr/admin/collections?action=CREATE&name=citibike&numShards=2&replicationFactor=1&maxShardsPerNode=1&collection.configName=rohit&&createNodeSet=192.168.3.15:7574_solr,192.168.3.15:8983_solr\n\n2. Index 8 documents to Solr collection citibike:\n{\n  \"responseHeader\":{\n    \"zkConnected\":true,\n    \"status\":0,\n    \"QTime\":10,\n    \"params\":{\n      \"q\":\":\",\n      \"indent\":\"on\",\n      \"wt\":\"json\"}},\n  \"response\":{\"numFound\":8,\"start\":0,\"maxScore\":1.0,\"docs\":[\n      \n{\n        \"id\":\"doc1\",\n        \"_version_\":1570643322182041600}\n,\n      \n{\n        \"id\":\"doc2\",\n        \"_version_\":1570643322185187328}\n,\n      \n{\n        \"id\":\"doc3\",\n        \"_version_\":1570643322185187329}\n,\n      \n{\n        \"id\":\"doc5\",\n        \"_version_\":1570643322188333056}\n,\n      \n{\n        \"id\":\"doc6\",\n        \"_version_\":1570643322191478784}\n,\n      \n{\n        \"id\":\"doc7\",\n        \"_version_\":1570643322191478785}\n,\n      \n{\n        \"id\":\"doc8\",\n        \"_version_\":1570643322191478786}\n,\n      \n{\n        \"id\":\"doc4\",\n        \"_version_\":1570643322179944448}\n]\n  }}\n\n\n2. Try to create a backup of the collection with only 8 documents:\nhttp://localhost:8983/solr/admin/collections?action=BACKUP&name=myBackupName&collection=citibike&location=/Users/Rohit/Documents/SolrInstall/backup\n\n{\n  \"responseHeader\":\n{\n    \"status\":500,\n    \"QTime\":20}\n,\n  \"failure\":\n{\n    \"192.168.3.15:8983_solr\":\"org.apache.solr.client.solrj.impl.HttpSolrClient$RemoteSolrException:Error from server at http://192.168.3.15:8983/solr: Failed to backup core=citibike_shard2_replica1 because java.nio.file.NoSuchFileException: /Users/Rohit/Documents/SolrInstall/solr-6.6.0/example/cloud/node1/solr/citibike_shard2_replica1/data/index/segments_8\"}\n,\n  \"Operation backup caused exception:\":\"org.apache.solr.common.SolrException:org.apache.solr.common.SolrException: Could not backup all replicas\",\n  \"exception\":\n{\n    \"msg\":\"Could not backup all replicas\",\n    \"rspCode\":500}\n,\n  \"error\":{\n    \"metadata\":[\n      \"error-class\",\"org.apache.solr.common.SolrException\",\n      \"root-error-class\",\"org.apache.solr.common.SolrException\"],\n    \"msg\":\"Could not backup all replicas\",\n    \"trace\":\"org.apache.solr.common.SolrException: Could not backup all replicas\\n\\tat org.apache.solr.handler.admin.CollectionsHandler.handleResponse(CollectionsHandler.java:300)\\n\\tat org.apache.solr.handler.admin.CollectionsHandler.invokeAction(CollectionsHandler.java:237)\\n\\tat org.apache.solr.handler.admin.CollectionsHandler.handleRequestBody(CollectionsHandler.java:215)\\n\\tat org.apache.solr.handler.RequestHandlerBase.handleRequest(RequestHandlerBase.java:173)\\n\\tat org.apache.solr.servlet.HttpSolrCall.handleAdmin(HttpSolrCall.java:748)\\n\\tat org.apache.solr.servlet.HttpSolrCall.handleAdminRequest(HttpSolrCall.java:729)\\n\\tat org.apache.solr.servlet.HttpSolrCall.call(HttpSolrCall.java:510)\\n\\tat org.apache.solr.servlet.SolrDispatchFilter.doFilter(SolrDispatchFilter.java:361)\\n\\tat org.apache.solr.servlet.SolrDispatchFilter.doFilter(SolrDispatchFilter.java:305)\\n\\tat org.eclipse.jetty.servlet.ServletHandler$CachedChain.doFilter(ServletHandler.java:1691)\\n\\tat org.eclipse.jetty.servlet.ServletHandler.doHandle(ServletHandler.java:582)\\n\\tat org.eclipse.jetty.server.handler.ScopedHandler.handle(ScopedHandler.java:143)\\n\\tat org.eclipse.jetty.security.SecurityHandler.handle(SecurityHandler.java:548)\\n\\tat org.eclipse.jetty.server.session.SessionHandler.doHandle(SessionHandler.java:226)\\n\\tat org.eclipse.jetty.server.handler.ContextHandler.doHandle(ContextHandler.java:1180)\\n\\tat org.eclipse.jetty.servlet.ServletHandler.doScope(ServletHandler.java:512)\\n\\tat org.eclipse.jetty.server.session.SessionHandler.doScope(SessionHandler.java:185)\\n\\tat org.eclipse.jetty.server.handler.ContextHandler.doScope(ContextHandler.java:1112)\\n\\tat org.eclipse.jetty.server.handler.ScopedHandler.handle(ScopedHandler.java:141)\\n\\tat org.eclipse.jetty.server.handler.ContextHandlerCollection.handle(ContextHandlerCollection.java:213)\\n\\tat org.eclipse.jetty.server.handler.HandlerCollection.handle(HandlerCollection.java:119)\\n\\tat org.eclipse.jetty.server.handler.HandlerWrapper.handle(HandlerWrapper.java:134)\\n\\tat org.eclipse.jetty.rewrite.handler.RewriteHandler.handle(RewriteHandler.java:335)\\n\\tat org.eclipse.jetty.server.handler.HandlerWrapper.handle(HandlerWrapper.java:134)\\n\\tat org.eclipse.jetty.server.Server.handle(Server.java:534)\\n\\tat org.eclipse.jetty.server.HttpChannel.handle(HttpChannel.java:320)\\n\\tat org.eclipse.jetty.server.HttpConnection.onFillable(HttpConnection.java:251)\\n\\tat org.eclipse.jetty.io.AbstractConnection$ReadCallback.succeeded(AbstractConnection.java:273)\\n\\tat org.eclipse.jetty.io.FillInterest.fillable(FillInterest.java:95)\\n\\tat org.eclipse.jetty.io.SelectChannelEndPoint$2.run(SelectChannelEndPoint.java:93)\\n\\tat org.eclipse.jetty.util.thread.strategy.ExecuteProduceConsume.executeProduceConsume(ExecuteProduceConsume.java:303)\\n\\tat org.eclipse.jetty.util.thread.strategy.ExecuteProduceConsume.produceConsume(ExecuteProduceConsume.java:148)\\n\\tat org.eclipse.jetty.util.thread.strategy.ExecuteProduceConsume.run(ExecuteProduceConsume.java:136)\\n\\tat org.eclipse.jetty.util.thread.QueuedThreadPool.runJob(QueuedThreadPool.java:671)\\n\\tat org.eclipse.jetty.util.thread.QueuedThreadPool$2.run(QueuedThreadPool.java:589)\\n\\tat java.lang.Thread.run(Thread.java:745)\\n\",\n    \"code\":500}}\n\nGoto path given in location and you will see that a folder with name=myBackupName is created and not cleared off even if the backup API call fails.\n\nNow, re-run the backup API command again. It will fail with exception \"The backup directory already exists\"\n\nSuggested fix:\n1. In case of error delete the directory in the location path automatically since, the partial update is not a correct backup anyways.\n2. Add and locationOverwrite parameter. This parameter will clear the old directory and create a backup in the location specified. It will prevent users the need to goto the backup path and to delete the folder automatically.",
    "attachments": {
        "10969.patch": "https://issues.apache.org/jira/secure/attachment/12874916/10969.patch"
    },
    "issue_links": {},
    "comments": [
        {
            "date": "2017-06-28T17:09:09+0000",
            "content": "1. The patch automatically deletes the backup directory created with the Backup API in case of failure.\n\n2. It provides a locationOverwrite parameter in the BackupAPI call. This will overwrite the existing directory in case the user wants to take backup without going to manually delete the backup directory. \nhttp://localhost:8983/solr/admin/collections?action=BACKUP&name=myBackupName&collection=test&location=/Users/Rohit/Documents/SolrInstall/backup&locationOverwrite=false ",
            "author": "Rohit",
            "id": "comment-16066875"
        }
    ]
}