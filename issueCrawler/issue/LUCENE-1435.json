{
    "id": "LUCENE-1435",
    "title": "CollationKeyFilter: convert tokens into CollationKeys encoded using IndexableBinaryStringTools",
    "details": {
        "labels": "",
        "priority": "Minor",
        "components": [],
        "type": "New Feature",
        "fix_versions": [
            "2.9"
        ],
        "affect_versions": "2.4",
        "resolution": "Fixed",
        "status": "Closed"
    },
    "description": "Converts each token into its CollationKey using the provided collator, and then encodes the CollationKey with IndexableBinaryStringTools, to allow it to be stored as an index term.\n\nThis will allow for efficient range searches and Sorts over fields that need collation for proper ordering.",
    "attachments": {
        "LUCENE-1435.patch": "https://issues.apache.org/jira/secure/attachment/12393189/LUCENE-1435.patch"
    },
    "issue_links": {},
    "comments": [
        {
            "date": "2008-11-01T18:22:44+0000",
            "content": "The one worry i have about an approach like this comes from the fine print of the CollationKey docs...\n\nYou can only compare CollationKeys generated from the same Collator object.\n\n\"same\" tends to have a very specific meaning in Java documentation, .. it's usually used to indicate refrence equality (ie \"==\" not .equals) ...\n\nThe equals method for class Object implements the most discriminating possible equivalence relation on objects; that is, for any non-null reference values x and y, this method returns true if and only if x and y refer to the same object (x == y has the value true).\n\nso the question becomes: did they reall mean \"same Collator\" or did they mean \"a Collator with the same rules\" ? \n\nis it safe to persist a CollationKey from a Collator A and then compare it with a CollationKey from another Collator B where A.equals(B) but A != B (because A and B are from different JVM instances?) ",
            "author": "Hoss Man",
            "id": "comment-12644526"
        },
        {
            "date": "2008-11-01T21:48:43+0000",
            "content": "at least in ICU, its not completely safe.  If the different JVM instances are \"different\" in version (upgrade, etc) then it would be a shame to find your sorts all busted. \n\nWhen comparing keys, it is important to know that both keys were generated by the same algorithms and weightings. Otherwise, identical strings with keys generated on two different dates, for example, might compare as unequal. Sort keys can be affected by new versions of ICU or its data tables, new sort key formats, or changes to the Collator.\n\nhttp://www.icu-project.org/userguide/Collate_ServiceArchitecture.html ",
            "author": "Robert Muir",
            "id": "comment-12644541"
        },
        {
            "date": "2008-11-02T17:16:43+0000",
            "content": "Three problems I can think of off the top of my head with attempting an automatically managed solution to the problem of CollationKey comparability:\n\n\n\tThere doesn't seem to be any way of ascertaining the RuleBasedCollator version, so one would have to store exact JVM version and Locale used to genenerate the Collator, and the strength used, and then fail any range or sort operations if the indexed CollationKeys were produced with ones different from the current ones.\n\tLucene doesn't have an index-level per-field place to store arbitrary information.\n\tOther implementations of java.text.Collator, besides RuleBasedCollator, are certainly possible.\n\n\n\nSo, it seems to me, either the user of this functionality has to manage the versioning external to the Lucene index, or they can't use the functionality .\n\nWould strong warnings in the javadocs be enough to allow people to take appropriate precautions? ",
            "author": "Steve Rowe",
            "id": "comment-12644600"
        },
        {
            "date": "2008-11-02T18:32:52+0000",
            "content": "One alternative is that the ICU implementation has versioning specifically for this purpose.\n\nThe version information of Collator is a 32-bit integer. If a new version of ICU has changes affecting the content of collation elements, the version information will be changed. In that case, to use the new version of ICU collator will require regenerating any saved or stored sort keys. However, since ICU 1.8.1. it is possible to build your program so that it uses more than one version of ICU. Therefore, you could use the current version for the features you need and use the older version for collation. ",
            "author": "Robert Muir",
            "id": "comment-12644604"
        },
        {
            "date": "2008-11-03T18:20:04+0000",
            "content": "So, it seems to me, either the user of this functionality has to manage the versioning external to the Lucene index, or they can't use the functionality .\n\nWould strong warnings in the javadocs be enough to allow people to take appropriate precautions?\n\nI agree with you on both points ... this is really just an extension of warning people to use compatible analyzers when indexing/querying. \n\n(I only brought it up in my first comment because i know very little about the internals of any Collator Implementations out there, and i wasn't sure if all Implementations produces keys that were only comparable between \"same\" instances .. as long as there are some implementations of Collator that products keys which can be compared between \"equivalent\" instances, then this feature certainly seems useful. ",
            "author": "Hoss Man",
            "id": "comment-12644773"
        },
        {
            "date": "2008-11-03T18:59:06+0000",
            "content": "Robert Muir wrote:\n\nOne alternative is that the ICU implementation has versioning specifically for this purpose. \n\nI'll look into using RegexQuery as a model here (it enables use of either java.util.regex or Jakarta Regexp, defaulting to java.util.regex), and try to add CollatorCapable/CollatorCapabilities, so that ICU's Collator implementation will be usable. ",
            "author": "Steve Rowe",
            "id": "comment-12644780"
        },
        {
            "date": "2008-11-03T19:01:43+0000",
            "content": "Hoss wrote:\n\n\nSo, it seems to me, either the user of this functionality has to manage the versioning external to the Lucene index, or they can't use the functionality .\n\nWould strong warnings in the javadocs be enough to allow people to take appropriate precautions?\n\nI agree with you on both points ... this is really just an extension of warning people to use compatible analyzers when indexing/querying. \n\nI will add warnings about this issue to the javadocs. ",
            "author": "Steve Rowe",
            "id": "comment-12644782"
        },
        {
            "date": "2008-11-11T05:03:05+0000",
            "content": "Modifications in this patch:\n\n\n\tAdded dependency on ICU4J 4.0\n\tIntroduced ICUCollationKeyFilter, which uses ICU collation to produce the collation keys\n\tAdded Analyzer versions of the Filters, creating IndexableBinaryStringTools-encoded collation keys from the single token produced by KeywordTokenizer.\n\tCentralized testing to a base class, which the four test classes extend, to avoid duplication\n\tMoved from contrib/analyzers/o/a/l/analysis/miscellaneous/ to a new contrib package: contrib/collation, because it doesn't make sense to add a dependency to the entire contrib/analyzers package just for ICUCollationKeyFilter/Analyzer\n\n\n\nThe external ICU4J dependency, which should be checked into contrib/collation/lib/, can be downloaded here: http://download.icu-project.org/files/icu4j/4.0/icu4j-4_0.jar.  The license for this jar is included in the patch at contrib/collation/lib/ICU-LICENSE.txt. ",
            "author": "Steve Rowe",
            "id": "comment-12646470"
        },
        {
            "date": "2008-11-11T10:58:10+0000",
            "content": "Could we, alternatively, push this change into DocumentsWriter, such that on writing a segment it uses a per-field Collator (FieldInfo would be extended to record this) to sort the terms dict?\n\nI haven't fully thought through the tradeoffs... but it seems like this'd be simpler to use?  Ie rather than putting a CollationKeyFilter in your analyzer chain, and then doing the reverse of this for all searches at search time, you simply set the Collator on the fields (at indexing & searching time, since I agree we should for now not try to serialize into the index which field has which Collator)?\n\nI guess there is a performance cost to using the Collator to do live binary search (during searching) and sorting (during indexing) vs doing unicode String comparisions but in practice at search time this is probably a tiny part of the net cost of searching? ",
            "author": "Michael McCandless",
            "id": "comment-12646525"
        },
        {
            "date": "2008-11-11T18:29:15+0000",
            "content": "Hi Mike,\n\nCould we, alternatively, push this change into DocumentsWriter, such that on writing a segment it uses a per-field Collator (FieldInfo would be extended to record this) to sort the terms dict?\n\nAre you suggesting to not store collation keys in the index?\n\nI haven't fully thought through the tradeoffs... but it seems like this'd be simpler to use? Ie rather than putting a CollationKeyFilter in your analyzer chain, and then doing the reverse of this for all searches at search time, you simply set the Collator on the fields (at indexing & searching time, since I agree we should for now not try to serialize into the index which field has which Collator)?\n\nThe query-time process in this patch is not the reverse - it is exactly the same.  The String-encoded collation keys stored in the index are compared directly with those from query terms.  Neither the String-encoding nor the CollationKey needs to be reversed.\n\nI guess there is a performance cost to using the Collator to do live binary search (during searching) and sorting (during indexing) vs doing unicode String comparisions but in practice at search time this is probably a tiny part of the net cost of searching?\n\nIn the current code base, for range searching on a collated field, every single term has to be collated with the search term.  This patch allows skipTo to function when using collation, potentially providing a significant speedup. ",
            "author": "Steve Rowe",
            "id": "comment-12646619"
        },
        {
            "date": "2008-11-11T21:18:25+0000",
            "content": "\nAre you suggesting to not store collation keys in the index?\n\nRight, I'm proposing storing the original Strings, but sorted\naccording Collator.compare (for that one field), in the Terms dict.\n\nThe query-time process in this patch is not the reverse - it is exactly the same.\n\nOK got it.  Where/how would you implement the query time conversion of\nterms?\n\nAnd wouldn't there be times when you also want to reverse the\nencoding?  EG if you enum all terms for presentation (maybe as part of\nfaceted search for example)?\n\nIn the current code base, for range searching on a collated field, every single term has to be collated with the search term. This patch allows skipTo to function when using collation, potentially providing a significant speedup.\n\nBoth the original proposed approach (external-to-indexing) and this\ninternal-to-indexing approach would solve this, right?  Ie, in both\ncases the terms have been sorted according to the Collator, but in the\ninternal-to-indexing case it's the original String term stored in the\nterms dict.\n\nHere are some pros of internal-to-indexing:\n\n\n\tYou don't have to convert every single term visited during\n    analysis first to a CollationKey then ByteBuffer then encoded\n    binary string.  Indexing throughput should be faster?  (Though,\n    when writing the segment you do need to sort using\n    Collator.compare, which I guess could be slow).\n\n\n\n\n\tReal terms are stored in the index \u2013 tools like Luke can look at\n    the index and see normal looking terms.  Though... I don't have a\n    sense of what the encoded term would look like \u2013 maybe it's not\n    that different from the original in practice?\n\n\n\n\n\tQuerying would just work without term conversion\n\n\n\nAnd some cons:\n\n\n\tIt's obviously a more invasive change to Lucene (and probably\n    should go after the flex-indexing changes).  The\n    external-to-indexing approach is nicely externalized.\n\n\n\n\n\tPerformance \u2013 the binary search of the terms index would be\n    slower using Collator.compare instead of String.compareTo (though\n    I would expect this to be minimal in practice).\n\n\n\nI'm sure there are many pros/cons I'm missing... ",
            "author": "Michael McCandless",
            "id": "comment-12646667"
        },
        {
            "date": "2008-11-11T21:51:47+0000",
            "content": "And wouldn't there be times when you also want to reverse the encoding? EG if you enum all terms for presentation (maybe as part of faceted search for example)?\n\nAFAIK, CollationKey generation is a one-way operation.  If the original terms are required for presentation, they can be stored, right?\n\n\nHere are some pros of internal-to-indexing:\n      [...]\n\n\tReal terms are stored in the index - tools like Luke can look at\n      the index and see normal looking terms. Though... I don't have a\n      sense of what the encoded term would look like - maybe it's not\n      that different from the original in practice?\n\n\n\nIndexableBinaryStringTools (LUCENE-1434) implements a base-8000h encoding: the lower 15 bits of each character have 1-7/8 bytes packed into them.  It's radically different from the original byte array, at least in terms of looking at it with a text viewer like Luke.  And I don't think CollationKeys themselves are intended for human consumption.\n\n\nIn the current code base, for range searching on a collated field, every single term has to be collated with the search term. This patch allows skipTo to function when using collation, potentially providing a significant speedup.\n\nBoth the original proposed approach (external-to-indexing) and this\ninternal-to-indexing approach would solve this, right? Ie, in both\ncases the terms have been sorted according to the Collator, but in the\ninternal-to-indexing case it's the original String term stored in the\nterms dict.\n\nPerhaps I'm missing something, but o.a.l.index.TermEnum.skipTo(Term) compares the target term using String.compareTo(), so regardless of the index term dictionary ordering, skipTo() won't necessarily stop at the correct location, right?  From TermEnum.java:\n\n\n  public boolean skipTo(Term target) throws IOException {\n     do {\n        if (!next())\n  \t        return false;\n     } while (target.compareTo(term()) > 0);\n     return true;\n  }\n\n\n\nand here's o.a.l.index.Term.compareTo(Term):\n\n\n  public final int compareTo(Term other) {\n    if (field == other.field)\t\t\t  // fields are interned\n      return text.compareTo(other.text);\n    else\n      return field.compareTo(other.field);\n  }\n\n ",
            "author": "Steve Rowe",
            "id": "comment-12646679"
        },
        {
            "date": "2008-11-11T22:31:33+0000",
            "content": "IndexableBinaryStringTools (LUCENE-1434) implements a base-8000h encoding: the lower 15 bits of each character have 1-7/8 bytes packed into them. It's radically different from the original byte array, at least in terms of looking at it with a text viewer like Luke. And I don't think CollationKeys themselves are intended for human consumption.\n\nOh OK.  So having done this term conversion, you can't really look at / use the resulting terms in the index for human consumption (you'd have to store stuff yourself).\n\nPerhaps I'm missing something, but o.a.l.index.TermEnum.skipTo(Term) compares the target term using String.compareTo(),\n\nBut we could just fix that to pay attention to the Collator for that field, if it has one, right?  (Or with flexible indexing I think the impl really should own this method, ie, it should be abstract in TermEnum).\n\nI think the external approach is fine for starters... I just think long-term it may make sense to have core Lucene respect the Collator, but it really is an invasive change.  We should wait until we make progress on flexible indexing at which point such a change should be far less costly. ",
            "author": "Michael McCandless",
            "id": "comment-12646699"
        },
        {
            "date": "2008-11-11T23:04:50+0000",
            "content": "\nPerhaps I'm missing something, but o.a.l.index.TermEnum.skipTo(Term) compares the target term using String.compareTo(),\n\nBut we could just fix that to pay attention to the Collator for that field, if it has one, right? (Or with flexible indexing I think the impl really should own this method, ie, it should be abstract in TermEnum).\n\nUm, yes.   \n\nI think the external approach is fine for starters... I just think long-term it may make sense to have core Lucene respect the Collator, but it really is an invasive change. We should wait until we make progress on flexible indexing at which point such a change should be far less costly.\n\nNow that I understand it, I too think the internal-to-indexing approach is cleaner/easier to use/better long-term.  This patch is an attempt to improve on the performance of the range collation facilities introduced in LUCENE-1279.  So I guess the question is whether it's worth putting in another less-than-optimal workaround. ",
            "author": "Steve Rowe",
            "id": "comment-12646717"
        },
        {
            "date": "2008-11-22T19:03:27+0000",
            "content": "Another use-case for allowing per-field custom sorting of Terms would be simpler numeric RangeQuery.  Ie, right now you have to zero-pad numbers to trick Lucene into sorting them numerically (which causes challenges for BigDecimal, being discussed now on java-user).  But if you could have Lucene sort by the number then numeric range queries would be straightforward. ",
            "author": "Michael McCandless",
            "id": "comment-12649967"
        },
        {
            "date": "2008-12-09T00:07:42+0000",
            "content": "Removed accidentally included IndexableBinaryString and its test from the patch (see LUCENE-1434 for these). ",
            "author": "Steve Rowe",
            "id": "comment-12654655"
        },
        {
            "date": "2009-03-18T20:31:06+0000",
            "content": "I think we should commit this to contrib/collation as an \"external\" way to get faster range filters on fields that require custom Collator; at some future point we can consider allowing a given field to sort its terms in some custom way.\n\nMarvin: does KS/Lucy give control over sort order of the terms in a field? ",
            "author": "Michael McCandless",
            "id": "comment-12683155"
        },
        {
            "date": "2009-03-18T20:57:59+0000",
            "content": "Steven, I'm hitting compilation errors, eg:\n\n\n    [javac] /tango/mike/src/lucene.collation/contrib/collation/src/test/org/apache/lucene/collation/CollationTestBase.java:42: package org.apache.lucene.queryParser.analyzing does not exist\n    [javac] import org.apache.lucene.queryParser.analyzing.AnalyzingQueryParser;\n    [javac]                                               ^\n    [javac] /tango/mike/src/lucene.collation/contrib/collation/src/test/org/apache/lucene/collation/CollationTestBase.java:89: cannot find symbol\n\n\n\nWhat is AnalyzingQueryParser? ",
            "author": "Michael McCandless",
            "id": "comment-12683167"
        },
        {
            "date": "2009-03-18T21:13:13+0000",
            "content": "It's in contrib/miscellaneous/\n\nI used AnalyzingQueryParser in the tests to allow CollationKeyFilter to be applied to the terms in the range query - the standard QueryParser doesn't analyze range terms.\n\nFrom:\n\nhttp://lucene.apache.org/java/2_4_1/api/org/apache/lucene/queryParser/analyzing/AnalyzingQueryParser.html\n\nOverrides Lucene's default QueryParser so that Fuzzy-, Prefix-, Range-, and WildcardQuerys are also passed through the given analyzer, but wild card characters (like *) don't get removed from the search terms. \n\nThis is a (test-only) cross-contrib dependency.  I'm not sure why I didn't have trouble with compilation - I haven't looked at this in months.  I'll take a look later on tonight. ",
            "author": "Steve Rowe",
            "id": "comment-12683174"
        },
        {
            "date": "2009-03-18T21:39:20+0000",
            "content": "OK, thanks for the pointer \u2013 I learn something new every day! ",
            "author": "Michael McCandless",
            "id": "comment-12683182"
        },
        {
            "date": "2009-03-19T06:33:35+0000",
            "content": "New patch that compiles.\n\nI'm not sure how this ever worked previously - I must somehow have had lucene-misc-X.jar on the classpath or something.\n\nAnyway, the build.xml in this patch, cribbing from contrib/benchmark/build.xml, first builds contrib/miscellaneous, then adds build/contrib/miscellaneous/classes/java/ to the classpath, so that AnalyzingQueryParser can be linked against.\n\nEverything now compiles, and all contrib tests pass. ",
            "author": "Steve Rowe",
            "id": "comment-12683342"
        },
        {
            "date": "2009-03-19T09:40:16+0000",
            "content": "Super, thanks Steven.  I plan to commit soon. ",
            "author": "Michael McCandless",
            "id": "comment-12683388"
        },
        {
            "date": "2009-03-19T10:52:04+0000",
            "content": "Thanks Steven! ",
            "author": "Michael McCandless",
            "id": "comment-12683424"
        }
    ]
}