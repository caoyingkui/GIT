{
    "id": "LUCENE-2680",
    "title": "Improve how IndexWriter flushes deletes against existing segments",
    "details": {
        "labels": "",
        "priority": "Major",
        "components": [],
        "type": "Improvement",
        "fix_versions": [
            "3.1",
            "4.0-ALPHA"
        ],
        "affect_versions": "None",
        "resolution": "Fixed",
        "status": "Closed"
    },
    "description": "IndexWriter buffers up all deletes (by Term and Query) and only\napplies them if 1) commit or NRT getReader() is called, or 2) a merge\nis about to kickoff.\n\nWe do this because, for a large index, it's very costly to open a\nSegmentReader for every segment in the index.  So we defer as long as\nwe can.  We do it just before merge so that the merge can eliminate\nthe deleted docs.\n\nBut, most merges are small, yet in a big index we apply deletes to all\nof the segments, which is really very wasteful.\n\nInstead, we should only apply the buffered deletes to the segments\nthat are about to be merged, and keep the buffer around for the\nremaining segments.\n\nI think it's not so hard to do; we'd have to have generations of\npending deletions, because the newly merged segment doesn't need the\nsame buffered deletions applied again.  So every time a merge kicks\noff, we pinch off the current set of buffered deletions, open a new\nset (the next generation), and record which segment was created as of\nwhich generation.\n\nThis should be a very sizable gain for large indices that mix\ndeletes, though, less so in flex since opening the terms index is much\nfaster.",
    "attachments": {
        "LUCENE-2680.patch": "https://issues.apache.org/jira/secure/attachment/12458565/LUCENE-2680.patch"
    },
    "issue_links": {},
    "comments": [
        {
            "date": "2010-10-02T09:47:21+0000",
            "content": "Hmm... I think there's another silliness going on inside IW: when applying deletes, we one-by-one open the SR, apply deletes, close it.\n\nBut then immediately thereafter we open the N segments to be merged.\n\nWe should somehow not do this double open, eg, use the pool temporarily, so that the reader is opened to apply deletes, and then kept open in order to do the merging.  Using the pool should be fine because the merge forcefully evicts the sub readers from the pool after completion. ",
            "author": "Michael McCandless",
            "id": "comment-12917174"
        },
        {
            "date": "2010-10-10T00:57:48+0000",
            "content": "Maybe we should implement this as pending deletes per segment rather than using a generational system because with LUCENE-2655, we may need to maintain the per query/term docidupto per segment.  The downside is the extraneous memory consumed by the hash map, however, if we use BytesRefHash this'll be reduced, or would it?  Because we'd be writing the term bytes to a unique byte pool per segment?  Hmm... Maybe there's a more efficient way. ",
            "author": "Jason Rutherglen",
            "id": "comment-12919549"
        },
        {
            "date": "2010-10-11T10:05:15+0000",
            "content": "Tracking per-segment would be easier but I worry about indices that have large numbers of segments... eg w/ a large mergeFactor and frequent flushing you can get very many segments.\n\nSo if we track per-segment, suddenly the RAM required (as well as CPU cost of copying these deletions to the N segments) is multiplied by the number of segments. ",
            "author": "Michael McCandless",
            "id": "comment-12919780"
        },
        {
            "date": "2010-11-01T17:58:06+0000",
            "content": "The general approach is to reuse BufferedDeletes though place them into a segment info keyed map for those segments generated post lastSegmentIndex as per what has been discussed here https://issues.apache.org/jira/browse/LUCENE-2655?focusedCommentId=12922894&page=com.atlassian.jira.plugin.system.issuetabpanels%3Acomment-tabpanel#action_12922894 and below.\n\n\n\tlastSegmentIndex is added to IW\n\n\n\n\n\tDW segmentDeletes is a map of segment info -> buffered deletes.  In the apply deletes method buffered deletes are pulled for a given segment info if they exist, otherwise they're taken from deletesFlushedLastSeg.\n\n\n\n\n\tI'm not entirely sure what pushDeletes should do now, probably the same thing as currently, only the name should change slightly in that it's pushing deletes only for the RAM buffer docs.\n\n\n\n\n\tThere needs to be tests to ensure the docid-upto logic is working correctly\n\n\n\n\n\tI'm not sure what to do with DW hasDeletes (it's usage is commented out)\n\n\n\n\n\tDoes there need to be separate deletes for the ram buffer vis-\u00e0-vis the (0 - lastSegmentIndex) deletes?\n\n\n\n\n\tThe memory accounting'll now get interesting as we'll need to track the RAM usage of terms/queries across multiple maps.\n\n\n\n\n\tIn commitMerge, DW verifySegmentDeletes removes the unused info -> deletes\n\n\n\n\n\ttestDeletes deletes a doc in segment 1, then merges segments 1 and 2.  We then test to insure the deletes were in fact applied only to segment 1 and 2.\n\n\n\n\n\ttestInitLastSegmentIndex insures that on IW init, the lastSegmentIndex is in fact set\n\n ",
            "author": "Jason Rutherglen",
            "id": "comment-12927063"
        },
        {
            "date": "2010-11-02T16:41:13+0000",
            "content": "The most recent one \"wins\", and we should do only one delete (per segment) for that term.\n\nHow should we define this recency and why does it matter?  Should it be per term/query or for the entire BD?\n\nI think there's an issue with keeping lastSegmentIndex in DW, while it's easy to maintain, Mike had mentioned keeping the lastSegmentIndex per BufferedDeletes object.  Coalescing the BDs should be easier to maintain after successful merge than maintaining a separate BD for them.  We'll see.\n\nI'll put together another patch with these changes. ",
            "author": "Jason Rutherglen",
            "id": "comment-12927488"
        },
        {
            "date": "2010-11-03T01:22:17+0000",
            "content": "Here's a new patch with properly working last segment index.  \n\nThe trunk version of apply deletes has become applyDeletesAll and is functionally unchanged.\n\nThere's a new method, DW applyDeletesToSegments called by _mergeInit for segments that are about to be merged.  The deleted terms and queries for these segments are kept in hash sets because docid-uptos are not needed.  \n\nLike the last patch DW maintains the last segment index.  There's no need to maintain the last-segindex per BD, instead I think it's only useful per DW, and for trunk we only have one DW being used at a time.  \n\nOn successful merge, the last segment index is set to the segment index previous to the start segment of the merge.  The merged segments deletes are coalesced into the startIndex-1's segment deletes. ",
            "author": "Jason Rutherglen",
            "id": "comment-12927714"
        },
        {
            "date": "2010-11-03T18:38:58+0000",
            "content": "I'm redoing things a bit to take into account the concurrency of merges.  For example, if a merge fails, we need to not have removed those segments' deletes to be applied.  Also probably the most tricky part is that lastSegmentIndex could have changed since a merge started, which means we need to be careful about how and which deletes we coalesce. ",
            "author": "Jason Rutherglen",
            "id": "comment-12927943"
        },
        {
            "date": "2010-11-03T20:07:31+0000",
            "content": "Another use case that can be wacky is if commit is called and a merge is finishing before or after, in that case all (point-in-time) deletes will have been applied by commit, however do we want to clear all per-segment deletes at the end of commit?  This would blank out deletes being applied by the merge, most of which should be cleared out, however if new deletes arrived during the commit (is this possible?), then we want these to be attached to segments and not lost.  I guess we want to DW sync'd clear out deletes in the applyDeletesAll method.  ADA will apply those deletes, any incoming will queue up and be shuffled around. ",
            "author": "Jason Rutherglen",
            "id": "comment-12927979"
        },
        {
            "date": "2010-11-03T22:48:53+0000",
            "content": "In my head at least I think the concurrency issues are worked\nout in this patch. We're not taking into account recency of\ndeletes as I'm not sure it matters. DW applyDeletesToSegments\ntakes care of the coalescing of segment deletes as this is a\nsynced DW method called by a synced IW method, meaning\nnothing'll be changing anywhere, so we're good with the possible\nconcurrency issues. I'm still a little worried about concurrent\nincoming deleted terms/queries, however those can't be added\nuntil after a successful ADTS call due to the DW sync. \n\nGuess it's time for the complete tests to run. ",
            "author": "Jason Rutherglen",
            "id": "comment-12928052"
        },
        {
            "date": "2010-11-04T01:00:29+0000",
            "content": "There's an issue in that we're redundantly applying deletes in the applyDeletesAll case because the deletes may have already been applied to a segment when a merge happened, ie, by applyDeletesToSegments.  In the ADA case we need to use applyDeletesToSegments up to the segment point when the buffered deletes can be used.   ",
            "author": "Jason Rutherglen",
            "id": "comment-12928075"
        },
        {
            "date": "2010-11-04T01:09:26+0000",
            "content": "This brings up another issue which is we're blindly iterating over docs in a segment reader to delete, even if we can know ahead of time that the reader's docs are going to exceed the term/query's docid-upto (from the max doc of the reader).  In applyDeletes we're opening a term docs iterator, though I think we're breaking at the first doc and moving on if the docid-upto is exceeded.  This term docs iterator opening can be skipped. ",
            "author": "Jason Rutherglen",
            "id": "comment-12928078"
        },
        {
            "date": "2010-11-04T22:52:42+0000",
            "content": "Here's a nice little checkpoint with more tests passing.  \n\n\n\tA last known segment is recorded, which is the last segment seen when\nadding a delete term/query per segment. This is for a applyDeletesAll\ncheck to ensure a given query/term has not already been applied to a\nsegment. If a term/query exists in the per-segment deletes and is in\ndeletesFlushed, we delete, unless we're beyond the last known segment, at\nwhich point we simply delete (adhering of course to the docid-upto).\n\n\n\n\n\tIn the interest of accuracy I nixed lastSegmentIndex in favor of\nlastSegmentInfo which is easier for debugging and implementation when\nsegments are shuffled around and/or removed/added. There's not too much of\na penalty in terms of performance. \n\n\n\n\n\torg.apache.lucene.index tests pass\n\n\n\n\n\tI need to address the applying deletes only on readers within the\ndocid-upto per term/query, perhaps that's best left to a different Jira\nissue.\n\n\n\n\n\tStill not committable as it needs cleaning up, complete unit tests, who\nknows what else.\n\n ",
            "author": "Jason Rutherglen",
            "id": "comment-12928417"
        },
        {
            "date": "2010-11-06T03:21:00+0000",
            "content": "All tests pass except org.apache.lucene.index.TestIndexWriterMergePolicy testMaxBufferedDocsChange.  Odd.  I'm looking into this.\n\n\n[junit] junit.framework.AssertionFailedError: maxMergeDocs=2147483647; numSegments=11; upperBound=10; mergeFactor=10; \nsegs=_65:c5950 _5t:c10->_32 _5u:c10->_32 _5v:c10->_32 _5w:c10->_32 _5x:c10->_32 _5y:c10->_32 _5z:c10->_32 _60:c10->_32 _61:c10->_32 _62:c3->_32 _64:c7->_62\n\n\n\nAlso, in IW deleteDocument we're calling a new method, getSegmentInfos which is sync'ed on IW.  Maybe we should use an atomic reference to a read only segment infos instead? ",
            "author": "Jason Rutherglen",
            "id": "comment-12928923"
        },
        {
            "date": "2010-11-06T05:05:31+0000",
            "content": "Sorry, spoke too soon, I made a small change to not redundantly delete, in apply deletes all and TestStressIndexing2 is breaking.  I think we need to \"push\" segment infos changes to DW as they happen.  I'm guessing that segment infos are being shuffled around and so the infos passed into DW in IW deleteDoc methods may be out of date by the time deletes are attached to segments.  Hopefully there aren't any lurking deadlock issues with this. ",
            "author": "Jason Rutherglen",
            "id": "comment-12928933"
        },
        {
            "date": "2010-11-06T21:59:20+0000",
            "content": "Pushing the segment infos seems to have cleared up some of the tests failing, however intermittently (1/4 of the time) there's the one below.\n\nI'm going to re-add lastSegmentInfo/Index, and assert that if we're not using it, that the deletes obtained from the segmentinfo -> deletes map is the same.  \n\n\n[junit] Testsuite: org.apache.lucene.index.TestStressIndexing2\n    [junit] Testcase: testRandom(org.apache.lucene.index.TestStressIndexing2):\tFAILED\n    [junit] expected:<12> but was:<11>\n    [junit] junit.framework.AssertionFailedError: expected:<12> but was:<11>\n    [junit] \tat org.apache.lucene.util.LuceneTestCase$LuceneTestCaseRunner.runChild(LuceneTestCase.java:878)\n    [junit] \tat org.apache.lucene.util.LuceneTestCase$LuceneTestCaseRunner.runChild(LuceneTestCase.java:844)\n    [junit] \tat org.apache.lucene.index.TestStressIndexing2.verifyEquals(TestStressIndexing2.java:278)\n    [junit] \tat org.apache.lucene.index.TestStressIndexing2.verifyEquals(TestStressIndexing2.java:271)\n    [junit] \tat org.apache.lucene.index.TestStressIndexing2.testRandom(TestStressIndexing2.java:89)\n\n ",
            "author": "Jason Rutherglen",
            "id": "comment-12929229"
        },
        {
            "date": "2010-11-06T22:25:51+0000",
            "content": "I wasn't coalescing the merged segment's deletes, with that implemented, TestStressIndexing2 ran successfully 49 of 50 times.  Below is the error:\n\n\n[junit] Testsuite: org.apache.lucene.index.TestStressIndexing2\n    [junit] Testcase: testMultiConfig(org.apache.lucene.index.TestStressIndexing2):\tFAILED\n    [junit] expected:<5> but was:<4>\n    [junit] junit.framework.AssertionFailedError: expected:<5> but was:<4>\n    [junit] \tat org.apache.lucene.util.LuceneTestCase$LuceneTestCaseRunner.runChild(LuceneTestCase.java:878)\n    [junit] \tat org.apache.lucene.util.LuceneTestCase$LuceneTestCaseRunner.runChild(LuceneTestCase.java:844)\n    [junit] \tat org.apache.lucene.index.TestStressIndexing2.verifyEquals(TestStressIndexing2.java:278)\n    [junit] \tat org.apache.lucene.index.TestStressIndexing2.verifyEquals(TestStressIndexing2.java:271)\n    [junit] \tat org.apache.lucene.index.TestStressIndexing2.testMultiConfig(TestStressIndexing2.java:115)\n\n ",
            "author": "Jason Rutherglen",
            "id": "comment-12929247"
        },
        {
            "date": "2010-11-06T22:37:26+0000",
            "content": "Putting a sync on DW block around the bulk of the segment alterations in IW commitMerge seems to have quelled the TestStressIndexing2 test failures.  Nice. ",
            "author": "Jason Rutherglen",
            "id": "comment-12929254"
        },
        {
            "date": "2010-11-06T23:10:45+0000",
            "content": "Here's a check point patch before I re-add lastSegmentInfo/Index.  All tests pass except for what's below.  I'm guessing segments with all docs deleted, are deleted before the test expects.\n\n\n[junit] Testcase: testCommitThreadSafety(org.apache.lucene.index.TestIndexWriter):\tFAILED\n    [junit] \n    [junit] junit.framework.AssertionFailedError: \n    [junit] \tat org.apache.lucene.util.LuceneTestCase$LuceneTestCaseRunner.runChild(LuceneTestCase.java:878)\n    [junit] \tat org.apache.lucene.util.LuceneTestCase$LuceneTestCaseRunner.runChild(LuceneTestCase.java:844)\n    [junit] \tat org.apache.lucene.index.TestIndexWriter.testCommitThreadSafety(TestIndexWriter.java:4699)\n    [junit] \n    [junit] \n    [junit] Testcase: testCommitThreadSafety(org.apache.lucene.index.TestIndexWriter):\tFAILED\n    [junit] Some threads threw uncaught exceptions!\n    [junit] junit.framework.AssertionFailedError: Some threads threw uncaught exceptions!\n    [junit] \tat org.apache.lucene.util.LuceneTestCase$LuceneTestCaseRunner.runChild(LuceneTestCase.java:878)\n    [junit] \tat org.apache.lucene.util.LuceneTestCase$LuceneTestCaseRunner.runChild(LuceneTestCase.java:844)\n    [junit] \tat org.apache.lucene.util.LuceneTestCase.tearDown(LuceneTestCase.java:437)\n    [junit] \n    [junit] \n    [junit] Tests run: 116, Failures: 2, Errors: 0, Time elapsed: 159.577 sec\n    [junit] \n    [junit] ------------- Standard Output ---------------\n    [junit] NOTE: reproduce with: ant test -Dtestcase=TestIndexWriter -Dtestmethod=testCommitThreadSafety -Dtests.seed=1826133140332330367:8102643307925777745\n    [junit] NOTE: test params are: codec=MockFixedIntBlock(blockSize=564), locale=es_CR, timezone=Asia/Urumqi\n    [junit] ------------- ---------------- ---------------\n    [junit] ------------- Standard Error -----------------\n    [junit] The following exceptions were thrown by threads:\n    [junit] *** Thread: Thread-1106 ***\n    [junit] java.lang.RuntimeException: java.lang.AssertionError: term=f:0_8; r=DirectoryReader(_0:c1  _1:c1  _2:c1  _3:c1  _4:c1  _5:c1  _6:c1  _7:c2  _8:c4 ) expected:<1> but was:<0>\n    [junit] \tat org.apache.lucene.index.TestIndexWriter$9.run(TestIndexWriter.java:4690)\n    [junit] Caused by: java.lang.AssertionError: term=f:0_8; r=DirectoryReader(_0:c1  _1:c1  _2:c1  _3:c1  _4:c1  _5:c1  _6:c1  _7:c2  _8:c4 ) expected:<1> but was:<0>\n    [junit] \tat org.junit.Assert.fail(Assert.java:91)\n    [junit] \tat org.junit.Assert.failNotEquals(Assert.java:645)\n    [junit] \tat org.junit.Assert.assertEquals(Assert.java:126)\n    [junit] \tat org.junit.Assert.assertEquals(Assert.java:470)\n    [junit] \tat org.apache.lucene.index.TestIndexWriter$9.run(TestIndexWriter.java:4684)\n    [junit] NOTE: all tests run in this JVM:\n    [junit] [TestMockAnalyzer, TestByteSlices, TestFilterIndexReader, TestIndexFileDeleter, TestIndexReaderClone, TestIndexReaderReopen, TestIndexWriter]\n\n ",
            "author": "Jason Rutherglen",
            "id": "comment-12929272"
        },
        {
            "date": "2010-11-07T22:34:52+0000",
            "content": "I placed (for now) the segment deletes directly into the segment info object.  There's applied term/queries sets which are checked against when apply deletes all is called.  All tests pass except for TestTransactions and TestPersistentSnapshotDeletionPolicy only because of an assertion check I added, that the last segment info is in fact in the newly pushed segment infos.  I think in both cases segment infos is being altered in IW in a place where the segment infos isn't being pushed, yet.  I wanted to checkpoint this though as it's a fairly well working at this point, including the last segment info/index, which is can be turned on or off via a static variable.   ",
            "author": "Jason Rutherglen",
            "id": "comment-12929404"
        },
        {
            "date": "2010-11-08T01:02:56+0000",
            "content": "Everything passes, except for tests that involve IW rollback.  We need to be able to rollback the last segment info/index in DW, however I'm not sure how we want to do that quite yet. ",
            "author": "Jason Rutherglen",
            "id": "comment-12929422"
        },
        {
            "date": "2010-11-08T01:31:08+0000",
            "content": "In DW abort (called by IW rollbackInternal) we should be able to simply clear all per segment pending deletes, however, I'm not sure we can do that, in fact, if we have applied deletes for a merge, then we rollback, we can't undo those deletes thereby breaking our current rollback model? ",
            "author": "Jason Rutherglen",
            "id": "comment-12929424"
        },
        {
            "date": "2010-11-08T01:55:25+0000",
            "content": "Here's an uncleaned up cut with all tests passing. I nulled out\nthe lastSegmentInfo on abort which fixes the my own assertion\nthat was causing the rollback tests to not pass. I don't know if\nthis is cheating or not yet just to get the tests to pass. ",
            "author": "Jason Rutherglen",
            "id": "comment-12929432"
        },
        {
            "date": "2010-11-08T16:46:17+0000",
            "content": "I'm running test-core multiple times and am seeing some lurking test\nfailures (thanks to the randomized tests that have been recently added).\nI'm guessing they're related to the syncs on IW and DW not being in \"sync\"\nsome of the time. \n\nI will clean up the patch so that others may properly review it and\nhopefully we can figure out what's going on.  ",
            "author": "Jason Rutherglen",
            "id": "comment-12929629"
        },
        {
            "date": "2010-11-08T21:29:50+0000",
            "content": "Here's a cleaned up patch, please take a look.  I ran 'ant test-core' 5 times with no failures, however running the below several times does eventually produce a failure.\n\nant test-core -Dtestcase=TestThreadedOptimize -Dtestmethod=testThreadedOptimize -Dtests.seed=1547315783637080859:5267275843141383546\n\nant test-core -Dtestcase=TestIndexWriterMergePolicy -Dtestmethod=testMaxBufferedDocsChange -Dtests.seed=7382971652679988823:-6672235304390823521 ",
            "author": "Jason Rutherglen",
            "id": "comment-12929743"
        },
        {
            "date": "2010-11-08T23:25:22+0000",
            "content": "The problem could be that IW deleteDocument is not synced on IW,\nwhen I tried adding the sync, there was deadlock perhaps from DW\nwaitReady. We could be adding pending deletes to segments that\nare not quite current because we're not adding them in an IW\nsync block. ",
            "author": "Jason Rutherglen",
            "id": "comment-12929810"
        },
        {
            "date": "2010-11-09T04:02:05+0000",
            "content": "Ok, TestThreadedOptimize works when the DW sync'ed pushSegmentInfos method\nisn't called anymore (no extra per-segment deleting is going on), and stops\nworking when pushSegmentInfos is turned back on. Something about the sync\non DW is causing a problem.  Hmm... We need another way to pass segment\ninfos around consistently.  ",
            "author": "Jason Rutherglen",
            "id": "comment-12929927"
        },
        {
            "date": "2010-11-10T17:23:23+0000",
            "content": "I think I've taken LUCENE-2680 as far as I can, though I'll\nprobably add some more assertions in there for good measure,\nsuch as whether or not a delete has in fact been applied etc. It\nseems to be working though again I should add more assertions to\nthat effect. I think there's a niggling sync issue in there as\nTestThreadedOptimize only fails when I try to run it 100s of\ntimes. I think the sync on DW is causing a wait notify to be\nmissed or skipped or something like that, as occasionally the\nisOptimized call fails as well. This is likely related to the\nappearance of deletes not being applied to segment(s) as\nevidenced by the difference in the actual doc count and the\nexpected doc count.\n\nBelow is the most common assertion failure. Maybe I should\nupload my patch that includes a method that iterates 200 times\non testThreadedOptimize?\n\n\n[junit] ------------- ---------------- ---------------\n    [junit] Testsuite: org.apache.lucene.index.TestThreadedOptimize\n    [junit] Testcase: testThreadedOptimize(org.apache.lucene.index.TestThreadedOptimize):\tFAILED\n    [junit] expected:<248> but was:<266>\n    [junit] junit.framework.AssertionFailedError: expected:<248> but was:<266>\n    [junit] \tat org.apache.lucene.util.LuceneTestCase$LuceneTestCaseRunner.runChild(LuceneTestCase.java:878)\n    [junit] \tat org.apache.lucene.util.LuceneTestCase$LuceneTestCaseRunner.runChild(LuceneTestCase.java:844)\n    [junit] \tat org.apache.lucene.index.TestThreadedOptimize.runTest(TestThreadedOptimize.java:119)\n    [junit] \tat org.apache.lucene.index.TestThreadedOptimize.testThreadedOptimize(TestThreadedOptimize.java:141)\n    [junit] \n    [junit] \n    [junit] Tests run: 1, Failures: 1, Errors: 0, Time elapsed: 1.748 sec\n\n ",
            "author": "Jason Rutherglen",
            "id": "comment-12930658"
        },
        {
            "date": "2010-11-10T23:53:05+0000",
            "content": "I think I've isolated this test failure to recording the applied deletes.\nBecause we're using last segment index/info, I was adding deletes that may\nor may not have been applied to a particular segment to the last segment\ninfo. I'm not sure what to do in this case as if we record the applied\nterms per segment, but keep the pending terms in last segment info, we're\neffectively not gaining anything from using last segment info because\nwe're then recording all of the terms per-segment anyways. In fact, this\nis how I've isolated that this is the issue, I simply removed the usage of\nlast segment info, and instead went to maintaining pending deletes\nper-segment. I'll give it some thought.\n\nIn conclusion, when deletes are recorded per-segment with no last segment\ninfo, the test passes after 200 times.  ",
            "author": "Jason Rutherglen",
            "id": "comment-12930845"
        },
        {
            "date": "2010-11-11T07:42:32+0000",
            "content": "Alright, we needed to clone the per-segment pending deletes in the\n_mergeInit prior to the merge, like cloning the SRs. There were other\nterms arriving after they were applied to a merge, then the coalescing of\napplied deletes was incorrect. I believe that this was the remaining\nlingering issue. The previous failures seem to have gone away, I ran the\ntest 400 times. I'll upload a new patch shortly. ",
            "author": "Jason Rutherglen",
            "id": "comment-12930949"
        },
        {
            "date": "2010-11-11T18:54:00+0000",
            "content": "I'm still seeing the error no matter what I do. Sometimes the index is not\noptimized, and sometimes there are too many docs. It requires thousands of\niterations to provoke either test error. Perhaps it's simply related to\nmerges that are scheduled but IW close isn't waiting on properly. ",
            "author": "Jason Rutherglen",
            "id": "comment-12931131"
        },
        {
            "date": "2010-11-11T18:58:38+0000",
            "content": "TestThreadedOptimize is a known intermittent failure \u2013 I'm trying to track it down!!  (LUCENE-2618) ",
            "author": "Michael McCandless",
            "id": "comment-12931133"
        },
        {
            "date": "2010-11-11T19:07:59+0000",
            "content": "Ah, nice, I should have looked for previous intermittent failures via Jira.   ",
            "author": "Jason Rutherglen",
            "id": "comment-12931143"
        },
        {
            "date": "2010-11-15T22:09:05+0000",
            "content": "Now that the intermittent failures have been successfully dealt with, ie,\nLUCENE-2618, LUCENE-2576, and LUCENE-2118, I'll merge this patch to trunk,\nthen it's probably time for benchmarking. That'll probably include\nsomething like indexing, then updating many documents and comparing the\nindex time vs. trunk?  ",
            "author": "Jason Rutherglen",
            "id": "comment-12932222"
        },
        {
            "date": "2010-11-16T15:51:27+0000",
            "content": "Straight indexing and deleting will probably not show much of an\nimprovement from this patch. In trunk, apply deletes (all) is called on\nall segments prior to a merge, so we need a synthetic way to measure the\nimprovement. One way is to monitor the merge time of small segments (of an\nindex with many deletes, and many existing large segments) with this patch\nvs. trunk. This'll show that this patch in that case is faster (because\nwe're only applying deletes to the smaller segments). \n\nI think I'll add a merge start time variable to OneMerge that'll be set in\nmergeinit. The var could also be useful for the info stream debug log. The\nbenchmark will simply print out the merge times (which'll be manufactured\nsynthetically).  ",
            "author": "Jason Rutherglen",
            "id": "comment-12932508"
        },
        {
            "date": "2010-11-17T11:47:15+0000",
            "content": "Why do we still have deletesFlushed?  And why do we still need to\nremap docIDs on merge?  I thought with this new approach the docIDUpto\nfor each buffered delete Term/Query would be a local docID to that\nsegment?\n\nOn flush the deletesInRAM should be carried directly over to the\nsegmentDeletes, and there shouldn't be a deletesFlushed?\n\nA few other small things:\n\n\n\tYou can use SegmentInfos.clone to copy the segment infos? (it\n    makes a deep copy)\n\n\n\n\n\tSegmentDeletes.clearAll() need not iterate through the\n    terms/queries to subtract the RAM used?  Ie just multiply by\n    .size() instead and make one call to deduct RAM used?\n\n\n\n\n\tThe SegmentDeletes use less than BYTES_PER_DEL_TERM because it's a\n    simple HashSet not a HashMap?  Ie we are over-counting RAM used\n    now?  (Same for by query)\n\n\n\n\n\tCan we store segment's deletes elsewhere?  The SegmentInfo should\n    be a lightweight class... eg it's used by DirectoryReader to read\n    the index, and if it's read only DirectoryReader there's no need\n    for it to allocate the SegmentDeletes?  These data structures\n    should only be held by IndexWriter/DocumentsWriter.\n\n\n\n\n\tDo we really need to track appliedTerms/appliedQueries?  Ie is\n    this just an optimization so that if the caller deletes by the\n    Term/Query again we know to skip it?  Seems unnecessary if that's\n    all...\n\n ",
            "author": "Michael McCandless",
            "id": "comment-12932915"
        },
        {
            "date": "2010-11-17T13:32:55+0000",
            "content": "Also: why are we tracking the last segment info/index?  Ie, this should only be necessary on cutover to DWPT right?  Because effectively today we have only a single \"DWPT\"? ",
            "author": "Michael McCandless",
            "id": "comment-12932945"
        },
        {
            "date": "2010-11-17T15:39:53+0000",
            "content": "Why do we still have deletesFlushed? And why do we still need to\nremap docIDs on merge? I thought with this new approach the docIDUpto for\neach buffered delete Term/Query would be a local docID to that\nsegment?\n\nDeletes flushed can be removed if we store the docid-upto per segment.\nThen we'll go back to having a hash map of deletes. \n\nThe SegmentDeletes use less than BYTES_PER_DEL_TERM because it's a\nsimple HashSet not a HashMap? Ie we are over-counting RAM used now? (Same\nfor by query)\n\nIntuitively, yes, however here's the constructor of hash set:\n\n\n public HashSet() { map = new HashMap<E,Object>(); } \n\n\nwhy are we tracking the last segment info/index?\n\nI thought last segment was supposed to be used to mark the last segment of\na commit/flush. This way we save on the hash(set,map) space on the\nsegments upto the last segment when the commit occurred.\n\nCan we store segment's deletes elsewhere?\n\nWe can, however I had to minimize places in the code that were potentially\ncausing errors (trying to reduce the problem set, which helped locate the\nintermittent exceptions), syncing segment infos with the per-segment\ndeletes was one was one of those places. That and I thought it'd be worth\na try simplify (at the expense of breaking the unstated intention of the\nSI class).\n\nDo we really need to track appliedTerms/appliedQueries? Ie is this\njust an optimization so that if the caller deletes by the Term/Query again\nwe know to skip it? \n\nYes to the 2nd question. Why would we want to try deleting multiple times?\nThe cost is the terms dictionary lookup which you're saying is in the\nnoise? I think potentially cracking open a query again could be costly in\ncases where the query is indeed expensive.\n\nnot iterate through the terms/queries to subtract the RAM\nused?\n\nWell, the RAM usage tracking can't be completely defined until we finish\nhow we're storing the terms/queries.  ",
            "author": "Jason Rutherglen",
            "id": "comment-12932988"
        },
        {
            "date": "2010-11-17T18:25:38+0000",
            "content": "\n\nDeletes flushed can be removed if we store the docid-upto per segment.\nThen we'll go back to having a hash map of deletes.\n\nI think we should do this?\n\nIe, each flushed segment stores the map of del Term/Query to\ndocid-upto, where that docid-upto is private to the segment (no\nremapping on merges needed).\n\nWhen it's time to apply deletes to about-to-be-merged segments, we\nmust apply all \"future\" segments deletions unconditionally to each\nsegment, and then conditionally (respecting the local docid-upto)\napply that segment's deletions.\n\n\nIntuitively, yes, however here's the constructor of hash set:\n\n\npublic HashSet() { map = new HashMap<E,Object>(); }\n\n\n\nUgh I forgot about that.  Is that still true?  That's awful.\n\n\nwhy are we tracking the last segment info/index?\n\nI thought last segment was supposed to be used to mark the last segment of\na commit/flush. This way we save on the hash(set,map) space on the\nsegments upto the last segment when the commit occurred.\n\nHmm... I think lastSegment was needed only for the multiple DWPT\ncase, to record the last segment already flushed in the index as of\nwhen that DWPT was created.  This is so we know \"going back\" when we\ncan start unconditionally apply the buffered delete term.\n\nWith the single DWPT we effectively have today isn't last segment\nalways going to be what we just flushed?  (Or null if we haven't yet\ndone a flush in the current session).\n\n\nDo we really need to track appliedTerms/appliedQueries? Ie is this just an optimization so that if the caller deletes by the Term/Query again we know to skip it?\n\nYes to the 2nd question. Why would we want to try deleting multiple times?\nThe cost is the terms dictionary lookup which you're saying is in the\nnoise? I think potentially cracking open a query again could be costly in\ncases where the query is indeed expensive.\n\nI'm saying this is unlikely to be worthwhile way to spend RAM.\n\nEG most apps wouldn't delete by same term again, like they'd\n\"typically\" go and process a big batch of docs, deleting by an id\nfield and adding the new version of the doc, where a given id is seen\nonly once in this session, and then IW is committed/closed? ",
            "author": "Michael McCandless",
            "id": "comment-12933067"
        },
        {
            "date": "2010-11-17T19:01:34+0000",
            "content": "DWPT deletes has perhaps confused this issue a little bit. \n\nTracking per-segment would be easier but I worry about indices that\nhave large numbers of segments... eg w/ a large mergeFactor and frequent\nflushing you can get very many segments.\n\nI think we may be back tracking here as I had earlier proposed we simply\nstore each term/query in a map per segment, however I think that was nixed\nin favor of last segment + deletes per segment afterwards. We're not\nworried about the cost of storing pending deletes in a map per segment\nanymore?\n\nWith the single DWPT we effectively have today isn't last segment\nalways going to be what we just flushed? (Or null if we haven't yet done a\nflush in the current session).\n\nPretty much. \n\nEG most apps wouldn't delete by same term again, like they'd\n\"typically\" go and process a big batch of docs, deleting by an id field\nand adding the new version of the doc, where a given id is seen only once\nin this session, and then IW is committed/closed?\n\nIn an extreme RT app that uses Lucene like a database, it could in fact\nupdate a doc many times, then we'd start accumulating and deleting the\nsame ID over and over again. However in the straight batch indexing model\noutlined, that is unlikely to happen. \n\nWhen it's time to apply deletes to about-to-be-merged segments, we\nmust apply all \"future\" segments deletions unconditionally to each\nsegment, and then conditionally (respecting the local docid-upto) apply\nthat segment's deletions.\n\nI'll use this as the go-ahead design then.\n\nIs that still true?\n\nThat's from Java 1.6. ",
            "author": "Jason Rutherglen",
            "id": "comment-12933082"
        },
        {
            "date": "2010-11-17T21:54:30+0000",
            "content": "Additionally we need to decide how accounting'll work for\nmaxBufferedDeleteTerms. We won't have a centralized place to keep track of\nthe number of terms, and the unique term count in aggregate over many\nsegments could be a little too time consuming calculate in a method like\ndoApplyDeletes. An alternative is to maintain a global unique term count,\nsuch that when a term is added, every other per-segment deletes is checked\nfor that term, and if it's not already been tallied, we increment the number\nof buffered terms. ",
            "author": "Jason Rutherglen",
            "id": "comment-12933182"
        },
        {
            "date": "2010-11-17T23:12:04+0000",
            "content": "\nI think we may be back tracking here as I had earlier proposed we simply\nstore each term/query in a map per segment, however I think that was nixed\nin favor of last segment + deletes per segment afterwards. We're not\nworried about the cost of storing pending deletes in a map per segment\nanymore?\n\nOK sorry now I remember.\n\nHmm but, my objection then was to carrying all deletes backward to all\nsegments?\n\nWhereas now I think what we can do is only record the deletions that\nwere added when that segment was a RAM buffer, in its pending deletes\nmap?  This should be fine, since we aren't storing a single deletion\nin multiple places (well, until DWPTs anyway).  It's just that on\napplying deletes to a segment because it's about to be merged we have\nto do a merge sort of the buffered deletes all \"future\" segments.\n\nBTW it could also be possible to not necessarily apply deletes when a\nsegment is merged; eg if there are few enough deletes it may not be\nworthwhile.  But we can leave that to another issue.\n\n\nAdditionally we need to decide how accounting'll work for\nmaxBufferedDeleteTerms. We won't have a centralized place to keep track of\nthe number of terms, and the unique term count in aggregate over many\nsegments could be a little too time consuming calculate in a method like\ndoApplyDeletes. An alternative is to maintain a global unique term count,\nsuch that when a term is added, every other per-segment deletes is checked\nfor that term, and if it's not already been tallied, we increment the number\nof buffered terms.\n\nMaybe we should change the definition to be total number of pending\ndelete term/queries?  (Ie, not dedup'd across segments).  This seems\nreasonable since w/ this new approach the RAM consumed is in\nproportion to that total number and not to dedup'd count? ",
            "author": "Michael McCandless",
            "id": "comment-12933227"
        },
        {
            "date": "2010-11-18T02:45:23+0000",
            "content": "Maybe we should change the definition to be total number of pending\ndelete term/queries? \n\nLets go with this, as even though we could record the total unique term\ncount, the approach outlined is more conservative.\n\nI think what we can do is only record the deletions that were added\nwhen that segment was a RAM buffer, in its pending deletes map\n\nOk, sounds like a design that'll work well. ",
            "author": "Jason Rutherglen",
            "id": "comment-12933299"
        },
        {
            "date": "2010-11-18T03:29:04+0000",
            "content": "Flush deletes equals true means that all deletes are applied, however when it's false, that means we're moving the pending deletes into the newly flushed segment, as is, with no docId-upto remapping.   ",
            "author": "Jason Rutherglen",
            "id": "comment-12933305"
        },
        {
            "date": "2010-11-18T03:42:21+0000",
            "content": "We can \"upgrade\" to an int[] from an ArrayList<Integer> for the aborted docs. ",
            "author": "Jason Rutherglen",
            "id": "comment-12933306"
        },
        {
            "date": "2010-11-19T23:57:34+0000",
            "content": "I'm seeing the following error which is probably triggered by the new per-segment deletes code, however also could be related to the recent CFS format changes?\n\n\nMockDirectoryWrapper: cannot close: there are still open files: {_0.cfs=1, _1.cfs=1}\n    [junit] java.lang.RuntimeException: MockDirectoryWrapper: cannot close: there are still open files: {_0.cfs=1, _1.cfs=1}\n    [junit] \tat org.apache.lucene.store.MockDirectoryWrapper.close(MockDirectoryWrapper.java:395)\n    [junit] \tat org.apache.lucene.index.TestIndexReader.testReopenChangeReadonly(TestIndexReader.java:1717)\n    [junit] \tat org.apache.lucene.util.LuceneTestCase$LuceneTestCaseRunner.runChild(LuceneTestCase.java:921)\n    [junit] \tat org.apache.lucene.util.LuceneTestCase$LuceneTestCaseRunner.runChild(LuceneTestCase.java:859)\n    [junit] Caused by: java.lang.RuntimeException: unclosed IndexInput\n    [junit] \tat org.apache.lucene.store.MockDirectoryWrapper.openInput(MockDirectoryWrapper.java:350)\n    [junit] \tat org.apache.lucene.store.Directory.openInput(Directory.java:138)\n    [junit] \tat org.apache.lucene.index.CompoundFileReader.<init>(CompoundFileReader.java:67)\n    [junit] \tat org.apache.lucene.index.SegmentReader$CoreReaders.<init>(SegmentReader.java:121)\n    [junit] \tat org.apache.lucene.index.SegmentReader.get(SegmentReader.java:527)\n    [junit] \tat org.apache.lucene.index.IndexWriter$ReaderPool.get(IndexWriter.java:628)\n    [junit] \tat org.apache.lucene.index.IndexWriter$ReaderPool.get(IndexWriter.java:603)\n    [junit] \tat org.apache.lucene.index.DocumentsWriter.applyDeletes(DocumentsWriter.java:1081)\n    [junit] \tat org.apache.lucene.index.IndexWriter.applyDeletesAll(IndexWriter.java:4300)\n    [junit] \tat org.apache.lucene.index.IndexWriter.doFlushInternal(IndexWriter.java:3440)\n    [junit] \tat org.apache.lucene.index.IndexWriter.doFlush(IndexWriter.java:3276)\n    [junit] \tat org.apache.lucene.index.IndexWriter.flush(IndexWriter.java:3266)\n    [junit] \tat org.apache.lucene.index.IndexWriter.prepareCommit(IndexWriter.java:3131)\n    [junit] \tat org.apache.lucene.index.IndexWriter.commit(IndexWriter.java:3206)\n\n ",
            "author": "Jason Rutherglen",
            "id": "comment-12934058"
        },
        {
            "date": "2010-11-22T00:19:53+0000",
            "content": "In trying to implement the per-segment deletes I encountered this error\nfrom TestStressIndexing2. So I started over with a new checkout of trunk,\nand started slowly adding in the per-segment code, running\nTestStressIndexing2 as each part was added. The attached patch breaks,\nthough the deletes are still using the old code. There's clearly some kind\nof synchronization issue, though nothing esoteric has been added, yikes.\n\n\n[junit] Testcase: testMultiConfigMany(org.apache.lucene.index.TestStressIndexing2):\tFAILED\n    [junit] expected:<20> but was:<19>\n    [junit] junit.framework.AssertionFailedError: expected:<20> but was:<19>\n\n ",
            "author": "Jason Rutherglen",
            "id": "comment-12934372"
        },
        {
            "date": "2010-11-22T01:58:28+0000",
            "content": "Running TestStressIndexing2 500 times on trunk causes this error which is probably intermittent:\n\n\n[junit] Testsuite: org.apache.lucene.index.TestStressIndexing2\n    [junit] Testcase: testMultiConfigMany(org.apache.lucene.index.TestStressIndexing2):\tCaused an ERROR\n    [junit] Array index out of range: 0\n    [junit] java.lang.ArrayIndexOutOfBoundsException: Array index out of range: 0\n    [junit] \tat java.util.Vector.get(Vector.java:721)\n    [junit] \tat org.apache.lucene.index.DocumentsWriter.applyDeletes(DocumentsWriter.java:1049)\n    [junit] \tat org.apache.lucene.index.IndexWriter.applyDeletes(IndexWriter.java:4291)\n    [junit] \tat org.apache.lucene.index.IndexWriter.doFlushInternal(IndexWriter.java:3444)\n    [junit] \tat org.apache.lucene.index.IndexWriter.doFlush(IndexWriter.java:3279)\n    [junit] \tat org.apache.lucene.index.IndexWriter.flush(IndexWriter.java:3269)\n    [junit] \tat org.apache.lucene.index.IndexWriter.closeInternal(IndexWriter.java:1760)\n    [junit] \tat org.apache.lucene.index.IndexWriter.close(IndexWriter.java:1723)\n    [junit] \tat org.apache.lucene.index.IndexWriter.close(IndexWriter.java:1687)\n    [junit] \tat org.apache.lucene.index.TestStressIndexing2.indexRandom(TestStressIndexing2.java:233)\n    [junit] \tat org.apache.lucene.index.TestStressIndexing2.testMultiConfig(TestStressIndexing2.java:123)\n    [junit] \tat org.apache.lucene.index.TestStressIndexing2.testMultiConfigMany(TestStressIndexing2.java:97)\n    [junit] \tat org.apache.lucene.util.LuceneTestCase$LuceneTestCaseRunner.runChild(LuceneTestCase.java:950)\n    [junit] \tat org.apache.lucene.util.LuceneTestCase$LuceneTestCaseRunner.runChild(LuceneTestCase.java:888)\n\n ",
            "author": "Jason Rutherglen",
            "id": "comment-12934381"
        },
        {
            "date": "2010-11-22T02:10:33+0000",
            "content": "The above isn't on trunk, I misread the screen. ",
            "author": "Jason Rutherglen",
            "id": "comment-12934384"
        },
        {
            "date": "2010-11-22T02:50:55+0000",
            "content": "I've isolated the mismatch in num docs between the CMS vs. SMS generated\nindexes to applying the deletes to the merging segments (whereas currently\nwe were/are not applying deletes to merging segments and\nTestStressIndexing2 passes). Assuming the deletes are being applied\ncorrectly to the merging segments, perhaps the logic of gathering up\nforward segment deletes is incorrect somehow in the concurrent merge case.\nWhen deletes were held in a map per segment, this test was passing.  ",
            "author": "Jason Rutherglen",
            "id": "comment-12934388"
        },
        {
            "date": "2010-11-22T03:25:55+0000",
            "content": "A test to see if the problem is the deletes per-segment go forward logic is to iterate over the deletes flushed map using the docid-upto to stay within the boundaries of the segment(s) being merged. ",
            "author": "Jason Rutherglen",
            "id": "comment-12934390"
        },
        {
            "date": "2010-11-24T18:53:20+0000",
            "content": "What a nice small patch \n\nI think the getDeletesSegmentsForward shouldn't be folding in the\ndeletesInRAM?  Ie, that newly flushed info will have carried over the\nprevious deletes in RAM?\n\nI think pushDeletes/pushSegmentDeletes should be merged, and we should\nnuke DocumentsWriter.deletesFlushed?  Ie, we should push directly from\ndeletesInRAM to the new SegmentInfo?  EG you are now pushing all\ndeletesFlushed into the new SegmentInfo when actually you should only\npush the deletes for that one segment.\n\nWe shouldn't do the remap deletes anymore.  We can remove\nDocumentsWriter.get/set/updateFlushedDocCount too.\n\nHmm... so what are we supposed to do if someone opens IW, does a bunch\nof deletes, then commits?  Ie flushDocs is false, so there's no new\nSegmentInfo.  I think in this case we can stick the deletes against\nthe last segment in the index, with the docidUpto set to the maxDoc()\nof that segment? ",
            "author": "Michael McCandless",
            "id": "comment-12935441"
        },
        {
            "date": "2010-11-27T19:44:21+0000",
            "content": "\n\tI added pushDeletesLastSegment to doc writer\n\n\n\n\n\tDeletes flushed is gone, only deletesInRAM exists\n\n\n\n\n\tIn the apply merge deletes case, won't we want to add deletesInRAM in\nthe getForwardDeletes method?\n\n\n\n\n\tThe TestStressIndexing2 test still fails so there is still something\nincorrect.\n\n\n\n\n\tThough for the failing unit test it does not matter, we need to figure\nout a solution for the pending doc ids deletions, eg, they can't simply\ntransferred around, they probably need to be applied as soon as possible.\nOtherwise they require remapping. \n\n ",
            "author": "Jason Rutherglen",
            "id": "comment-12964432"
        },
        {
            "date": "2010-11-27T19:54:25+0000",
            "content": "In the apply merge deletes case, won't we want to add deletesInRAM in the getForwardDeletes method?\n\nNo, we can't add those deletes until the current buffered segment is successfully flushed.\n\nEg, say the segment hits a disk full on flush, and DocsWriter aborts (discards all buffered docs/deletions from that segment).  If we included these deletesInRAM when applying deletes then suddenly the app will see that some deletes were applied yet the added documents were not.  So on disk full during flush, calls to .updateDocument may wind up deleting the old doc but not adding the new one.\n\nSo we need to keep them segregated for proper error case semantics.\n\n\nThough for the failing unit test it does not matter, we need to figure\nout a solution for the pending doc ids deletions, eg, they can't simply\ntransferred around, they probably need to be applied as soon as possible.\nOtherwise they require remapping.\n\nHmm why must we remap?  Can't we carry these buffered deleteByDocIDs along with the segment?  The docIDs would be the segment's docIDs (ie no base added) so no shifting is needed?\n\nThese deleted docIDs would only apply to the current segment, ie would not be included in getForwardDeletes? ",
            "author": "Michael McCandless",
            "id": "comment-12964441"
        },
        {
            "date": "2010-11-27T20:08:01+0000",
            "content": "I made the changes listed above, ie, docids and deletesInRAM aren't included in getForwardDeletes.  However TestStressIndexing2 still fails, and the numbers are still off significantly which probably indicates it's not a synchronization issue. ",
            "author": "Jason Rutherglen",
            "id": "comment-12964447"
        },
        {
            "date": "2010-11-27T20:33:55+0000",
            "content": "So nice to see remapDeletes deleted!\n\n\n\tDon't forget to remove DocumentsWriter.get/set/updateFlushedDocCount too.\n\n\n\n\n\tCan you move the deletes out of SegmentInfo?  We can just use a\n    Map<SegmentInfo,BufferedDeletes>?  But remember to delete segments\n    from the map once we commit the merge...\n\n\n\n\n\tI think DocsWriter shouldn't hold onto the SegmentInfos; we should\n    pass it in to only those methods that need it.  That SegmentInfos\n    is protected under IW's monitor so it makes me nervous if it's\n    also a member on DW.\n\n\n\n\n\tHmm we're no longer accounting for RAM usage of per-segment\n    deletes?  I think we need an AtomicInt, which we incr w/ RAM used\n    on pushing deletes into a segment, and decr on clearing?\n\n\n\n\n\tThe change to the message(...) in DW.applyDeletes is wrong (ie\n    switching to deletesInRAM); I think we should just remove the\n    details, ie so it says \"applying deletes on N segments\"?  But then\n    add a more detailed message per-segment with the aggregated\n    (forward) deletes details?\n\n\n\n\n\tI think we should move this delete handling out of DW as much as\n    possible... that's really IW's role (DW is \"about\" flushing the\n    next segment, not tracking details associated with all other\n    segments in the index)\n\n\n\n\n\tInstead of adding pushDeletesLastSegment, can we just have IW call\n    pushDeletes(lastSegmentInfo)?\n\n\n\n\n\tCalling .getForwardDeletes inside the for loop iterating over the\n    infos is actually O(N^2) cost, and it could matter for\n    delete-intensive many-segment indices.  Can you change this,\n    instead, to walk the infos backwards, incrementally building up\n    the forward deletes to apply to each segment by adding in that\n    infos deletions?\n\n ",
            "author": "Michael McCandless",
            "id": "comment-12964450"
        },
        {
            "date": "2010-11-28T22:49:22+0000",
            "content": "I guess you think the sync on doc writer is the cause of the\nTestStressIndexing2 unit test failure?\n\nI think we should move this delete handling out of DW\n\nI agree, I originally took this approach however unit tests were failing\nwhen segment infos was passed directly into the apply deletes method(s).\nThis'll be the 2nd time however apparently the 3rd time's the charm.\n\nI'll make the changes and cross my fingers. ",
            "author": "Jason Rutherglen",
            "id": "comment-12964606"
        },
        {
            "date": "2010-11-29T00:15:26+0000",
            "content": "I started on taking the approach of moving deletes to a SegmentDeletes class\nthat's a member of IW. Removing DW's addDeleteTerm is/was fairly trivial. \n\nIn moving deletes out of DW, how should we handle the bufferDeleteTerms sync on\nDW and the containing waitReady? The purpose of BDT is to check if RAM\nconsumption has reached it's peak, and if so, balance out the ram usage and/or\nflush pending deletes that are ram consuming. This is probably why deletes are\nintertwined with DW. We could change DW's BDT method though I'm loathe to\nchange the wait logic of DW for fear of causing a ripple effect of inexplicable\nunit test failures elsewhere. ",
            "author": "Jason Rutherglen",
            "id": "comment-12964610"
        },
        {
            "date": "2010-11-29T10:30:28+0000",
            "content": "\nI guess you think the sync on doc writer is the cause of the\nTestStressIndexing2 unit test failure?\n\nI'm not sure what's causing the failure, but, I think getting the net approach roughly right is the first goal, and then we see what's failing.\n\n\nI think we should move this delete handling out of DW\n\nI agree, I originally took this approach however unit tests were failing\nwhen segment infos was passed directly into the apply deletes method(s).\nThis'll be the 2nd time however apparently the 3rd time's the charm.\n\nNot only moving the SegmentInfos out of DW as a member, but also move all the applyDeletes logic out.  Ie it should be IW that pulls readers from the pool, walks the merged del term/queries/per-seg docIDs and actually does the deletion.\n\nIn moving deletes out of DW, how should we handle the bufferDeleteTerms sync on DW and the containing waitReady?\n\nI think all the bufferDeleteX would move into IW, and timeToFlushDeletes. The RAM accounting can be done fully inside IW.\n\nThe waitReady(null) is there so that DW.pauseAllThreads also pauses any threads doing deletions.  But, in moving these methods to IW, we'd make them sync on IW (they are now sync'd on DW), which takes care of pausing these threads. ",
            "author": "Michael McCandless",
            "id": "comment-12964680"
        },
        {
            "date": "2010-11-29T20:58:35+0000",
            "content": "The waitReady(null) is there so that DW.pauseAllThreads also pauses any threads doing deletions\n\nwaitReady is used in getThreadState as well as bufferDeleteX, we may need to redundantly add it to SegmentDeletes?  Maybe not.  We'll be sync'ing on IW when adding deletions, that seems like it'll be OK.  \n\nin moving these methods to IW, we'd make them sync on IW (they are now sync'd on DW), which takes care of pausing these threads\n\nBecause we're sync'ing on IW we don't need to pause the indexing threads?  Ok this is because doFlushX is sync'd on IW.  \n\nThe RAM accounting can be done fully inside IW.\n\nWell, inside of SegmentDeletes. ",
            "author": "Jason Rutherglen",
            "id": "comment-12964938"
        },
        {
            "date": "2010-11-30T19:12:33+0000",
            "content": "This patch separates out most of the deletes storage and processing into a\nSegmentDeletes class. The segments are walked backwards to coalesce the pending\ndeletions. I think/hope this logic is correct. \n\nUpdate document is a bit tricky as we cannot sync on IW to insure correctness\nof del term addition, nor can we really sync inside of DW without probably\ncausing deadlock. When I simply delete the doc after adding it in IW,\nTestStressIndexing2 fails miserably with 0 num docs. ",
            "author": "Jason Rutherglen",
            "id": "comment-12965352"
        },
        {
            "date": "2010-11-30T19:24:19+0000",
            "content": "Now we're returning the DocumentsWriterThreadState to IW to record the exact doc id as the del term limit.  TestStressIndexing2 fails but far less from the mark, eg, 1 when it does and actually passes some of the time. ",
            "author": "Jason Rutherglen",
            "id": "comment-12965360"
        },
        {
            "date": "2010-11-30T22:48:19+0000",
            "content": "Here's a random guess, I think because with this patch we're applying deletes\nsometimes multiple times, whereas before we were applying all of them and\nclearing them out at once, there's a mismatch in terms of over/under-applying\ndeletes. Oddly when deletes are performed in _mergeInit on all segments vs.\nonly on the segments being merged, the former has a much higher success rate.\nThis is strange because all deletes will have been applied by the time\ncommit/getreader is called anyways.  ",
            "author": "Jason Rutherglen",
            "id": "comment-12965468"
        },
        {
            "date": "2010-12-08T19:44:32+0000",
            "content": "\nOK I started from the last patch and iterated quite a bit.\n\nThe per-segment deletes are now working!  All tests pass.  It turned\nout to be a little more hairy than we thought because you also must\naccount for deletes that are pushed backwards onto a segment being\nmerged (eg due to a flush, or a merge just ahead) while that merge is\nstill running.\n\nI swapped the two classes \u2013 SegmentDeletes tracks deletes for one\nsegment, while BufferedDeletes tracks deletes for all segments.\n\nI also wound up doing a fair amount of cleanup/refactoring on how\nDW/IW interact, I think a good step towards DWPT.  EG IW's flush is\nnow much smaller (could almost become unsync'd) since I moved\nflushing doc stores, building CFS, etc. down into DW.\n\nI added a new FlushControl class to manage (external to DW) triggering\nof flushing due to RAM, add doc count, buffered del count.  This way\nDWPT can share the single FlushControl instance in IW. ",
            "author": "Michael McCandless",
            "id": "comment-12969448"
        },
        {
            "date": "2010-12-08T21:41:53+0000",
            "content": "When patching there are errors on IndexWriter. ",
            "author": "Jason Rutherglen",
            "id": "comment-12969504"
        },
        {
            "date": "2010-12-09T10:58:42+0000",
            "content": "Woops, sorry about that Jason \u2013 I wasn't fully updated.  Try this one? ",
            "author": "Michael McCandless",
            "id": "comment-12969693"
        },
        {
            "date": "2010-12-09T15:02:58+0000",
            "content": "We're close, I think SegmentDeletes is missing? ",
            "author": "Jason Rutherglen",
            "id": "comment-12969754"
        },
        {
            "date": "2010-12-09T15:14:40+0000",
            "content": "Ugh, OK new patch.  3rd time's a charm? ",
            "author": "Michael McCandless",
            "id": "comment-12969763"
        },
        {
            "date": "2010-12-09T16:38:25+0000",
            "content": "The patch applied.\n\nOk, a likely cause of the TestStressIndexing2 failures was that when we're\nflushing deletes to the last segment (because a segment isn't being flushed),\nwe needed to move deletes also to the newly merged segment?\n\nIn the patch we've gone away from sync'ing on IW when deleting, which was a\nchallenge because we needed the sync on DW to properly wait on flushing threads\netc. ",
            "author": "Jason Rutherglen",
            "id": "comment-12969799"
        },
        {
            "date": "2010-12-09T17:20:41+0000",
            "content": "All tests pass. ",
            "author": "Jason Rutherglen",
            "id": "comment-12969822"
        },
        {
            "date": "2010-12-09T20:08:00+0000",
            "content": "\nOk, a likely cause of the TestStressIndexing2 failures was that when we're\nflushing deletes to the last segment (because a segment isn't being flushed),\nwe needed to move deletes also to the newly merged segment?\n\nRight, and also the case where a merge just-ahead of you kicks off and dumps its merged deletes onto you. ",
            "author": "Michael McCandless",
            "id": "comment-12969914"
        },
        {
            "date": "2010-12-11T11:09:42+0000",
            "content": "OK I committed this to trunk.\n\nSince it's a biggish change I'll hold off on back-porting to 3.x for now... let's let hudson chew on it some first. ",
            "author": "Michael McCandless",
            "id": "comment-12970446"
        },
        {
            "date": "2011-03-30T15:49:59+0000",
            "content": "Bulk close for 3.1 ",
            "author": "Grant Ingersoll",
            "id": "comment-13013326"
        },
        {
            "date": "2011-10-28T19:03:42+0000",
            "content": "Hey, is it something that was ported to 3.x, or not really? ",
            "author": "Roman Alekseenkov",
            "id": "comment-13138649"
        },
        {
            "date": "2011-10-28T19:14:51+0000",
            "content": "Hi, this was backported since lucene 3.1 ",
            "author": "Robert Muir",
            "id": "comment-13138661"
        },
        {
            "date": "2011-10-28T19:55:22+0000",
            "content": "thank you, Robert\n\nI was asking because we are having issues with 3.4.0 where applyDeletes() takes an large amount of time on commit for 150GB index, and this is stopping all indexing threads. it looks like applyDeletes() is re-scanning an entire index, even though it's unnecessary as we are only adding documents to the index but not deleting them\n\nif this optimization was backported, then I will probably have to find a solution for my problem elsewhere... ",
            "author": "Roman Alekseenkov",
            "id": "comment-13138695"
        },
        {
            "date": "2011-10-28T19:59:29+0000",
            "content": "\neven though it's unnecessary as we are only adding documents to the index but not deleting them\n\nHi Roman, i saw your post.\n\nI think by default when you add a document with unique id X, Solr deletes-by-term of X.\n\nBut I'm pretty sure it has an option (sorry i dont know what it is), where you can tell it \nthat you are sure that the documents you are adding are new and it won't do this. ",
            "author": "Robert Muir",
            "id": "comment-13138700"
        }
    ]
}