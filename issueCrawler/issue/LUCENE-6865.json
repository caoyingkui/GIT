{
    "id": "LUCENE-6865",
    "title": "BooleanQuery2ModifierNodeProcessor breaks the query node hierarchy",
    "details": {
        "resolution": "Duplicate",
        "affect_versions": "None",
        "components": [],
        "labels": "",
        "fix_versions": [
            "5.3"
        ],
        "priority": "Major",
        "status": "Closed",
        "type": "Bug"
    },
    "description": "We discovered that one of our own implementations of QueryNodeProcessor was seeing node.getParent() returning null for nodes other than the root of the query tree.\n\nI put a diagnostic processor around every processor which runs and found that BooleanQuery2ModifierNodeProcessor (and possibly others, although it isn't clear) are mysteriously setting some of the node references to null.\n\nExample query tree before:\n\n\nGroupQueryNode, parent = null\n  WithinQueryNode, parent = GroupQueryNode\n    QuotedFieldQueryNode, parent = WithinQueryNode\n    GroupQueryNode, parent = WithinQueryNode\n      AndQueryNode, parent = GroupQueryNode\n        GroupQueryNode, parent = AndQueryNode\n          OrQueryNode, parent = GroupQueryNode\n            QuotedFieldQueryNode, parent = OrQueryNode\n            QuotedFieldQueryNode, parent = OrQueryNode\n        GroupQueryNode, parent = AndQueryNode\n          OrQueryNode, parent = GroupQueryNode\n            QuotedFieldQueryNode, parent = OrQueryNode\n            QuotedFieldQueryNode, parent = OrQueryNode\n\n\n\nAnd after BooleanQuery2ModifierNodeProcessor.process():\n\n\nGroupQueryNode, parent = null\n  WithinQueryNode, parent = GroupQueryNode\n    QuotedFieldQueryNode, parent = WithinQueryNode\n    GroupQueryNode, parent = WithinQueryNode\n      AndQueryNode, parent = GroupQueryNode\n        BooleanModifierNode, parent = AndQueryNode\n          GroupQueryNode, parent = null\n            OrQueryNode, parent = GroupQueryNode\n              QuotedFieldQueryNode, parent = OrQueryNode\n              QuotedFieldQueryNode, parent = OrQueryNode\n        BooleanModifierNode, parent = AndQueryNode\n          GroupQueryNode, parent = null\n            OrQueryNode, parent = GroupQueryNode\n              QuotedFieldQueryNode, parent = OrQueryNode\n              QuotedFieldQueryNode, parent = OrQueryNode\n\n\n\nLooking at QueryNodeImpl, there is a lot of fiddly logic in there. Removing children can trigger setting the parent to null, but setting the parent can also trigger the child removing itself, so it's near impossible to figure out why this could be happening, but I'm closing in on it at least. My initial suspicion is that cloneTree() is responsible, because ironically the number of failures of this sort increase if I try to use cloneTree to defend against mutability bugs.\n\nThe fix I have come up with is to clone the whole API but making QueryNode immutable. This removes the ability for processors to mess with nodes that don't belong to them, but also obviates the need for a parent reference in the first place, which I think is the entire source of the problem - keeping the parent and child in sync correctly is obviously going to be hard, and indeed we find that there is at least one bug of this sort lurking in there.\n\nBut even if we rewrite it, I figured I would report the issue so that maybe it can be fixed for others.\n\n\nCode to use for diagnostics:\n\n\nimport java.util.List;\n\nimport org.apache.lucene.queryparser.flexible.core.QueryNodeException;\nimport org.apache.lucene.queryparser.flexible.core.config.QueryConfigHandler;\nimport org.apache.lucene.queryparser.flexible.core.nodes.QueryNode;\nimport org.apache.lucene.queryparser.flexible.core.processors.QueryNodeProcessor;\n\npublic class DiagnosticQueryNodeProcessor implements QueryNodeProcessor\n{\n    private final QueryNodeProcessor delegate;\n\n    public TreeFixingQueryNodeProcessor(QueryNodeProcessor delegate)\n    {\n        this.delegate = delegate;\n    }\n\n    @Override\n    public QueryConfigHandler getQueryConfigHandler()\n    {\n        return delegate.getQueryConfigHandler();\n    }\n\n    @Override\n    public void setQueryConfigHandler(QueryConfigHandler queryConfigHandler)\n    {\n        delegate.setQueryConfigHandler(queryConfigHandler);\n    }\n\n    @Override\n    public QueryNode process(QueryNode queryNode) throws QueryNodeException\n    {\n        System.out.println(\"Before \" + delegate.getClass().getSimpleName() + \".process():\");\n        dumpTree(queryNode);\n\n        queryNode = delegate.process(queryNode);\n\n        System.out.println(\"After \" + delegate.getClass().getSimpleName() + \".process():\");\n        dumpTree(queryNode);\n\n        return queryNode;\n    }\n\n    private void dumpTree(QueryNode queryNode)\n    {\n        dumpTree(queryNode, \"\");\n    }\n\n    private void dumpTree(QueryNode queryNode, String prefix)\n    {\n        System.out.println(prefix + queryNode.getClass().getSimpleName() +\n                           \", parent = \" + (queryNode.getParent() == null ? \"null\" : queryNode.getParent().getClass().getSimpleName()));\n        List<QueryNode> children = queryNode.getChildren();\n        if (children != null)\n        {\n            String childPrefix = \"  \" + prefix;\n            for (QueryNode child : children)\n            {\n                dumpTree(child, childPrefix);\n            }\n        }\n    }\n}",
    "attachments": {},
    "issue_links": {},
    "comments": [
        {
            "id": "comment-14979528",
            "author": "Trejkaz",
            "date": "2015-10-29T00:05:44+0000",
            "content": "Standalone reproduction:\n\n\nimport java.util.Arrays;\nimport java.util.List;\n\nimport org.apache.lucene.queryparser.flexible.core.nodes.AndQueryNode;\nimport org.apache.lucene.queryparser.flexible.core.nodes.GroupQueryNode;\nimport org.apache.lucene.queryparser.flexible.core.nodes.OrQueryNode;\nimport org.apache.lucene.queryparser.flexible.core.nodes.QueryNode;\nimport org.apache.lucene.queryparser.flexible.core.nodes.QuotedFieldQueryNode;\nimport org.apache.lucene.queryparser.flexible.core.processors.QueryNodeProcessor;\nimport org.apache.lucene.queryparser.flexible.standard.config.StandardQueryConfigHandler;\nimport org.apache.lucene.queryparser.flexible.standard.processors.BooleanQuery2ModifierNodeProcessor;\nimport org.junit.Test;\n\nimport static org.hamcrest.Matchers.*;\nimport static org.junit.Assert.*;\n\n/**\n * Tests for {@link BooleanQuery2ModifierNodeProcessor},\n */\npublic class TestBooleanQuery2ModifierNodeProcessor\n{\n    @Test\n    public void testProcess() throws Exception\n    {\n        QueryNode before = new GroupQueryNode(\n                    new AndQueryNode(Arrays.asList(\n                        new GroupQueryNode(\n                            new OrQueryNode(Arrays.asList(\n                                new QuotedFieldQueryNode(\"a\", \"a\", 0, 0),\n                                new QuotedFieldQueryNode(\"a\", \"a\", 0, 0)))),\n                        new GroupQueryNode(\n                            new OrQueryNode(Arrays.asList(\n                                new QuotedFieldQueryNode(\"a\", \"a\", 0, 0),\n                                new QuotedFieldQueryNode(\"a\", \"a\", 0, 0)))))));\n\n        QueryNodeProcessor processor = new BooleanQuery2ModifierNodeProcessor();\n        processor.setQueryConfigHandler(new StandardQueryConfigHandler());\n\n        QueryNode after = processor.process(before);\n        checkTree(after);\n    }\n\n\n    private static void checkTree(QueryNode queryNode)\n    {\n        checkTree(queryNode, \"\");\n    }\n\n    private static void checkTree(QueryNode queryNode, String prefix)\n    {\n        List<QueryNode> children = queryNode.getChildren();\n        if (children != null)\n        {\n            String childPrefix = \"  \" + prefix;\n            for (QueryNode child : children)\n            {\n                assertThat(child.getParent(), is(queryNode));\n                checkTree(child, childPrefix);\n            }\n        }\n    }\n}\n\n "
        },
        {
            "id": "comment-14979537",
            "author": "Trejkaz",
            "date": "2015-10-29T00:15:57+0000",
            "content": "Suspicious code #1. A call to processIteration which is not using the return value.\n\n\n    protected void processChildren(QueryNode queryTree) throws QueryNodeException {\n        List children = queryTree.getChildren();\n        if(children != null && children.size() > 0) {\n            Iterator var3 = children.iterator();\n\n            while(var3.hasNext()) {\n                QueryNode child = (QueryNode)var3.next();\n                this.processIteration(child);\n            }\n        }\n\n    }\n\n "
        },
        {
            "id": "comment-14979605",
            "author": "Trejkaz",
            "date": "2015-10-29T01:03:44+0000",
            "content": "Another reproduction which doesn't use the processor, confirming my suspicions that this is a widespread problem with query nodes themselves:\n\n\nimport java.util.Collections;\nimport java.util.List;\n\nimport org.apache.lucene.queryparser.flexible.core.nodes.AndQueryNode;\nimport org.apache.lucene.queryparser.flexible.core.nodes.GroupQueryNode;\nimport org.apache.lucene.queryparser.flexible.core.nodes.ModifierQueryNode;\nimport org.apache.lucene.queryparser.flexible.core.nodes.QueryNode;\nimport org.apache.lucene.queryparser.flexible.core.nodes.QuotedFieldQueryNode;\nimport org.apache.lucene.queryparser.flexible.standard.nodes.BooleanModifierNode;\nimport org.junit.Test;\n\nimport static org.hamcrest.Matchers.*;\nimport static org.junit.Assert.*;\n\n/**\n * Tests for query nodes,\n */\npublic class TestQueryNodes\n{\n    @Test\n    public void testCutDown() throws Exception\n    {\n        QueryNode before = new GroupQueryNode(\n            new AndQueryNode(Collections.singletonList(\n                new QuotedFieldQueryNode(\"a\", \"a\", 0, 0))));\n        checkTree(before);\n\n        // This wrecks the query tree somehow.\n        before.set(Collections.singletonList(\n            new BooleanModifierNode(before.getChildren().get(0), ModifierQueryNode.Modifier.MOD_REQ)));\n\n        checkTree(before);\n    }\n\n    private static void checkTree(QueryNode queryNode)\n    {\n        checkTree(queryNode, \"\");\n    }\n\n    private static void checkTree(QueryNode queryNode, String prefix)\n    {\n        List<QueryNode> children = queryNode.getChildren();\n        if (children != null)\n        {\n            String childPrefix = \"  \" + prefix;\n            for (QueryNode child : children)\n            {\n                assertThat(child.getParent(), is(queryNode));\n                checkTree(child, childPrefix);\n            }\n        }\n    }\n\n}\n\n\n "
        },
        {
            "id": "comment-14979684",
            "author": "Trejkaz",
            "date": "2015-10-29T02:30:53+0000",
            "content": "These tests fail too. Note these don't even call set() - the tree gets corrupted just by passing one of its nodes into another constructor. This is the sort of spooky mutability bug that I would rather avoid by just having the nodes immutable.\n\n\n    @Test\n    public void testCutDown1() throws Exception\n    {\n        QueryNode before = new GroupQueryNode(\n            new AndQueryNode(Collections.singletonList(\n                new QuotedFieldQueryNode(\"a\", \"a\", 0, 0))));\n        checkTree(before);\n\n        // This wrecks the query tree somehow.\n        new ModifierQueryNode(before.getChildren().get(0), ModifierQueryNode.Modifier.MOD_REQ);\n        checkTree(before);\n    }\n\n    @Test\n    public void testCutDown2() throws Exception\n    {\n        QueryNode before = new GroupQueryNode(\n            new AndQueryNode(Collections.singletonList(\n                new QuotedFieldQueryNode(\"a\", \"a\", 0, 0))));\n        checkTree(before);\n\n        // This wrecks the query tree somehow.\n        new BooleanQueryNode(Collections.singletonList(before.getChildren().get(0)));\n        checkTree(before);\n    }\n\n "
        },
        {
            "id": "comment-14981682",
            "author": "Trejkaz",
            "date": "2015-10-30T01:14:18+0000",
            "content": "The underlying issue here seems like it might be LUCENE-6506 ... but to get that fix we have to update to 5.3.  "
        },
        {
            "id": "comment-14984675",
            "author": "Trejkaz",
            "date": "2015-11-02T03:04:20+0000",
            "content": "Tried updating to 5.3, looks like backwards compatibility was broken in the 5.3 release, and we depend on elasticsearch as well, meaning we can't update even if we update all our own code to 5.3. "
        },
        {
            "id": "comment-14984702",
            "author": "Trejkaz",
            "date": "2015-11-02T03:43:43+0000",
            "content": "Temporary workaround for now I guess. Override the process method to wedge in an extra call to a method which corrects the problem.\n\n\n    @Override\n    public QueryNode process(QueryNode queryTree) throws QueryNodeException\n    {\n        for (QueryNodeProcessor processor : this)\n        {\n            queryTree = processor.process(queryTree);\n            fixQueryTree(queryTree);\n        }\n\n        return queryTree;\n    }\n\n    /**\n     * Recursively fixes parent-child links in the query tree.\n     * Basically this works by detaching and reattaching all descendants from their immediate parent.\n     *\n     * @param input the input query node.\n     */\n    private void fixQueryTree(QueryNode input)\n    {\n        List<QueryNode> children = input.getChildren();\n        if (children != null)\n        {\n            children.forEach(this::fixQueryTree);\n\n            // This is what fixes it.\n            input.set(children);\n        }\n    }\n\n "
        },
        {
            "id": "comment-15262622",
            "author": "Trejkaz",
            "date": "2016-04-28T17:56:14+0000",
            "content": "Verified as another duplicate of LUCENE-5805. Fixed by the same fix of course. "
        }
    ]
}