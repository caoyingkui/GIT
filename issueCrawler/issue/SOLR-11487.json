{
    "id": "SOLR-11487",
    "title": "Collection Alias metadata for time partitioned collections",
    "details": {
        "labels": "",
        "priority": "Major",
        "components": [
            "SolrCloud"
        ],
        "type": "Sub-task",
        "fix_versions": [
            "7.2"
        ],
        "affect_versions": "None",
        "resolution": "Fixed",
        "status": "Resolved"
    },
    "description": "SOLR-11299 outlines an approach to using a collection Alias to refer to a series of collections of a time series. We'll need to store some metadata about these time series collections, such as which field of the document contains the timestamp to route on.\n\nThe current /aliases.json is a Map with a key collection which is in turn a Map of alias name strings to a comma delimited list of the collections.\nIf we change the comma delimited list to be another Map to hold the existing list and more stuff, older CloudSolrClient (configured to talk to ZooKeeper) will break.  Although if it's configured with an HTTP Solr URL then it would not break.  There's also some read/write hassle to worry about \u2013 we may need to continue to read an aliases.json in the older format.\n\nAlternatively, we could add a new map entry to aliases.json, say, collection_metadata keyed by alias name?\n\nPerhaps another very different approach is to attach metadata to the configset in use?",
    "attachments": {
        "SOLR_11487.patch": "https://issues.apache.org/jira/secure/attachment/12892310/SOLR_11487.patch"
    },
    "issue_links": {},
    "comments": [
        {
            "date": "2017-10-15T17:29:54+0000",
            "content": "In zk nodes can have both values and children right? So the value of the node called aliases.json can remain the same json text, but it could also have a list of children corresponding to each alias and then each member of the alias containing that metadata... yes some duplication there, but this would mean that any older clients reading the value from the node will still get what they expect... newer code could simply ignore the old json... ",
            "author": "Gus Heck",
            "id": "comment-16205218"
        },
        {
            "date": "2017-10-15T20:36:28+0000",
            "content": "Patch showing rough sketch of what I am thinking, The thing I like about this is it allows us to track metadata on the aliases, and the collections that they alias as well, which may be useful in caching info used in 11299, such as the calculated milliseconds that represent when a partition's data starts.\n\nThe thing I don't like about this is it does a lot of reading from Zk... possibly something like this should become maintained by watches and not read every time... which also makes me learn further in the direction of my comment in code that the metadata should probably be <String,Object> not <String,String>... to let JSON parsing do all our conversions for primitives. ",
            "author": "Gus Heck",
            "id": "comment-16205291"
        },
        {
            "date": "2017-10-16T20:24:50+0000",
            "content": "Thanks for sharing your idea Gus Heck.  This is an approach I didn't think of.  I'm concerned this is over-using ZooKeeper nodes for what could be a simple map instead.  It's not like the metadata on the collection (as associated with the alias) is going to change so often as to benefit from the ability to change some but not all of this metadata.  Noble Paul what do you think of this? ",
            "author": "David Smiley",
            "id": "comment-16206546"
        },
        {
            "date": "2017-10-16T23:28:45+0000",
            "content": "I prefer the approach of adding a collection_metadata key in the current aliases.json approach. That means fewer nodes . Every extra node is extra bookkeeping ",
            "author": "Noble Paul",
            "id": "comment-16206772"
        },
        {
            "date": "2017-10-19T13:22:26+0000",
            "content": "Is this ticket meant to add a general collection metadata facility (with admin commands for users to add/remove metadata of their own), or just make the metadata available in code at the ZkStateReader.getAliases() level?  ",
            "author": "Gus Heck",
            "id": "comment-16211026"
        },
        {
            "date": "2017-10-19T14:15:44+0000",
            "content": "The latter \u2013 alias metadata. ",
            "author": "David Smiley",
            "id": "comment-16211098"
        },
        {
            "date": "2017-10-23T14:56:11+0000",
            "content": "Patch vs trunk to implement simple string based metadata on aliases as an additional element (peer to existing \"collection\" element) in the existing aliases.json. I think we should consider whether there is a possible need to add support for Lists or Maps as values for tracking more complex metadata in the future, but I have left that out for now. ",
            "author": "Gus Heck",
            "id": "comment-16215250"
        },
        {
            "date": "2017-10-23T21:10:46+0000",
            "content": "Thanks for the patch Gus!\n\n\tI think just String values is fine; it's like a Properties object.  Therefore you could change the type of the aliasMap field to what it was (Map,String,Map<String,String>>?\n\tWhy change Collections.emptyMap() to Collections.EMPTY_MAP ?  The latter results in Java unchecked assignment warnings.  Speaking of which, can you please address such warnings?\n\tgetCollectionMetadataMap needs some docs.  Can result be null?\n\tsetAliasMetadata:\n\t\n\t\twould you mind changing the \"key\" param name to \"keyMetadata\" and \"metadata\" param name to \"valueMetadata\" (or shorter \"Meta\" instead of \"Metadata\" if you choose)?  That would read clearer to me.\n\t\tsetAliasMetadata doesn't have \"collection\" in its name.  Likewise the aliasMetadataField should be qualified as well.  Or... we stop pretending at the class level that we support other alias types, yet continue to read/write with the \"collection\" prefix in case we actually do add new types later?\n\t\toh... hey this method makes Aliases not immutable anymore.  Maybe change this to be something like cloneWithCollectionAliasMetadata?  Or we cold make immutable again but I admit Immutability is a nice property here.\n\t\n\t\n\tcloneWithCollectionAlias seems off; I don't think it should be using zkStateReader.  I think this method now needs a metadata map parameter (optional).  Furthermore, if we remove an alias, remove the corresponding metadata too.\n\n\n\nI see you moved some alias CRUD stuff to ZkStateReader.  Just curious; what drove that decision?\n\nTimeOut: do you envision other uses of this utility; what in particular? ",
            "author": "David Smiley",
            "id": "comment-16215845"
        },
        {
            "date": "2017-10-23T21:38:50+0000",
            "content": "BTW FWIW RE TimeOut... IMO it'd be more nice to have a static utility method named something like callWithRetry(long intervalSleep, long timeout, TimeUnit unit, Callable<V> callable) throws Exception ",
            "author": "David Smiley",
            "id": "comment-16215893"
        },
        {
            "date": "2017-10-24T03:03:49+0000",
            "content": "Thx for the review Dave. \n\nI'll start in on some of the fix-ups, here's some of the whys for what I did, I can probably be talked out of anything here, but this is what I was thinking... Let me know what you think.\n\nFix List\n\n\tWill add test for removal of alias case and fix it.\n\tdocs: yes of course good point \n\tnames: sure sounds fine \n\tI had initially started supporting lists and then decided to axe that until discussion. I will move back to <String,String> from <String,Object>..\n\n\n\n\n\nWarnings: this gets difficult because we don't really have type safety anymore... \n\nWe have a Map<String,X> with two keys \"collection\" and \"collection_metadata\" the values for these two keys don't match. The former is Map<String,String> and the later is a Map<String,Map<String,String>> String and Map are not convertible types so one use case or the other wont compile... unless you back off from type safety. To achieve type safety we either need to keep two separate maps or we need to be serializing an actual object hierarchy rather than collection classes.\n\n\n\nThe ZkStateReader field is necessary because we need to get the metadata back to zookeeper. Based on your earlier response we won't have a collections API call to set metadata, so we need to have a ZkStateReader somehow or nothing gets written to zookeeper. In the case of cloneWithCollectionAlias, yeah that can be eliminated there, good catch. I can add an overload for the signature you suggest as well for the case where both are to be updated at the same time, but WRT removing ZkStateReader entirely, see comments about immutability below... \n\n\n\nImmutability is nice of course, and great for things that are immutable, or only held for a short duration, but once you have a long held reference and the underlying data is actually mutable, it gets difficult to be sure nobody is retaining a reference a stale copy every time a change is made... A little digging reveals that CoreContainer has a ZkContainer which has a ZkController, which has a ZkStateReader, which therefore holds onto an immutable copy of Aliases for a difficult to determine time frame....\n\nThe existing cloning/immutability scheme therefore worries me. It seems like it would make more sense for Aliases to function as a wrapper around the (fundamentally mutable) json in zookeeper. If we never want to know if there was a change after we get our initial copy, and we never give away a reference to the copy we got, and we never retain that copy after we make an update we could have immutable copies... hard to make those stick however. It might be that we want a snapshot at the start of a request that doesn't change for the duration request (I can imagine that getting funky fast), but the long held versions need to be mutable I think... maybe a mutable super class and an immutable subclass that throws UnsupportedOperation on mutators?\n\n\n\nThe Collections.EMPTY_MAP came up because I can't put anything into an empty map, and need to test if that's what we currently have or if we have a regular map that I can add stuff to. Collections.emptyMap() is not required to return the same instance, or any particular implementation class, so in order to test for it and not be subject to breakage in odd VM's or future versions (or past versions?) I have to use the single unique instance in Collections.EMPTY_MAP. I've grown slightly unsure as to whether that if block is still necessary, a possible hold over from early versions of this code, so I might give a shot at eliminating it and go back to Collections.emptyMap().\n\n\n\nI moved CRUD stuff to ZkStateReader so I didn't have to duplicate it in Aliases to get metadata written back to zookeeper. Also it feels reasonable to have a ZK class doing the Zk CRUD rather than having that code live in a command class that grabs ZkClient from ZkStateReader and writes the data directly itself... (law of Demeter etc). This way, the command does command type stuff like identify the data to be written and validation to be sure we really do want to write the data and then hands the data off to the thing that knows how to work with zookeeper data so it can do the actual writing... Controller & service/DAO stuff. The present code seems like the controller/action in a web app firing up a JDBC connection directly...\n\n\n\nTimeOut... initially I was going to copy it over verbatim since it was in core and core is not available in solrj (when I moved the CRUD to ZkStateReader) and then I realized it could be improved so I improved it. I think perhaps this timeout and the one in Core could be reconciled and moved to a commonly available location to facilitate re-use, but that seems like a separate endeavor not part of this ticket. The previous checkForAlias() method was running a tight loop with no sleep inside the loop for up to 30 seconds (evidently waiting for another thread to call updateAliases() to replace our \"immutable\" aliases with a copy that had the alias that we were meant to add... This probably soaks up an entire processor core while we wait. Since the use case is to block the current thread until a condition is observed, an api that forces you to set a sleep delay seems beneficial.\n\nI could possibly also just write the poling loop directly without the timeout class... but I was just following from the code I had brought over from the command class in this case, perhaps a bit too blindly. ",
            "author": "Gus Heck",
            "id": "comment-16216223"
        },
        {
            "date": "2017-10-24T04:35:11+0000",
            "content": "Fantastic response to my code review by the way \n\nRE aliasMap: my suggestion was embarassing; of course the value side should now be what you have \u2013 just Map!\n\nBased on your earlier response we won't have a collections API call to set metadata\n\nWhat's this in reference to?  But you've got me thinking... what if this was a collection-or-alias metadata thing?  That sounds pretty useful/cool from a user/conceptual standpoint.  From a code details standpoint... maybe this would be no change \u2013 alias metadata goes in one place (aliases.json) whereas collections would theoretically have it in their state.json?  Any way I don't want to create extra work for hypothetical features that are not in scope.\n\nRE ZkStateReader field: Naturally we need to save the data in ZK but that doesn't require Aliases.java to have the field and it hurts immutability (more on that in a sec).  Couldn't ZkStateReader make this happen (Law of Demeter perhaps?)?\n\nRE immutability: I believe ZkStateReader is keeping the Aliases instance up to date via a ZK watcher... so if code doesn't hold a durable reference to Aliases (outside of ZkStateReader) then we're good?  DocCollection is immutable; I think it's consistent for Aliases to follow the same approach too; no?  I don't think we want to break with the trend here.  If it were mutable, the caller might not be sure when exactly the ZK interaction happens (hidden behind some innocent method call?).  I get this is a trade-off and you've articulated the other side well I think.\n\nRE Collections.EMPTY_MAP:  Okay.\n\nRE Aliases CRUD in ZkStateReader: I like it.\n\nRE TimeOut: nice catch on finding the hot loop!  I recommend not copying TimeOut; just add some utility method if wanted.  Classes add more conceptual complexity than a static method for a case like this IMO. ",
            "author": "David Smiley",
            "id": "comment-16216287"
        },
        {
            "date": "2017-10-30T03:47:28+0000",
            "content": "Attaching revised patch. \n\nHighlights:\n\n\tImmutability was restored\n\tAfter getting irritated with a number of issues caused by miss-matches between the Map<String,String> version of the aliaes and Map<String,List<String>> notions of aliases that were being kept, including a need to clone, tweak and re-clone to get the list version back in sync, I nixed the duplicated state, and made the method providing the Map<String,String> view construct that view on the fly. There is now only one canonical map, nothing to keep in sync, and it contains the List<String> values. I could be talked into flip flopping to keep comma strings and construct lists on the fly, but at the moment it all passes (and still writes comma strings to zookeeper). I don't think it matters much which way we do it.\n\tI fixed immutability leakage with the Map<String<List<String>> version where the Map was immutable, but the list elements were still mutable, and thus could be added/removed producing state (reflected in the original Alias instance) out of sync with the Map<String,String> version of aliases held in the \"collections\" key of the main aliasMap field. New code now provides Immutable map with immutable list values.\n\tTimeOut class removed, replaced with a OneTimeListener class that allows easy, temporary piggybacking on the AliasWatcher I extracted in the prior patch. This is coded in a way that if other watchers simply extend Observer they can also use this too. The net effect is rather than polling on a loop we wait on a countdown latch which is released after a timeout or if the watcher hears an update that passes a test (written by the implementor of the OneTimeListener). The listener is automatically removed on successful test or timeout. This means we don't evaluate the test condition any more times than aliases are updated. This could be more executions of the test condition if aliases were under heavy updates, but that seems like an oddball condition so this will probably result in many fewer tests. In any case it will be way less expensive than the hot loop.\n\n ",
            "author": "Gus Heck",
            "id": "comment-16224353"
        },
        {
            "date": "2017-10-30T19:39:04+0000",
            "content": "Aliases.java\n\n\tcloneAliases: you can probably reduce the LOC a lot here using Java 8 streams; see https://stackoverflow.com/a/28288729/92186 for similar code\n\tAFAICT you've changed the storage of the value side of the map of the \"collections\" key to be a List<String> instead of a String (comma delimited).  But since this map is serialized to JSON and back and stored in ZooKeeper, wouldn't this affect compatibility with aliases.json in existing setups?  We definitely don't want to break things.\n\tIt's a shame that getCollectionAliasMap and getCollectionAliasListMap are no longer simple getters (albeit with unmodifiable wrappers). I don't think the extra code & cost is worth true immutability.  This is internal code.  As a compromise, perhaps instead you might consider creating a view that splits the comma on the fly only when it's value is asked for?  See Guava Maps.transformValues().\n\n\n\nZkStateReader\n\n\tThe TODO in \"exportAliasToZk\" is a real concern; we don't want race conditions between various alias modifications to cause some to be overridden/ignored.  I think there are two parts to this: firstly use ZK versions when reading/writing aliases.json so that we overwrite the version we are expecting. This will mean putting the version number in Aliases (see DocCollection.zknodeversion for the same idea) whenever we read the aliases.  Also, if we do need to retry, that retry loop needs to incorporate fetching the aliases and doing the modification over again, rather than repeatedly trying in vain to save the serialized aliases from when it started.\n\tIn AliasWatcher, the LOG.debug should use \"{}\" template to avoid possible expensive aliases.toString()\n\tI very much like that you're removing the hot loop and thinking about creating abstractions/mechanisms to make it nicer.  But I admit the change here with Observer & Observable seem very odd to me.  IMO weird that ZkStateReader is an Observer (Observable seems more intuitive \u2013 it has state that can be observed) and likewise it's weird that a Watcher is Observable (wouldn't it fundamentally be an Observer?).  I think you're trying to chain some existing observable stuff which means the Watchers thus become Observable themselves... but I don't like the result even if it works.  Perhaps instead, you could have a Watcher subclass called ChainableWatcher, and thus remove the need for Observable/Observer altogether?  I don't know if it's that simple without trying to tackle it myself, but it's at least an idea.\n\n ",
            "author": "David Smiley",
            "id": "comment-16225618"
        },
        {
            "date": "2017-11-04T17:16:05+0000",
            "content": "I believe this patch addresses your concerns above, let me know what you think ",
            "author": "Gus Heck",
            "id": "comment-16239110"
        },
        {
            "date": "2017-11-06T15:05:13+0000",
            "content": "Aliases\n\n\tconstructor is confusing to me; you save aliasMap to a field and then swap with EMPTY_MAP if you can? Why not before? And maybe we can simply not bother with initializing the metadata map here... worry about that when we get/populate it. It'll probably simplify seeing that the get/set code for it in other methods will be correct since won't require assumptions about being initialized.\n\tin general... these changes invoke \"convertMapOfCommaDelimitedToMapOfList\" way more than before. It used to be only at Alias construction, now it's at every call to resolveAliases  and getCollectionAliasListMap.  Sorry but can we avoid that?  I think it's not a big deal to lazy split the value for the particular collection being requested, but doing so for all collections seems excessive to me.\n\tconvertMapOfCommaDelimitedToMapOfList: you've converted this to Java 8 streams which is fine.  However you've wrapped the result in new LinkedHashMap which actually doesn't retain the original order of the input since Collectors.toMap is going to use a HashMap inbetween.  toMap is overloaded with a Supplier<Map>; you can call that one suppling the LinkedHashMap.\n\tThe introduced use of a field priorChange Function seems really hokey; I sorta see what you're doing with it but I think we need to go about this in some other way.  It feels like too much of a wart on Aliases. Maybe we can chat about this on IRC.\n\n\n\nFrom a Solr API perspective, it seems we've forgotten to expose the read/write of metadata; no?    I feel badly I didn't recognize this earlier; it's obvious in retrospect.  When in Solr tests we can work directly with ZooKeeper and Solr's internals, it's easy to forget the need for a public API.\n\nZkStateReader\n\n\texportAliasToZk computes a new Aliases instance at the first line (Aliases.cloneWithCollectionAlias)  before calling exportAllAlias then checkForAlias, both of which have loops to do their jobs with retries / re-checking.  It's hard for me to see how this is correct... shouldn't Aliases.cloneWithCollectionAlias be called within a loop?\n\tnice use of aliasLock with wait & notifyAll\n\tminor: aliasWatcher & aliasLock fields should probably be adjacent to aliases.\n\n ",
            "author": "David Smiley",
            "id": "comment-16240417"
        },
        {
            "date": "2017-11-07T14:24:56+0000",
            "content": "Constructor - Yeah that can be simplified. Much of the code directly accesses the field, so I try to make it impossible to observe invalid state, but I haven't covered the EMPTY_MAP case it seems. It might be that the null checks are not actually necessary if I have actually provided this guarantee up front. \n\nMap Conversion - This is a result of my not caching/duplicating state. At one point I began to have issues (test failures) due to the cached state getting out of sync, and rather than continue to try to maintain that duplicated state I opted to remove the duplication. My dislike for the possibility of repeated splitting of the list was why I originally changed things such that the main map contained a list. As you pointed out that complicates serialization if we are to maintain the existing comma separated format. So we wind up with one of these three things, none of which I like:\n\n\n\tDuplicated state\n\tComplicated serialization\n\tRepeated splitting of the comma separated list.\n\n\n\nThis sort of conundrum is more or less why I had previously suggested we do the metadata via zk nodes and don't expand the complexity of aliases.json... Now that everything else is working it should be more tractable to push the duplication/caching back in than it was to maintain it while things were evolving so I can do that if you like, but basically we have to pay for the fact that we are clumping this into a single json file somewhere.\n\nconvertMap  - ah yes good catch thx.\n\npriorChange - The task of avoiding competition among unrelated nodes of aliases.json is complicated by the fact that the API allows several consecutive clones to be made before the result is given to zkStateReader.exportAllAliases (again, issues arising from to the \"one big json\" strategy). We could fix that in documentation, and/or set a package private flag that prevents further cloning until ZkStateReader has written the current changes... in that case we could possibly have a few fields that retained the previous change data as string data rather than a function closure. Not sure how fields containing strings and a flag is less hokey though, and the flag would technically break immutability.\n\nThink of it this way: The state in aliasMap is \"candidate\" state, and the chain of Function calls is an immutable change history that can be applied to a new value read from zk if needed. \n\nAPI - Yeah I had attempted to raise this issue above, but confusingly conflated it with the possibility of collection metadata earlier, you responded to the latter in the negative, and I took it to mean negative vs the former. Sorry for the confusing question. This can certainly be added \n\nZkStateReader - These loops perform different tasks, there are two steps here. \n\n\tensure the data we are sending includes the latest changes (exportAllAliases)\n\tensure (with timeout) that Zookeeper got the data we eventually decided to send.\n\n\n\nWe do in fact call clone in the first loop via the Function closure, if needed. The one you see in exportAliasToZk is just the initial attempt.\n\nField order - yup, agree.\n\nover all\nI am increasingly feeling like there's a lot of complication here that derives from our attempts to provide zookeeper like guarantees and prevent competition within a single json file. Can you perhaps elaborate on the bookkeeping that worries you and Noble Paul? Is it really heavier than what we have here? ",
            "author": "Gus Heck",
            "id": "comment-16242091"
        },
        {
            "date": "2017-11-07T15:52:03+0000",
            "content": "Decomposing aliases.json has pros/cons, but it won't remove the possibility of races between modifying some portion of the aliases state; it just makes it more rare.  So we still need to deal with races in code.... using a zkVersion with a retry and eventual timeout, etc.\n\nGood observation in \"Map Conversion\"; there is no perfect choice.  I suppose \"complicated serialization\" needn't be too bad? This would mean that a user-provided comma separated list might end up normalized according to the rules of StrUtils.splitSmart and reversed as StrUtils.join and that's probably okay.  So if a user strangely supplies \"\\f\\o\\o\" it will see \"foo\" back.\n\nI could take a stab at ZkStateReader loop/retry, and removing the Aliases.priorChange stuff.  I don't argue what you have now doesn't work, only that the particular arrangement is unclear. ",
            "author": "David Smiley",
            "id": "comment-16242236"
        },
        {
            "date": "2017-11-07T19:01:00+0000",
            "content": "Decomposing aliases.json has pros/cons, but it won't remove the possibility of races between modifying some portion of the aliases state; it just makes it more rare. So we still need to deal with races in code.... using a zkVersion with a retry and eventual timeout, etc.\n\nIf decomposed to the level of a metadata item (or whatever level at which we become ok with \"last one wins\") we do get rid of this because we are not trying to do optimistic concurrency, only ensure unrelated stuff is not wiped out. If no \"unrelated stuff\" is part of the update then this problem goes away. ",
            "author": "Gus Heck",
            "id": "comment-16242637"
        },
        {
            "date": "2017-11-07T20:30:08+0000",
            "content": "Added SOLR-11617 to track the creation of an API ",
            "author": "Gus Heck",
            "id": "comment-16242826"
        },
        {
            "date": "2017-11-07T21:34:01+0000",
            "content": "Patch addressing, constructor, convertMap, and field order comments. \n\nStill pending For this ticket:\n\n\tMap Conversion strategy - My next patch will move things to the simple internal model with more complicated serialization option. (2nd in the above list of 3 non-thrilling options).\n\tZkStateReader/Function - Dave investigating alternatives.\n\n\n ",
            "author": "Gus Heck",
            "id": "comment-16242925"
        },
        {
            "date": "2017-11-08T22:13:12+0000",
            "content": "Here's an updated patch.\n\n\tCreated an inner class ZkStateReader.AliasesManager this is itself the watcher and generally holds and manages the state.  All aliases related code/state in ZkStateReader is now organized together, some into the manager this class where appropriate.  Admittedly I didn't add a getter for this manager; perhaps it should be there as a matter of taste.\n\tMoved the zk version from the Aliases instance into the AliasesManager alongside the aliases instance.  While it was fine on Aliases, once I conceived of the design of an AliasesManager, it felt nicer to put it there and leave Aliases ignorant of such things.\n\tremoved the use of Function within Aliases.  Instead I'm using a UnaryOperator as a method param to AliasesManager.applyModificationAndExportToZk\n\tNo actual need anymore for wait/notifyAll or sleeping.  There should be no hot loop.  If there is a zk version conflict, it should retry immediately and usually succeed unless there is yet another conflict (which should eventually get resolved within reason).\n\tThe DeleteAliasCmd was missing from the last patch.\n\tAliases: some slight little changes in addition to removing zkVersion. Gus if you've been modifying it, you may want to compare.\n\n\n\nWe don't have a race-condition test between modifications to aliases.  Perhaps human peer-review is a substitute.  What do you think of these changes Gus Heck? ",
            "author": "David Smiley",
            "id": "comment-16244823"
        },
        {
            "date": "2017-11-09T16:01:49+0000",
            "content": "\n\tConsolidation of the alias related stuff in ZkStateReader is nice.\n\tI think the getter would be consistent and play nicer with IDE auto complete, but as you say, its more of a taste/style issue, not a material issue.\n\tThe use of UnaryOperator rather than Function<Aliases,Aliases> of course makes good sense\n\tI suspect in this patch the int version should also be volatile, but I haven't looked carefully enough to see if we have sufficient monitor locking to make that unnecessary yet...\n\tI don't like moving the version out of the Aliases object. The version in zk that this instance was derived from is information about the Aliases object and therefore should be a property of the object. I like it much better as an immutable property on Aliases that is set directly upon creation, and can be made accessible from the Aliases object (don't recall if I provided a getter in my patch but it should probably be there to support folks who are working with aliases and some other data in zk so they can know if changes to aliases.json have occurred). Future modifications to the code could more easily get the version out of sync this way by failing to update the field in AliasManager whereas having it as required in the constructor enforces and communicates the need to track the version.\n\tThis patch places the burden of coordinating a set of changes on the caller of the API instead of handling it transparently. This is reflected by line 111 in Test where you wrapped the previously independent clone operations in a single UnaryOperator, which basically redesigns the test such that it passes due to the special case in the test of consecutive invocations that are easily wrapped together. The present patch will require that UnaryOperation be used like a transaction wrapper whereas the previous patch tracked changes internally and then transparently re-applied them in the event of a conflict. This made series of changes transactional by default without any explicit coordination code on the caller's part, and thus somewhat fool proofed the usage of the API. If substantial logic is involved in calculating multiple pieces of metadata and/or a collection name and that logic that has to all be applied at the same time to ensure consistent information in zookeeper then ALL that logic has to be place inside the UnaryOperation. In the Prior patch it was sufficient to perform several clone operations and then exportToZk with no effect on the organization of the calling code. I feel this patch simplifies the current code by adding complexity to future code using the API.\n\tAliasIntegrationTest.test() seems to fail?\n\n ",
            "author": "Gus Heck",
            "id": "comment-16245905"
        },
        {
            "date": "2017-11-10T01:14:57+0000",
            "content": "\n\tThe zkVersion int need not be volatile because it is only ever read/written from within synchronized block.  Any way, if you want to try to put it back in Aliases, that's fine.  I found it a bit annoying to have Aliases with zkVersion yet also find a way to set it despite Aliases immutability.  Nothing that we can't figure out but it was that trip-up that led me to the path of zkVersion decoupled from the Aliases class.\n\tI introduced a bug causing the AliasIntegrationTest.test() failure.  ZkStateReader.createClusterStateWatchersAndUpdate should call refreshAliases with the field reference aliasesHolder instead of constructing a new instance.  This took a while to figure out; DEBUG logging (with additional log statements and references to \"this\" to get the object ID) proved indispensable. I think this bug would never have happened if the AliasesManager did not implement Watcher but instead had a newWatcher() method to return an anonymous instance.\n\tAt the end of CreateAliasCmd.call, I sadly think we need to put back the 100ms wait (I added more commentary below):\n\n    // Give other nodes a bit of time to see these changes. Solr is eventually consistent, so we expect other Solr nodes\n    // and even CloudSolrClient (ZkClientClusterStateProvider) to eventually become aware of the change.\n    Thread.sleep(100);\n\n\nIf we remove it with this new change for metadata, we might add more test instability (and it's already on fire) or increase the likelihood that some real code out there won't work. The caller should sleep perhaps but that's also sad.  I've been ruminating on this a bit and may file an issue with more specific ideas.\n\tin CollectionsHandler, LISTALIASES_OP (~line 480) add this line:\n\nzkStateReader.aliasesHolder.update(); // just in case there are changes being propagated through ZK\n\n\n\n ",
            "author": "David Smiley",
            "id": "comment-16246858"
        },
        {
            "date": "2017-11-12T23:12:43+0000",
            "content": "Patch providing List in Map java representation which was our lesser of 3 evils choice for comma-string-in-map vs list-in-map vs duplication and moving version back to alias. The last 2 comments you had are one liners but everything passes and runs fine without them. I actually am seeing almost 30-40% pass rate with many JVMS on the core tests, which is a lot better than it was a couple weeks ago. The good thing about that is the suites after core have been run some too without problems. I don't know that the sleep makes a difference, I'll leave it up to you.\n\nOne thing I noticed is that the retry for getting updates from Zk if the version is a hot loop, but it should never really loop more than once or twice unless there's a bug and we're not getting the updated data, or causing a write and incrementing the version before checking it again somehow... I had started putting in a backoff, but then had the thought that that really opens up vulnerability to a busy system where once it backs off it will never succeed...  see comment/code in ZkStateReader around L1495. ",
            "author": "Gus Heck",
            "id": "comment-16249008"
        },
        {
            "date": "2017-11-13T21:17:25+0000",
            "content": "Looks like we're finally super close!\n\nAliases:\n\n\tgood \u2013 all my feedback below is little stuff\n\tyou can use aliasMap.computeIfAbset to reduce the LOC\n\tmaybe use \"getZNodeVersion\" naming to be consistent with DocCollection\n\tresolveAliases: it has a null check here but I think it's not necessary; resolveAliasesGivenAliasMap handles this.\n\tgetCollectionAliasListMap seems to replace it's content with unmodifiable Lists each time it's called which I think is bad.  I suggest not wrapping the List<String> collection values in this method; instead we can do that on creation?  The outer unmodifiableMap call here is fine, however... again if we're going to do the unmodifiable list wrapping on creation, might as well do so for the map too?  BTW I'm fine with removing some or all of this immutable wrapping because this is internal code.  I tend to do this wrapping too but if it's painful (and it's painful here!) I'm not religious about it.\n\tI got what you were saying earlier in this issue about EMPTY_MAP but (thankfully) we're no longer doing instanceof equality with EMPTY_MAP so we can just not use EMPTY_MAP (directly) anymore; right?\n\tcloneCollectionMetadataMap: the outer recreation of the HashMap is pointless because you're ultimately overwriting the reference and replacing it.  You could keep the check for null but in that event, exit early with a new empty HashMap.\n\n\n\nZkStateReader:\n\n\tin IRC we spoke about removing the modification equality check in the loop of applyModificationAndExportToZk; did you change your mind?  I think it's fine either way FWIW.\n\n\n\nsee comment/code in ZkStateReader around L1495.\n\nYeah, if we can't save in a few tries (ZK BadVersionException each time), it's hard to believe trying again will be successful.  Either timeout or fix # retries; I don't care. Why did you add the sleep? ",
            "author": "David Smiley",
            "id": "comment-16250254"
        },
        {
            "date": "2017-11-15T01:30:28+0000",
            "content": "All good points, many of them bits that didn't get cleaned up as related code made them obsolete...\n.\n\n\tcomputeIfAbsent() - used it in the constructor, elsewhere we don't want to modify the map we are querying.\n\tgetZNodeVersion - \n\tresolveAliases -  That check was previously needed because a conversion to map of list from map of comma separated string and the method doing the conversion didn't like nulls. Now that that has gone away this can to.\n\tUnmodifiable lists - This thought had crossed my mind but I had a vague worry that making them unmodifiable from the start might cause issues and wanted to get the patch up so I didn't investigate, but I've found no support for my worries. Lists are now unmodifiable from the start. I very much prefer that they not be modifiable. If we are going to be immutable we should really be immutable so as not to trick someone later, be they internal or external.\n\tEMPTY_MAP -  Yup, now we can go back to Collections.emptyMap() \n\tcloneCollectionMetadataMap - \n\tArray.equals() - whoops, forgot to do that, thx.\n\tsleep(1) - that was my compromise such that the loop wasn't flaming hot, just very toasty. I took it out and now stop the loop with a different message if we have tried at least 5 times and failed vs timing out.\n\n ",
            "author": "Gus Heck",
            "id": "comment-16252802"
        },
        {
            "date": "2017-11-15T05:33:51+0000",
            "content": "This looks really good, I'll commit this with some very small tweaks tomorrow.\n\nBTW I don't think you get how to use Map.computeIfAbsent (as seen in Aliases constructor).  The idea is to simply return the new value from the lambda \u2013 no need to actually try to map.put(...) it; it's the job of the code behind computeIfAbsent to handle that.  The upshot is less code and can be more efficient as well if the Map impl natively implements it (most do).\n\nI noticed Aliases.cloneCollectionMap does not actually do a deep clone, despite its caller saying it shares nothing. ",
            "author": "David Smiley",
            "id": "comment-16252963"
        },
        {
            "date": "2017-11-15T17:34:51+0000",
            "content": "I admit I'm getting a bit obsessive over Aliases.java.  My problem, not yours.  Check out my latest version Gus; I hope you find my changes are improvements.\n\n\tDue to a bug, we weren't actually  keeping back-compat of the format of aliases.json. In toJSON, building the new map was fine but it ultimately used the original map to actually serialize.  Doh!  I added a test for this and fixed the bug.\n\tRefactored away the presence of the top level map \"aliasMap\" so that instead it's only used in toJSON & fromJSON.  Aliases now has two fields for both child maps on Aliases, both non-null.\n\tMoved the comma delimited parsing from Aliases constructor to fromJSON since that's where we expect it to be needed.\n\tAliases constructor is now trivial but its docs insist that it's callers ensure that deeply nested collections are unmodifiable.  So it's 3 callers now ensure that.\n\tless clone related method LOC; IMO it looks simpler.\n\tmore consistently used LinkedHashMap instead of HashMap (no big deal)\n\n\n\nNet change was around ~60 lines of fewer code with other misc things since the last patch.\n\nBTW I discovered Map.replaceAll which made it easy to replace deeply nested collections with unmodifiable ones ",
            "author": "David Smiley",
            "id": "comment-16253845"
        },
        {
            "date": "2017-11-16T17:46:28+0000",
            "content": "\n\tBug: heh, I almost wrote a test for that too... I clearly should have. Thx\n\tLove the elimination of the top map. definitely cleaner.\n\tLess Clone... yes you've done a nice job of actually cashing in on our immutability there. That's a very logical thing to do.\n\n\n\nOther stuff good too... Map.replaceAll()... cool! .\n\nAll looks good to me. Does look cleaner overall. One other really nice benefit here is by eliminating the top map we eliminated almost all the unchecked cast stuff, only 2 methods need it now, and the class level @SuppressWarnings can go away I think. ",
            "author": "Gus Heck",
            "id": "comment-16255683"
        },
        {
            "date": "2017-11-16T18:57:30+0000",
            "content": "Commit fd1820a430c321e6a2b2910004d7d2be60d3db4a in lucene-solr's branch refs/heads/master from David Smiley\n[ https://git-wip-us.apache.org/repos/asf?p=lucene-solr.git;h=fd1820a ]\n\nSOLR-11487: Collection Aliases may now have metadata ",
            "author": "ASF subversion and git services",
            "id": "comment-16255782"
        },
        {
            "date": "2017-11-16T18:59:20+0000",
            "content": "Commit 6d9f6cda1a0fa6a48e36a153f69a8aa2cfcd943f in lucene-solr's branch refs/heads/branch_7x from David Smiley\n[ https://git-wip-us.apache.org/repos/asf?p=lucene-solr.git;h=6d9f6cd ]\n\nSOLR-11487: Collection Aliases may now have metadata\n\n(cherry picked from commit fd1820a) ",
            "author": "ASF subversion and git services",
            "id": "comment-16255784"
        },
        {
            "date": "2017-11-16T19:00:55+0000",
            "content": "Finally committed!  Thanks for your work on this Gus and my endless code reviews  ",
            "author": "David Smiley",
            "id": "comment-16255787"
        },
        {
            "date": "2017-11-17T22:20:23+0000",
            "content": "Commit 51b2dea68e291141e2bfb98a2e07420a6b5869b2 in lucene-solr's branch refs/heads/master from David Smiley\n[ https://git-wip-us.apache.org/repos/asf?p=lucene-solr.git;h=51b2dea ]\n\nSOLR-11487: Put back sleep(100) in CreateAliasCmd.\nUpdate AliasIntegrationTest with some sleeps and use new alias names where\npossible to avoid eventual consistency challenges. ",
            "author": "ASF subversion and git services",
            "id": "comment-16257672"
        },
        {
            "date": "2017-11-17T22:21:44+0000",
            "content": "Commit 7c64847d80e1d6025822d991598711cba5ace123 in lucene-solr's branch refs/heads/branch_7x from David Smiley\n[ https://git-wip-us.apache.org/repos/asf?p=lucene-solr.git;h=7c64847 ]\n\nSOLR-11487: Put back sleep(100) in CreateAliasCmd.\nUpdate AliasIntegrationTest with some sleeps and use new alias names where\npossible to avoid eventual consistency challenges.\n\n(cherry picked from commit 51b2dea) ",
            "author": "ASF subversion and git services",
            "id": "comment-16257676"
        },
        {
            "date": "2018-04-11T19:43:44+0000",
            "content": "Hi David,\n\nI've added the fix version as 7.2 for this Jira for reference\n\n\u00a0\n\nWe recently had a user who ran into a race condition when updating aliases\u00a0on a Solr 5.x . Looking at master today it looks like we're dealing with race conditions and this comment confirms that we fixed it as part of this Jira\u00a0\n\n\u00a0\nDecomposing aliases.json has pros/cons, but it won't remove the possibility of races between modifying some portion of the aliases state; it just makes it more rare. So we still need to deal with races in code.... using a zkVersion with a retry and eventual timeout, etc. ",
            "author": "Varun Thacker",
            "id": "comment-16434467"
        },
        {
            "date": "2018-04-12T14:22:09+0000",
            "content": "Decomposing aliases.json has pros/cons, but it won't remove the possibility of races between modifying some portion of the aliases state; it just makes it more rare. So we still need to deal with races in code.... using a zkVersion with a retry and eventual timeout, etc.\nThe context of the above comment was a discussion where I was suggesting an alternate storage for the alias metadata (properties). I was proposing a different style of storing the data (in zk nodes, not as part of aliases.json). This idea was deemed too costly in terms of \"bookkeeping\" and dropped. Existing behavior was retained, and nowhere was there an intent in this ticket to change the existing behavior with respect to updating aliases. Before and after this ticket, an update to an alias should have detected prior update to any part of aliases.json (version change), reloaded state and retried. There is a limit on the retry loop.\n\nSo it depends on what your user means by \"running into a race condition...\"\n\n\tIf writing one alias lost an update to a different alias, that would be a bug.\n\tIf two updates to the same alias are racing, that's a \"feature.\" and is documented\u00a0the first\u00a0paragraph of the ref guide docs for CREATEALIAS.\n\tIf the retries were exceeded and the second update eventually returns an error, that's a feature, and something is causing a\u00a0LOT of churn in aliases.json. The retry limit is set high to accommodate a fairly aggressive unit test I wrote. See\u00a0org.apache.solr.common.cloud.ZkStateReader.AliasesManager#applyModificationAndExportToZk for details.\n\n\n\nMuch\u00a0cleanup was done in this code so if there was a bug with one alias interfering with another it may well have been eliminated but this should be tested since it was not the focus of our work.\u00a0 ",
            "author": "Gus Heck",
            "id": "comment-16435662"
        }
    ]
}