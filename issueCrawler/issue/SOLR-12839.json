{
    "id": "SOLR-12839",
    "title": "add a 'prelim_sort' option to JSON faceting",
    "details": {
        "type": "Improvement",
        "status": "Resolved",
        "labels": "",
        "fix_versions": [
            "master (8.0)",
            "7.7"
        ],
        "components": [
            "Facet Module"
        ],
        "priority": "Major",
        "resolution": "Fixed",
        "affect_versions": "None"
    },
    "description": "As discusssed in SOLR-9480 ...\n\nSimilar to how the rerank request param allows people to collect & score documents using a \"cheap\" query, and then re-score the top N using a ore expensive query, I think it would be handy if JSON Facets supported a resort option that could be used on any FacetRequestSorted instance right along side the sort param, using the same JSON syntax, so that clients could have Solr internaly sort all the facet buckets by something simple (like count) and then \"Re-Sort\" the top N=limit (or maybe ( N=limit+overrequest ?) using a more expensive function like skg()",
    "attachments": {
        "SOLR-12839.patch": "https://issues.apache.org/jira/secure/attachment/12942767/SOLR-12839.patch"
    },
    "issue_links": {},
    "comments": [
        {
            "id": "comment-16641312",
            "content": "I've started looking into this, and i think it's a very viable idea.\n\nIronically this is something that's fairly trivial to implement in the SolrCloud situation because of existing division in labor between the FacetFieldProcessor handling the shard requests (which only needs to worry about sort), and the FacetFieldMerger (which looks at sort during phase#1 and then the resort after refinement). In the single node Solr situation, things are actaully much more complex because of how the SlotAcc(umulators) are used and collection of (non-sort) stats is defered until final buckets have been determined.\n\nThe attached patch includes a \"complete\" cloud solution with lots of tests, and a straw man implemention for single node solr that isn't very good \u2013 it completely fails in the case of resorting on non-trivial stats (like relatedness() or percentiles() , which defeats the whole point \u2013 but was a good starting point for writing tests and to help me understand why i was initially struggling to have a simple impl using the SlotAcc's directly.\n\nThe syntax is pretty simple, just a new resort option that uses the same syntax as the sort param...\n\njson.facet={\n  categories : {\n    type : terms,\n    field : cat,\n    limit : 5,\n    sort : \"count desc\",\n    resort : \"consumer_value desc\",\n    facet : { consumer_value : \"sum(div(popularity,price))\" }\n  }\n}\n\n\n\n...the semantics are conceptually straightforward:\n\n\toverrequest + (effective) limit is used to pick the initial buckets to consier acording to sort\n\t\n\t\tpatch modifies the single-node solr case to respect explicit overrequest if resort is used\n\t\tstill no implicit default overrequest for single-node even if resort is used\n\t\n\t\n\tonce initial buckets are selected (and refined), resort is used to pick the final top buckets\n\n\n\nMy plan is to try and move forward w/fixing the single node model per the rough game plan noted in the comments, unless people have any concerns about the overall concept/API/approach. ",
            "author": "Hoss Man",
            "date": "2018-10-08T03:23:54+0000"
        },
        {
            "id": "comment-16648144",
            "content": "Updated patch with a \"real\" implementation of resort for single node solr instances, and some more tests i wrote along the way.\n\nstill some nocommits \u2013 mostly involving additional tests we need, and a few places where i think the code can be cleaned up \u2013 but i wanted to get this posted ASAP in case people want to try it out ... i probably won't have time to work on this again for at least a week. ",
            "author": "Hoss Man",
            "date": "2018-10-12T17:08:25+0000"
        },
        {
            "id": "comment-16648773",
            "content": "\n\n\n  -1 overall \n\n\n\n\n\n\n\n\n\n Vote \n Subsystem \n Runtime \n Comment \n\n\n\u00a0\n\u00a0\n\u00a0\n  Prechecks  \n\n\n +1 \n  test4tests  \n   0m  0s \n  The patch appears to include 4 new or modified test files.  \n\n\n\u00a0\n\u00a0\n\u00a0\n  master Compile Tests  \n\n\n +1 \n  compile  \n   2m 21s \n  master passed  \n\n\n\u00a0\n\u00a0\n\u00a0\n  Patch Compile Tests  \n\n\n +1 \n  compile  \n   3m  5s \n  the patch passed  \n\n\n +1 \n  javac  \n   3m  5s \n  the patch passed  \n\n\n +1 \n  Release audit (RAT)  \n   3m  5s \n  the patch passed  \n\n\n +1 \n  Check forbidden APIs  \n   3m  5s \n  the patch passed  \n\n\n -1 \n  Validate source patterns  \n   3m  5s \n  Validate source patterns validate-source-patterns failed  \n\n\n\u00a0\n\u00a0\n\u00a0\n  Other Tests  \n\n\n +1 \n  unit  \n  85m  0s \n  core in the patch passed.  \n\n\n  \n   \n  95m 35s \n   \n\n\n\n\n\n\n\n\n\n Subsystem \n Report/Notes \n\n\n JIRA Issue \n SOLR-12839 \n\n\n JIRA Patch URL \n https://issues.apache.org/jira/secure/attachment/12943677/SOLR-12839.patch \n\n\n Optional Tests \n  compile  javac  unit  ratsources  checkforbiddenapis  validatesourcepatterns  \n\n\n uname \n Linux lucene2-us-west.apache.org 4.4.0-112-generic #135-Ubuntu SMP Fri Jan 19 11:48:36 UTC 2018 x86_64 x86_64 x86_64 GNU/Linux \n\n\n Build tool \n ant \n\n\n Personality \n /home/jenkins/jenkins-slave/workspace/PreCommit-SOLR-Build/sourcedir/dev-tools/test-patch/lucene-solr-yetus-personality.sh \n\n\n git revision \n master / 9c8ffab \n\n\n ant \n version: Apache Ant(TM) version 1.9.6 compiled on July 20 2018 \n\n\n Default Java \n 1.8.0_172 \n\n\n Validate source patterns \n https://builds.apache.org/job/PreCommit-SOLR-Build/198/artifact/out/patch-validate-source-patterns-root.txt \n\n\n  Test Results \n https://builds.apache.org/job/PreCommit-SOLR-Build/198/testReport/ \n\n\n modules \n C: solr/core U: solr/core \n\n\n Console output \n https://builds.apache.org/job/PreCommit-SOLR-Build/198/console \n\n\n Powered by \n Apache Yetus 0.7.0   http://yetus.apache.org \n\n\n\n\n\n\nThis message was automatically generated.\n ",
            "author": "Lucene/Solr QA",
            "date": "2018-10-13T06:30:21+0000"
        },
        {
            "id": "comment-16649244",
            "content": "We should perhaps think about how to extend to N sorts instead of 2.\nAlso keeping in mind that sort should be able to have tiebreaks someday.\n\nBrainstorming syntax:\nMaybe just append a number to our existing sort syntax, so we would get something like \"foo desc, bar asc 50\" (bar would be a tiebreak in this case)\nSo two resorts in a row could be\n  \"field1 asc 100; field2 desc 10\" or a slightly more decomposed array [\"field1 asc 100\",\"field2 desc 10\"]\nOr given that this is just an extension of the sort syntax, it could even just go in the \"sort\" param itself and not bother with \"resort\"\nsort:\"count desc 5\" could be a synonym for sort:\"count desc\",limit:5\n\nIt's late and my slides for Activate aren't done.... take it for what it's worth  ",
            "author": "Yonik Seeley",
            "date": "2018-10-14T04:00:13+0000"
        },
        {
            "id": "comment-16649265",
            "content": "We should perhaps think about how to extend to N sorts instead of 2.\nI'm confused ... why/how/when would it make sense to resort multiple times? Do you have an example of what you have in mind?\n\nMy usecase/idea here is directly analogous to the \"rerank\" concept of queries and sorting (docs) by score: start with a \"simple\" query/sort when doing the first pass to find matches/buckets, then \"rerank/resort only the topN on a more complex query/function that you don't want to compute against every doc/bucket.\n\nI can't really think of a situation where it would would be useful to resort buckets more then once \u2013 or how it could work practically given the 2 phrase nature of distributed facet refinement. (as long as we only do 2 phrases, it seems like it would just be wasted cycles to do anything but the first and last sort?)\nMaybe just append a number to our existing sort syntax, so we would get something like \"foo desc, bar asc 50\" (bar would be a tiebreak in this case)\nI'm not really understanding what you're suggestion ... can you elaborate on what would happen in that example? if \"foo desc\" is the primary sort, and \"bar asc\" is the tiebreaker, then what is being resorted on? and where does the \"50\" in your example come into play,? (is that suppose to be how many of the top buckets we want to resort? the rerank parser has a reRankDocs local param but i didn't really see much point in having that concept for facet resorting since the shards will have already computed all the stat values for all the buckets once they've been refined, and so why bother artificially limiting the number of buckets being considered for resorting beyond that?)\nAlso keeping in mind that sort should be able to have tiebreaks someday.\n...\nOr given that this is just an extension of the sort syntax, it could even just go in the \"sort\" param itself and not bother with \"resort\"\nI briefly considered adding resorting as a new option to the sort syntax, but quickly dismissed it for the precise reason that you mention: i expect the sort option to get more robust, and supporting secondary, tertiary, etc... tie breakers - so trying to shoe horn resorting into it as well seemed like a bad idea (plus i wanted to ensure that whatever features were added to the sort syntax down the road \u2013 tie breakers, etc... \u2013 would also be supported for resorting as well.) ",
            "author": "Hoss Man",
            "date": "2018-10-14T05:20:20+0000"
        },
        {
            "id": "comment-16649387",
            "content": "\u00a0if \"foo desc\" is the primary sort, and \"bar asc\" is the tiebreaker, then what is being resorted on?\n\n\u00a0\"foo desc, bar asc 50\" was an example of a single sort with tiebreak and a limit (no resort).\nIf one wanted a single string version \";\" would be the divider.\u00a0 For example adding a resort with a tiebreak:\u00a0\"foo desc, bar asc 50; baz desc, qux asc 10\"\n\nwhy/how/when would it make sense to resort multiple times?\nIf there are use cases for starting with N sorted things and reducing that to K with a different sort, then it's just sort of recursive.  Why would there be use cases for one resort and not two resorts?\n\nOne use case that comes to mind are stock screens I've seen that consist of multiple sorting and \"take top N\" steps.\nExample: Sort by current dividend yield and take the top 100, then sort those by low PE and take the top 50, then sort those by total return 1 year and take the top 10.\n\nor how it could work practically given the 2 phrase nature of distributed facet refinement.\n\nHmm, good point.  Over the long term I'd always imagined the number of phases could be variable, so It's more of a current implementation detail (albeit a very major one).  It would currently kill the usefulness in distributed though.  \nAnyway we don't have to worry about multiple resorts now as long as we can unambiguously upgrade if desired later (i.e. whatever the resort spec looks like, if we can unambiguously wrap an array around it later and specify multiple of them, then we're good) ",
            "author": "Yonik Seeley",
            "date": "2018-10-14T13:44:09+0000"
        },
        {
            "id": "comment-16659854",
            "content": "\"foo desc, bar asc 50\" was an example of a single sort with tiebreak and a limit (no resort). If one wanted a single string version \";\" would be the divider. For example adding a resort with a tiebreak: \"foo desc, bar asc 50; baz desc, qux asc 10\"\nOk ... i realize now that you were discussing 2 diff ideas and giving 2 diff examples and i was conflating them \u2013 but i'm still not certain what you're saying the behavior of these examples would be, particulalry because (independent of the idea of resorting AND independent of the idea of supporting tiebreakers on sort/resort syntax) you ALSO seem to be suggesting a numeric \"limit\" that would be inlined as part of the sort/resort syntax \u2013 and this confuses me in 2 orthoginal ways:\n\n\tare you suggesting this would be an alternative for the existing limit param on these facets?\n\t\n\t\tif so, what would be behavior if someone tired to do both? use the \"inline limit\" and use a \"limit\" param?\n\t\tif not, then what do you mean by \"limit\" in the above sentence?\n\t\n\t\n\tassuming you did mean as a replacement/override of the existing limit param, i don't understand your example and what the value add of asking solr to resort the \"top 10\" by criteria \"baz desc, qux asc\" if we're already returning the \"top 50\"\n\n\n\nIf there are use cases for starting with N sorted things and reducing that to K with a different sort, then it's just sort of recursive. Why would there be use cases for one resort and not two resorts?\n ...\n One use case that comes to mind are stock screens I've seen that consist of multiple sorting and \"take top N\" steps.\n\nExample: Sort by current dividend yield and take the top 100, then sort those by low PE and take the top 50, then sort those by total return 1 year and take the top 10.\n...again: if this is a situation where solr is returning the top 100 buckets, what's the value add in having solr resort the top 50 (and then the top 10 again) instead of just letting the client manipulate & re-order those same buckets?\n\nI feel like maybe there is a disconnect in the principle of the ideas we are discussing?\n\nAs I mentioned when i created this issue, the overall goal i'm trying to address is to mirror the concept of the \"reranking query\" at a facet bucket level ... for addressing the performance cost of sorting by something complex/expensive.\n\n\tToday you can ask solr:\n\t\n\t\tCompute expensive_function() for every bucket that exists, and sort all the buckets by that function \u2013 then return the top $limit buckets\"\n\t\n\t\n\tI want to be able to tell solr:\n\t\n\t\t\"Compute cheaper_aproximation_of_expensive_function() for every bucket that exists, sort all the buckets by that function, and compute expensive_function() only for the top candidate buckets \u2013 then (once refinement/merging is complete) resort just the fully populated buckets by expensive_function()\n\t\n\t\n\n\n\n...note in particular that I'm not even suggesting any sort of new resort_limit option or any hard and fast guarantees on the number of buckets that are \"resorted\" \u2013 just a way to tell solr \"during the first pass, you can use this cheap function instead of the final expensive function i really care about\" ... in essence just a \"performance hint\" or \"save some CPU cycles\" type feature\n\nWhat you're describing on the other hand seems to be more akin to a \"i want specific operations to be performed on my buckets\" type feature ... the examples you're describing sound almost like a subset of a more robust scripting type functionality, or at the very least a multi stage \"post processing\" that might include filtering or collapsing of buckets?\n\n...Lemme come back to this conceptual disconnect in a minute...\n\nAnyway we don't have to worry about multiple resorts now as long as we can unambiguously upgrade if desired later (i.e. whatever the resort spec looks like, if we can unambiguously wrap an array around it later and specify multiple of them, then we're good)\nright ... but if you're trying to future proof the API, there's also the question of \"tiebreakers\" look like when using the (existing) JSON object syntax for sorting instead of just the shorthand string syntax.\n\nie, if you completely ignore the concept of \"resorting\", today we support this...\n\njson.facet={\n  categories : {\n    type : terms,\n    field : cat,\n    limit : 5,\n    facet : { x : \"sum(div(popularity,price))\" },\n    // can use short hand of \"x desc\"\n    sort : { x : desc }, \n  }\n}\n\n\n...and if you assume you want to have multiple tiebreaker sorts then that would be something like...\n\njson.facet={\n  categories : {\n    type : terms,\n    field : cat,\n    limit : 5,\n    facet : { x : \"sum(div(popularity,price))\" },\n    // can use short hand of \"x desc, count desc\"\n    sort : [{ x : desc },\n            { count : desc }], \n  }\n}\n\n\n...so in a hypothetical future world were you can have multiple \"resort\" options, each of which can be arrays of sort criteria JSON objects (which may or may not have their own \"intermediate limits\") then we have to imagine what we might want that to look like?\n\n...revisiting the conceptual disconnect I mentioned above: Let's assume (since you've clearly already thought about it) that somewhere down the road we definitely do want more robust options for resorting/filtering/reducing buckets, then maybe the best way to more forward now with a short term improvement for the sorting/resorting on an expensive_function() vs cheaper_aproximation_of_expensive_function() performance hint/optimization \u2013 in a way that wouldn't hinder us down the road with more full featured bucket processing \u2013 would be to \"invert\" the API i proposed/implemented and renamed the option...\n\n\tinstead of adding a resort option, add an approximate_sort option and flip the meaning from what i was originally thinking...\n\njson.facet={\n  categories : {\n    type : terms,\n    field : cat,\n    limit : 5,\n    sort : \"consumer_value desc\",\n    approximate_sort : \"count desc\",\n    facet : { consumer_value : \"sum(div(popularity,price))\" }\n  }\n}\n\n\n\n\n\n\n\tinstead of using sort in phase#1, and resorting on the resort option after merging, we would use approximate_sort in phase#1, and sort in phase#2\n\tfrom an end user perspective sort is the most important thing:\n\t\n\t\tthe buckets to be returned will be in sort order\n\t\tapproximate_sort is an expert level option only used as an inexpensive approximation when picking the buckets to be returned, where the exact number of buckets considered in this way is essentially an implementation detail\n\t\n\t\n\tdown the road, when we add \"tiebreaker\" support to \"sort type options\", it should be fairly trivial to support it for both options (with some generalization of the helper methods added in the patch)\n\tfarther down the road, if we want a more robust \"sort, resort, process, filter the buckets returned\" type option/syntax to replace the sort param \u2013 then we can add that independent of the approximate_sort option, and approximate_sort can still be used as a way to indicate an \"inexpensive\" way to initially rank the buckets to consider before any of that new functionality.\n\n\n\nWDYT? ",
            "author": "Hoss Man",
            "date": "2018-10-22T23:57:34+0000"
        },
        {
            "id": "comment-16661582",
            "content": "patch updated to finish filling in the tests i wanted, and a fix forsome problems found with resorting when using 'allBuckets' that i found as a result ... this actaully simplifies the number of places in the code that need to care about resorting.\n\n\u00a0\n\nNOTE: this updated doesn't make any of the API/semantic changes i mentioned in my last comment (ie: still using \"sort -> resort\" not \"approximate_sort -> sort\") ... still waiting on feedback for that idea before diving in. ",
            "author": "Hoss Man",
            "date": "2018-10-24T01:49:56+0000"
        },
        {
            "id": "comment-16662398",
            "content": "\n\n\n  -1 overall \n\n\n\n\n\n\n\n\n\n Vote \n Subsystem \n Runtime \n Comment \n\n\n\u00a0\n\u00a0\n\u00a0\n  Prechecks  \n\n\n +1 \n  test4tests  \n   0m  0s \n  The patch appears to include 4 new or modified test files.  \n\n\n\u00a0\n\u00a0\n\u00a0\n  master Compile Tests  \n\n\n +1 \n  compile  \n   3m 32s \n  master passed  \n\n\n\u00a0\n\u00a0\n\u00a0\n  Patch Compile Tests  \n\n\n +1 \n  compile  \n   3m 46s \n  the patch passed  \n\n\n +1 \n  javac  \n   3m 46s \n  the patch passed  \n\n\n +1 \n  Release audit (RAT)  \n   3m 46s \n  the patch passed  \n\n\n +1 \n  Check forbidden APIs  \n   3m 46s \n  the patch passed  \n\n\n -1 \n  Validate source patterns  \n   3m 47s \n  Validate source patterns validate-source-patterns failed  \n\n\n\u00a0\n\u00a0\n\u00a0\n  Other Tests  \n\n\n -1 \n  unit  \n  82m 56s \n  core in the patch failed.  \n\n\n  \n   \n  93m 44s \n   \n\n\n\n\n\n\n\n\n\n Reason \n Tests \n\n\n Failed junit tests \n solr.search.QueryEqualityTest \n\n\n\n\n\n\n\n\n\n Subsystem \n Report/Notes \n\n\n JIRA Issue \n SOLR-12839 \n\n\n JIRA Patch URL \n https://issues.apache.org/jira/secure/attachment/12945318/SOLR-12839.patch \n\n\n Optional Tests \n  compile  javac  unit  ratsources  checkforbiddenapis  validatesourcepatterns  \n\n\n uname \n Linux lucene2-us-west.apache.org 4.4.0-112-generic #135-Ubuntu SMP Fri Jan 19 11:48:36 UTC 2018 x86_64 x86_64 x86_64 GNU/Linux \n\n\n Build tool \n ant \n\n\n Personality \n /home/jenkins/jenkins-slave/workspace/PreCommit-SOLR-Build/sourcedir/dev-tools/test-patch/lucene-solr-yetus-personality.sh \n\n\n git revision \n master / e083b15 \n\n\n ant \n version: Apache Ant(TM) version 1.9.6 compiled on July 20 2018 \n\n\n Default Java \n 1.8.0_172 \n\n\n Validate source patterns \n https://builds.apache.org/job/PreCommit-SOLR-Build/211/artifact/out/patch-validate-source-patterns-root.txt \n\n\n unit \n https://builds.apache.org/job/PreCommit-SOLR-Build/211/artifact/out/patch-unit-solr_core.txt \n\n\n  Test Results \n https://builds.apache.org/job/PreCommit-SOLR-Build/211/testReport/ \n\n\n modules \n C: solr/core U: solr/core \n\n\n Console output \n https://builds.apache.org/job/PreCommit-SOLR-Build/211/console \n\n\n Powered by \n Apache Yetus 0.7.0   http://yetus.apache.org \n\n\n\n\n\n\nThis message was automatically generated.\n ",
            "author": "Lucene/Solr QA",
            "date": "2018-10-24T15:05:34+0000"
        },
        {
            "id": "comment-16699252",
            "content": "Pinging Yonik Seeley \u2013 any thoughts/objections to the idea i mentioned on Oct 22 ...\n... maybe the best way to more forward now with a short term improvement for the sorting/resorting on an expensive_function() vs cheaper_aproximation_of_expensive_function() performance hint/optimization \u2013 in a way that wouldn't hinder us down the road with more full featured bucket processing \u2013 would be to \"invert\" the API i proposed/implemented and renamed the option...\n\n\tinstead of adding a resort option, add an approximate_sort option and flip the meaning from what i was originally thinking...\n\njson.facet={\n  categories : {\n    type : terms,\n    field : cat,\n    limit : 5,\n    sort : \"consumer_value desc\",\n    approximate_sort : \"count desc\",\n    facet : { consumer_value : \"sum(div(popularity,price))\" }\n  }\n}\n\n\n\n\n\n\n\tinstead of using sort in phase#1, and resorting on the resort option after merging, we would use approximate_sort in phase#1, and sort in phase#2\n\tfrom an end user perspective sort is the most important thing:\n\t\n\t\tthe buckets to be returned will be in sort order\n\t\tapproximate_sort is an expert level option only used as an inexpensive approximation when picking the buckets to be returned, where the exact number of buckets considered in this way is essentially an implementation detail\n\t\n\t\n\tdown the road, when we add \"tiebreaker\" support to \"sort type options\", it should be fairly trivial to support it for both options (with some generalization of the helper methods added in the patch)\n\tfarther down the road, if we want a more robust \"sort, resort, process, filter the buckets returned\" type option/syntax to replace the sort param \u2013 then we can add that independent of the approximate_sort option, and approximate_sort can still be used as a way to indicate an \"inexpensive\" way to initially rank the buckets to consider before any of that new functionality.\n\n\n...this would be a fairly meaty re-working of the existing patch i've got in progress (sort->approx_sort, resort->sort, & flipping the syntax in all the test queries) so i'd rather not bite it off if it's something you have objections to in principle. ",
            "author": "Hoss Man",
            "date": "2018-11-26T16:37:15+0000"
        },
        {
            "id": "comment-16703900",
            "content": "\nI've updated the patch to use prelim_sort as the new param name \u2013 not quite as unweildy as approximate_sort but still long enough to not be \"common\" and indicitive of something advanced/expert.  (While also leaving the door open for using the concept of \"resorting\" and/or beefing up the sort syntax) for the future\n\nHere's the syntax/example I used in the ref guide updates...\n\n\n{\n  categories:{\n    type : terms,\n    field : cat,\n    refine: true,\n    limit: 10,\n    overrequest: 100,\n    prelim_sort: \"sales_rank desc\",\n    sort : \"prod_quality desc\",\n    facet : {\n      prod_quality : \"avg(div(prod(rating,sales_rank),prod(num_returns,price)))\"\n      sales_rank : \"sum(sales_rank)\"\n    }\n  }\n}\n\n\n\nI think this is ready to commit unless anyone has any objections. ",
            "author": "Hoss Man",
            "date": "2018-11-29T22:21:19+0000"
        },
        {
            "id": "comment-16705018",
            "content": "\n\n\n  +1 overall \n\n\n\n\n\n\n\n\n\n Vote \n Subsystem \n Runtime \n Comment \n\n\n\u00a0\n\u00a0\n\u00a0\n  Prechecks  \n\n\n +1 \n  test4tests  \n   0m  0s \n  The patch appears to include 4 new or modified test files.  \n\n\n\u00a0\n\u00a0\n\u00a0\n  master Compile Tests  \n\n\n +1 \n  compile  \n   1m 40s \n  master passed  \n\n\n\u00a0\n\u00a0\n\u00a0\n  Patch Compile Tests  \n\n\n +1 \n  compile  \n   1m 37s \n  the patch passed  \n\n\n +1 \n  javac  \n   1m 37s \n  the patch passed  \n\n\n +1 \n  Release audit (RAT)  \n   1m 43s \n  the patch passed  \n\n\n +1 \n  Check forbidden APIs  \n   1m 37s \n  the patch passed  \n\n\n +1 \n  Validate source patterns  \n   1m 37s \n  the patch passed  \n\n\n +1 \n  Validate ref guide  \n   1m 37s \n  the patch passed  \n\n\n\u00a0\n\u00a0\n\u00a0\n  Other Tests  \n\n\n +1 \n  unit  \n  35m 57s \n  core in the patch passed.  \n\n\n  \n   \n  42m 56s \n   \n\n\n\n\n\n\n\n\n\n Subsystem \n Report/Notes \n\n\n JIRA Issue \n SOLR-12839 \n\n\n JIRA Patch URL \n https://issues.apache.org/jira/secure/attachment/12950083/SOLR-12839.patch \n\n\n Optional Tests \n  compile  javac  unit  ratsources  checkforbiddenapis  validatesourcepatterns  validaterefguide  \n\n\n uname \n Linux lucene1-us-west 4.4.0-137-generic #163~14.04.1-Ubuntu SMP Mon Sep 24 17:14:57 UTC 2018 x86_64 x86_64 x86_64 GNU/Linux \n\n\n Build tool \n ant \n\n\n Personality \n /home/jenkins/jenkins-slave/workspace/PreCommit-SOLR-Build/sourcedir/dev-tools/test-patch/lucene-solr-yetus-personality.sh \n\n\n git revision \n master / 0491623 \n\n\n ant \n version: Apache Ant(TM) version 1.9.3 compiled on July 24 2018 \n\n\n Default Java \n 1.8.0_191 \n\n\n  Test Results \n https://builds.apache.org/job/PreCommit-SOLR-Build/237/testReport/ \n\n\n modules \n C: solr/core solr/solr-ref-guide U: solr \n\n\n Console output \n https://builds.apache.org/job/PreCommit-SOLR-Build/237/console \n\n\n Powered by \n Apache Yetus 0.7.0   http://yetus.apache.org \n\n\n\n\n\n\nThis message was automatically generated.\n ",
            "author": "Lucene/Solr QA",
            "date": "2018-11-30T16:53:46+0000"
        },
        {
            "id": "comment-16705178",
            "content": "Yeah, I think this is OK - my main objection was going to be the name \"approximate\" which highly suggests that an estimate is fine. \"prelim_sort\" seems fine. ",
            "author": "Yonik Seeley",
            "date": "2018-11-30T19:07:59+0000"
        },
        {
            "id": "comment-16705385",
            "content": "Commit 5763d8b194009cdf602e983d56115be9480f69b8 in lucene-solr's branch refs/heads/branch_7x from Chris Hostetter\n[ https://git-wip-us.apache.org/repos/asf?p=lucene-solr.git;h=5763d8b ]\n\nSOLR-12839: JSON 'terms' Faceting now supports a 'prelim_sort' option to use when initially selecting the top ranking buckets, prior to the final 'sort' option used after refinement.\n\n(cherry picked from commit 5dc988f5eeff78464d852f54ce7f06a801dcbfee)\n\nConflicts:\n\tsolr/CHANGES.txt ",
            "author": "ASF subversion and git services",
            "date": "2018-11-30T22:58:53+0000"
        },
        {
            "id": "comment-16705386",
            "content": "Commit 5dc988f5eeff78464d852f54ce7f06a801dcbfee in lucene-solr's branch refs/heads/master from Chris Hostetter\n[ https://git-wip-us.apache.org/repos/asf?p=lucene-solr.git;h=5dc988f ]\n\nSOLR-12839: JSON 'terms' Faceting now supports a 'prelim_sort' option to use when initially selecting the top ranking buckets, prior to the final 'sort' option used after refinement. ",
            "author": "ASF subversion and git services",
            "date": "2018-11-30T22:58:54+0000"
        },
        {
            "id": "comment-16705390",
            "content": "my main objection was going to be the name \"approximate\" which highly suggests that an estimate is fine. \"prelim_sort\" seems fine.\n+1 ... i hadn't considered that.\u00a0 I'm glad i disliked it for other reasons ",
            "author": "Hoss Man",
            "date": "2018-11-30T23:01:09+0000"
        },
        {
            "id": "comment-16705920",
            "content": "Commit 5dc988f5eeff78464d852f54ce7f06a801dcbfee in lucene-solr's branch refs/heads/jira/http2 from Chris Hostetter\n[ https://git-wip-us.apache.org/repos/asf?p=lucene-solr.git;h=5dc988f ]\n\nSOLR-12839: JSON 'terms' Faceting now supports a 'prelim_sort' option to use when initially selecting the top ranking buckets, prior to the final 'sort' option used after refinement. ",
            "author": "ASF subversion and git services",
            "date": "2018-12-01T17:09:51+0000"
        }
    ]
}