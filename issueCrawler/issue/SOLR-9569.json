{
    "id": "SOLR-9569",
    "title": "Moving to a unified solrconfig experience",
    "details": {
        "components": [],
        "type": "Improvement",
        "labels": "",
        "fix_versions": [],
        "affect_versions": "None",
        "status": "Open",
        "resolution": "Unresolved",
        "priority": "Major"
    },
    "description": "Any config API call will result in a collection reload. We should ensure that only the relevant component is reloaded. This will work only for components specified in the configoverlay.json\n\tMove most commonly used paths to ImplicitPlugins\n\tmove their request parameters to params.json\n\tEnhance the config API to expand show the params used for each requesthandler inline\n\n\n\n\n\nToday we use the solrconfig.xml as a place to document things. As we move more stuff off of solrconfig.xml let's point it to a ref guide page to discuss about all the requesthandlers available by default and their configuration",
    "attachments": {},
    "issue_links": {},
    "comments": [
        {
            "date": "2016-10-01T12:42:41+0000",
            "author": "Shawn Heisey",
            "content": "Interesting ideas!  Perhaps this is the correct place to fold all configurations to unified formats (with automatic conversion of old formats in master/7.0) as well.  JSON appears to be a favorite.\n\nAn important part of the larger discussion is whether to separate things into multiple config files, or just go with an intelligent reload approach to subsections of a file with a name like config.json or coreconfig.json and whatever we end up naming the schema.  From a \"help the user\" support perspective, I tend to like single config files.  No need to ask for a different set of files depending on the user's problem, it's all together.  On the other hand, several config files with good names might actually be easier for novice users.  Either way, we might want to write a script for gathering support info into a compressed package users can share and automatically redacting information that we know in advance to be sensitive, such as passwords.\n\nA related format discussion:\nDo we continue to use properties files, with core.properties being a prime example?  We could keep the basic idea and just convert the format to JSON, or we could just continue using the built-in Java capability and the near-ubiquitous public understanding of the properties file for information that is purely key-value and not structured.\n\nI think that the general idea of properties files (regardless of format) is very useful.  The core.properties idea brought us reliable automatic core discovery, something I think worked out really well.\n\nBeyond features like auto-discovery, properties files allow injection of config information at various levels \u2013 per-cloud, per-collection, per-instance, per-core, etc, in a way that can be utilized in other config files.  We have seen a question from a user about how they can insert JNDI config information for their dataimport handler now that Solr is no longer a an easily deployable webapp and the container config is part of what gets replaced on upgrade.  Well-documented multi-tier properties that live in zookeeper and/or the core data are an excellent alternate answer for this.  An idea for the property structure in config files, some of which is already in place:\n${solr.cloud.XXX}\n${solr.collection.XXX}\n${solr.instance.XXX}\n${solr.core.XXX} ",
            "id": "comment-15538465"
        },
        {
            "date": "2016-10-01T13:08:18+0000",
            "author": "Shawn Heisey",
            "content": "I've opened SOLR-9587 to build a script for tech support packages. ",
            "id": "comment-15538498"
        },
        {
            "date": "2016-10-02T18:16:01+0000",
            "author": "Alexandre Rafalovitch",
            "content": "I am comparing solrconfig.xml and the output of the /config command and I see the following challenges in going forward to something that can round-trip via JSON:\n\n\n\tXML entities have attributes as well as child entries, JSON has only child entries (nested objects and properties), so the /config output combines the attributes and nested properties together. Given that both attributes and nested entities may be arbitrary, this mapping is a one-way street. The question is whether we loose anything in this simplification\n\tWith the current implementation, the default values become explicit values (e.g. commitWithin/softCommit), which pollutes the human-comprehension (specifically, the minimal config file showing only deviation from defaults). It is wonderful to be able to see the defaults, but that should be an optional extra, not a forced representation.\n\tThe variable substitutions are lost/materialized (e.g. ${solr.autoCommit.maxTime:15000}), which is ignorable for one-way trip, but not for round-trip as users may want to change those variables later from the command line or in core.properties\n\tThere are still some significant output weirdness with null values (e.g. for JMX), empty keys (e.g. inside updateRequestProcessorChain), missing entries (perSegFilter), and loosing/simplifying-away component names (e.g. highlighting).\n\tI believe solrconfig.xml is supposed to be extendable to plugins that can inject/read their own attributes/entities. I suspect all of those are ignored when /config is called\n\tThe code between the config reading class, config output and overlay setters/getters feels heavily duplicate yet inconsistent and prone to getting out-of-sync on a slightest change.\n\n\n\nThis was not the case for the schema, as it was much more controlled. But solrconfig.xml is somewhat more complex structure and it feels that the current most-direct approach may not take us very far, and certainly not to the round-trip end-goal.\n\nI don't have an answer to the above. Still, I have a vague feeling that perhaps some sort of meta-representation of the solrconfig structure taking advantage of the latest Java 8 features (method pointers, lambdas, etc) would give us a more consistent path forward.   ",
            "id": "comment-15540750"
        },
        {
            "date": "2016-10-03T02:28:05+0000",
            "author": "Noble Paul",
            "content": "Do we continue to use properties files, with core.properties being a prime example?\n\n.properties files are good for editing. In a solrcloud world we don't expect any of the conf files to be hand edited by users. \n\nXML entities have attributes as well as child entries, JSON has only child entries (nested objects and properties), so the /config output combines the attributes and nested properties together. Given that both attributes and nested entities may be arbitrary, this mapping is a one-way street. The question is whether we loose anything in this simplification\n\nThere is an impedance mismatch between XML & JSON. It does not mean that XML is better than JSON. It just means they are different and we have been using one over another. As our components get used to the new format, this will be OK\n\n\nWith the current implementation, the default values become explicit values (e.g. commitWithin/softCommit), which pollutes the human-comprehension (specifically, the minimal config file showing only deviation from defaults). It is wonderful to be able to see the defaults, but that should be an optional extra, not a forced representation.\n\nI'm unable to understand this. care to elaborate?\n\nThe variable substitutions are lost/materialized (e.g. ${solr.autoCommit.maxTime:15000}), which is ignorable for one-way trip, but not for round-trip as users may want to change those variables later from the command line or in core.properties\n\nThis is a missing feature. To be implemented . When you view/save it the templates must show up as specified and not the substituted values\n\nI believe solrconfig.xml is supposed to be extendable to plugins that can inject/read their own attributes/entities. I suspect all of those are ignored when /config is called\n\nit is indeed supposed to be better than XML in that aspect. You could look at the security,json for a taste of things to come. The format of the config is delegated to the component itself. So, the component can actually validate/read/persist its configuration\n\nBut solrconfig.xml is somewhat more complex structure and it feels that the current most-direct approach may not take us very far, and certainly not to the round-trip end-goal.\n\nround-tripping should be an objective. I don't see any reason why can't achieve it ",
            "id": "comment-15541361"
        },
        {
            "date": "2016-10-03T09:58:29+0000",
            "author": "Alexandre Rafalovitch",
            "content": "There is an impedance mismatch between XML & JSON. It does not mean that XML is better than JSON. It just means they are different and we have been using one over another. As our components get used to the new format, this will be OK\n\nXML is richer and is legacy. So, the question is how we are going to deal with that. I am not sure I understood the answer. Perhaps that is something that is obvious to those deep into it, but I feel it is still a valid question given the complexity of code I am seeing already.\n\nI'm unable to understand this (...the default values become explicit values...). care to elaborate?\nRight now, the /config against the core with default configuration returns: _\"commitWithin\":\n{\"softCommit\":true}\n_, the setting that is nowhere in the solrconfig for the core. So, if that round-trips back to whatever format, we suddenly have additional setting in the file, making it bloated. Same with JMX, the /config inserts 3 null-value properties.\n\nit is indeed supposed to be better than XML in that aspect. You could look at the security,json for a taste of things to come. \nI could not find a representative security.json in the codebase. Could you point out the one you mean. I could also not see any evidence of round-tripping in the code, just reading from the json file. The complexities I am trying to discuss are of round-tripping as well as dealing with multiple-sources in a meaningful way.\n\nround-tripping should be an objective. I don't see any reason why can't achieve it\nJust because something is achievable theoretically, does not mean we started on the road in the right direction. I am not saying we have, but I cannot find the discussion explaining how the current effective direction is supposed to - eventually - take care of the issues I raised. ",
            "id": "comment-15542029"
        },
        {
            "date": "2016-10-03T11:28:14+0000",
            "author": "Noble Paul",
            "content": "XML is richer and is legacy. So, the question is how we are going to deal with that. I am not sure I understood the answer. \n\nThe richness is not necessarily a requirement. It is the legacy and I don't see any other reason. The problem with xml is there is no 1:1 mapping between data and the corresponding xml. This results is very complex code required to read/edit/persist xml\n\nRight now, the /config against the core with default configuration returns: _\"commitWithin\":\n\nI don't see that. Can you tell me the steps to see that. \n\nI could not find a representative security.json in the codebase. Could you point out the one you mean. \n\nYou may not find one in codebase. However you can see one in the documentation https://cwiki.apache.org/confluence/display/solr/Rule-Based+Authorization+Plugin . The point is more about how configuration of the component is delegated to the component itself. We currently don't do round tripping from an API. We expect users to fetch zk files and put it back exactly as it is. The best place to add that functionality is to add it to the /admin/zookeeper endpoint. Today, it returns the data wrapped in JSON.\nJust because something is achievable theoretically, does not mean we started on the road in the right direction.\n\nit is not theoretical. It is not done because it was not a requirement ",
            "id": "comment-15542199"
        },
        {
            "date": "2016-10-03T17:11:14+0000",
            "author": "Alexandre Rafalovitch",
            "content": "I don't see that (commitWithin). Can you tell me the steps to see that. \n\n\n> bin/solr start\n> bin/solr create -c test\n> curl http://localhost:8983/solr/test/config |head -10 |cat -n\n     1 \t{\n     2 \t  \"responseHeader\":{\n     3 \t    \"status\":0,\n     4 \t    \"QTime\":0},\n     5 \t  \"config\":{\n     6 \t    \"luceneMatchVersion\":\"org.apache.lucene.util.Version:7.0.0\",\n     7 \t    \"updateHandler\":{\n     8 \t      \"indexWriter\":{\"closeWaitsForMerges\":true},\n     9 \t      \"commitWithin\":{\"softCommit\":true},\n    10 \t      \"autoCommit\":{\n\n\nLine 9 above is the one I refer to. Similarly, for jmx:\n\n\n> curl http://localhost:8983/solr/test/config |grep -A 3 jmx\n    \"jmx\":{\n      \"agentId\":null,\n      \"serviceUrl\":null,\n      \"rootName\":null},\n\n\n\nBoth of these are not defined in the solrconfig.xml. ",
            "id": "comment-15542889"
        }
    ]
}