{
    "id": "LUCENE-1345",
    "title": "Allow Filter as clause to BooleanQuery",
    "details": {
        "labels": "",
        "priority": "Minor",
        "components": [
            "core/search"
        ],
        "type": "Improvement",
        "fix_versions": [
            "4.1"
        ],
        "affect_versions": "None",
        "resolution": "Won't Fix",
        "status": "Closed"
    },
    "description": "",
    "attachments": {
        "TestIteratorPerf.java": "https://issues.apache.org/jira/secure/attachment/12387060/TestIteratorPerf.java",
        "OpenBitSetIteratorExperiment.java": "https://issues.apache.org/jira/secure/attachment/12387137/OpenBitSetIteratorExperiment.java",
        "DisjunctionDISI.patch": "https://issues.apache.org/jira/secure/attachment/12386963/DisjunctionDISI.patch",
        "DisjunctionDISI.java": "https://issues.apache.org/jira/secure/attachment/12387135/DisjunctionDISI.java",
        "LUCENE-1345-Filter+Query-merge.patch": "https://issues.apache.org/jira/secure/attachment/12397654/LUCENE-1345-Filter%2BQuery-merge.patch",
        "booleansetperf.txt": "https://issues.apache.org/jira/secure/attachment/12397594/booleansetperf.txt",
        "LUCENE-1345.patch": "https://issues.apache.org/jira/secure/attachment/12386757/LUCENE-1345.patch"
    },
    "issue_links": {},
    "comments": [
        {
            "date": "2008-07-23T21:45:10+0000",
            "content": "A first half attempt, it still leaves a few compile errors.\n\nThis would allow faster Filter evaluation because the tight loop\nwould be in ConjunctionScorer only.\n\nIt would also allow to get rid of Filter in most of the search api,\nas any Filter can just be added to a BooleanQuery.\n\nWould anyone have a DisjunctionDISI (Disjunction over DocIdSetIterators) somewhere? ",
            "author": "Paul Elschot",
            "id": "comment-12616272"
        },
        {
            "date": "2008-07-26T20:23:48+0000",
            "content": "Would anyone have a DisjunctionDISI (Disjunction over DocIdSetIterators) somewhere?\n\nI have played with DisjunctionSumScorer rip-off, maybe you find it useful for this issue...\n\nWhat would be nice here(and in DisjunctionSumScorer ), if possible?:\n\n\n\tto remove initDISIQueue() from next() and skipTo() (also the same in DisjunctionSumScorer()) ... this is due to this ugly  -1 position before first call, I just do not know how to get rid of it \n\n\n\n\n\tto switch to Conjuction \"mode\" if minNrShouldMatch kicks in.... there are already todo-s for it arround\n\n\n\n\nif you think you can use it, just go ahead and include it in your patch, I am not using this for anything, just wrapped it up when you asked.  ",
            "author": "Eks Dev",
            "id": "comment-12617210"
        },
        {
            "date": "2008-07-26T21:48:43+0000",
            "content": "Thanks for the DisjunctionDISI.patch. I had just continued, but I hadn't come that far yet.\nI'll be off quite irregularly in the next month, I'll try and attach here when there's real progress. ",
            "author": "Paul Elschot",
            "id": "comment-12617220"
        },
        {
            "date": "2008-07-27T14:05:29+0000",
            "content": "I just realised TestDisjunctionDISI had a bug (iterators have to be reinitialized)... \n\napart from that only small change in DISIQueue to use constants instead of vars (compiler should have done it as well, but you never know) \n\n private final void downHeap() {\n+    int i = 1;\n+    int j = 2; //i << 1;         // find smaller child\n+    int k = 3; //j + 1; \n+     ",
            "author": "Eks Dev",
            "id": "comment-12617294"
        },
        {
            "date": "2008-07-28T21:55:22+0000",
            "content": "Hi Paul, \nI gave it a try on micro benchmarking, and it looks like we could gain a lot by switcing to sentinel approach for iterators, apart for being faster they are also a bit robuster to \"one off\" bugs. \n\nThis test is just a simulation made assuming docId is long (I have tried it with int and it is about the same result).\n\nJust attaching it here as I did not want to create new issue for now, before we identify if there are some design/performance knock-out criteria.\n\ntest on my setup:\n32bit java version \"1.6.0_10-rc\"\njava(TM) SE Runtime Environment (build 1.6.0_10-rc-b28)\nWindows XP Profesional 32bit\nnotebook, 3Gb RAM, \nCPU x86 Family 6 Model 15 Stepping 11 GenuineIntel ~2194 Mhz\n\njava -server -Xbatch\n\n\nresult (with docID long):\nold  milliseconds=6938\nold  milliseconds=6953\nold  milliseconds=6890\nold  milliseconds=6938\nold  milliseconds=6906\nold  milliseconds=6922\nold  milliseconds=6906\nold  milliseconds=6938\nold  milliseconds=6906\nold  milliseconds=6906\nold total milliseconds=69203\n\nnew  milliseconds=5797\nnew  milliseconds=5703\nnew  milliseconds=5266\nnew  milliseconds=5250\nnew  milliseconds=5234\nnew  milliseconds=5250\nnew  milliseconds=5235\nnew  milliseconds=5250\nnew  milliseconds=5250\nnew  milliseconds=5250\nnew total milliseconds=53485\nNew/Old Time 53485/69203 (77.28711%)\n\nall in all, faster more than 22% !!\n\nOf course, this type of benchmark does not mean all iterator ops in real life are going to be 20% faster... other things probably dominate, but if it proves that this test does not have some flaws (easy possible)... well worth of pursuing\n\ncheers, eks \n\n ",
            "author": "Eks Dev",
            "id": "comment-12617577"
        },
        {
            "date": "2008-07-28T22:24:53+0000",
            "content": "Patch of 20080729: all tests pass, but no tests cases for filter clauses yet.\n\nAdded BooleanFilterClause class, usable as argument to BooleanQuery.add().\n\nAPI change: made ReqExclScorer package private, added an arg to the constructor.\n\nRemoved the queueSize variable in DisjunctionSumScorer and in the added DisjunctionDISI. Left the doc caching in ScorerDocQueue and in the added DisiDocQueue.\n\nIt might be possible to subclass DisjunctionSumScorer from DisjunctionDISI,\nand to subclass ScorerDocQueue from DisiDocQueue, I have not checked that.\n\nSince ConjunctionScorer can handle DocIdSetIterators with this patch, it should improve the speed for Filters when they are added to a BooleanQuery instead of being used as through the current search API.\n\nEks, thanks for DisjunctionDISI, I took it a bit further. ",
            "author": "Paul Elschot",
            "id": "comment-12617594"
        },
        {
            "date": "2008-07-28T22:40:28+0000",
            "content": "great! Will look into at at the weekend in more datails.\n\n I have moved this part to Constructor on my local copy, it passes all tests:\n\n+    if (disiDocQueue == null) \n{\n+      initDisiDocQueue();\n+    }\n\n\nit is in next() and skipTo()....\n\npractically the same as reported in https://issues.apache.org/jira/browse/LUCENE-1145, with this, 1145 can be closed\n ",
            "author": "Eks Dev",
            "id": "comment-12617603"
        },
        {
            "date": "2008-07-28T22:44:03+0000",
            "content": "20090729 is the date here, the attachment is dated 20080728, never mind.\n\nAs to the sentinel for doc()/next() in the TestIteraratorPerf patch: this will need some real Scorers/DocIdSetIterators to see actual JIT compiler inlining in both cases. In the patch, the Old and New classes are local private classes, which are much easier to inline than separate, (non final) public classes.  ",
            "author": "Paul Elschot",
            "id": "comment-12617604"
        },
        {
            "date": "2008-07-28T22:47:22+0000",
            "content": "Indeed, it makes sense to add the changes from LUCENE-1145 here.\nI remembered some discussion about this, but not that there was an issue open... ",
            "author": "Paul Elschot",
            "id": "comment-12617606"
        },
        {
            "date": "2008-07-29T00:47:25+0000",
            "content": "Eks: just for grins, you can sometimes save a single cycle by changing \"id==-1\" to \"id<0\" (many operations on x86 automatically set status flags, hence comparison to zero can often be free).  Not sure if the java optimizer will catch it though, and if it does if it would actually rise above the noise level. ",
            "author": "Yonik Seeley",
            "id": "comment-12617631"
        },
        {
            "date": "2008-07-29T07:17:05+0000",
            "content": "Yonik, this would probably work fine for int values (on my CPU), I have tried it on long values and this was significantly slower on this test... it boils down again to \"what is the CPU we are optimizing for\"  ",
            "author": "Eks Dev",
            "id": "comment-12617726"
        },
        {
            "date": "2008-07-29T15:33:19+0000",
            "content": "I have tried it on long values and this was significantly slower on this test.\n\nHuh... I bet it's the test.  It's probably so simple that everything is inlined and the comparison with -1 is being optimized away entirely (since a compare instruction is the same speed... doesn't matter if one is checking for equality or for less). ",
            "author": "Yonik Seeley",
            "id": "comment-12617822"
        },
        {
            "date": "2008-07-29T16:20:31+0000",
            "content": "comparison with -1 is being optimized away entirely \n\nI do not think so, how compiler could \"optimize away\" the only condition that stops the loop? The loop would never finish, or am I misreading something here? \n\nAnyhow, the test is so simple that compiler can take completely other direction from the real case. I guess much better test (without too much effort!) would be to take something like OpenBitSetIterator and make one Iterator implementation with sentinel approach and then compare... this test is really just a dumb loop, but on the other side isolates the difference between two approaches...\n ",
            "author": "Eks Dev",
            "id": "comment-12617836"
        },
        {
            "date": "2008-07-29T21:18:31+0000",
            "content": "DisjunctionDisi.java of 20080729 has a first try of switching to conjunction mode, see advanceAfterCurrent and requiredDisis in there.\n\nI have not even compiled it yet, just showing the basic idea, no more time at the moment. ",
            "author": "Paul Elschot",
            "id": "comment-12617958"
        },
        {
            "date": "2008-07-29T21:46:28+0000",
            "content": "I just enhanced TestIteratorPerf  to work with OpenBitSetIterator(Experiment)... on dense bit sets sentinel based are faster (ca 9%), on low density about the same?\n\nYonik's tip -1 < doc instead of -1 != doc still performs worse, and knowing Yonik's hunch on these things, I am still not convinced it is really faster ...\n\nPaul's work here is more interesting, clear API and Performance win on many fronts... \n\npractically, no need to pollute this issue more with iterator semantics if I(or someone else) figure out something really interesting there, will create new issue .... ",
            "author": "Eks Dev",
            "id": "comment-12617969"
        },
        {
            "date": "2008-07-30T21:24:29+0000",
            "content": "Eks, I just tried your first TestIteratorPerf.java myself, and comparison with zero was faster (as expected) by about 8%\nI commented everything out except for testNew for simplicity.\n\nOriginal testNew:\n\n$ java -server -cp . TestIteratorPerf\nnew  milliseconds=2883\nnew  milliseconds=3289\nnew  milliseconds=3148\nnew  milliseconds=3195\nnew  milliseconds=3149\nnew  milliseconds=3179\nnew  milliseconds=3180\nnew  milliseconds=3164\nnew  milliseconds=3179\nnew  milliseconds=3164\nnew total milliseconds=31530\n\n\n\nModified testNew:\n      // while(-1!=(doc=it.next())){\n      while((doc=it.next()) >= 0) \n\n\n$ java -server -cp . TestIteratorPerf\nnew  milliseconds=2806\nnew  milliseconds=2899\nnew  milliseconds=2915\nnew  milliseconds=2899\nnew  milliseconds=2914\nnew  milliseconds=2899\nnew  milliseconds=2899\nnew  milliseconds=3040\nnew  milliseconds=2899\nnew  milliseconds=2930\nnew total milliseconds=29100\n\n\n\nSystem: WinXP, Pentium4, java version \"1.5.0_11\" ",
            "author": "Yonik Seeley",
            "id": "comment-12618513"
        },
        {
            "date": "2009-01-10T06:25:43+0000",
            "content": "Added perf comparisons with boolean set iterators with current scorers\n\nSee patch\n\nSystem: Ubunto, \njava version \"1.6.0_11\"\nIntel core2 Duo 2.44ghz\n\nnew  milliseconds=470\nnew  milliseconds=534\nnew  milliseconds=450\nnew  milliseconds=443\nnew  milliseconds=444\nnew  milliseconds=445\nnew  milliseconds=449\nnew  milliseconds=441\nnew  milliseconds=444\nnew  milliseconds=445\nnew total milliseconds=4565\nold  milliseconds=529\nold  milliseconds=491\nold  milliseconds=428\nold  milliseconds=549\nold  milliseconds=427\nold  milliseconds=424\nold  milliseconds=420\nold  milliseconds=424\nold  milliseconds=423\nold  milliseconds=422\nold total milliseconds=4537\n\nNew/Old Time 4565/4537 (100.61715%)\nOrDocIdSetIterator  milliseconds=1138\nOrDocIdSetIterator  milliseconds=1106\nOrDocIdSetIterator  milliseconds=1065\nOrDocIdSetIterator  milliseconds=1066\nOrDocIdSetIterator  milliseconds=1065\nOrDocIdSetIterator  milliseconds=1067\nOrDocIdSetIterator  milliseconds=1072\nOrDocIdSetIterator  milliseconds=1118\nOrDocIdSetIterator  milliseconds=1065\nOrDocIdSetIterator  milliseconds=1069\nOrDocIdSetIterator total milliseconds=10831\nDisjunctionMaxScorer  milliseconds=1914\nDisjunctionMaxScorer  milliseconds=1981\nDisjunctionMaxScorer  milliseconds=1861\nDisjunctionMaxScorer  milliseconds=1893\nDisjunctionMaxScorer  milliseconds=1886\nDisjunctionMaxScorer  milliseconds=1885\nDisjunctionMaxScorer  milliseconds=1887\nDisjunctionMaxScorer  milliseconds=1889\nDisjunctionMaxScorer  milliseconds=1891\nDisjunctionMaxScorer  milliseconds=1888\nDisjunctionMaxScorer total milliseconds=18975\nOr/DisjunctionMax Time 10831/18975 (57.080368%)\nOrDocIdSetIterator  milliseconds=1079\nOrDocIdSetIterator  milliseconds=1075\nOrDocIdSetIterator  milliseconds=1076\nOrDocIdSetIterator  milliseconds=1093\nOrDocIdSetIterator  milliseconds=1077\nOrDocIdSetIterator  milliseconds=1074\nOrDocIdSetIterator  milliseconds=1078\nOrDocIdSetIterator  milliseconds=1075\nOrDocIdSetIterator  milliseconds=1074\nOrDocIdSetIterator  milliseconds=1074\nOrDocIdSetIterator total milliseconds=10775\nDisjunctionSumScorer  milliseconds=1398\nDisjunctionSumScorer  milliseconds=1322\nDisjunctionSumScorer  milliseconds=1320\nDisjunctionSumScorer  milliseconds=1305\nDisjunctionSumScorer  milliseconds=1304\nDisjunctionSumScorer  milliseconds=1301\nDisjunctionSumScorer  milliseconds=1304\nDisjunctionSumScorer  milliseconds=1300\nDisjunctionSumScorer  milliseconds=1301\nDisjunctionSumScorer  milliseconds=1317\nDisjunctionSumScorer total milliseconds=13172\nOr/DisjunctionSum Time 10775/13172 (81.80231%)\nAndDocIdSetIterator  milliseconds=330\nAndDocIdSetIterator  milliseconds=336\nAndDocIdSetIterator  milliseconds=298\nAndDocIdSetIterator  milliseconds=299\nAndDocIdSetIterator  milliseconds=310\nAndDocIdSetIterator  milliseconds=298\nAndDocIdSetIterator  milliseconds=298\nAndDocIdSetIterator  milliseconds=334\nAndDocIdSetIterator  milliseconds=298\nAndDocIdSetIterator  milliseconds=299\nAndDocIdSetIterator total milliseconds=3100\nConjunctionScorer  milliseconds=332\nConjunctionScorer  milliseconds=307\nConjunctionScorer  milliseconds=302\nConjunctionScorer  milliseconds=350\nConjunctionScorer  milliseconds=300\nConjunctionScorer  milliseconds=304\nConjunctionScorer  milliseconds=305\nConjunctionScorer  milliseconds=303\nConjunctionScorer  milliseconds=303\nConjunctionScorer  milliseconds=299\nConjunctionScorer total milliseconds=3105\nAnd/Conjunction Time 3100/3105 (99.83897%) ",
            "author": "John Wang",
            "id": "comment-12662627"
        },
        {
            "date": "2009-01-10T06:27:59+0000",
            "content": "Added And/Or/Not DocidSet/Iterators\n\ncode ported over from Kamikaze:\nhttp://code.google.com/p/lucene-ext/\n\nPerf test updated.\n\nmain contributors to the patch: Anmol Bhasin & Yasuhiro Matsuda ",
            "author": "John Wang",
            "id": "comment-12662631"
        },
        {
            "date": "2009-01-10T06:30:03+0000",
            "content": "Given the perf number improvements we see, can we consider up the priority? ",
            "author": "John Wang",
            "id": "comment-12662632"
        },
        {
            "date": "2009-01-10T10:49:47+0000",
            "content": "\n> Given the perf number improvements we see, can we consider up the priority? \nI agree, the results look compelling; I marked this and LUCENE-1145 as fix version 2.9. ",
            "author": "Michael McCandless",
            "id": "comment-12662650"
        },
        {
            "date": "2009-01-10T12:39:53+0000",
            "content": "Paul Elschot, a while back:\n\n> It would also allow to get rid of Filter in most of the search api,\n> as any Filter can just be added to a BooleanQuery.\n\nIn KS svn trunk (and potentially in Lucy), there is no \"Filter\"; all classes\nthat perform filtering are just subclasses of Query which you're expected to\napply using an ANDQuery.  Can you think of any downside to that model? (Would\nit be possible to retrofit Lucene to use it in 3.0?) The motivation was the\nsame as the one you articulate: to simplify the search API.\n\n(Hmm...Thinking out loud: DeletionsFilter as a subclass of Query...) ",
            "author": "Marvin Humphrey",
            "id": "comment-12662656"
        },
        {
            "date": "2009-01-10T13:22:38+0000",
            "content": "\n> (Hmm...Thinking out loud: DeletionsFilter as a subclass of Query...)\n+1 ",
            "author": "Michael McCandless",
            "id": "comment-12662657"
        },
        {
            "date": "2009-01-10T17:07:17+0000",
            "content": "Filters by definition (afaik) does not participate in scoring. Since \"score gathering\" is done at the BooleanQuery level, does it mean BooleanQuery would need to do instanceof check to see if it is a Filter? \n\nOr do we always hardcode filter with score 0? This is also dangerous if people do augment scores at hitcollector level or score gathering logic changes to something not as straightforward as summing.\n\nmy two cents. ",
            "author": "John Wang",
            "id": "comment-12662673"
        },
        {
            "date": "2009-01-10T20:03:15+0000",
            "content": "Marvin,\n\nIn KS svn trunk (and potentially in Lucy), there is no \"Filter\"; all classes that perform filtering are just subclasses of Query which you're expected to apply using an ANDQuery. Can you think of any downside to that model?\n\nIn Lucene the class model is that Scorer extends DocIdSetIterator by some\nmethods involved with document score values. To prepare searching in\nLucene the following 'transformations' are done:\nQuery -> Weight -> Scorer\nand\nFilter -> DocIdSetIterator\n\nI've never seen the KS classes, but on the face of it, the downside of using\nANDQuery (KS) for filtering is that it has to provide a score value, which\nsomehow must be ignored during search. ",
            "author": "Paul Elschot",
            "id": "comment-12662685"
        },
        {
            "date": "2009-01-10T20:12:16+0000",
            "content": "John, Michael,\n\nGiven the perf number improvements we see, can we consider up the priority? \n\nI think most of the performance improvements that John posted can be moved into\ntrunk without the addition of Filter as a clause to BooleanQuery. Therefore I'd rather let\nthese go in before adding Filter as clause to BooleanQuery. ",
            "author": "Paul Elschot",
            "id": "comment-12662687"
        },
        {
            "date": "2009-01-11T12:11:11+0000",
            "content": "Here is a nice idea, how to merge Filters and Queries:\n\nWhy not just combine ConstantScoreQuery and the current abstract Filter APIs to a new Filter class. This would make it possible, to use every filter as a query. The new abstract filter class would contain all methods of ConstantScoreQuery and it would even be backwards compatible. If somebody implements the filters getDocIdSet()/bits() methods he has nothing more to do, he could just use the filter as a normal query.\n\nFor some performance improvements when combining more than one filter in a BooleanQuery (e.g. anding/oring the iterators, filtering,...) the code of BooleanQuery could use instanceof. ",
            "author": "Uwe Schindler",
            "id": "comment-12662766"
        },
        {
            "date": "2009-01-11T13:11:03+0000",
            "content": "Attached is a patch, that merges ConstantScoreQuery and Filter APIs. The ConstantScoreQuery is deprecated by this. Further cleanups then may remove the use of ConstantScoreQuery from other places in Lucene, where the class is currently used to wrap filters as Queries.\n\nAll important tests pass! Only one test does not pass: a problem occurs in TestSimpleExplanations, but this may be because the changed toString()/toString(field) and query explanations (because ConstantScoreQuery no longer returns an explanation), this may be cha nged or the test should be rewritten. Nevertheless, I do not understand the whole test case \n\nUwe ",
            "author": "Uwe Schindler",
            "id": "comment-12662774"
        },
        {
            "date": "2009-01-11T14:47:03+0000",
            "content": "Uwe, \n\nThe point here is to let BooleanQuery also take care of the filtering logic without doing any extra score computations.\n\nFor example that involves changing ConjunctionScorer to not only accept Scorers, but also DocIdSetIterators,\n and use these DocIdSetIterators together with the Scorers to skip to the next matching document, but only use the Scorers to compute the score value.\n\nWhat is the point of adding a score value to Filters, when that score value has to be ignored during query search? ",
            "author": "Paul Elschot",
            "id": "comment-12662782"
        },
        {
            "date": "2009-01-11T14:52:54+0000",
            "content": "The idea behind the patch was to merge the code of filters and queries. Further optimizations now can remove the score calculation from the filter code.\n\nUsing my patch you are now be able to add filters to BooleanQueries or directly execute them using Searcher.search, because they are subclasses of Query. Further optimizations now may remove the score computation in complete, if the given query extends Filter (if (query instanceof Filter) do something other). ",
            "author": "Uwe Schindler",
            "id": "comment-12662783"
        },
        {
            "date": "2009-01-11T15:29:03+0000",
            "content": "Further optimizations now may remove the score computation in complete, if the given query extends Filter (if (query instanceof Filter) do something other)\n\nSuch further optimization is precisily the idea of the original patch here, but without making Filter a subclass of Query. ",
            "author": "Paul Elschot",
            "id": "comment-12662786"
        },
        {
            "date": "2009-01-11T15:36:09+0000",
            "content": "I know this. My idea was just to remove the burden of thinking about Filters and Queries for the developer of Lucene applications.\n\nIn my opinion, the terms \"Query\" and \"Filter\" should be merged. Logic behind BooleanQuery or Searcher should simply think about the *best\" logic how to optimize what the user wants to do.\n\nMaybe I should create an new JIRA issue out of my suggestion to merge Filters and Queries? In my opinion, this is something nice to have in 3.0. ",
            "author": "Uwe Schindler",
            "id": "comment-12662790"
        },
        {
            "date": "2009-01-11T15:56:47+0000",
            "content": "In my opinion, the terms \"Query\" and \"Filter\" should be merged.\n\nThere is clear distinction between the two terms.\nQueryWrapperFilter changes a Query into a Filter and ConstantScoreQuery changes a Filter into a Query.\nThe first one removes the scoring by upcasting a Scorer to a DocIdSetIterator, and the second one adds a constant score to a DocIdSetIterator to create a Scorer. ",
            "author": "Paul Elschot",
            "id": "comment-12662795"
        },
        {
            "date": "2009-01-11T16:27:03+0000",
            "content": "\nIn my opinion, the terms \"Query\" and \"Filter\" should be merged.\n\nThere is clear distinction between the two terms.\nQueryWrapperFilter changes a Query into a Filter and ConstantScoreQuery changes a Filter into a Query.\nThe first one removes the scoring by upcasting a Scorer to a DocIdSetIterator, and the second one adds a constant score to a DocIdSetIterator to create a Scorer.\nYou are right, but for a Lucene user there is always the problem of the distiction between both terms. When combining both, the user would get less burden on thinking about both. It would make life easier, and would hide some work for the user. The problem are the fine differences between the both, but for the general user who does not have such large indexes where the difference between both counts, it would makte things easier.\n\nHow about merging Filters and Queries and then thinking about optimizations in the code of BooleanQuery to identify use cases where the scoring can be removed and where a constant score is needed. There are two cases where the two different types make problems:\n\n\n\tuser (A) wants to use my contrib TrieRangeQuery/-Filter and just execute a Query that returns documents that match the Range. The problem for this user is: How to implement this? User a MatchAllDocsQuery and filter the results with TrieRangeFilter or use ConstantScoreQuery to combine both? What is faster?\n\tuser (B) wants to filter some documents using a normal Filter. If he uses the standard Query+Filter combination of Searcher.search() he must before distinguish what part of the combinations should be the filter and what should be the query. Maybe he got a TrieRangeQuery (the query one using a ConstantScore on the Filter) as query and want it combine with another query. With the new code that detects the type of both clauses, BooleanQuery code could choose to execute the TermQueries as normal scorer query and filter the results using the given Filter as clause.\n\n\n\nBoth tasks could be easily combined if Query and Filter would be the same. The user (A) would not need to create a constant score query on the Trie filter, he could just use it with Searcher.search() as a \"Query\". If he want to add some normal term queries from a query parser to it, he would use a BooleanQuery to combine both. The BooleanQuery code would then find out that one of the clauses is a Filter and would not use ConstantScore code to filter the result and just use the normal filter code. For the user it is simplier: He would always create a TrieRangeQueryFilter combination and would let BooleanQuery choose what query execution strategy to use. ",
            "author": "Uwe Schindler",
            "id": "comment-12662796"
        },
        {
            "date": "2009-01-11T16:29:43+0000",
            "content": "An additional case: User (A) uses a BooleanQuery and just adds the Filter to it and nothing more (no TermQueries and so on). In this case, ConstantScore algorithm must be used! But for the end user the API is always identical. ",
            "author": "Uwe Schindler",
            "id": "comment-12662797"
        },
        {
            "date": "2009-01-11T16:44:50+0000",
            "content": "Here some ideas how to implement search() with Query and Filter:\n\n\tUser runs Searcher.search() using a Filter as the only parameter. As every Filter is also a ConstantScoreQuery, the query can be executed and returns score 1.0 for all matching documents.\n\tUser runs Searcher.search() using a Query as the only parameter: No change, all is the same as before\n\tUser runs Searcher.search() using a BooleanQuery as parameter: If the BooleanQuery does not contain a Query that is subclass of Filter (the new Filter) everything as usual. If the BooleanQuery only contains exactly one Filter and nothing else the Filter is used as a constant score query. If BooleanQuery contains clauses with Queries and Filters the new algorithm could be used: The queries are executed and the results filtered with the filters.\n\n\n\nI hope this explains how I would implement the combined Filters and Queries. ",
            "author": "Uwe Schindler",
            "id": "comment-12662799"
        },
        {
            "date": "2009-01-11T20:18:05+0000",
            "content": "In case there is no score value for each matching document it is not possible to order the results to be presented to a user. Because of that I don't want BooleanQuery to run correctly without at least one normal query clause to provide a score to order the results. Putting this in another way: TopDocs (and the meanwhile deprecated Hits) make no sense without at least one normal query clause.\n\nThere are cases when all results are needed, and in that case for a Query one normally uses to the HitCollector API. For Filters one could provide a MatchCollector API that collects all hits providing only the document numbers, and no score (as in HitCollector). This was part of the earlier versions of the patches at LUCENE-584 that introduced the new Filter API, but it was dropped because it was new functionality that was not really needed at the time.\nThe same MatchCollector API can also be provided for Query searching. At that point, there is no difference between Query and Filter. ",
            "author": "Paul Elschot",
            "id": "comment-12662814"
        },
        {
            "date": "2009-01-11T20:56:57+0000",
            "content": "But where is the problem then: You only mean that BooleanQueries with only a Filter clause are not sortable. In my opinion this is not a real problem: I do for example use ConstantScoreQuery with a TrieRangeFilter as the only query constraint. All results are returned with score=1, this is similar to a classic SQL database. The default order of equal scores is index order, so it makes sense for TopDocs. And if you additionally add a SortField it makes more sense \n\nSo why not implement the three cases as described in my last message and use a ConstantScoreQuery, if the Filter is alone in the BooleanQuery. In this case all options can be used with a simple API with no difference between Filters and Queries? The MatchCollector API in my opinion is also not needed. In the case of constant score (=1.0) why not simple call collect(dociId, 1.0f)? Why do we need a new API just because the score is not needed. Just define 1.0 as the score (like ConstantScoreQuery does). ",
            "author": "Uwe Schindler",
            "id": "comment-12662820"
        },
        {
            "date": "2009-01-11T21:02:27+0000",
            "content": "Paul Elschot:\n\n> To prepare searching in Lucene the following 'transformations' are done:\n>\n>   Query -> Weight -> Scorer\n>   and\n>   Filter -> DocIdSetIterator\n> \n> I've never seen the KS classes\n\nKS's Search classes used to be pretty direct ports from the Lucene Search\nhierarchy \u2013 because when I was doing the work I had so much trouble grokking\nit that I felt there was no choice but to cargo cult. \n\nSince then, many changes have been made.  Here are some that are germane to\nthis discussion:\n\n\n\tFilter has been eliminated, and filtering subclasses have been made into\n  subclasses of Query.\n\tWeight has been made a subclass of Query and renamed to \"Compiler\".\n\tBooleanQuery has been replaced by the foursome of ANDQuery, ORQuery,\n  NOTQuery, and RequiredOptionalQuery, all of which descend from the common\n  parent PolyQuery, and which compile to scorers roughly akin to those from\n  Lucene's BooleanScorer2 (i.e. they implement Scorer.skipTo())..\n\n\n\nBy making both Filter and Weight/Compiler subclasses of Query, it became\npossible to simplify the Searchable/Searcher interface considerably.\n\n> the downside of using ANDQuery (KS) for filtering is that it has to provide\n> a score value, which somehow must be ignored during search.\n\nGood point, thanks!\n\nRight now, QueryFilter, NOTQuery, MatchAllQuery, and such all\njust provide a score of 0.0.  ANDScorer adds the scores of its subscorers\ntogether, so there's no direct effect on the final score.  However, the\nSimilarity.coord() bonus is affected because the number of clauses has\nincreased.  That might be considered a bug.\n\nBeyond that, there's Scorer-compile-time optimization work to do along the\nlines of what Uwe proposes.\n ",
            "author": "Marvin Humphrey",
            "id": "comment-12662821"
        },
        {
            "date": "2009-01-11T21:36:13+0000",
            "content": "Paul Elschot:\n\nJust for clarification: I do not want to completely convert Filters to ConstantScoreQueries. The idea was to combine Queries and Filters in such a way, that every Filter can automatically be used at all places where a Query can be used (e.g. also alone a search query without any other constraint). For that, the abstract Query methods must be implemented and return a \"default\" weight for Filters which is the current ConstantScore Logic. If the filter is used as a real filter (where the API wants a Filter), the getDocIdSet part could be directly used, the weight is useless (as it is currently, too). The constant score default implementation is only used when the Filter is used as a Query (e.g. as direct parameter to Searcher.search()). For the special case of BooleanQueries combining Filters and Queries the idea is, to optimize the BooleanQuery logic in such a way, that it detects if a BooleanClause is a Filter (using instanceof) and then directly uses the Filter API and not take the burden of the ConstantScoreQuery. There is only one special case: If the Filter is used alone in the BooleanQuery, then it must be executed as a ConstantScoreQuery, but only in this case. The problems with sorting are in my opinion not relevant: If score is identical (e.g. 1.0f) the results come in index order (this is how it appears to me). In this case TopDocs first list the docs with lower docIds.\n\nFor the user this has the main advantage: That he can construct his query using a simplified API without thinking about Filters oder Queries, you can just combine clauses together. The scorer/weight logic then identifies the cases to use the filter or the query weight API. Just like the query optimizer of a RDB \n\nIs this clear now? ",
            "author": "Uwe Schindler",
            "id": "comment-12662823"
        },
        {
            "date": "2009-01-12T08:39:29+0000",
            "content": "To add a Filter is as a clause to a BooleanQuery, I would prefer to not give it a Weight. Instead I'd like the addition of a required Filter to behave exactly like the current Searcher(Query, Filter) API.\nThat also touches another point: backward compatibility with BooleanQuery and Searcher.\n\nIt's certainly possible to add scoring behaviour to a Filter when it is added to a BooleanQuery. A default score value could be used, and also a default coordination behaviour.\nIn principle it is also possible to add a disjunction of Filters to a BooleanQuery, even with a minimum number of required filters. For this case a score value does make sense.\n\nRequired Filters and for prohibited Filters could be added to a BooleanQuery without scoring behaviour. In fact, for prohibited Queries, the score value is never used, so one might even constrain prohibited clauses to be Filters only.\n\nMost, if not all, of the scoring behaviour for Filters that was discussed so far can be obtained by using a ConstantScoreQuery based on a Filter and adding it to a BooleanQuery. So I think it would be cleaner to keep the scoring yes/no distinction between Queries and Filters. In case a simplified interface is desired this could then use any of the options available, for example always wrapping a Filter in a ConstantScoreQuery, and then composing a BooleanQuery only from Query clauses. ",
            "author": "Paul Elschot",
            "id": "comment-12662907"
        },
        {
            "date": "2009-01-12T16:16:58+0000",
            "content": "What about complete merge of filters/queries, and deciding whether to score/use constant score/don't score when adding a query to BooleanQuery (or AND/OR/NOT alternative)?\nSomething along the lines of: boolQuery.add(new TermQuery(..), SHOULD, NO_SCORE) ",
            "author": "Earwin Burrfoot",
            "id": "comment-12662984"
        },
        {
            "date": "2009-01-12T16:37:10+0000",
            "content": "This:\nboolQuery.add(new TermQuery(..), SHOULD, NO_SCORE)\ncan be done (with the patch here applied) by:\n\nboolQuery.add(new QueryWrapperFilter(new TermQuery(..), MUST) .\n\n(SHOULD cannot be used for filters as clauses).\n\nI'll post a working version of the patch within a few days. It's better to discuss on working code than on ideas only. ",
            "author": "Paul Elschot",
            "id": "comment-12662993"
        },
        {
            "date": "2009-01-12T16:51:51+0000",
            "content": "> (SHOULD cannot be used for filters as clauses).\n\nIt doesn't have to be that way.  In KS, QueryFilter is a Query, which you can add as a clause to an ORQuery or a RequiredOptionalQuery.  Docs which match only the QueryFilter are fed to the HitCollector with a score of 0.0. ",
            "author": "Marvin Humphrey",
            "id": "comment-12662998"
        },
        {
            "date": "2009-01-12T17:31:33+0000",
            "content": "Uwe Schindler:\n\n> Maybe I should create an new JIRA issue out of my suggestion to merge \n> Filters and Queries? In my opinion, this is something nice to have in 3.0.\n\nI agree with this tack, having taken it in KS.  However, I don't think we have\nconsensus as far as the best approach yet, so perhaps it would be beneficial\nto hash things out on the mailing list first. ",
            "author": "Marvin Humphrey",
            "id": "comment-12663021"
        },
        {
            "date": "2009-01-12T19:18:53+0000",
            "content": "Uwe> Maybe I should create an new JIRA issue out of my suggestion to merge Filters and Queries?\n\n+1 to creating a new issue and +1 to the idea. ",
            "author": "Doug Cutting",
            "id": "comment-12663055"
        },
        {
            "date": "2009-01-12T20:01:29+0000",
            "content": "I created and linked a new issue LUCENE-1518, that handles the merge suggestion. I also included all relevant comments from me about this. ",
            "author": "Uwe Schindler",
            "id": "comment-12663070"
        },
        {
            "date": "2009-01-12T20:22:15+0000",
            "content": "Ok, I'll wait for  LUCENE-1518. ",
            "author": "Paul Elschot",
            "id": "comment-12663075"
        },
        {
            "date": "2009-03-22T15:14:19+0000",
            "content": "An interim update (22 March 2009) to the patch for this issue.\n\nThe patch pushes the evaluation of required filter clauses into ConjunctionScorer, which should bring a small speed improvement to filtered searches. This also gives an alternative to the current use of filters in the Searcher API.\n\nHowever, the patch still fails some test cases, most notably TestBoolean2.testQueries06 which has two excluding query clauses. This indicates that there is a bug somewhere in/around the DisiDocQueue class that is added by the patch. Some of the random query tests also fail. AFAIK all failing test cases have excluding query clauses.\nSo I think all tests will pass once this bug is solved.\n\nAnother issue with this is more duplication of code originating from PriorityQueue in the DisiDocQueue class.\n\nI don't really like to post a patch with a known bug, but I can spend so little time on this issue in the near future that I prefer to give someone else the 'opportunity' to complete this.\n\nIn case the patch does not apply cleanly please let me know. ",
            "author": "Paul Elschot",
            "id": "comment-12688135"
        },
        {
            "date": "2009-04-20T21:24:10+0000",
            "content": "Even though Paul's patch doesn't pass a test, it sounds like it\ncan be benchmarked? Part of the goal of patch is to make certain\nqueries faster? This could help with how we approach optimizing\nLUCENE-1345. ",
            "author": "Jason Rutherglen",
            "id": "comment-12700944"
        },
        {
            "date": "2009-04-20T22:06:43+0000",
            "content": "The interesting thing to benchmark is filtered queries. One could do this by adding the filter as a required clause to a BooleanQuery in IndexSearcher, and see whether filtered queries are faster with that implementation. This part should work normally with the current patch.\n\nIn case that turns out to make a real difference, it might also be considered to deprecate all the Searcher methods that take a Filter argument, and indicate the preferred alternative implementation with a Filter as a clause to BooleanQuery in the javadocs.\n\nNow, if I could find the time to get this last bug out of the current patch... ",
            "author": "Paul Elschot",
            "id": "comment-12700961"
        },
        {
            "date": "2009-06-11T15:10:43+0000",
            "content": "Since I don't think I'll get to providing an improved patch anytime soon, I'm setting the fix version to 3.1.\n\nThe recent changes to DocIdSetIterator conflict with the patch here (not very much), and the patch here failed some test cases even before this conflict. ",
            "author": "Paul Elschot",
            "id": "comment-12718494"
        },
        {
            "date": "2012-10-18T19:15:39+0000",
            "content": "Enough time has passed to show that there is not sufficient interestin this. ",
            "author": "Paul Elschot",
            "id": "comment-13479267"
        },
        {
            "date": "2013-05-10T10:33:19+0000",
            "content": "Closed after release. ",
            "author": "Uwe Schindler",
            "id": "comment-13653892"
        },
        {
            "date": "2017-01-04T10:52:42+0000",
            "content": "I don't know the exact issue, but this idea was eventually implemented, since BooleanQuery does now accept FILTER clauses. ",
            "author": "Michael McCandless",
            "id": "comment-15797929"
        }
    ]
}