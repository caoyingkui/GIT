{
    "id": "SOLR-11653",
    "title": "create next time collection based on a fixed time gap",
    "details": {
        "labels": "",
        "priority": "Major",
        "components": [
            "SolrCloud"
        ],
        "type": "Sub-task",
        "fix_versions": [
            "7.3"
        ],
        "affect_versions": "None",
        "resolution": "Fixed",
        "status": "Closed"
    },
    "description": "For time series collections (as part of a collection Alias with certain metadata), we want to automatically add new collections. In this issue, this is about creating the next collection based on a configurable fixed time gap.  And we will also add this collection synchronously once a document flowing through the URP chain exceeds the gap, as opposed to asynchronously in advance.  There will be some Alias metadata to define in this issue.  The preponderance of the implementation will be in TimePartitionedUpdateProcessor or perhaps a helper to this URP.\n\nnote: other issues will implement pre-emptive creation and capping collections by size.",
    "attachments": {
        "SOLR-11653.patch": "https://issues.apache.org/jira/secure/attachment/12903852/SOLR-11653.patch"
    },
    "issue_links": {},
    "comments": [
        {
            "date": "2017-12-28T04:20:12+0000",
            "content": "Here's a first draft patch that is fairly incomplete insofar as lacking tests and I haven't actually run this code at all yet.  It shows the approach.  There are two main parts:\n\n(1) New RoutedAliasCreateCollectionCmd, an Overseer Cmd registered as \"ROUTEDALIAS_CREATECOLL\".  It adds the next collection to a time routed alias.  It assumes the metadata on the alias with a certain prefix is collection creation metadata, and it mandates collection.configName is present (we want all the collections to have the same configset, by default any way).  The collection creation is invoked in two steps by first calling CollectionsHandler.CollectionOperation.CREATE_OP.execute to get the overseer message, and then it delivers it to CreateCollectionCmd indirectly via the OverseerCollectionMessageHandler.  The alias is updated to have the new collection at the first position (thus reverse chronological order).  Note that this Cmd has a parameter ifHeadCollName that is the head (latest) collection name that the caller sees when it calls the command.  If the head collection is something else, the Cmd returns without error, as it's assumed there may have been a race of multiple attempts to create the next collection at the same time.\n\n(2) Changes to TimeRoutedAliasUpdateProcessor.  There's now a loop such that if we think we need to create the collection, we do so and then we retry from the start, more or less.  This is mostly because we may need to create a series of collections if the current collection head is very out of date.  I also added a check to throw an exception if the timestamp of the document is far into the future (currently 10 minutes).\n\nSo yeah I need to actually use it and work on tests.  But there are some code re-arrangement that should be done as well, I think.  The Cmd calls into the URP to share some code but it ought to be the other way around.  Or maybe a new \"TimeRoutedAliasInfo\" class could exist that is used by both the URP and Cmd?  There will probably be some code sharing with SOLR-11722 like formatting the collection name from a timestamp \u2013 CC Gus Heck ",
            "author": "David Smiley",
            "id": "comment-16305042"
        },
        {
            "date": "2018-01-01T16:34:58+0000",
            "content": "Updated patch, significantly moving this issue to being done.  I tested it which uncovered various bugs which I fixed.  I tweaked some but not all metadata param names to align with SOLR-11722; we can fully align them here or there.  Unfortunately there's a bit of redundant stuff in that issue and this one (and internally in this one between the URP & Cmd) that we can resolve in a separate issue to tidy up duplication.  Some reflection on changes in this patch:\n\nOverseer & OverseerTaskProcessor: added checks for \"operation\" being null to pass a clear error.  Of course this should never happen in bug free code, but my code wasn't bug free at first .  In OTP I left a nocommit because I think the order of the nearby code should be reordered a little (a very minor refactoring). The patch won't easily show this as there isn't enough contextual lines of code.  I think operation should be gotten & verified (not null), then check for the asyncId logic, and then acquire the messageHandler (thus immediately before the MH is used).\n\nCollectionsHandler.waitForActiveCollection: I made this method public because it's important to check for this level of collection readiness before we actually use it.  I had hoped waitForFinalState would be sufficient but tests proved it wasn't.  Having to call this feels bad; I have to wonder if Collection creation should internally wait for being \"active\"; what's the harm in that?\n\nIMO CollectionsHandler.handleResponse is a bad name... it's name suggest it only handles the response when it performs the intended action too!  I have TODOs to rename to submitToOverseerRPC since it submits to the Overseer queue and it does so in an RPC way (expects a response; it's not just a message on a queue).  Input on the name is welcome.\n\nAdded TZ timezone handling for working with the interval.\n\nWhat I want to do now is improve testing for race conditions by having the test submit documents in parallel.  I may also get to a minor TODO involving the addition of a Lock to reduce wasted concurrent calls by the URP to the Overseer to create a new collection.  This is minor because the RoutedAliasCreateCollectionCmd doesn't do anything if ifHeadCollName doesn't jive with the actual head collection name.\n\nGus Heck can you please review this now? ",
            "author": "David Smiley",
            "id": "comment-16307490"
        },
        {
            "date": "2018-01-02T01:09:23+0000",
            "content": "Some thoughts: \n\nIt seems that you've added ROUTEDALIAS_CREATECOLL as a user accessible command (the v1 API will respond to it I think) but not reflected in v2 api json files. I think this is because this command is  probably not meant for API invocation in the first place, so it kinda looks out of place as an undocumented API. I kind of wonder why it was done as an admin command. I'm probably missing something, but it seems like this means we have:\n\n\tdoc arrives for which it is appropriate to create a new collection.\n\tissue admin command ROUTEDALIAS_CREATECOLL and wait for it\n\tinside ROUTEDALIAS_CREATECOLL issue CollectionsHandler.CollectionOperation.CREATE_OP.execute(... and wait for that\n\tfinally process the update\n\n\n\nI'm not sure why we want the extra layer? is there actually a use case for manual creation of the next partition? To me it seems as if this operation is internal to TimeRoutedAliasUpdateProcessor and should be there. I can possibly imagine that if we were proactively keeping ahead of things by one collection this structure could allow fast processing of the update by giving it an async id, but it looks like the code is set up to add a collection the first time it gets a document that requires that collection (up to maxFutureMs), and delay the update until that succeeds.\n\nThis makes me wonder if we should even be supporting +1SECOND? If this command is not sub-second we fall behind... That probably also is a really bad idea for sheer number of collections too. As a side benefit we could also shorten our collection names too...\n\nI think your loop for creating collections should be dependent on the value of maxFutureMs? Let's say now() is 01:22 the head is presently ending in _01_00 and accepting 01:00 hrs to 02:00 hrs, maxFutureMs=72*60*60*1000 and we get a document for 60 hours in the future... looks like we loop up to 5 times and successfully create the _02_00, 0_03_00, _04_00,_05_00,_06_00 partitions and then error out unless we get an update to our parsedCollectionAliases in the mean time... if any 5 creations are faster than the updates to parsedCollectionAliases we wrongly error out. The error message will be misleading too since the attempts to create the collections all succeeded but we quit due to some sort of communications lag. IF the parsedCollectionsAliases gets updated in time we will reset our counter and keep going, but why not directly calculate the appropriate minimum number of attempts from DocTimestampMs - HeadTimestampMs divided by HeadTimestampMs+(one interval) - HeadTimestampMs?  A constant can be added if we want some slack for retrying failed calls.\n\nPerhaps my work in SOLR-11722 should be filling out all prospective next collections up to maxFutureMs (which I need to add to metadata)? Then in this code rather than testing the current document's time stamp to see if we create a new collection, test whether or not the next increment falls within MaxFutureMS. In the case that it's time to create a new collection we can then check the document value and create the next one asynchronously unless the current document would fall in the yet to be created collection (which should normally be a rare case). That would go from one guaranteed slow update every hour (for +1HOUR routed aliases) to only having a slow update if a document at the very beginning of an hour happens to fall just inside maxFutureMs. We would need to track that the collection was in progress for creation of course to avoid spamming the overseer each hour... \n\nIt seems easier and more robust to never need to create more than one collection during an update. In that case your present loop is just fine.\n\nIn code, you have variable names and comments talking about \"head\" but I had to dig a little to confirm that this was actually the \"most recent\" not \"the first\".... be nice if comments made this clear.\n\nI agree with your desire to rename handleResponse() ... confused me at first. ",
            "author": "Gus Heck",
            "id": "comment-16307584"
        },
        {
            "date": "2018-01-02T19:55:41+0000",
            "content": "\n\tI don't believe this patch exposes ROUTEDALIAS_CREATECOLL through v1 or v2; it takes internal code to invoke it.  Notice there is no reference to it in CollectionsHandler.  Eventually I do think it will be a useful command but I don't want to lengthen this issue with documenting it, ensuring v1 & v2, and thinking about it's API which might need work.  The first patch iteration exposed it but 2nd patch removed it from CollectionsHandler for the above reasons.\n\tRE Why the \"extra layer\":  Very good question; I should add some explanatory docs. I think you are wondering why does RoutedAliasCreateCollectionCmd exist as such when our URP could do the same actions? In my work for the Harvard BOP project, I approached it that way in fact.  The reason is that by adding an Overseer command, I can get code to operate in a mutex/lock by the alias name, thus ensuring that the choice of the next collection name & it's creation and addition to the alias happens atomically.  This isn't critical at the moment because the next collection name is deterministic, and thus could be handled at the URP with retries.  But eventually we'd like to have it be more dynamic like when a size threshold is reached, or simply because the user wants to (calls an API to make it happen on-demand).  Without a lock, I think it's impossible to support that.\n\t\n\t\tIt does seem to be a shame that I need to create an Overseer command just to get a cluster lock on the alias name... not that it's that big a deal. I suppose using ZooKeeper directly (or probably better Curator) but unless other parts of Solr are doing this (I don't think so?), I don't want time routed aliases to be the first to break the mold.\n\t\tBTW I think it's silly that all the alias operations are Overseer commands since they merely do atomic operations against ZooKeeper (that compare the version) so what's the point?\n\t\n\t\n\tRE \"+1SECOND\" sure that's perhaps not realistic but I'm not sure we want to insist you can't do it.  We already round away unnecessary _00 suffixes of seconds, minutes, and hours.\n\tRE create collection loop: What is not clear in the patch is that parsedCollectionAliases is going to be updated with every new collection (since it gets prepended to the alias).  I want to improve the clarity of the logic to instead have it examine the head collection name to see that it's different.  And maybe we don't need 5 retries; maybe none or make it configurable?\n\tYes in SOLR-11722 please add maxFutureMS.  But I don't think that issue should create more than the initial collection.\n\tIn a couple cases you've mentioned creating the next collection in advance of it being needed.  Yes absolutely, LucidWorks' Fusion appropriately calls this \"preemptive\" creation BTW. But I want to make that a separate feature we can work on later, these issues open now have enough to do without worrying about that \n\tAh, I really like your suggestion of \"most recent\" naming... thus I'll do some renames even if it's more wordy.\n\n ",
            "author": "David Smiley",
            "id": "comment-16308618"
        },
        {
            "date": "2018-01-03T04:49:40+0000",
            "content": "New patch...\n\n\trenamed \"head\" terminology to \"mostRecent\"\n\tURP:\n\t\n\t\tNo longer will retry 5 times if makes no progress. This is probably best and it simplifies understanding the loop.  As long as the alias is getting updated after createCollectionAfter is called (thus it appears we're making progress), we retry.\n\t\trefactored a updateParsedCollectionAliases method out of findTargetCollectionGivenTimestamp so we can call it separately.\n\t\tcreateCollectionAfter now forces an update to the aliases to ensure we'll see changes (if there were any).  Otherwise, it's possible the ZK watcher is slow to update and we may think no alias state progress has occurred when it's imminent\n\t\tadded a locking mechanism in the URP to avoid needless concurrent messages to the Overseer from the same JVM to add another collection\n\t\n\t\n\tadded parallel updates to test\n\tImproved the OverseerTaskProcessor flow I referred to before\n\n\n\nI beasted the test a bit; and it has survived.  Earlier I was stumped by consistently getting a failure \"collection already exists: myalias_2017-10-24\" whenever tests.iters was > 1.  This is the first collection the test creates that is not ultimately deleted.  Yet I thought it wasn't necessary to clean up unused collections in tests... so maybe there is a test infrastructure bug here?  I found some other similar but simpler test, ConfigSetsAPITest, and tried to see if it fails similarly but it does not.  I haven't dug into why but it's at least easy to deal with \u2013 just clean up when done.\n\nI wonder what would happen if the collection is partially created but not completely for whatever reason (e.g. overloaded system).  Would it ultimately recover?  Probably not; you'd have to manually (via e.g. HTTP API call) delete the collection that was never ultimately added to the alias. ",
            "author": "David Smiley",
            "id": "comment-16309142"
        },
        {
            "date": "2018-01-05T18:53:38+0000",
            "content": "Commit 925733d1ef3ac6fbabc450804511c65a4c6424ac in lucene-solr's branch refs/heads/master from David Smiley\n[ https://git-wip-us.apache.org/repos/asf?p=lucene-solr.git;h=925733d ]\n\nSOLR-11653: TimeRoutedAlias URP now auto-creates collections using new RoutedAliasCreateCollectionCmd ",
            "author": "ASF subversion and git services",
            "id": "comment-16313666"
        },
        {
            "date": "2018-01-05T18:55:26+0000",
            "content": "Commit c59db0c33778bac7430aa4c2dfd0eb39ef60e205 in lucene-solr's branch refs/heads/branch_7x from David Smiley\n[ https://git-wip-us.apache.org/repos/asf?p=lucene-solr.git;h=c59db0c ]\n\nSOLR-11653: TimeRoutedAlias URP now auto-creates collections using new RoutedAliasCreateCollectionCmd\n\n(cherry picked from commit 925733d) ",
            "author": "ASF subversion and git services",
            "id": "comment-16313669"
        },
        {
            "date": "2018-01-05T19:00:51+0000",
            "content": "Thanks for the review Gus.  With this committed you can now reference some of the utility methods in SOLR-11722. ",
            "author": "David Smiley",
            "id": "comment-16313682"
        },
        {
            "date": "2018-01-12T03:27:00+0000",
            "content": "Just thought of something I missed in my review:\n\nIt looks like we would be creating collection names that look like this in the case of +1HOUR interval\n\nalias_2014-01-14_22\nalias_2014-01-14_23\nalias_2014-01-15\nalias_2014-01-15_01\n\nor for +30MINUTE interval:\n\nalias_2014-01-14_22\nalias_2014-01-14_22_30\nalias_2014-01-14_23\nalias_2014-01-14_23_30\nalias_2014-01-15\nalias_2014-01-15_01\n\nI think that's not very nice since the length is inconsistent lengths and would be hard for (users) who won't have our fancy formater definition on hand to parse or generate... maybe we should be creating names like these:\n\nalias_2014-01-14_22\nalias_2014-01-14_23\nalias_2014-01-15_00\nalias_2014-01-15_01\n\nand\n\nalias_2014-01-14_22_00\nalias_2014-01-14_22_30\nalias_2014-01-14_23_00\nalias_2014-01-14_23_30\nalias_2014-01-15_00_00\nalias_2014-01-15_01_00\n\nTo do that we probably have to analyze the interval and decide what the smallest unit in the date math is and then record that format (or a value that maps to the right format) in metadata.\n\nIf someone specifies +60MINUTES however I'd say they just get the extra _00 on everything vs +1HOUR ...that actually could be viewed as a feature. ",
            "author": "Gus Heck",
            "id": "comment-16323486"
        }
    ]
}